; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\os_mutex.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\os_mutex.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\os_mutex.crf ..\..\uCOS-III\uCOS-III\Source\os_mutex.c]
                          THUMB

                          AREA ||i.OSMutexCreate||, CODE, READONLY, ALIGN=2

                  OSMutexCreate PROC
;;;68     
;;;69     void  OSMutexCreate (OS_MUTEX  *p_mutex,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;70                          CPU_CHAR  *p_name,
;;;71                          OS_ERR    *p_err)
;;;72     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;73         CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;74     
;;;75     
;;;76     
;;;77     #ifdef OS_SAFETY_CRITICAL
;;;78         if (p_err == DEF_NULL) {
;;;79             OS_SAFETY_CRITICAL_EXCEPTION();
;;;80             return;
;;;81         }
;;;82     #endif
;;;83     
;;;84     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;85         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;86            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;87             return;
;;;88         }
;;;89     #endif
;;;90     
;;;91     #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;92         if (OSIntNestingCtr > 0u) {                                 /* Not allowed to be called from an ISR                 */
00000c  4819              LDR      r0,|L1.116|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000010  b120              CBZ      r0,|L1.28|
;;;93            *p_err = OS_ERR_CREATE_ISR;
000012  f64260e1          MOV      r0,#0x2ee1
000016  8028              STRH     r0,[r5,#0]
                  |L1.24|
;;;94             return;
;;;95         }
;;;96     #endif
;;;97     
;;;98     #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;99         if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
;;;100           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;101            return;
;;;102        }
;;;103    #endif
;;;104    
;;;105        OS_CRITICAL_ENTER();
;;;106    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;107        p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;            /* Mark the data structure as a mutex                   */
;;;108    #endif
;;;109    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;110        p_mutex->NamePtr           =  p_name;
;;;111    #else
;;;112        (void)&p_name;
;;;113    #endif
;;;114        p_mutex->MutexGrpNextPtr   = DEF_NULL;
;;;115        p_mutex->OwnerTCBPtr       = DEF_NULL;
;;;116        p_mutex->OwnerNestingCtr   = 0u;                            /* Mutex is available                                   */
;;;117    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;118        p_mutex->TS                = 0u;
;;;119    #endif
;;;120        OS_PendListInit(&p_mutex->PendList);                        /* Initialize the waiting list                          */
;;;121    
;;;122    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;123        OS_MutexDbgListAdd(p_mutex);
;;;124        OSMutexQty++;
;;;125    #endif
;;;126    
;;;127    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;128        TRACE_OS_MUTEX_CREATE(p_mutex, p_name);                     /* Record the event.                                    */
;;;129    #endif
;;;130    
;;;131        OS_CRITICAL_EXIT_NO_SCHED();
;;;132       *p_err = OS_ERR_NONE;
;;;133    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L1.28|
00001c  bf00              NOP                            ;105
00001e  bf00              NOP                            ;105
000020  f7fffffe          BL       CPU_SR_Save
000024  4607              MOV      r7,r0                 ;105
000026  bf00              NOP                            ;105
000028  f7fffffe          BL       CPU_IntDisMeasStart
00002c  bf00              NOP                            ;105
00002e  4812              LDR      r0,|L1.120|
000030  6020              STR      r0,[r4,#0]            ;107
000032  6066              STR      r6,[r4,#4]            ;110
000034  2000              MOVS     r0,#0                 ;114
000036  6220              STR      r0,[r4,#0x20]         ;114
000038  6260              STR      r0,[r4,#0x24]         ;115
00003a  f8840028          STRB     r0,[r4,#0x28]         ;116
00003e  62e0              STR      r0,[r4,#0x2c]         ;118
000040  f1040008          ADD      r0,r4,#8              ;120
000044  f7fffffe          BL       OS_PendListInit
000048  4620              MOV      r0,r4                 ;123
00004a  f7fffffe          BL       OS_MutexDbgListAdd
00004e  480b              LDR      r0,|L1.124|
000050  8800              LDRH     r0,[r0,#0]            ;124  ; OSMutexQty
000052  1c40              ADDS     r0,r0,#1              ;124
000054  4909              LDR      r1,|L1.124|
000056  8008              STRH     r0,[r1,#0]            ;124
000058  bf00              NOP                            ;131
00005a  f7fffffe          BL       CPU_IntDisMeasStop
00005e  bf00              NOP                            ;131
000060  4638              MOV      r0,r7                 ;131
000062  f7fffffe          BL       CPU_SR_Restore
000066  bf00              NOP                            ;131
000068  bf00              NOP                            ;131
00006a  2000              MOVS     r0,#0                 ;132
00006c  8028              STRH     r0,[r5,#0]            ;132
00006e  bf00              NOP      
000070  e7d2              B        |L1.24|
;;;134    
                          ENDP

000072  0000              DCW      0x0000
                  |L1.116|
                          DCD      OSIntNestingCtr
                  |L1.120|
                          DCD      0x5854554d
                  |L1.124|
                          DCD      OSMutexQty

                          AREA ||i.OSMutexPend||, CODE, READONLY, ALIGN=2

                  OSMutexPend PROC
;;;359    
;;;360    void  OSMutexPend (OS_MUTEX  *p_mutex,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;361                       OS_TICK    timeout,
;;;362                       OS_OPT     opt,
;;;363                       CPU_TS    *p_ts,
;;;364                       OS_ERR    *p_err)
;;;365    {
000004  b088              SUB      sp,sp,#0x20
000006  4605              MOV      r5,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  461c              MOV      r4,r3
00000e  9e10              LDR      r6,[sp,#0x40]
;;;366        OS_PEND_DATA  pend_data;
;;;367        OS_TCB       *p_tcb;
;;;368        CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;369    
;;;370    
;;;371    #if (OS_CFG_TS_EN == DEF_DISABLED)
;;;372        (void)&p_ts;                                                /* Prevent compiler warning for not using 'ts'          */
;;;373    #endif
;;;374    
;;;375    #ifdef OS_SAFETY_CRITICAL
;;;376        if (p_err == DEF_NULL) {
;;;377            OS_SAFETY_CRITICAL_EXCEPTION();
;;;378            return;
;;;379        }
;;;380    #endif
;;;381    
;;;382    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;383        if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
000014  4877              LDR      r0,|L2.500|
000016  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000018  b128              CBZ      r0,|L2.38|
;;;384    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;385            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                    /* Record the event.                                    */
;;;386    #endif
;;;387           *p_err = OS_ERR_PEND_ISR;
00001a  f24610ae          MOV      r0,#0x61ae
00001e  8030              STRH     r0,[r6,#0]
                  |L2.32|
;;;388            return;
;;;389        }
;;;390    #endif
;;;391    
;;;392    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;393        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;394           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;395            return;
;;;396        }
;;;397    #endif
;;;398    
;;;399    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;400        if (p_mutex == DEF_NULL) {                                  /* Validate arguments                                   */
;;;401    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;402            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                    /* Record the event.                                    */
;;;403    #endif
;;;404           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;405            return;
;;;406        }
;;;407        switch (opt) {                                              /* Validate 'opt'                                       */
;;;408            case OS_OPT_PEND_BLOCKING:
;;;409            case OS_OPT_PEND_NON_BLOCKING:
;;;410                 break;
;;;411    
;;;412            default:
;;;413    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;414                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);               /* Record the event.                                    */
;;;415    #endif
;;;416                *p_err = OS_ERR_OPT_INVALID;
;;;417                 return;
;;;418        }
;;;419    #endif
;;;420    
;;;421    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;422        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
;;;423    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;424            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                    /* Record the event.                                    */
;;;425    #endif
;;;426           *p_err = OS_ERR_OBJ_TYPE;
;;;427            return;
;;;428        }
;;;429    #endif
;;;430    
;;;431        CPU_CRITICAL_ENTER();
;;;432        if (p_mutex->OwnerNestingCtr == 0u) {                       /* Resource available?                                  */
;;;433            p_mutex->OwnerTCBPtr     = OSTCBCurPtr;                 /* Yes, caller may proceed                              */
;;;434            p_mutex->OwnerNestingCtr = 1u;
;;;435    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;436            if (p_ts != DEF_NULL) {
;;;437               *p_ts = p_mutex->TS;
;;;438            }
;;;439    #endif
;;;440            OS_MutexGrpAdd(OSTCBCurPtr, p_mutex);                   /* Add mutex to owner's group                           */
;;;441            CPU_CRITICAL_EXIT();
;;;442    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;443            TRACE_OS_MUTEX_PEND(p_mutex);                           /* Record the event.                                    */
;;;444    #endif
;;;445           *p_err = OS_ERR_NONE;
;;;446            return;
;;;447        }
;;;448    
;;;449        if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {                  /* See if current task is already the owner of the mutex*/
;;;450            if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)-1) {
;;;451                CPU_CRITICAL_EXIT();
;;;452    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;453                TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                    */
;;;454    #endif
;;;455               *p_err = OS_ERR_MUTEX_OVF;
;;;456                return;
;;;457            }
;;;458            p_mutex->OwnerNestingCtr++;
;;;459    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;460            if (p_ts != DEF_NULL) {
;;;461               *p_ts = p_mutex->TS;
;;;462            }
;;;463    #endif
;;;464            CPU_CRITICAL_EXIT();
;;;465    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;466            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                    /* Record the event.                                    */
;;;467    #endif
;;;468           *p_err = OS_ERR_MUTEX_OWNER;                             /* Indicate that current task already owns the mutex    */
;;;469            return;
;;;470        }
;;;471    
;;;472        if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
;;;473            CPU_CRITICAL_EXIT();
;;;474    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;475            if (p_ts != DEF_NULL) {
;;;476               *p_ts = 0u;
;;;477            }
;;;478    #endif
;;;479    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;480            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                    /* Record the event.                                    */
;;;481    #endif
;;;482           *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
;;;483            return;
;;;484        } else {
;;;485            if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
;;;486                CPU_CRITICAL_EXIT();
;;;487    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;488                if (p_ts != DEF_NULL) {
;;;489                   *p_ts = 0u;
;;;490                }
;;;491    #endif
;;;492    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;493                TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                    */
;;;494    #endif
;;;495               *p_err = OS_ERR_SCHED_LOCKED;
;;;496                return;
;;;497            }
;;;498        }
;;;499                                                                    /* Lock the scheduler/re-enable interrupts              */
;;;500        OS_CRITICAL_ENTER_CPU_EXIT();
;;;501        p_tcb = p_mutex->OwnerTCBPtr;                               /* Point to the TCB of the Mutex owner                  */
;;;502        if (p_tcb->Prio > OSTCBCurPtr->Prio) {                      /* See if mutex owner has a lower priority than current */
;;;503            OS_TaskChangePrio(p_tcb, OSTCBCurPtr->Prio);
;;;504    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;505                     TRACE_OS_MUTEX_TASK_PRIO_INHERIT(p_tcb, p_tcb->Prio);
;;;506    #endif
;;;507        }
;;;508    
;;;509        OS_Pend(&pend_data,                                         /* Block task pending on Mutex                          */
;;;510                (OS_PEND_OBJ *)((void *)p_mutex),
;;;511                 OS_TASK_PEND_ON_MUTEX,
;;;512                 timeout);
;;;513    
;;;514        OS_CRITICAL_EXIT_NO_SCHED();
;;;515    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;516        TRACE_OS_MUTEX_PEND_BLOCK(p_mutex);                         /* Record the event.                                    */
;;;517    #endif
;;;518        OSSched();                                                  /* Find the next highest priority task ready to run     */
;;;519    
;;;520        CPU_CRITICAL_ENTER();
;;;521        switch (OSTCBCurPtr->PendStatus) {
;;;522            case OS_STATUS_PEND_OK:                                 /* We got the mutex                                     */
;;;523    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;524                 if (p_ts != DEF_NULL) {
;;;525                    *p_ts = OSTCBCurPtr->TS;
;;;526                 }
;;;527    #endif
;;;528    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;529                 TRACE_OS_MUTEX_PEND(p_mutex);                      /* Record the event.                                    */
;;;530    #endif
;;;531                *p_err = OS_ERR_NONE;
;;;532                 break;
;;;533    
;;;534            case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
;;;535    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;536                 if (p_ts != DEF_NULL) {
;;;537                    *p_ts = OSTCBCurPtr->TS;
;;;538                 }
;;;539    #endif
;;;540    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;541                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);               /* Record the event.                                    */
;;;542    #endif
;;;543                *p_err = OS_ERR_PEND_ABORT;
;;;544                 break;
;;;545    
;;;546            case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get mutex within timeout     */
;;;547    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;548                 if (p_ts != DEF_NULL) {
;;;549                    *p_ts = 0u;
;;;550                 }
;;;551    #endif
;;;552    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;553                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);               /* Record the event.                                    */
;;;554    #endif
;;;555                *p_err = OS_ERR_TIMEOUT;
;;;556                 break;
;;;557    
;;;558            case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
;;;559    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;560                 if (p_ts != DEF_NULL) {
;;;561                    *p_ts = OSTCBCurPtr->TS;
;;;562                 }
;;;563    #endif
;;;564    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;565                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);               /* Record the event.                                    */
;;;566    #endif
;;;567                *p_err = OS_ERR_OBJ_DEL;
;;;568                 break;
;;;569    
;;;570            default:
;;;571    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;572                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);               /* Record the event.                                    */
;;;573    #endif
;;;574                *p_err = OS_ERR_STATUS_INVALID;
;;;575                 break;
;;;576        }
;;;577        CPU_CRITICAL_EXIT();
;;;578    }
000020  b008              ADD      sp,sp,#0x20
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L2.38|
000026  4974              LDR      r1,|L2.504|
000028  6828              LDR      r0,[r5,#0]            ;422
00002a  4288              CMP      r0,r1                 ;422
00002c  d003              BEQ      |L2.54|
00002e  f64550c4          MOV      r0,#0x5dc4            ;426
000032  8030              STRH     r0,[r6,#0]            ;426
000034  e7f4              B        |L2.32|
                  |L2.54|
000036  bf00              NOP                            ;431
000038  bf00              NOP                            ;431
00003a  f7fffffe          BL       CPU_SR_Save
00003e  4682              MOV      r10,r0                ;431
000040  bf00              NOP                            ;431
000042  f7fffffe          BL       CPU_IntDisMeasStart
000046  bf00              NOP                            ;431
000048  f8950028          LDRB     r0,[r5,#0x28]         ;432
00004c  b9c8              CBNZ     r0,|L2.130|
00004e  486b              LDR      r0,|L2.508|
000050  6800              LDR      r0,[r0,#0]            ;433  ; OSTCBCurPtr
000052  6268              STR      r0,[r5,#0x24]         ;433
000054  2001              MOVS     r0,#1                 ;434
000056  f8850028          STRB     r0,[r5,#0x28]         ;434
00005a  b10c              CBZ      r4,|L2.96|
00005c  6ae8              LDR      r0,[r5,#0x2c]         ;437
00005e  6020              STR      r0,[r4,#0]            ;437
                  |L2.96|
000060  4629              MOV      r1,r5                 ;440
000062  4866              LDR      r0,|L2.508|
000064  6800              LDR      r0,[r0,#0]            ;440  ; OSTCBCurPtr
000066  f7fffffe          BL       OS_MutexGrpAdd
00006a  bf00              NOP                            ;441
00006c  f7fffffe          BL       CPU_IntDisMeasStop
000070  bf00              NOP                            ;441
000072  4650              MOV      r0,r10                ;441
000074  f7fffffe          BL       CPU_SR_Restore
000078  bf00              NOP                            ;441
00007a  bf00              NOP                            ;441
00007c  2000              MOVS     r0,#0                 ;445
00007e  8030              STRH     r0,[r6,#0]            ;445
000080  e7ce              B        |L2.32|
                  |L2.130|
000082  495e              LDR      r1,|L2.508|
000084  6a68              LDR      r0,[r5,#0x24]         ;449
000086  6809              LDR      r1,[r1,#0]            ;449  ; OSTCBCurPtr
000088  4288              CMP      r0,r1                 ;449
00008a  d125              BNE      |L2.216|
00008c  f8950028          LDRB     r0,[r5,#0x28]         ;450
000090  28ff              CMP      r0,#0xff              ;450
000092  d10c              BNE      |L2.174|
000094  bf00              NOP                            ;451
000096  f7fffffe          BL       CPU_IntDisMeasStop
00009a  bf00              NOP                            ;451
00009c  4650              MOV      r0,r10                ;451
00009e  f7fffffe          BL       CPU_SR_Restore
0000a2  bf00              NOP                            ;451
0000a4  bf00              NOP                            ;451
0000a6  f2457084          MOV      r0,#0x5784            ;455
0000aa  8030              STRH     r0,[r6,#0]            ;455
0000ac  e7b8              B        |L2.32|
                  |L2.174|
0000ae  f8950028          LDRB     r0,[r5,#0x28]         ;458
0000b2  1c40              ADDS     r0,r0,#1              ;458
0000b4  f8850028          STRB     r0,[r5,#0x28]         ;458
0000b8  b10c              CBZ      r4,|L2.190|
0000ba  6ae8              LDR      r0,[r5,#0x2c]         ;461
0000bc  6020              STR      r0,[r4,#0]            ;461
                  |L2.190|
0000be  bf00              NOP                            ;464
0000c0  f7fffffe          BL       CPU_IntDisMeasStop
0000c4  bf00              NOP                            ;464
0000c6  4650              MOV      r0,r10                ;464
0000c8  f7fffffe          BL       CPU_SR_Restore
0000cc  bf00              NOP                            ;464
0000ce  bf00              NOP                            ;464
0000d0  f2457082          MOV      r0,#0x5782            ;468
0000d4  8030              STRH     r0,[r6,#0]            ;468
0000d6  e7a3              B        |L2.32|
                  |L2.216|
0000d8  f4194f00          TST      r9,#0x8000            ;472
0000dc  d00f              BEQ      |L2.254|
0000de  bf00              NOP                            ;473
0000e0  f7fffffe          BL       CPU_IntDisMeasStop
0000e4  bf00              NOP                            ;473
0000e6  4650              MOV      r0,r10                ;473
0000e8  f7fffffe          BL       CPU_SR_Restore
0000ec  bf00              NOP                            ;473
0000ee  bf00              NOP                            ;473
0000f0  b10c              CBZ      r4,|L2.246|
0000f2  2000              MOVS     r0,#0                 ;476
0000f4  6020              STR      r0,[r4,#0]            ;476
                  |L2.246|
0000f6  f24610b0          MOV      r0,#0x61b0            ;482
0000fa  8030              STRH     r0,[r6,#0]            ;482
0000fc  e790              B        |L2.32|
                  |L2.254|
0000fe  4840              LDR      r0,|L2.512|
000100  7800              LDRB     r0,[r0,#0]            ;485  ; OSSchedLockNestingCtr
000102  b178              CBZ      r0,|L2.292|
000104  bf00              NOP                            ;486
000106  f7fffffe          BL       CPU_IntDisMeasStop
00010a  bf00              NOP                            ;486
00010c  4650              MOV      r0,r10                ;486
00010e  f7fffffe          BL       CPU_SR_Restore
000112  bf00              NOP                            ;486
000114  bf00              NOP                            ;486
000116  b10c              CBZ      r4,|L2.284|
000118  2000              MOVS     r0,#0                 ;489
00011a  6020              STR      r0,[r4,#0]            ;489
                  |L2.284|
00011c  f6465063          MOV      r0,#0x6d63            ;495
000120  8030              STRH     r0,[r6,#0]            ;495
000122  e77d              B        |L2.32|
                  |L2.292|
000124  6a6f              LDR      r7,[r5,#0x24]         ;501
000126  f8970037          LDRB     r0,[r7,#0x37]         ;502
00012a  4934              LDR      r1,|L2.508|
00012c  6809              LDR      r1,[r1,#0]            ;502  ; OSTCBCurPtr
00012e  f8911037          LDRB     r1,[r1,#0x37]         ;502
000132  4288              CMP      r0,r1                 ;502
000134  dd06              BLE      |L2.324|
000136  4831              LDR      r0,|L2.508|
000138  6800              LDR      r0,[r0,#0]            ;503  ; OSTCBCurPtr
00013a  f8901037          LDRB     r1,[r0,#0x37]         ;503
00013e  4638              MOV      r0,r7                 ;503
000140  f7fffffe          BL       OS_TaskChangePrio
                  |L2.324|
000144  4643              MOV      r3,r8                 ;509
000146  2204              MOVS     r2,#4                 ;509
000148  4629              MOV      r1,r5                 ;509
00014a  4668              MOV      r0,sp                 ;509
00014c  f7fffffe          BL       OS_Pend
000150  bf00              NOP                            ;514
000152  f7fffffe          BL       CPU_IntDisMeasStop
000156  bf00              NOP                            ;514
000158  4650              MOV      r0,r10                ;514
00015a  f7fffffe          BL       CPU_SR_Restore
00015e  bf00              NOP                            ;514
000160  bf00              NOP                            ;514
000162  f7fffffe          BL       OSSched
000166  bf00              NOP                            ;520
000168  bf00              NOP                            ;520
00016a  f7fffffe          BL       CPU_SR_Save
00016e  4682              MOV      r10,r0                ;520
000170  bf00              NOP                            ;520
000172  f7fffffe          BL       CPU_IntDisMeasStart
000176  bf00              NOP                            ;520
000178  4820              LDR      r0,|L2.508|
00017a  6800              LDR      r0,[r0,#0]            ;521  ; OSTCBCurPtr
00017c  f8900035          LDRB     r0,[r0,#0x35]         ;521
000180  b130              CBZ      r0,|L2.400|
000182  2801              CMP      r0,#1                 ;521
000184  d00c              BEQ      |L2.416|
000186  2802              CMP      r0,#2                 ;521
000188  d01a              BEQ      |L2.448|
00018a  2803              CMP      r0,#3                 ;521
00018c  d121              BNE      |L2.466|
00018e  e010              B        |L2.434|
                  |L2.400|
000190  b11c              CBZ      r4,|L2.410|
000192  481a              LDR      r0,|L2.508|
000194  6800              LDR      r0,[r0,#0]            ;525  ; OSTCBCurPtr
000196  6c80              LDR      r0,[r0,#0x48]         ;525
000198  6020              STR      r0,[r4,#0]            ;525
                  |L2.410|
00019a  2000              MOVS     r0,#0                 ;531
00019c  8030              STRH     r0,[r6,#0]            ;531
00019e  e01c              B        |L2.474|
                  |L2.416|
0001a0  b11c              CBZ      r4,|L2.426|
0001a2  4816              LDR      r0,|L2.508|
0001a4  6800              LDR      r0,[r0,#0]            ;537  ; OSTCBCurPtr
0001a6  6c80              LDR      r0,[r0,#0x48]         ;537
0001a8  6020              STR      r0,[r4,#0]            ;537
                  |L2.426|
0001aa  f24610a9          MOV      r0,#0x61a9            ;543
0001ae  8030              STRH     r0,[r6,#0]            ;543
0001b0  e013              B        |L2.474|
                  |L2.434|
0001b2  b10c              CBZ      r4,|L2.440|
0001b4  2000              MOVS     r0,#0                 ;549
0001b6  6020              STR      r0,[r4,#0]            ;549
                  |L2.440|
0001b8  f24720d9          MOV      r0,#0x72d9            ;555
0001bc  8030              STRH     r0,[r6,#0]            ;555
0001be  e00c              B        |L2.474|
                  |L2.448|
0001c0  b11c              CBZ      r4,|L2.458|
0001c2  480e              LDR      r0,|L2.508|
0001c4  6800              LDR      r0,[r0,#0]            ;561  ; OSTCBCurPtr
0001c6  6c80              LDR      r0,[r0,#0x48]         ;561
0001c8  6020              STR      r0,[r4,#0]            ;561
                  |L2.458|
0001ca  f64550c2          MOV      r0,#0x5dc2            ;567
0001ce  8030              STRH     r0,[r6,#0]            ;567
0001d0  e003              B        |L2.474|
                  |L2.466|
0001d2  f646602e          MOV      r0,#0x6e2e            ;574
0001d6  8030              STRH     r0,[r6,#0]            ;574
0001d8  bf00              NOP                            ;575
                  |L2.474|
0001da  bf00              NOP                            ;532
0001dc  bf00              NOP                            ;577
0001de  f7fffffe          BL       CPU_IntDisMeasStop
0001e2  bf00              NOP                            ;577
0001e4  4650              MOV      r0,r10                ;577
0001e6  f7fffffe          BL       CPU_SR_Restore
0001ea  bf00              NOP                            ;577
0001ec  bf00              NOP                            ;577
0001ee  bf00              NOP      
0001f0  e716              B        |L2.32|
;;;579    
                          ENDP

0001f2  0000              DCW      0x0000
                  |L2.500|
                          DCD      OSIntNestingCtr
                  |L2.504|
                          DCD      0x5854554d
                  |L2.508|
                          DCD      OSTCBCurPtr
                  |L2.512|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSMutexPost||, CODE, READONLY, ALIGN=2

                  OSMutexPost PROC
;;;759    
;;;760    void  OSMutexPost (OS_MUTEX  *p_mutex,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;761                       OS_OPT     opt,
;;;762                       OS_ERR    *p_err)
;;;763    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4615              MOV      r5,r2
;;;764        OS_PEND_LIST  *p_pend_list;
;;;765        OS_TCB        *p_tcb;
;;;766        CPU_TS         ts;
;;;767        OS_PRIO        prio_new;
;;;768        CPU_SR_ALLOC();
00000a  f04f0b00          MOV      r11,#0
;;;769    
;;;770    
;;;771    #ifdef OS_SAFETY_CRITICAL
;;;772        if (p_err == DEF_NULL) {
;;;773            OS_SAFETY_CRITICAL_EXCEPTION();
;;;774            return;
;;;775        }
;;;776    #endif
;;;777    
;;;778    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;779        if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
00000e  485c              LDR      r0,|L3.384|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000012  b120              CBZ      r0,|L3.30|
;;;780    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;781            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                    /* Record the event.                                    */
;;;782    #endif
;;;783           *p_err = OS_ERR_POST_ISR;
000014  f246200e          MOV      r0,#0x620e
000018  8028              STRH     r0,[r5,#0]
                  |L3.26|
;;;784            return;
;;;785        }
;;;786    #endif
;;;787    
;;;788    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;789        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;790           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;791            return;
;;;792        }
;;;793    #endif
;;;794    
;;;795    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;796        if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
;;;797    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;798            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                    /* Record the event.                                    */
;;;799    #endif
;;;800           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;801            return;
;;;802        }
;;;803        switch (opt) {                                              /* Validate 'opt'                                       */
;;;804            case OS_OPT_POST_NONE:
;;;805            case OS_OPT_POST_NO_SCHED:
;;;806                 break;
;;;807    
;;;808            default:
;;;809    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;810                 TRACE_OS_MUTEX_POST_FAILED(p_mutex);               /* Record the event.                                    */
;;;811    #endif
;;;812                *p_err =  OS_ERR_OPT_INVALID;
;;;813                 return;
;;;814        }
;;;815    #endif
;;;816    
;;;817    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;818        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
;;;819    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;820            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                    /* Record the event.                                    */
;;;821    #endif
;;;822           *p_err = OS_ERR_OBJ_TYPE;
;;;823            return;
;;;824        }
;;;825    #endif
;;;826    
;;;827        CPU_CRITICAL_ENTER();
;;;828        if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {                  /* Make sure the mutex owner is releasing the mutex     */
;;;829            CPU_CRITICAL_EXIT();
;;;830    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;831            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                    /* Record the event.                                    */
;;;832    #endif
;;;833           *p_err = OS_ERR_MUTEX_NOT_OWNER;
;;;834            return;
;;;835        }
;;;836    
;;;837    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;838        TRACE_OS_MUTEX_POST(p_mutex);                               /* Record the event.                                    */
;;;839    #endif
;;;840    
;;;841        OS_CRITICAL_ENTER_CPU_EXIT();
;;;842    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;843        ts          = OS_TS_GET();                                  /* Get timestamp                                        */
;;;844        p_mutex->TS = ts;
;;;845    #else
;;;846        ts          = 0u;
;;;847    #endif
;;;848        p_mutex->OwnerNestingCtr--;                                 /* Decrement owner's nesting counter                    */
;;;849        if (p_mutex->OwnerNestingCtr > 0u) {                        /* Are we done with all nestings?                       */
;;;850            OS_CRITICAL_EXIT();                                     /* No                                                   */
;;;851           *p_err = OS_ERR_MUTEX_NESTING;
;;;852            return;
;;;853        }
;;;854    
;;;855        OS_MutexGrpRemove(OSTCBCurPtr, p_mutex);                    /* Remove mutex from owner's group                      */
;;;856    
;;;857        p_pend_list = &p_mutex->PendList;
;;;858        if (p_pend_list->HeadPtr == DEF_NULL) {                      /* Any task waiting on mutex?                           */
;;;859            p_mutex->OwnerTCBPtr     = DEF_NULL;                    /* No                                                   */
;;;860            p_mutex->OwnerNestingCtr = 0u;
;;;861            OS_CRITICAL_EXIT();
;;;862           *p_err = OS_ERR_NONE;
;;;863            return;
;;;864        }
;;;865                                                                    /* Yes                                                  */
;;;866        if (OSTCBCurPtr->Prio != OSTCBCurPtr->BasePrio) {           /* Has owner inherited a priority?                      */
;;;867            prio_new = OS_MutexGrpPrioFindHighest(OSTCBCurPtr);     /* Yes, find highest priority pending                   */
;;;868            prio_new = prio_new > OSTCBCurPtr->BasePrio ? OSTCBCurPtr->BasePrio : prio_new;
;;;869            if (prio_new > OSTCBCurPtr->Prio) {
;;;870                OS_RdyListRemove(OSTCBCurPtr);
;;;871                OSTCBCurPtr->Prio = prio_new;                       /* Lower owner's priority back to its original one      */
;;;872    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;873                TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(OSTCBCurPtr, prio_new);
;;;874    #endif
;;;875                OS_PrioInsert(prio_new);
;;;876                OS_RdyListInsertTail(OSTCBCurPtr);                  /* Insert owner in ready list at new priority           */
;;;877                OSPrioCur         = prio_new;
;;;878            }
;;;879        }
;;;880                                                                    /* Get TCB from head of pend list                       */
;;;881        p_tcb                      = p_pend_list->HeadPtr->TCBPtr;
;;;882        p_mutex->OwnerTCBPtr       = p_tcb;                         /* Give mutex to new owner                              */
;;;883        p_mutex->OwnerNestingCtr   = 1u;
;;;884        OS_MutexGrpAdd(p_tcb, p_mutex);
;;;885                                                                    /* Post to mutex                                        */
;;;886        OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
;;;887                p_tcb,
;;;888                DEF_NULL,
;;;889                0u,
;;;890                ts);
;;;891    
;;;892        OS_CRITICAL_EXIT_NO_SCHED();
;;;893    
;;;894        if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
;;;895            OSSched();                                              /* Run the scheduler                                    */
;;;896        }
;;;897    
;;;898       *p_err = OS_ERR_NONE;
;;;899    }
00001a  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.30|
00001e  4959              LDR      r1,|L3.388|
000020  6820              LDR      r0,[r4,#0]            ;818
000022  4288              CMP      r0,r1                 ;818
000024  d003              BEQ      |L3.46|
000026  f64550c4          MOV      r0,#0x5dc4            ;822
00002a  8028              STRH     r0,[r5,#0]            ;822
00002c  e7f5              B        |L3.26|
                  |L3.46|
00002e  bf00              NOP                            ;827
000030  bf00              NOP                            ;827
000032  f7fffffe          BL       CPU_SR_Save
000036  4683              MOV      r11,r0                ;827
000038  bf00              NOP                            ;827
00003a  f7fffffe          BL       CPU_IntDisMeasStart
00003e  bf00              NOP                            ;827
000040  4951              LDR      r1,|L3.392|
000042  6a60              LDR      r0,[r4,#0x24]         ;828
000044  6809              LDR      r1,[r1,#0]            ;828  ; OSTCBCurPtr
000046  4288              CMP      r0,r1                 ;828
000048  d00c              BEQ      |L3.100|
00004a  bf00              NOP                            ;829
00004c  f7fffffe          BL       CPU_IntDisMeasStop
000050  bf00              NOP                            ;829
000052  4658              MOV      r0,r11                ;829
000054  f7fffffe          BL       CPU_SR_Restore
000058  bf00              NOP                            ;829
00005a  bf00              NOP                            ;829
00005c  f2457081          MOV      r0,#0x5781            ;833
000060  8028              STRH     r0,[r5,#0]            ;833
000062  e7da              B        |L3.26|
                  |L3.100|
000064  f7fffffe          BL       CPU_TS_TmrRd
000068  4680              MOV      r8,r0                 ;843
00006a  f1040428          ADD      r4,r4,#0x28           ;844
00006e  f8c48004          STR      r8,[r4,#4]            ;844
000072  7820              LDRB     r0,[r4,#0]            ;848
000074  f1a00001          SUB      r0,r0,#1              ;848
000078  7020              STRB     r0,[r4,#0]            ;848
00007a  f8140928          LDRB     r0,[r4],#-0x28        ;849
00007e  b160              CBZ      r0,|L3.154|
000080  bf00              NOP                            ;850
000082  f7fffffe          BL       CPU_IntDisMeasStop
000086  bf00              NOP                            ;850
000088  4658              MOV      r0,r11                ;850
00008a  f7fffffe          BL       CPU_SR_Restore
00008e  bf00              NOP                            ;850
000090  bf00              NOP                            ;850
000092  f2457083          MOV      r0,#0x5783            ;851
000096  8028              STRH     r0,[r5,#0]            ;851
000098  e7bf              B        |L3.26|
                  |L3.154|
00009a  4621              MOV      r1,r4                 ;855
00009c  483a              LDR      r0,|L3.392|
00009e  6800              LDR      r0,[r0,#0]            ;855  ; OSTCBCurPtr
0000a0  f7fffffe          BL       OS_MutexGrpRemove
0000a4  f1040908          ADD      r9,r4,#8              ;857
0000a8  f8d90000          LDR      r0,[r9,#0]            ;858
0000ac  b978              CBNZ     r0,|L3.206|
0000ae  2000              MOVS     r0,#0                 ;859
0000b0  6260              STR      r0,[r4,#0x24]         ;859
0000b2  f8840028          STRB     r0,[r4,#0x28]         ;860
0000b6  bf00              NOP                            ;861
0000b8  f7fffffe          BL       CPU_IntDisMeasStop
0000bc  bf00              NOP                            ;861
0000be  4658              MOV      r0,r11                ;861
0000c0  f7fffffe          BL       CPU_SR_Restore
0000c4  bf00              NOP                            ;861
0000c6  bf00              NOP                            ;861
0000c8  2000              MOVS     r0,#0                 ;862
0000ca  8028              STRH     r0,[r5,#0]            ;862
0000cc  e7a5              B        |L3.26|
                  |L3.206|
0000ce  482e              LDR      r0,|L3.392|
0000d0  6800              LDR      r0,[r0,#0]            ;866  ; OSTCBCurPtr
0000d2  f8900037          LDRB     r0,[r0,#0x37]         ;866
0000d6  492c              LDR      r1,|L3.392|
0000d8  6809              LDR      r1,[r1,#0]            ;866  ; OSTCBCurPtr
0000da  f8911038          LDRB     r1,[r1,#0x38]         ;866
0000de  4288              CMP      r0,r1                 ;866
0000e0  d028              BEQ      |L3.308|
0000e2  4829              LDR      r0,|L3.392|
0000e4  6800              LDR      r0,[r0,#0]            ;867  ; OSTCBCurPtr
0000e6  f7fffffe          BL       OS_MutexGrpPrioFindHighest
0000ea  4606              MOV      r6,r0                 ;867
0000ec  4826              LDR      r0,|L3.392|
0000ee  6800              LDR      r0,[r0,#0]            ;868  ; OSTCBCurPtr
0000f0  f8901038          LDRB     r1,[r0,#0x38]         ;868
0000f4  42b1              CMP      r1,r6                 ;868
0000f6  da04              BGE      |L3.258|
0000f8  4823              LDR      r0,|L3.392|
0000fa  6800              LDR      r0,[r0,#0]            ;868  ; OSTCBCurPtr
0000fc  f8900038          LDRB     r0,[r0,#0x38]         ;868
000100  e000              B        |L3.260|
                  |L3.258|
000102  4630              MOV      r0,r6                 ;868
                  |L3.260|
000104  4606              MOV      r6,r0                 ;868
000106  4820              LDR      r0,|L3.392|
000108  6800              LDR      r0,[r0,#0]            ;869  ; OSTCBCurPtr
00010a  f8900037          LDRB     r0,[r0,#0x37]         ;869
00010e  42b0              CMP      r0,r6                 ;869
000110  da10              BGE      |L3.308|
000112  481d              LDR      r0,|L3.392|
000114  6800              LDR      r0,[r0,#0]            ;870  ; OSTCBCurPtr
000116  f7fffffe          BL       OS_RdyListRemove
00011a  481b              LDR      r0,|L3.392|
00011c  6800              LDR      r0,[r0,#0]            ;871  ; OSTCBCurPtr
00011e  f8806037          STRB     r6,[r0,#0x37]         ;871
000122  4630              MOV      r0,r6                 ;875
000124  f7fffffe          BL       OS_PrioInsert
000128  4817              LDR      r0,|L3.392|
00012a  6800              LDR      r0,[r0,#0]            ;876  ; OSTCBCurPtr
00012c  f7fffffe          BL       OS_RdyListInsertTail
000130  4816              LDR      r0,|L3.396|
000132  7006              STRB     r6,[r0,#0]            ;877
                  |L3.308|
000134  f8d90000          LDR      r0,[r9,#0]            ;881
000138  6887              LDR      r7,[r0,#8]            ;881
00013a  6267              STR      r7,[r4,#0x24]         ;882
00013c  2001              MOVS     r0,#1                 ;883
00013e  f8840028          STRB     r0,[r4,#0x28]         ;883
000142  4621              MOV      r1,r4                 ;884
000144  4638              MOV      r0,r7                 ;884
000146  f7fffffe          BL       OS_MutexGrpAdd
00014a  2300              MOVS     r3,#0                 ;886
00014c  461a              MOV      r2,r3                 ;886
00014e  4639              MOV      r1,r7                 ;886
000150  4620              MOV      r0,r4                 ;886
000152  f8cd8000          STR      r8,[sp,#0]            ;886
000156  f7fffffe          BL       OS_Post
00015a  bf00              NOP                            ;892
00015c  f7fffffe          BL       CPU_IntDisMeasStop
000160  bf00              NOP                            ;892
000162  4658              MOV      r0,r11                ;892
000164  f7fffffe          BL       CPU_SR_Restore
000168  bf00              NOP                            ;892
00016a  bf00              NOP                            ;892
00016c  f41a4f00          TST      r10,#0x8000           ;894
000170  d101              BNE      |L3.374|
000172  f7fffffe          BL       OSSched
                  |L3.374|
000176  2000              MOVS     r0,#0                 ;898
000178  8028              STRH     r0,[r5,#0]            ;898
00017a  bf00              NOP      
00017c  e74d              B        |L3.26|
;;;900    
                          ENDP

00017e  0000              DCW      0x0000
                  |L3.384|
                          DCD      OSIntNestingCtr
                  |L3.388|
                          DCD      0x5854554d
                  |L3.392|
                          DCD      OSTCBCurPtr
                  |L3.396|
                          DCD      OSPrioCur

                          AREA ||i.OS_MutexClr||, CODE, READONLY, ALIGN=2

                  OS_MutexClr PROC
;;;917    
;;;918    void  OS_MutexClr (OS_MUTEX  *p_mutex)
000000  b510              PUSH     {r4,lr}
;;;919    {
000002  4604              MOV      r4,r0
;;;920    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;921        p_mutex->Type              =  OS_OBJ_TYPE_NONE;             /* Mark the data structure as a NONE                    */
000004  4807              LDR      r0,|L4.36|
000006  6020              STR      r0,[r4,#0]
;;;922    #endif
;;;923    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;924        p_mutex->NamePtr           = (CPU_CHAR *)((void *)"?MUTEX");
000008  a007              ADR      r0,|L4.40|
00000a  6060              STR      r0,[r4,#4]
;;;925    #endif
;;;926        p_mutex->MutexGrpNextPtr   = DEF_NULL;
00000c  2000              MOVS     r0,#0
00000e  6220              STR      r0,[r4,#0x20]
;;;927        p_mutex->OwnerTCBPtr       = DEF_NULL;
000010  6260              STR      r0,[r4,#0x24]
;;;928        p_mutex->OwnerNestingCtr   = 0u;
000012  f8840028          STRB     r0,[r4,#0x28]
;;;929    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;930        p_mutex->TS                = 0u;
000016  62e0              STR      r0,[r4,#0x2c]
;;;931    #endif
;;;932        OS_PendListInit(&p_mutex->PendList);                        /* Initialize the waiting list                          */
000018  f1040008          ADD      r0,r4,#8
00001c  f7fffffe          BL       OS_PendListInit
;;;933    }
000020  bd10              POP      {r4,pc}
;;;934    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x454e4f4e
                  |L4.40|
000028  3f4d5554          DCB      "?MUTEX",0
00002c  455800  
00002f  00                DCB      0

                          AREA ||i.OS_MutexDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_MutexDbgListAdd PROC
;;;951    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;952    void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
000000  a109              ADR      r1,|L5.40|
;;;953    {
;;;954        p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
000002  61c1              STR      r1,[r0,#0x1c]
;;;955        p_mutex->DbgPrevPtr               = DEF_NULL;
000004  2100              MOVS     r1,#0
000006  6141              STR      r1,[r0,#0x14]
;;;956        if (OSMutexDbgListPtr == DEF_NULL) {
000008  4908              LDR      r1,|L5.44|
00000a  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
00000c  b911              CBNZ     r1,|L5.20|
;;;957            p_mutex->DbgNextPtr           = DEF_NULL;
00000e  2100              MOVS     r1,#0
000010  6181              STR      r1,[r0,#0x18]
000012  e005              B        |L5.32|
                  |L5.20|
;;;958        } else {
;;;959            p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
000014  4905              LDR      r1,|L5.44|
000016  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
000018  6181              STR      r1,[r0,#0x18]
;;;960            OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
00001a  4904              LDR      r1,|L5.44|
00001c  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
00001e  6148              STR      r0,[r1,#0x14]
                  |L5.32|
;;;961        }
;;;962        OSMutexDbgListPtr                 =  p_mutex;
000020  4902              LDR      r1,|L5.44|
000022  6008              STR      r0,[r1,#0]  ; OSMutexDbgListPtr
;;;963    }
000024  4770              BX       lr
;;;964    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
000028  2000              DCB      " ",0
00002a  00                DCB      0
00002b  00                DCB      0
                  |L5.44|
                          DCD      OSMutexDbgListPtr

                          AREA ||i.OS_MutexDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_MutexDbgListRemove PROC
;;;966    
;;;967    void  OS_MutexDbgListRemove (OS_MUTEX  *p_mutex)
000000  6942              LDR      r2,[r0,#0x14]
;;;968    {
;;;969        OS_MUTEX  *p_mutex_next;
;;;970        OS_MUTEX  *p_mutex_prev;
;;;971    
;;;972    
;;;973        p_mutex_prev = p_mutex->DbgPrevPtr;
;;;974        p_mutex_next = p_mutex->DbgNextPtr;
000002  6981              LDR      r1,[r0,#0x18]
;;;975    
;;;976        if (p_mutex_prev == DEF_NULL) {
000004  b93a              CBNZ     r2,|L6.22|
;;;977            OSMutexDbgListPtr = p_mutex_next;
000006  4b09              LDR      r3,|L6.44|
000008  6019              STR      r1,[r3,#0]  ; OSMutexDbgListPtr
;;;978            if (p_mutex_next != DEF_NULL) {
00000a  b109              CBZ      r1,|L6.16|
;;;979                p_mutex_next->DbgPrevPtr = DEF_NULL;
00000c  2300              MOVS     r3,#0
00000e  614b              STR      r3,[r1,#0x14]
                  |L6.16|
;;;980            }
;;;981            p_mutex->DbgNextPtr = DEF_NULL;
000010  2300              MOVS     r3,#0
000012  6183              STR      r3,[r0,#0x18]
000014  e009              B        |L6.42|
                  |L6.22|
;;;982    
;;;983        } else if (p_mutex_next == DEF_NULL) {
000016  b919              CBNZ     r1,|L6.32|
;;;984            p_mutex_prev->DbgNextPtr = DEF_NULL;
000018  2300              MOVS     r3,#0
00001a  6193              STR      r3,[r2,#0x18]
;;;985            p_mutex->DbgPrevPtr      = DEF_NULL;
00001c  6143              STR      r3,[r0,#0x14]
00001e  e004              B        |L6.42|
                  |L6.32|
;;;986    
;;;987        } else {
;;;988            p_mutex_prev->DbgNextPtr =  p_mutex_next;
000020  6191              STR      r1,[r2,#0x18]
;;;989            p_mutex_next->DbgPrevPtr =  p_mutex_prev;
000022  614a              STR      r2,[r1,#0x14]
;;;990            p_mutex->DbgNextPtr      = DEF_NULL;
000024  2300              MOVS     r3,#0
000026  6183              STR      r3,[r0,#0x18]
;;;991            p_mutex->DbgPrevPtr      = DEF_NULL;
000028  6143              STR      r3,[r0,#0x14]
                  |L6.42|
;;;992        }
;;;993    }
00002a  4770              BX       lr
;;;994    #endif
                          ENDP

                  |L6.44|
                          DCD      OSMutexDbgListPtr

                          AREA ||i.OS_MutexGrpAdd||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpAdd PROC
;;;1014   
;;;1015   void  OS_MutexGrpAdd (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;1016   {
;;;1017       p_mutex->MutexGrpNextPtr = p_tcb->MutexGrpHeadPtr;      /* The mutex grp is not sorted add to head of list.       */
000002  620a              STR      r2,[r1,#0x20]
;;;1018       p_tcb->MutexGrpHeadPtr   = p_mutex;
000004  63c1              STR      r1,[r0,#0x3c]
;;;1019   }
000006  4770              BX       lr
;;;1020   
                          ENDP


                          AREA ||i.OS_MutexGrpPostAll||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpPostAll PROC
;;;1112   
;;;1113   void  OS_MutexGrpPostAll (OS_TCB  *p_tcb)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1114   {
000004  4605              MOV      r5,r0
;;;1115       OS_MUTEX      *p_mutex;
;;;1116       OS_MUTEX      *p_mutex_next;
;;;1117       CPU_TS         ts;
;;;1118       OS_PEND_LIST  *p_pend_list;
;;;1119       OS_TCB        *p_tcb_new;
;;;1120   
;;;1121   
;;;1122       p_mutex = p_tcb->MutexGrpHeadPtr;
000006  6bec              LDR      r4,[r5,#0x3c]
;;;1123   
;;;1124       while(p_mutex != DEF_NULL) {
000008  e026              B        |L8.88|
                  |L8.10|
;;;1125   
;;;1126   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1127       TRACE_OS_MUTEX_POST(p_mutex);                               /* Record the event.                                    */
;;;1128   #endif
;;;1129   
;;;1130           p_mutex_next = p_mutex->MutexGrpNextPtr;
00000a  f8d49020          LDR      r9,[r4,#0x20]
;;;1131   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1132           ts           = OS_TS_GET();                             /* Get timestamp                                        */
00000e  f7fffffe          BL       CPU_TS_TmrRd
000012  4606              MOV      r6,r0
;;;1133           p_mutex->TS  = ts;
000014  62e6              STR      r6,[r4,#0x2c]
;;;1134   #else
;;;1135           ts           = 0u;
;;;1136   #endif
;;;1137           OS_MutexGrpRemove(p_tcb,  p_mutex);                     /* Remove mutex from owner's group                      */
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       OS_MutexGrpRemove
;;;1138   
;;;1139           p_pend_list = &p_mutex->PendList;
00001e  f1040808          ADD      r8,r4,#8
;;;1140           if (p_pend_list->HeadPtr == DEF_NULL) {                 /* Any task waiting on mutex?                           */
000022  f8d80000          LDR      r0,[r8,#0]
000026  b920              CBNZ     r0,|L8.50|
;;;1141               p_mutex->OwnerNestingCtr = 0u;                      /* Decrement owner's nesting counter                    */
000028  2000              MOVS     r0,#0
00002a  f8840028          STRB     r0,[r4,#0x28]
;;;1142               p_mutex->OwnerTCBPtr     = DEF_NULL;                /* No                                                   */
00002e  6260              STR      r0,[r4,#0x24]
000030  e011              B        |L8.86|
                  |L8.50|
;;;1143           } else {
;;;1144                                                                   /* Get TCB from head of pend list                       */
;;;1145               p_tcb_new = p_pend_list->HeadPtr->TCBPtr;
000032  f8d80000          LDR      r0,[r8,#0]
000036  6887              LDR      r7,[r0,#8]
;;;1146               p_mutex->OwnerTCBPtr     = p_tcb;                   /* Give mutex to new owner                              */
000038  6265              STR      r5,[r4,#0x24]
;;;1147               p_mutex->OwnerNestingCtr = 1u;
00003a  2001              MOVS     r0,#1
00003c  f8840028          STRB     r0,[r4,#0x28]
;;;1148               OS_MutexGrpAdd(p_tcb_new, p_mutex);
000040  4621              MOV      r1,r4
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       OS_MutexGrpAdd
;;;1149                                                                   /* Post to mutex                                        */
;;;1150               OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
000048  2300              MOVS     r3,#0
00004a  461a              MOV      r2,r3
00004c  4639              MOV      r1,r7
00004e  4620              MOV      r0,r4
000050  9600              STR      r6,[sp,#0]
000052  f7fffffe          BL       OS_Post
                  |L8.86|
;;;1151                                               p_tcb_new,
;;;1152                                               DEF_NULL,
;;;1153                                               0u,
;;;1154                                               ts);
;;;1155           }
;;;1156   
;;;1157           p_mutex = p_mutex_next;
000056  464c              MOV      r4,r9
                  |L8.88|
000058  2c00              CMP      r4,#0                 ;1124
00005a  d1d6              BNE      |L8.10|
;;;1158       }
;;;1159   
;;;1160   }
00005c  e8bd83f8          POP      {r3-r9,pc}
;;;1161   
                          ENDP


                          AREA ||i.OS_MutexGrpPrioFindHighest||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpPrioFindHighest PROC
;;;1069   
;;;1070   OS_PRIO  OS_MutexGrpPrioFindHighest (OS_TCB  *p_tcb)
000000  b530              PUSH     {r4,r5,lr}
;;;1071   {
000002  4604              MOV      r4,r0
;;;1072       OS_MUTEX     **pp_mutex;
;;;1073       OS_PRIO        highest_prio;
;;;1074       OS_PRIO        prio;
;;;1075       OS_PEND_DATA  *p_head;
;;;1076   
;;;1077   
;;;1078       highest_prio = OS_CFG_PRIO_MAX - 1u;
000004  201f              MOVS     r0,#0x1f
;;;1079       pp_mutex = &p_tcb->MutexGrpHeadPtr;
000006  f104013c          ADD      r1,r4,#0x3c
;;;1080   
;;;1081       while(*pp_mutex != DEF_NULL) {
00000a  e00b              B        |L9.36|
                  |L9.12|
;;;1082           p_head = (*pp_mutex)->PendList.HeadPtr;
00000c  680d              LDR      r5,[r1,#0]
00000e  68ab              LDR      r3,[r5,#8]
;;;1083           if (p_head!= DEF_NULL) {
000010  b12b              CBZ      r3,|L9.30|
;;;1084               prio = p_head->TCBPtr->Prio;
000012  689d              LDR      r5,[r3,#8]
000014  f8952037          LDRB     r2,[r5,#0x37]
;;;1085               if(prio < highest_prio) {
000018  4282              CMP      r2,r0
00001a  da00              BGE      |L9.30|
;;;1086                   highest_prio = prio;
00001c  4610              MOV      r0,r2
                  |L9.30|
;;;1087               }
;;;1088           }
;;;1089           pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
00001e  680d              LDR      r5,[r1,#0]
000020  f1050120          ADD      r1,r5,#0x20
                  |L9.36|
000024  680d              LDR      r5,[r1,#0]            ;1081
000026  2d00              CMP      r5,#0                 ;1081
000028  d1f0              BNE      |L9.12|
;;;1090       }
;;;1091   
;;;1092       return (highest_prio);
;;;1093   }
00002a  bd30              POP      {r4,r5,pc}
;;;1094   
                          ENDP


                          AREA ||i.OS_MutexGrpRemove||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpRemove PROC
;;;1039   
;;;1040   void  OS_MutexGrpRemove (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
000000  4602              MOV      r2,r0
;;;1041   {
;;;1042       OS_MUTEX  **pp_mutex;
;;;1043   
;;;1044       pp_mutex = &p_tcb->MutexGrpHeadPtr;
000002  f102003c          ADD      r0,r2,#0x3c
;;;1045   
;;;1046       while(*pp_mutex != p_mutex) {
000006  e002              B        |L10.14|
                  |L10.8|
;;;1047           pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
000008  6803              LDR      r3,[r0,#0]
00000a  f1030020          ADD      r0,r3,#0x20
                  |L10.14|
00000e  6803              LDR      r3,[r0,#0]            ;1046
000010  428b              CMP      r3,r1                 ;1046
000012  d1f9              BNE      |L10.8|
;;;1048       }
;;;1049   
;;;1050       *pp_mutex = (*pp_mutex)->MutexGrpNextPtr;
000014  6803              LDR      r3,[r0,#0]
000016  6a1b              LDR      r3,[r3,#0x20]
000018  6003              STR      r3,[r0,#0]
;;;1051   }
00001a  4770              BX       lr
;;;1052   
                          ENDP

