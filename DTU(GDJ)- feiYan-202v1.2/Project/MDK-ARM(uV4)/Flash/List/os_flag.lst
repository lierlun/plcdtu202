L 1 "..\..\uCOS-III\uCOS-III\Source\os_flag.c"
N/*
N************************************************************************************************************************
N*                                                      uC/OS-III
N*                                                 The Real-Time Kernel
N*
N*                                  (c) Copyright 2009-2015; Micrium, Inc.; Weston, FL
N*                           All rights reserved.  Protected by international copyright laws.
N*
N*                                                EVENT FLAG MANAGEMENT
N*
N* File    : OS_FLAG.C
N* By      : JJL
N* Version : V3.05.00
N*
N* LICENSING TERMS:
N* ---------------
N*           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
N*           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
N*           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
N*           application/product.   We provide ALL the source code for your convenience and to help you 
N*           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
N*           it commercially without paying a licensing fee.
N*
N*           Knowledge of the source code may NOT be used to develop a similar product.
N*
N*           Please help us continue to provide the embedded community with the finest software available.
N*           Your honesty is greatly appreciated.
N*
N*           You can find our product's user manual, API reference, release notes and
N*           more information at https://doc.micrium.com.
N*           You can contact us at www.micrium.com.
N************************************************************************************************************************
N*/
N
N#define  MICRIUM_SOURCE
N#include "os.h"
L 1 "..\..\uCOS-III\uCOS-III\Source\os.h" 1
N/*
N************************************************************************************************************************
N*                                                      uC/OS-III
N*                                                 The Real-Time Kernel
N*
N*                                  (c) Copyright 2009-2015; Micrium, Inc.; Weston, FL
N*                           All rights reserved.  Protected by international copyright laws.
N*
N* File    : OS.H
N* By      : JJL
N* Version : V3.05.00
N*
N* LICENSING TERMS:
N* ---------------
N*           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
N*           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
N*           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
N*           application/product.   We provide ALL the source code for your convenience and to help you
N*           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
N*           it commercially without paying a licensing fee.
N*
N*           Knowledge of the source code may NOT be used to develop a similar product.
N*
N*           Please help us continue to provide the embedded community with the finest software available.
N*           Your honesty is greatly appreciated.
N*
N*           You can find our product's user manual, API reference, release notes and
N*           more information at https://doc.micrium.com.
N*           You can contact us at www.micrium.com.
N************************************************************************************************************************
N* Note(s) : (1) Assumes the following versions (or more recent) of software modules are included in the project build:
N*
N*               (a) uC/LIB V1.36.01
N*               (b) uC/CPU V1.30.02
N************************************************************************************************************************
N*/
N
N#ifndef   OS_H
N#define   OS_H
N
N/*
N************************************************************************************************************************
N*                                               uC/OS-III VERSION NUMBER
N************************************************************************************************************************
N*/
N
N#define  OS_VERSION  30500u                       /* Version of uC/OS-III (Vx.yy.zz mult. by 10000)                   */
N
N/*
N************************************************************************************************************************
N*                                                 INCLUDE HEADER FILES
N************************************************************************************************************************
N*/
N
N#include <os_cfg.h>
L 1 "..\..\User\os_cfg.h" 1
N/*
N************************************************************************************************************************
N*                                                      uC/OS-III
N*                                                 The Real-Time Kernel
N*
N*                                  (c) Copyright 2009-2015; Micrium, Inc.; Weston, FL
N*                           All rights reserved.  Protected by international copyright laws.
N*
N*                                                  CONFIGURATION FILE
N*
N* File    : OS_CFG.H
N* By      : JJL
N* Version : V3.05.00
N*
N* LICENSING TERMS:
N* ---------------
N*           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
N*           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
N*           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
N*           application/product.   We provide ALL the source code for your convenience and to help you
N*           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
N*           it commercially without paying a licensing fee.
N*
N*           Knowledge of the source code may NOT be used to develop a similar product.
N*
N*           Please help us continue to provide the embedded community with the finest software available.
N*           Your honesty is greatly appreciated.
N*
N*           You can find our product's user manual, API reference, release notes and
N*           more information at https://doc.micrium.com.
N*           You can contact us at www.micrium.com.
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_H
N#define OS_CFG_H
N
N                                                           /* --------------------------- MISCELLANEOUS --------------------------- */
N#define OS_CFG_APP_HOOKS_EN             DEF_ENABLED        /* Enable (DEF_ENABLED) application specific hooks                       */
N#define OS_CFG_ARG_CHK_EN               DEF_DISABLED        /* Enable (DEF_ENABLED) argument checking                                */
N#define OS_CFG_CALLED_FROM_ISR_CHK_EN   DEF_ENABLED        /* Enable (DEF_ENABLED) check for called from ISR                        */
N#define OS_CFG_DBG_EN                   DEF_ENABLED        /* Enable (DEF_ENABLED) debug code/variables                             */
N#define OS_CFG_DYN_TICK_EN              DEF_DISABLED       /* Enable (DEF_ENABLED) the Dynamic Tick                                 */
N#define OS_CFG_INVALID_OS_CALLS_CHK_EN  DEF_DISABLED       /* Enable (DEF_ENABLED) checks for invalid kernel calls                  */
N#define OS_CFG_ISR_POST_DEFERRED_EN     DEF_DISABLED       /* DEPRECATED Feature: Enable (DEF_ENABLED) deferred ISR posts           */
N#define OS_CFG_OBJ_TYPE_CHK_EN          DEF_ENABLED        /* Enable (DEF_ENABLED) object type checking                             */
N#define OS_CFG_TS_EN                    DEF_ENABLED        /* Enable (DEF_ENABLED) time stamping                                    */
N
N#define OS_CFG_PEND_MULTI_EN            DEF_DISABLED       /* DEPRECATED Feature: Enable (DEF_ENABLED) multi-pend feature           */
N
N#define OS_CFG_PRIO_MAX                 32u                /* Defines the maximum number of task priorities (see OS_PRIO data type) */
N
N#define OS_CFG_SCHED_LOCK_TIME_MEAS_EN  DEF_DISABLED       /* Include (DEF_ENABLED) code to measure scheduler lock time             */
N#define OS_CFG_SCHED_ROUND_ROBIN_EN     DEF_DISABLED       /* Include (DEF_ENABLED) code for Round-Robin scheduling                 */
N
N#define OS_CFG_STK_SIZE_MIN             64u                /* Minimum allowable task stack size                                     */
N
N
N                                                           /* --------------------------- EVENT FLAGS ----------------------------- */
N#define OS_CFG_FLAG_EN                  DEF_DISABLED       /* Enable (DEF_ENABLED) code generation for EVENT FLAGS                  */
N#define OS_CFG_FLAG_DEL_EN              DEF_DISABLED       /*     Include (DEF_ENABLED) code for OSFlagDel()                        */
N#define OS_CFG_FLAG_MODE_CLR_EN         DEF_DISABLED       /*     Include (DEF_ENABLED) code for Wait on Clear EVENT FLAGS          */
N#define OS_CFG_FLAG_PEND_ABORT_EN       DEF_DISABLED       /*     Include (DEF_ENABLED) code for OSFlagPendAbort()                  */
N
N
N                                                           /* ------------------------ MEMORY MANAGEMENT -------------------------  */
N#define OS_CFG_MEM_EN                   DEF_DISABLED       /* Enable (DEF_ENABLED) code generation for the MEMORY MANAGER           */
N
N
N                                                           /* ------------------- MUTUAL EXCLUSION SEMAPHORES --------------------  */
N#define OS_CFG_MUTEX_EN                 DEF_ENABLED        /* Enable (DEF_ENABLED) code generation for MUTEX                        */
N#define OS_CFG_MUTEX_DEL_EN             DEF_DISABLED       /*     Include (DEF_ENABLED) code for OSMutexDel()                       */
N#define OS_CFG_MUTEX_PEND_ABORT_EN      DEF_DISABLED       /*     Include (DEF_ENABLED) code for OSMutexPendAbort()                 */
N
N
N                                                           /* -------------------------- MESSAGE QUEUES --------------------------  */
N#define OS_CFG_Q_EN                     DEF_ENABLED        /* Enable (DEF_ENABLED) code generation for QUEUES                       */
N#define OS_CFG_Q_DEL_EN                 DEF_ENABLED        /*     Include (DEF_ENABLED) code for OSQDel()                           */
N#define OS_CFG_Q_FLUSH_EN               DEF_ENABLED        /*     Include (DEF_ENABLED) code for OSQFlush()                         */
N#define OS_CFG_Q_PEND_ABORT_EN          DEF_ENABLED        /*     Include (DEF_ENABLED) code for OSQPendAbort()                     */
N
N
N                                                           /* ---------------------------- SEMAPHORES ----------------------------- */
N#define OS_CFG_SEM_EN                   DEF_ENABLED        /* Enable (DEF_ENABLED) code generation for SEMAPHORES                   */
N#define OS_CFG_SEM_DEL_EN               DEF_ENABLED        /*     Include (DEF_ENABLED) code for OSSemDel()                         */
N#define OS_CFG_SEM_PEND_ABORT_EN        DEF_ENABLED        /*     Include (DEF_ENABLED) code for OSSemPendAbort()                   */
N#define OS_CFG_SEM_SET_EN               DEF_ENABLED        /*     Include (DEF_ENABLED) code for OSSemSet()                         */
N
N
N                                                           /* ----------------------------- MONITORS ------------------------------ */
N#define OS_CFG_MON_EN                   DEF_ENABLED        /* Enable (DEF_ENABLED) code generation for MONITORS                     */
N#define OS_CFG_MON_DEL_EN               DEF_DISABLED       /*     Include (DEF_ENABLED) code for OSMonDel()                         */
N
N                                                           /* -------------------------- TASK MANAGEMENT -------------------------- */
N#define OS_CFG_STAT_TASK_EN             DEF_DISABLED       /* Enable (DEF_ENABLED) the statistics task                              */
N#define OS_CFG_STAT_TASK_STK_CHK_EN     DEF_ENABLED        /*     Check task stacks (DEF_ENABLED) from the statistic task           */
N
N#define OS_CFG_TASK_CHANGE_PRIO_EN      DEF_DISABLED       /* Include (DEF_ENABLED) code for OSTaskChangePrio()                     */
N#define OS_CFG_TASK_DEL_EN              DEF_DISABLED       /* Include (DEF_ENABLED) code for OSTaskDel()                            */
N#define OS_CFG_TASK_IDLE_EN             DEF_ENABLED        /* Include (DEF_ENABLED) the idle task                                   */
N#define OS_CFG_TASK_PROFILE_EN          DEF_ENABLED        /* Include (DEF_ENABLED) variables in OS_TCB for profiling               */
N#define OS_CFG_TASK_Q_EN                DEF_ENABLED        /* Include (DEF_ENABLED) code for OSTaskQXXXX()                          */
N#define OS_CFG_TASK_Q_PEND_ABORT_EN     DEF_DISABLED       /* Include (DEF_ENABLED) code for OSTaskQPendAbort()                     */
N#define OS_CFG_TASK_REG_TBL_SIZE        1u                 /* Number of task specific registers                                     */
N#define OS_CFG_TASK_STK_REDZONE_EN      DEF_DISABLED       /* Enable (DEF_ENABLED) stack redzone                                    */
N#define OS_CFG_TASK_STK_REDZONE_DEPTH   8u                 /*     Depth of the stack redzone                                        */
N#define OS_CFG_TASK_SEM_PEND_ABORT_EN   DEF_ENABLED        /* Include (DEF_ENABLED) code for OSTaskSemPendAbort()                   */
N#define OS_CFG_TASK_SUSPEND_EN          DEF_ENABLED        /* Include (DEF_ENABLED) code for OSTaskSuspend() and OSTaskResume()     */
N#define OS_CFG_TASK_TICK_EN             DEF_ENABLED        /* Include (DEF_ENABLED) the kernel tick task                            */
N
N                                                           /* ------------------ TASK LOCAL STORAGE MANAGEMENT -------------------  */
N#define OS_CFG_TLS_TBL_SIZE             0u                 /* Include (DEF_ENABLED) code for Task Local Storage (TLS) registers     */
N
N                                                           /* ------------------------- TIME MANAGEMENT --------------------------  */
N#define OS_CFG_TIME_DLY_HMSM_EN         DEF_ENABLED        /* Include (DEF_ENABLED) code for OSTimeDlyHMSM()                        */
N#define OS_CFG_TIME_DLY_RESUME_EN       DEF_DISABLED       /* Include (DEF_ENABLED) code for OSTimeDlyResume()                      */
N
N                                                           /* ------------------------- TIMER MANAGEMENT -------------------------- */
N#define OS_CFG_TMR_EN                   DEF_ENABLED        /* Enable (DEF_ENABLED) code generation for TIMERS                       */
N#define OS_CFG_TMR_DEL_EN               DEF_ENABLED        /* Enable (DEF_ENABLED) code generation for OSTmrDel()                   */
N
N                                                           /* uC/TRACE                                                              */
N#define TRACE_CFG_EN                    DEF_DISABLED       /* Enable (DEF_ENABLED) uC/Trace instrumentation                         */
N
N#endif
L 56 "..\..\uCOS-III\uCOS-III\Source\os.h" 2
N#include <os_cfg_app.h>
L 1 "..\..\User\os_cfg_app.h" 1
N/*
N************************************************************************************************************************
N*                                                      uC/OS-III
N*                                                 The Real-Time Kernel
N*
N*                                  (c) Copyright 2009-2015; Micrium, Inc.; Weston, FL
N*                           All rights reserved.  Protected by international copyright laws.
N*
N*                                       OS CONFIGURATION (APPLICATION SPECIFICS)
N*
N* File    : OS_CFG_APP.H
N* By      : JJL
N* Version : V3.05.00
N*
N* LICENSING TERMS:
N* ---------------
N*           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
N*           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
N*           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
N*           application/product.   We provide ALL the source code for your convenience and to help you 
N*           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
N*           it commercially without paying a licensing fee.
N*
N*           Knowledge of the source code may NOT be used to develop a similar product.
N*
N*           Please help us continue to provide the embedded community with the finest software available.
N*           Your honesty is greatly appreciated.
N*
N*           You can find our product's user manual, API reference, release notes and
N*           more information at https://doc.micrium.com.
N*           You can contact us at www.micrium.com.
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_APP_H
N#define OS_CFG_APP_H
N
N/*
N************************************************************************************************************************
N*                                                      CONSTANTS
N************************************************************************************************************************
N*/
N                                                                /* ------------------ MISCELLANEOUS ------------------- */
N#define  OS_CFG_ISR_STK_SIZE                         128u       /* Stack size of ISR stack (number of CPU_STK elements) */
N
N#define  OS_CFG_MSG_POOL_SIZE                         32u       /* Maximum number of messages                           */
N
N#define  OS_CFG_TASK_STK_LIMIT_PCT_EMPTY              10u       /* Stack limit position in percentage to empty          */
N
N
N                                                                /* -------------------- IDLE TASK --------------------- */
N#define  OS_CFG_IDLE_TASK_STK_SIZE                   128u       /* Stack size (number of CPU_STK elements)              */
N
N
N                                                                /* ----------------- ISR HANDLER TASK ----------------- */
N#define  OS_CFG_INT_Q_SIZE                            10u       /* Size of ISR handler task queue                       */
N#define  OS_CFG_INT_Q_TASK_STK_SIZE                  100u       /* Stack size (number of CPU_STK elements)              */
N
N
N                                                                /* ------------------ STATISTIC TASK ------------------ */
N#define  OS_CFG_STAT_TASK_PRIO       (OS_CFG_PRIO_MAX-2u)       /* Priority                                             */
N#define  OS_CFG_STAT_TASK_RATE_HZ                     10u       /* Rate of execution (1 to 10 Hz)                       */
N#define  OS_CFG_STAT_TASK_STK_SIZE                   100u       /* Stack size (number of CPU_STK elements)              */
N
N
N                                                                /* ---------------------- TICKS ----------------------- */
N#define  OS_CFG_TICK_RATE_HZ                        1000u       /* Tick rate in Hertz (10 to 1000 Hz)                   */
N#define  OS_CFG_TICK_TASK_PRIO                         1u       /* Priority                                             */
N#define  OS_CFG_TICK_TASK_STK_SIZE                   128u       /* Stack size (number of CPU_STK elements)              */
N
N
N                                                                /* --------------------- TIMERS ----------------------- */
N#define  OS_CFG_TMR_TASK_PRIO        (OS_CFG_PRIO_MAX-3u)       /* Priority of 'Timer Task'                             */
N#define  OS_CFG_TMR_TASK_RATE_HZ                      10u       /* Rate for timers (10 Hz Typ.)                         */
N#define  OS_CFG_TMR_TASK_STK_SIZE                    128u       /* Stack size (number of CPU_STK elements)              */
N
N#endif
L 57 "..\..\uCOS-III\uCOS-III\Source\os.h" 2
N#include <cpu_core.h>
L 1 "..\..\uCOS-III\uC-CPU\cpu_core.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2015; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can find our product's user manual, API reference, release notes and
N*               more information at https://doc.micrium.com.
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                           CORE CPU MODULE
N*
N* Filename      : cpu_core.h
N* Version       : V1.30.02
N* Programmer(s) : SR
N*                 ITJ
N*********************************************************************************************************
N* Note(s)       : (1) Assumes the following versions (or more recent) of software modules are included in 
N*                     the project build :
N*
N*                     (a) uC/LIB V1.35.00
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This core CPU header file is protected from multiple pre-processor inclusion through use of 
N*               the  core CPU module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CORE_MODULE_PRESENT                                /* See Note #1.                                         */
N#define  CPU_CORE_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   CPU_CORE_MODULE
S#define  CPU_CORE_EXT
N#else
N#define  CPU_CORE_EXT  extern
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) CPU-configuration software files are located in the following directories :
N*
N*               (a) \<Your Product Application>\cpu_cfg.h
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_*.*
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <Your Product Application>      directory path for Your Product's Application
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (2) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               (a) Standard library functions are implemented in the custom library module(s) :
N*
N*                       \<Custom Library Directory>\lib_*.*
N*
N*                           where
N*                                   <Custom Library Directory>      directory path for custom library software
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Your Product Application>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #1b1
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #1b2
N*
N*               (c) '\<Custom Library Directory>\' directory                            See Note #2a
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
L 1 "..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView\cpu.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2015; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can find our product's user manual, API reference, release notes and
N*               more information at https://doc.micrium.com.
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                            CPU PORT FILE
N*
N*                                            ARM-Cortex-M3
N*                                      RealView Development Suite
N*                            RealView Microcontroller Development Kit (MDK)
N*                                       ARM Developer Suite (ADS)
N*                                            Keil uVision
N*
N* Filename      : cpu.h
N* Version       : V1.30.02.00
N* Programmer(s) : JJL
N*                 BAN
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This CPU header file is protected from multiple pre-processor inclusion through use of 
N*               the  CPU module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_MODULE_PRESENT                                     /* See Note #1.                                         */
N#define  CPU_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                          CPU INCLUDE FILES
N*
N* Note(s) : (1) The following CPU files are located in the following directories :
N*
N*               (a) \<Your Product Application>\cpu_cfg.h
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_def.h
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <Your Product Application>      directory path for Your Product's Application
N*                               <CPU-Compiler Directory>        directory path for common   CPU-compiler software
N*                               <cpu>                           directory name for specific CPU
N*                               <compiler>                      directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Your Product Application>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #1b1
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #1b2
N*
N*           (3) Since NO custom library modules are included, 'cpu.h' may ONLY use configurations from
N*               CPU configuration file 'cpu_cfg.h' that do NOT reference any custom library definitions.
N*
N*               In other words, 'cpu.h' may use 'cpu_cfg.h' configurations that are #define'd to numeric
N*               constants or to NULL (i.e. NULL-valued #define's); but may NOT use configurations to
N*               custom library #define's (e.g. DEF_DISABLED or DEF_ENABLED).
N*********************************************************************************************************
N*/
N
N#include  <cpu_def.h>
L 1 "..\..\uCOS-III\uC-CPU\cpu_def.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2015; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can find our product's user manual, API reference, release notes and
N*               more information at https://doc.micrium.com.
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                      CPU CONFIGURATION DEFINES
N*
N* Filename      : cpu_def.h
N* Version       : V1.30.02
N* Programmer(s) : ITJ
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This CPU definition header file is protected from multiple pre-processor inclusion 
N*               through use of the CPU definition module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_DEF_MODULE_PRESENT
N#define  CPU_DEF_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                   CORE CPU MODULE VERSION NUMBER
N*
N* Note(s) : (1) (a) The core CPU module software version is denoted as follows :
N*
N*                       Vx.yy.zz
N*
N*                           where
N*                                   V               denotes 'Version' label
N*                                   x               denotes     major software version revision number
N*                                   yy              denotes     minor software version revision number
N*                                   zz              denotes sub-minor software version revision number
N*
N*               (b) The software version label #define is formatted as follows :
N*
N*                       ver = x.yyzz * 100 * 100
N*
N*                           where
N*                                   ver             denotes software version number scaled as an integer value
N*                                   x.yyzz          denotes software version number, where the unscaled integer 
N*                                                       portion denotes the major version number & the unscaled 
N*                                                       fractional portion denotes the (concatenated) minor 
N*                                                       version numbers
N*********************************************************************************************************
N*/
N
N#define  CPU_CORE_VERSION                              13002u   /* See Note #1.                                         */
N
N
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE & CPU_CFG_DATA_SIZE in 'cpu.h' with CPU's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE in 'cpu.h' with CPU's data-word-memory order :
N*
N*               (a) CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*               (b) CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                        /* ---------------------- CPU WORD SIZE ----------------------- */
N#define  CPU_WORD_SIZE_08                          1u   /*  8-bit word size (in octets).                                */
N#define  CPU_WORD_SIZE_16                          2u   /* 16-bit word size (in octets).                                */
N#define  CPU_WORD_SIZE_32                          4u   /* 32-bit word size (in octets).                                */
N#define  CPU_WORD_SIZE_64                          8u   /* 64-bit word size (in octets).                                */
N
N
N                                                        /* ------------------ CPU WORD-ENDIAN ORDER ------------------- */
N#define  CPU_ENDIAN_TYPE_NONE                      0u
N#define  CPU_ENDIAN_TYPE_BIG                       1u   /* Big-   endian word order (see Note #1a).                     */
N#define  CPU_ENDIAN_TYPE_LITTLE                    2u   /* Little-endian word order (see Note #1b).                     */
N
N
N/*
N*********************************************************************************************************
N*                                       CPU STACK CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_STK_GROWTH in 'cpu.h' with CPU's stack growth order :
N*
N*               (a) CPU_STK_GROWTH_LO_TO_HI     CPU stack pointer increments to the next higher  stack 
N*                                                   memory address after data is pushed onto the stack
N*               (b) CPU_STK_GROWTH_HI_TO_LO     CPU stack pointer decrements to the next lower   stack 
N*                                                   memory address after data is pushed onto the stack
N*********************************************************************************************************
N*/
N
N                                                        /* ------------------ CPU STACK GROWTH ORDER ------------------ */
N#define  CPU_STK_GROWTH_NONE                       0u
N#define  CPU_STK_GROWTH_LO_TO_HI                   1u   /* CPU stk incs towards higher mem addrs (see Note #1a).        */
N#define  CPU_STK_GROWTH_HI_TO_LO                   2u   /* CPU stk decs towards lower  mem addrs (see Note #1b).        */
N
N
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Push/save   interrupt status onto a local stack
N*                       (2) Disable     interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Pop/restore interrupt status from a local stack
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Save    interrupt status into a local variable
N*                       (2) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) (a) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need 
N*                   to be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).
N*
N*                   (1) 'cpu_sr' local variable SHOULD be declared via the CPU_SR_ALLOC() macro which, 
N*                        if used, MUST be declared following ALL other local variables (see any 'cpu.h  
N*                        CRITICAL SECTION CONFIGURATION  Note #3a1').
N*
N*                        Example :
N*
N*                           void  Fnct (void)
N*                           {
N*                               CPU_INT08U  val_08;
N*                               CPU_INT16U  val_16;
N*                               CPU_INT32U  val_32;
N*                               CPU_SR_ALLOC();         MUST be declared after ALL other local variables
N*                                   :
N*                                   :
N*                           }
N*
N*               (b) Configure 'CPU_SR' data type with the appropriate-sized CPU data type large enough to 
N*                   completely store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N
N                                                        /* --------------- CPU CRITICAL SECTION METHODS --------------- */
N#define  CPU_CRITICAL_METHOD_NONE                  0u   /*                                                              */
N#define  CPU_CRITICAL_METHOD_INT_DIS_EN            1u   /* DIS/EN       ints                    (see Note #1a).         */
N#define  CPU_CRITICAL_METHOD_STATUS_STK            2u   /* Push/Pop     int status onto stk     (see Note #1b).         */
N#define  CPU_CRITICAL_METHOD_STATUS_LOCAL          3u   /* Save/Restore int status to local var (see Note #1c).         */
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'cpu_def.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                  /* End of CPU def module include.                               */
N
L 90 "..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView\cpu.h" 2
N#include  <cpu_cfg.h>                                           /* See Note #3.                                         */
L 1 "..\..\User\cpu_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2015; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can find our product's user manual, API reference, release notes and
N*               more information at https://doc.micrium.com.
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                       CPU CONFIGURATION FILE
N*
N*                                              TEMPLATE
N*
N* Filename      : cpu_cfg.h
N* Version       : V1.30.02
N* Programmer(s) : SR
N*                 ITJ
N*                 JBL
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_MODULE_PRESENT
N#define  CPU_CFG_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                       CPU NAME CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_NAME_EN to enable/disable CPU host name feature :
N*
N*               (a) CPU host name storage
N*               (b) CPU host name API functions
N*
N*           (2) Configure CPU_CFG_NAME_SIZE with the desired ASCII string size of the CPU host name, 
N*               including the terminating NULL character.
N*
N*               See also 'cpu_core.h  GLOBAL VARIABLES  Note #1'.
N*********************************************************************************************************
N*/
N
N                                                                /* Configure CPU host name feature (see Note #1) :      */
N#define  CPU_CFG_NAME_EN                        DEF_ENABLED
N                                                                /*   DEF_DISABLED  CPU host name DISABLED               */
N                                                                /*   DEF_ENABLED   CPU host name ENABLED                */
N
N                                                                /* Configure CPU host name ASCII string size ...        */
N#define  CPU_CFG_NAME_SIZE                                16    /* ... (see Note #2).                                   */
N
N
N/*
N*********************************************************************************************************
N*                                     CPU TIMESTAMP CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_TS_xx_EN to enable/disable CPU timestamp features :
N*
N*               (a) CPU_CFG_TS_32_EN   enable/disable 32-bit CPU timestamp feature
N*               (b) CPU_CFG_TS_64_EN   enable/disable 64-bit CPU timestamp feature
N*
N*           (2) (a) Configure CPU_CFG_TS_TMR_SIZE with the CPU timestamp timer's word size :
N*
N*                       CPU_WORD_SIZE_08         8-bit word size
N*                       CPU_WORD_SIZE_16        16-bit word size
N*                       CPU_WORD_SIZE_32        32-bit word size
N*                       CPU_WORD_SIZE_64        64-bit word size
N*
N*               (b) If the size of the CPU timestamp timer is not a binary multiple of 8-bit octets 
N*                   (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple octet word 
N*                   size SHOULD be configured (e.g. to 16-bits).  However, the minimum supported word 
N*                   size for CPU timestamp timers is 8-bits.
N*
N*                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2a'.
N*********************************************************************************************************
N*/
N
N                                                                /* Configure CPU timestamp features (see Note #1) :     */
N#define  CPU_CFG_TS_32_EN                       DEF_ENABLED
N#define  CPU_CFG_TS_64_EN                       DEF_DISABLED
N                                                                /*   DEF_DISABLED  CPU timestamps DISABLED              */
N                                                                /*   DEF_ENABLED   CPU timestamps ENABLED               */
N
N                                                                /* Configure CPU timestamp timer word size ...          */
N                                                                /* ... (see Note #2) :                                  */
N#define  CPU_CFG_TS_TMR_SIZE                    CPU_WORD_SIZE_32
N
N
N/*
N*********************************************************************************************************
N*                        CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION
N*
N* Note(s) : (1) (a) Configure CPU_CFG_INT_DIS_MEAS_EN to enable/disable measuring CPU's interrupts 
N*                   disabled time :
N*
N*                   (a)  Enabled,       if CPU_CFG_INT_DIS_MEAS_EN      #define'd in 'cpu_cfg.h'
N*
N*                   (b) Disabled,       if CPU_CFG_INT_DIS_MEAS_EN  NOT #define'd in 'cpu_cfg.h'
N*
N*                   See also 'cpu_core.h  FUNCTION PROTOTYPES  Note #1'.
N*
N*               (b) Configure CPU_CFG_INT_DIS_MEAS_OVRHD_NBR with the number of times to measure & 
N*                   average the interrupts disabled time measurements overhead.
N*
N*                   See also 'cpu_core.c  CPU_IntDisMeasInit()  Note #3a'.
N*********************************************************************************************************
N*/
N
N#if 1                                                           /* Configure CPU interrupts disabled time ...           */
N#define  CPU_CFG_INT_DIS_MEAS_EN                                /* ... measurements feature (see Note #1a).             */
N#endif
N
N                                                                /* Configure number of interrupts disabled overhead ... */
N#define  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR                    1u   /* ... time measurements (see Note #1b).                */
N
N
N/*
N*********************************************************************************************************
N*                                    CPU COUNT ZEROS CONFIGURATION
N*
N* Note(s) : (1) (a) Configure CPU_CFG_LEAD_ZEROS_ASM_PRESENT  to define count leading  zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_LEAD_ZEROS_ASM_PRESENT       #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_LEAD_ZEROS_ASM_PRESENT   NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*
N*               (b) Configure CPU_CFG_TRAIL_ZEROS_ASM_PRESENT to define count trailing zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT      #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT  NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*********************************************************************************************************
N*/
N
N#if 1                                                           /* Configure CPU count leading  zeros bits ...          */
N#define  CPU_CFG_LEAD_ZEROS_ASM_PRESENT                         /* ... assembly-version (see Note #1a).                 */
N#endif
N
N#if 0                                                           /* Configure CPU count trailing zeros bits ...          */
S#define  CPU_CFG_TRAIL_ZEROS_ASM_PRESENT                        /* ... assembly-version (see Note #1b).                 */
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                      CPU ENDIAN TYPE OVERRIDE
N*
N* Note(s) : (1) Configure CPU_CFG_ENDIAN_TYPE to override the default CPU endian type defined in cpu.h.
N*
N*               (a) CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*               (b) CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*
N*           (2) Defining CPU_CFG_ENDIAN_TYPE here is only valid for supported bi-endian architectures.
N*               See  'cpu.h  CPU WORD CONFIGURATION  Note #3' for details
N*********************************************************************************************************
N*/
N
N#if 0
S#define  CPU_CFG_ENDIAN_TYPE            CPU_ENDIAN_TYPE_BIG     /* Defines CPU data    word-memory order (see Note #2). */
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                          CACHE MANAGEMENT
N*
N* Note(s) : (1) Configure CPU_CFG_CACHE_MGMT_EN to enable the cache managment API.
N
N*
N*           (2) Defining CPU_CFG_CACHE_MGMT_EN to DEF_ENABLED only enable the cache management function.
N*               Cache are assumed to be configured and enabled by the time CPU_init() is called.
N*********************************************************************************************************
N*/
N
N#define  CPU_CFG_CACHE_MGMT_EN            DEF_DISABLED          /* Defines CPU data    word-memory order (see Note #1). */
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of CPU cfg module include.                       */
N
L 91 "..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView\cpu.h" 2
N
N#ifdef __cplusplus
Sextern  "C" {
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                    CONFIGURE STANDARD DATA TYPES
N*
N* Note(s) : (1) Configure standard data types according to CPU-/compiler-specifications.
N*
N*           (2) (a) (1) 'CPU_FNCT_VOID' data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has no arguments.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_VOID  FnctName;
N*
N*                           FnctName();
N*
N*               (b) (1) 'CPU_FNCT_PTR'  data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has a single void
N*                       pointer argument.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_PTR   FnctName;
N*                           void          *p_obj
N*
N*                           FnctName(p_obj);
N*********************************************************************************************************
N*/
N
Ntypedef            void        CPU_VOID;
Ntypedef            char        CPU_CHAR;                        /*  8-bit character                                     */
Ntypedef  unsigned  char        CPU_BOOLEAN;                     /*  8-bit boolean or logical                            */
Ntypedef  unsigned  char        CPU_INT08U;                      /*  8-bit unsigned integer                              */
Ntypedef    signed  char        CPU_INT08S;                      /*  8-bit   signed integer                              */
Ntypedef  unsigned  short       CPU_INT16U;                      /* 16-bit unsigned integer                              */
Ntypedef    signed  short       CPU_INT16S;                      /* 16-bit   signed integer                              */
Ntypedef  unsigned  int         CPU_INT32U;                      /* 32-bit unsigned integer                              */
Ntypedef    signed  int         CPU_INT32S;                      /* 32-bit   signed integer                              */
Ntypedef  unsigned  long  long  CPU_INT64U;                      /* 64-bit unsigned integer                              */
Ntypedef    signed  long  long  CPU_INT64S;                      /* 64-bit   signed integer                              */
N
Ntypedef            float       CPU_FP32;                        /* 32-bit floating point                                */
Ntypedef            double      CPU_FP64;                        /* 64-bit floating point                                */
N
N
Ntypedef  volatile  CPU_INT08U  CPU_REG08;                       /*  8-bit register                                      */
Ntypedef  volatile  CPU_INT16U  CPU_REG16;                       /* 16-bit register                                      */
Ntypedef  volatile  CPU_INT32U  CPU_REG32;                       /* 32-bit register                                      */
Ntypedef  volatile  CPU_INT64U  CPU_REG64;                       /* 64-bit register                                      */
N
N
Ntypedef            void      (*CPU_FNCT_VOID)(void);            /* See Note #2a.                                        */
Ntypedef            void      (*CPU_FNCT_PTR )(void *p_obj);     /* See Note #2b.                                        */
N
N
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE, CPU_CFG_DATA_SIZE, & CPU_CFG_DATA_SIZE_MAX with CPU's &/or 
N*               compiler's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE with CPU's data-word-memory order :
N*
N*               (a) CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*               (b) CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                                /* Define  CPU         word sizes (see Note #1) :       */
N#define  CPU_CFG_ADDR_SIZE              CPU_WORD_SIZE_32        /* Defines CPU address word size  (in octets).          */
N#define  CPU_CFG_DATA_SIZE              CPU_WORD_SIZE_32        /* Defines CPU data    word size  (in octets).          */
N#define  CPU_CFG_DATA_SIZE_MAX          CPU_WORD_SIZE_64        /* Defines CPU maximum word size  (in octets).          */
N
N#define  CPU_CFG_ENDIAN_TYPE            CPU_ENDIAN_TYPE_LITTLE  /* Defines CPU data    word-memory order (see Note #2). */
N
N
N/*
N*********************************************************************************************************
N*                                 CONFIGURE CPU ADDRESS & DATA TYPES
N*********************************************************************************************************
N*/
N
N                                                                /* CPU address type based on address bus size.          */
N#if     (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_32)
X#if     (4u == 4u)
Ntypedef  CPU_INT32U  CPU_ADDR;
N#elif   (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_ADDR;
S#else
Stypedef  CPU_INT08U  CPU_ADDR;
N#endif
N
N                                                                /* CPU data    type based on data    bus size.          */
N#if     (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
X#if     (4u == 4u)
Ntypedef  CPU_INT32U  CPU_DATA;
N#elif   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_DATA;
S#else
Stypedef  CPU_INT08U  CPU_DATA;
N#endif
N
N
Ntypedef  CPU_DATA    CPU_ALIGN;                                 /* Defines CPU data-word-alignment size.                */
Ntypedef  CPU_ADDR    CPU_SIZE_T;                                /* Defines CPU standard 'size_t'   size.                */
N
N
N/*
N*********************************************************************************************************
N*                                       CPU STACK CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_STK_GROWTH in 'cpu.h' with CPU's stack growth order :
N*
N*               (a) CPU_STK_GROWTH_LO_TO_HI     CPU stack pointer increments to the next higher  stack
N*                                                   memory address after data is pushed onto the stack
N*               (b) CPU_STK_GROWTH_HI_TO_LO     CPU stack pointer decrements to the next lower   stack
N*                                                   memory address after data is pushed onto the stack
N*
N*           (2) Configure CPU_CFG_STK_ALIGN_BYTES with the highest minimum alignement required for
N*               cpu stacks.
N*
N*               (a) ARM Procedure Calls Standard requires an 8 bytes stack alignment.
N*********************************************************************************************************
N*/
N
N#define  CPU_CFG_STK_GROWTH       CPU_STK_GROWTH_HI_TO_LO       /* Defines CPU stack growth order (see Note #1).        */
N
N#define  CPU_CFG_STK_ALIGN_BYTES  (8u)                          /* Defines CPU stack alignment in bytes. (see Note #2). */
N
Ntypedef  CPU_INT32U               CPU_STK;                      /* Defines CPU stack data type.                         */
Ntypedef  CPU_ADDR                 CPU_STK_SIZE;                 /* Defines CPU stack size data type.                    */
N
N
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Push/save   interrupt status onto a local stack
N*                       (2) Disable     interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Pop/restore interrupt status from a local stack
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it supports multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (1) Save    interrupt status into a local variable
N*                       (2) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (3) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) (a) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need
N*                   to be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).
N*
N*                   (1) 'cpu_sr' local variable SHOULD be declared via the CPU_SR_ALLOC() macro which, if 
N*                        used, MUST be declared following ALL other local variables.
N*
N*                        Example :
N*
N*                           void  Fnct (void)
N*                           {
N*                               CPU_INT08U  val_08;
N*                               CPU_INT16U  val_16;
N*                               CPU_INT32U  val_32;
N*                               CPU_SR_ALLOC();         MUST be declared after ALL other local variables
N*                                   :
N*                                   :
N*                           }
N*
N*               (b) Configure 'CPU_SR' data type with the appropriate-sized CPU data type large enough to
N*                   completely store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N                                                                /* Configure CPU critical method      (see Note #1) :   */
N#define  CPU_CFG_CRITICAL_METHOD    CPU_CRITICAL_METHOD_STATUS_LOCAL
N
Ntypedef  CPU_INT32U                 CPU_SR;                     /* Defines   CPU status register size (see Note #3b).   */
N
N                                                                /* Allocates CPU status register word (see Note #3a).   */
N#if     (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
X#if     (3u == 3u)
N#define  CPU_SR_ALLOC()             CPU_SR  cpu_sr = (CPU_SR)0
N#else
S#define  CPU_SR_ALLOC()
N#endif
N
N
N
N#define  CPU_INT_DIS()         do { cpu_sr = CPU_SR_Save(); } while (0) /* Save    CPU status word & disable interrupts.*/
N#define  CPU_INT_EN()          do { CPU_SR_Restore(cpu_sr); } while (0) /* Restore CPU status word.                     */
N
N
N#ifdef   CPU_CFG_INT_DIS_MEAS_EN
N                                                                        /* Disable interrupts, ...                      */
N                                                                        /* & start interrupts disabled time measurement.*/
N#define  CPU_CRITICAL_ENTER()  do { CPU_INT_DIS();         \
N                                    CPU_IntDisMeasStart(); }  while (0)
X#define  CPU_CRITICAL_ENTER()  do { CPU_INT_DIS();                                             CPU_IntDisMeasStart(); }  while (0)
N                                                                        /* Stop & measure   interrupts disabled time,   */
N                                                                        /* ...  & re-enable interrupts.                 */
N#define  CPU_CRITICAL_EXIT()   do { CPU_IntDisMeasStop();  \
N                                    CPU_INT_EN();          }  while (0)
X#define  CPU_CRITICAL_EXIT()   do { CPU_IntDisMeasStop();                                      CPU_INT_EN();          }  while (0)
N
N#else
S
S#define  CPU_CRITICAL_ENTER()  do { CPU_INT_DIS(); } while (0)          /* Disable   interrupts.                        */
S#define  CPU_CRITICAL_EXIT()   do { CPU_INT_EN();  } while (0)          /* Re-enable interrupts.                        */
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                    MEMORY BARRIERS CONFIGURATION
N*
N* Note(s) : (1) (a) Configure memory barriers if required by the architecture.
N*
N*                   CPU_MB      Full memory barrier.
N*                   CPU_RMB     Read (Loads) memory barrier.
N*                   CPU_WMB     Write (Stores) memory barrier.
N*
N*********************************************************************************************************
N*/
N
N#define  CPU_MB()       __dsb(0xF)
N#define  CPU_RMB()      __dsb(0xF)
N#define  CPU_WMB()      __dsb(0xF)
N
N
N/*
N*********************************************************************************************************
N*                                    CPU COUNT ZEROS CONFIGURATION
N*
N* Note(s) : (1) (a) Configure CPU_CFG_LEAD_ZEROS_ASM_PRESENT  to define count leading  zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_LEAD_ZEROS_ASM_PRESENT       #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_LEAD_ZEROS_ASM_PRESENT   NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*
N*               (b) Configure CPU_CFG_TRAIL_ZEROS_ASM_PRESENT to define count trailing zeros bits 
N*                   function(s) in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT      #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT  NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s) otherwise
N*********************************************************************************************************
N*/
N
N                                                                /* Configure CPU count leading  zeros bits ...          */
N#define  CPU_CFG_LEAD_ZEROS_ASM_PRESENT                         /* ... assembly-version (see Note #1a).                 */
N
N                                                                /* Configure CPU count trailing zeros bits ...          */
N#define  CPU_CFG_TRAIL_ZEROS_ASM_PRESENT                        /* ... assembly-version (see Note #1b).                 */
N
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid        CPU_IntDis       (void);
Nvoid        CPU_IntEn        (void);
N
Nvoid        CPU_IntSrcDis    (CPU_INT08U  pos);
Nvoid        CPU_IntSrcEn     (CPU_INT08U  pos);
Nvoid        CPU_IntSrcPendClr(CPU_INT08U  pos);
NCPU_INT16S  CPU_IntSrcPrioGet(CPU_INT08U  pos);
Nvoid        CPU_IntSrcPrioSet(CPU_INT08U  pos,
N                              CPU_INT08U  prio);
N
N
NCPU_SR      CPU_SR_Save      (void);
Nvoid        CPU_SR_Restore   (CPU_SR      cpu_sr);
N
N
Nvoid        CPU_WaitForInt   (void);
Nvoid        CPU_WaitForExcept(void);
N
N
NCPU_DATA    CPU_RevBits      (CPU_DATA    val);
N
Nvoid        CPU_BitBandClr   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
Nvoid        CPU_BitBandSet   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
N
N
N/*
N*********************************************************************************************************
N*                                          INTERRUPT SOURCES
N*********************************************************************************************************
N*/
N
N#define  CPU_INT_STK_PTR                                   0u
N#define  CPU_INT_RESET                                     1u
N#define  CPU_INT_NMI                                       2u
N#define  CPU_INT_HFAULT                                    3u
N#define  CPU_INT_MEM                                       4u
N#define  CPU_INT_BUSFAULT                                  5u
N#define  CPU_INT_USAGEFAULT                                6u
N#define  CPU_INT_RSVD_07                                   7u
N#define  CPU_INT_RSVD_08                                   8u
N#define  CPU_INT_RSVD_09                                   9u
N#define  CPU_INT_RSVD_10                                  10u
N#define  CPU_INT_SVCALL                                   11u
N#define  CPU_INT_DBGMON                                   12u
N#define  CPU_INT_RSVD_13                                  13u
N#define  CPU_INT_PENDSV                                   14u
N#define  CPU_INT_SYSTICK                                  15u
N#define  CPU_INT_EXT0                                     16u
N
N
N/*
N*********************************************************************************************************
N*                                            CPU REGISTERS
N*********************************************************************************************************
N*/
N
N#define  CPU_REG_NVIC_NVIC           (*((CPU_REG32 *)(0xE000E004)))             /* Int Ctrl'er Type Reg.                */
N#define  CPU_REG_NVIC_ST_CTRL        (*((CPU_REG32 *)(0xE000E010)))             /* SysTick Ctrl & Status Reg.           */
N#define  CPU_REG_NVIC_ST_RELOAD      (*((CPU_REG32 *)(0xE000E014)))             /* SysTick Reload      Value Reg.       */
N#define  CPU_REG_NVIC_ST_CURRENT     (*((CPU_REG32 *)(0xE000E018)))             /* SysTick Current     Value Reg.       */
N#define  CPU_REG_NVIC_ST_CAL         (*((CPU_REG32 *)(0xE000E01C)))             /* SysTick Calibration Value Reg.       */
N
N#define  CPU_REG_NVIC_SETEN(n)       (*((CPU_REG32 *)(0xE000E100 + (n) * 4u)))  /* IRQ Set En Reg.                      */
N#define  CPU_REG_NVIC_CLREN(n)       (*((CPU_REG32 *)(0xE000E180 + (n) * 4u)))  /* IRQ Clr En Reg.                      */
N#define  CPU_REG_NVIC_SETPEND(n)     (*((CPU_REG32 *)(0xE000E200 + (n) * 4u)))  /* IRQ Set Pending Reg.                 */
N#define  CPU_REG_NVIC_CLRPEND(n)     (*((CPU_REG32 *)(0xE000E280 + (n) * 4u)))  /* IRQ Clr Pending Reg.                 */
N#define  CPU_REG_NVIC_ACTIVE(n)      (*((CPU_REG32 *)(0xE000E300 + (n) * 4u)))  /* IRQ Active Reg.                      */
N#define  CPU_REG_NVIC_PRIO(n)        (*((CPU_REG32 *)(0xE000E400 + (n) * 4u)))  /* IRQ Prio Reg.                        */
N
N#define  CPU_REG_NVIC_CPUID          (*((CPU_REG32 *)(0xE000ED00)))             /* CPUID Base Reg.                      */
N#define  CPU_REG_NVIC_ICSR           (*((CPU_REG32 *)(0xE000ED04)))             /* Int Ctrl State  Reg.                 */
N#define  CPU_REG_NVIC_VTOR           (*((CPU_REG32 *)(0xE000ED08)))             /* Vect Tbl Offset Reg.                 */
N#define  CPU_REG_NVIC_AIRCR          (*((CPU_REG32 *)(0xE000ED0C)))             /* App Int/Reset Ctrl Reg.              */
N#define  CPU_REG_NVIC_SCR            (*((CPU_REG32 *)(0xE000ED10)))             /* System Ctrl Reg.                     */
N#define  CPU_REG_NVIC_CCR            (*((CPU_REG32 *)(0xE000ED14)))             /* Cfg    Ctrl Reg.                     */
N#define  CPU_REG_NVIC_SHPRI1         (*((CPU_REG32 *)(0xE000ED18)))             /* System Handlers  4 to  7 Prio.       */
N#define  CPU_REG_NVIC_SHPRI2         (*((CPU_REG32 *)(0xE000ED1C)))             /* System Handlers  8 to 11 Prio.       */
N#define  CPU_REG_NVIC_SHPRI3         (*((CPU_REG32 *)(0xE000ED20)))             /* System Handlers 12 to 15 Prio.       */
N#define  CPU_REG_NVIC_SHCSR          (*((CPU_REG32 *)(0xE000ED24)))             /* System Handler Ctrl & State Reg.     */
N#define  CPU_REG_NVIC_CFSR           (*((CPU_REG32 *)(0xE000ED28)))             /* Configurable Fault Status Reg.       */
N#define  CPU_REG_NVIC_HFSR           (*((CPU_REG32 *)(0xE000ED2C)))             /* Hard  Fault Status Reg.              */
N#define  CPU_REG_NVIC_DFSR           (*((CPU_REG32 *)(0xE000ED30)))             /* Debug Fault Status Reg.              */
N#define  CPU_REG_NVIC_MMFAR          (*((CPU_REG32 *)(0xE000ED34)))             /* Mem Manage Addr Reg.                 */
N#define  CPU_REG_NVIC_BFAR           (*((CPU_REG32 *)(0xE000ED38)))             /* Bus Fault  Addr Reg.                 */
N#define  CPU_REG_NVIC_AFSR           (*((CPU_REG32 *)(0xE000ED3C)))             /* Aux Fault Status Reg.                */
N
N#define  CPU_REG_NVIC_PFR0           (*((CPU_REG32 *)(0xE000ED40)))             /* Processor Feature Reg 0.             */
N#define  CPU_REG_NVIC_PFR1           (*((CPU_REG32 *)(0xE000ED44)))             /* Processor Feature Reg 1.             */
N#define  CPU_REG_NVIC_DFR0           (*((CPU_REG32 *)(0xE000ED48)))             /* Debug     Feature Reg 0.             */
N#define  CPU_REG_NVIC_AFR0           (*((CPU_REG32 *)(0xE000ED4C)))             /* Aux       Feature Reg 0.             */
N#define  CPU_REG_NVIC_MMFR0          (*((CPU_REG32 *)(0xE000ED50)))             /* Memory Model Feature Reg 0.          */
N#define  CPU_REG_NVIC_MMFR1          (*((CPU_REG32 *)(0xE000ED54)))             /* Memory Model Feature Reg 1.          */
N#define  CPU_REG_NVIC_MMFR2          (*((CPU_REG32 *)(0xE000ED58)))             /* Memory Model Feature Reg 2.          */
N#define  CPU_REG_NVIC_MMFR3          (*((CPU_REG32 *)(0xE000ED5C)))             /* Memory Model Feature Reg 3.          */
N#define  CPU_REG_NVIC_ISAFR0         (*((CPU_REG32 *)(0xE000ED60)))             /* ISA Feature Reg 0.                   */
N#define  CPU_REG_NVIC_ISAFR1         (*((CPU_REG32 *)(0xE000ED64)))             /* ISA Feature Reg 1.                   */
N#define  CPU_REG_NVIC_ISAFR2         (*((CPU_REG32 *)(0xE000ED68)))             /* ISA Feature Reg 2.                   */
N#define  CPU_REG_NVIC_ISAFR3         (*((CPU_REG32 *)(0xE000ED6C)))             /* ISA Feature Reg 3.                   */
N#define  CPU_REG_NVIC_ISAFR4         (*((CPU_REG32 *)(0xE000ED70)))             /* ISA Feature Reg 4.                   */
N#define  CPU_REG_NVIC_SW_TRIG        (*((CPU_REG32 *)(0xE000EF00)))             /* Software Trigger Int Reg.            */
N
N#define  CPU_REG_MPU_TYPE            (*((CPU_REG32 *)(0xE000ED90)))             /* MPU Type Reg.                        */
N#define  CPU_REG_MPU_CTRL            (*((CPU_REG32 *)(0xE000ED94)))             /* MPU Ctrl Reg.                        */
N#define  CPU_REG_MPU_REG_NBR         (*((CPU_REG32 *)(0xE000ED98)))             /* MPU Region Nbr Reg.                  */
N#define  CPU_REG_MPU_REG_BASE        (*((CPU_REG32 *)(0xE000ED9C)))             /* MPU Region Base Addr Reg.            */
N#define  CPU_REG_MPU_REG_ATTR        (*((CPU_REG32 *)(0xE000EDA0)))             /* MPU Region Attrib & Size Reg.        */
N
N#define  CPU_REG_DBG_CTRL            (*((CPU_REG32 *)(0xE000EDF0)))             /* Debug Halting Ctrl & Status Reg.     */
N#define  CPU_REG_DBG_SELECT          (*((CPU_REG32 *)(0xE000EDF4)))             /* Debug Core Reg Selector Reg.         */
N#define  CPU_REG_DBG_DATA            (*((CPU_REG32 *)(0xE000EDF8)))             /* Debug Core Reg Data     Reg.         */
N#define  CPU_REG_DBG_INT             (*((CPU_REG32 *)(0xE000EDFC)))             /* Debug Except & Monitor Ctrl Reg.     */
N
N
N/*
N*********************************************************************************************************
N*                                          CPU REGISTER BITS
N*********************************************************************************************************
N*/
N
N                                                                /* ---------- SYSTICK CTRL & STATUS REG BITS ---------- */
N#define  CPU_REG_NVIC_ST_CTRL_COUNTFLAG           0x00010000
N#define  CPU_REG_NVIC_ST_CTRL_CLKSOURCE           0x00000004
N#define  CPU_REG_NVIC_ST_CTRL_TICKINT             0x00000002
N#define  CPU_REG_NVIC_ST_CTRL_ENABLE              0x00000001
N
N
N                                                                /* -------- SYSTICK CALIBRATION VALUE REG BITS -------- */
N#define  CPU_REG_NVIC_ST_CAL_NOREF                0x80000000
N#define  CPU_REG_NVIC_ST_CAL_SKEW                 0x40000000
N
N                                                                /* -------------- INT CTRL STATE REG BITS ------------- */
N#define  CPU_REG_NVIC_ICSR_NMIPENDSET             0x80000000
N#define  CPU_REG_NVIC_ICSR_PENDSVSET              0x10000000
N#define  CPU_REG_NVIC_ICSR_PENDSVCLR              0x08000000
N#define  CPU_REG_NVIC_ICSR_PENDSTSET              0x04000000
N#define  CPU_REG_NVIC_ICSR_PENDSTCLR              0x02000000
N#define  CPU_REG_NVIC_ICSR_ISRPREEMPT             0x00800000
N#define  CPU_REG_NVIC_ICSR_ISRPENDING             0x00400000
N#define  CPU_REG_NVIC_ICSR_RETTOBASE              0x00000800
N
N                                                                /* ------------- VECT TBL OFFSET REG BITS ------------- */
N#define  CPU_REG_NVIC_VTOR_TBLBASE                0x20000000
N
N                                                                /* ------------ APP INT/RESET CTRL REG BITS ----------- */
N#define  CPU_REG_NVIC_AIRCR_ENDIANNESS            0x00008000
N#define  CPU_REG_NVIC_AIRCR_SYSRESETREQ           0x00000004
N#define  CPU_REG_NVIC_AIRCR_VECTCLRACTIVE         0x00000002
N#define  CPU_REG_NVIC_AIRCR_VECTRESET             0x00000001
N
N                                                                /* --------------- SYSTEM CTRL REG BITS --------------- */
N#define  CPU_REG_NVIC_SCR_SEVONPEND               0x00000010
N#define  CPU_REG_NVIC_SCR_SLEEPDEEP               0x00000004
N#define  CPU_REG_NVIC_SCR_SLEEPONEXIT             0x00000002
N
N                                                                /* ----------------- CFG CTRL REG BITS ---------------- */
N#define  CPU_REG_NVIC_CCR_STKALIGN                0x00000200
N#define  CPU_REG_NVIC_CCR_BFHFNMIGN               0x00000100
N#define  CPU_REG_NVIC_CCR_DIV_0_TRP               0x00000010
N#define  CPU_REG_NVIC_CCR_UNALIGN_TRP             0x00000008
N#define  CPU_REG_NVIC_CCR_USERSETMPEND            0x00000002
N#define  CPU_REG_NVIC_CCR_NONBASETHRDENA          0x00000001
N
N                                                                /* ------- SYSTEM HANDLER CTRL & STATE REG BITS ------- */
N#define  CPU_REG_NVIC_SHCSR_USGFAULTENA           0x00040000
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTENA           0x00020000
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTENA           0x00010000
N#define  CPU_REG_NVIC_SHCSR_SVCALLPENDED          0x00008000
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTPENDED        0x00004000
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTPENDED        0x00002000
N#define  CPU_REG_NVIC_SHCSR_USGFAULTPENDED        0x00001000
N#define  CPU_REG_NVIC_SHCSR_SYSTICKACT            0x00000800
N#define  CPU_REG_NVIC_SHCSR_PENDSVACT             0x00000400
N#define  CPU_REG_NVIC_SHCSR_MONITORACT            0x00000100
N#define  CPU_REG_NVIC_SHCSR_SVCALLACT             0x00000080
N#define  CPU_REG_NVIC_SHCSR_USGFAULTACT           0x00000008
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTACT           0x00000002
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTACT           0x00000001
N
N                                                                /* -------- CONFIGURABLE FAULT STATUS REG BITS -------- */
N#define  CPU_REG_NVIC_CFSR_DIVBYZERO              0x02000000
N#define  CPU_REG_NVIC_CFSR_UNALIGNED              0x01000000
N#define  CPU_REG_NVIC_CFSR_NOCP                   0x00080000
N#define  CPU_REG_NVIC_CFSR_INVPC                  0x00040000
N#define  CPU_REG_NVIC_CFSR_INVSTATE               0x00020000
N#define  CPU_REG_NVIC_CFSR_UNDEFINSTR             0x00010000
N#define  CPU_REG_NVIC_CFSR_BFARVALID              0x00008000
N#define  CPU_REG_NVIC_CFSR_STKERR                 0x00001000
N#define  CPU_REG_NVIC_CFSR_UNSTKERR               0x00000800
N#define  CPU_REG_NVIC_CFSR_IMPRECISERR            0x00000400
N#define  CPU_REG_NVIC_CFSR_PRECISERR              0x00000200
N#define  CPU_REG_NVIC_CFSR_IBUSERR                0x00000100
N#define  CPU_REG_NVIC_CFSR_MMARVALID              0x00000080
N#define  CPU_REG_NVIC_CFSR_MSTKERR                0x00000010
N#define  CPU_REG_NVIC_CFSR_MUNSTKERR              0x00000008
N#define  CPU_REG_NVIC_CFSR_DACCVIOL               0x00000002
N#define  CPU_REG_NVIC_CFSR_IACCVIOL               0x00000001
N
N                                                                /* ------------ HARD FAULT STATUS REG BITS ------------ */
N#define  CPU_REG_NVIC_HFSR_DEBUGEVT               0x80000000
N#define  CPU_REG_NVIC_HFSR_FORCED                 0x40000000
N#define  CPU_REG_NVIC_HFSR_VECTTBL                0x00000002
N
N                                                                /* ------------ DEBUG FAULT STATUS REG BITS ----------- */
N#define  CPU_REG_NVIC_DFSR_EXTERNAL               0x00000010
N#define  CPU_REG_NVIC_DFSR_VCATCH                 0x00000008
N#define  CPU_REG_NVIC_DFSR_DWTTRAP                0x00000004
N#define  CPU_REG_NVIC_DFSR_BKPT                   0x00000002
N#define  CPU_REG_NVIC_DFSR_HALTED                 0x00000001
N
N
N/*
N*********************************************************************************************************
N*                                          CPU REGISTER MASK
N*********************************************************************************************************
N*/
N
N#define  CPU_MSK_NVIC_ICSR_VECT_ACTIVE            0x000001FF
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_ADDR_SIZE
S#error  "CPU_CFG_ADDR_SIZE              not #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
S
S#elif  ((CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_64))
X#elif  ((4u != 1u) &&         (4u != 2u) &&         (4u != 4u) &&         (4u != 8u))
S#error  "CPU_CFG_ADDR_SIZE        illegally #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
N#endif
N
N
N#ifndef  CPU_CFG_DATA_SIZE
S#error  "CPU_CFG_DATA_SIZE              not #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
S
S#elif  ((CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_64))
X#elif  ((4u != 1u) &&         (4u != 2u) &&         (4u != 4u) &&         (4u != 8u))
S#error  "CPU_CFG_DATA_SIZE        illegally #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
N#endif
N
N
N#ifndef  CPU_CFG_DATA_SIZE_MAX
S#error  "CPU_CFG_DATA_SIZE_MAX          not #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
S
S#elif  ((CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_DATA_SIZE_MAX != CPU_WORD_SIZE_64))
X#elif  ((8u != 1u) &&         (8u != 2u) &&         (8u != 4u) &&         (8u != 8u))
S#error  "CPU_CFG_DATA_SIZE_MAX    illegally #define'd in 'cpu.h'               "
S#error  "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S#error  "                         [     ||  CPU_WORD_SIZE_64  64-bit alignment]"
N#endif
N
N
N
N#if     (CPU_CFG_DATA_SIZE_MAX < CPU_CFG_DATA_SIZE)
X#if     (8u < 4u)
S#error  "CPU_CFG_DATA_SIZE_MAX    illegally #define'd in 'cpu.h' "
S#error  "                         [MUST be  >= CPU_CFG_DATA_SIZE]"
N#endif
N
N
N
N
N#ifndef  CPU_CFG_ENDIAN_TYPE
S#error  "CPU_CFG_ENDIAN_TYPE            not #define'd in 'cpu.h'   "
S#error  "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error  "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
S
S#elif  ((CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_BIG   ) && \
S        (CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_LITTLE))
X#elif  ((2u != 1u   ) &&         (2u != 2u))
S#error  "CPU_CFG_ENDIAN_TYPE      illegally #define'd in 'cpu.h'   "
S#error  "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error  "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
N#endif
N
N
N
N
N#ifndef  CPU_CFG_STK_GROWTH
S#error  "CPU_CFG_STK_GROWTH             not #define'd in 'cpu.h'    "
S#error  "                         [MUST be  CPU_STK_GROWTH_LO_TO_HI]"
S#error  "                         [     ||  CPU_STK_GROWTH_HI_TO_LO]"
S
S#elif  ((CPU_CFG_STK_GROWTH != CPU_STK_GROWTH_LO_TO_HI) && \
S        (CPU_CFG_STK_GROWTH != CPU_STK_GROWTH_HI_TO_LO))
X#elif  ((2u != 1u) &&         (2u != 2u))
S#error  "CPU_CFG_STK_GROWTH       illegally #define'd in 'cpu.h'    "
S#error  "                         [MUST be  CPU_STK_GROWTH_LO_TO_HI]"
S#error  "                         [     ||  CPU_STK_GROWTH_HI_TO_LO]"
N#endif
N
N
N
N
N#ifndef  CPU_CFG_CRITICAL_METHOD
S#error  "CPU_CFG_CRITICAL_METHOD        not #define'd in 'cpu.h'             "
S#error  "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
S
S#elif  ((CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_INT_DIS_EN  ) && \
S        (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_STK  ) && \
S        (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_LOCAL))
X#elif  ((3u != 1u  ) &&         (3u != 2u  ) &&         (3u != 3u))
S#error  "CPU_CFG_CRITICAL_METHOD  illegally #define'd in 'cpu.h'             "
S#error  "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error  "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'cpu.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif                                                          /* End of CPU module include.                           */
N
L 106 "..\..\uCOS-III\uC-CPU\cpu_core.h" 2
N#include  <lib_def.h>
L 1 "..\..\uCOS-III\uC-LIB\lib_def.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
N*
N*                  All rights reserved.  Protected by international copyright laws.
N*
N*                  uC/LIB is provided in source form to registered licensees ONLY.  It is
N*                  illegal to distribute this source code to any third party unless you receive
N*                  written permission by an authorized Micrium representative.  Knowledge of
N*                  the source code may NOT be used to develop a similar product.
N*
N*                  Please help us continue to provide the Embedded community with the finest
N*                  software available.  Your honesty is greatly appreciated.
N*
N*                  You can find our product's user manual, API reference, release notes and
N*                  more information at: https://doc.micrium.com
N*
N*                  You can contact us at: http://www.micrium.com
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     CORE CUSTOM LIBRARY MODULE
N*
N* Filename      : lib_def.h
N* Version       : V1.38.01
N* Programmer(s) : ITJ
N*                 FBJ
N*                 JFD
N*********************************************************************************************************
N* Note(s)       : (1) Assumes the following versions (or more recent) of software modules are included in
N*                     the project build :
N*
N*                     (a) uC/CPU V1.29.00
N*
N*
N*                 (2) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This library definition header file is protected from multiple pre-processor inclusion
N*               through use of the library definition module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_DEF_MODULE_PRESENT
N#define  LIB_DEF_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                CUSTOM LIBRARY MODULE VERSION NUMBER
N*
N* Note(s) : (1) (a) The custom library module software version is denoted as follows :
N*
N*                       Vx.yy.zz
N*
N*                           where
N*                                   V               denotes 'Version' label
N*                                   x               denotes     major software version revision number
N*                                   yy              denotes     minor software version revision number
N*                                   zz              denotes sub-minor software version revision number
N*
N*               (b) The software version label #define is formatted as follows :
N*
N*                       ver = x.yyzz * 100 * 100
N*
N*                           where
N*                                   ver             denotes software version number scaled as an integer value
N*                                   x.yyzz          denotes software version number, where the unscaled integer
N*                                                       portion denotes the major version number & the unscaled
N*                                                       fractional portion denotes the (concatenated) minor
N*                                                       version numbers
N*********************************************************************************************************
N*/
N
N#define  LIB_VERSION                                   13801u   /* See Note #1.                                         */
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Custom Library Directory>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*********************************************************************************************************
N*/
N
N#include  <cpu_def.h>
N#include  <cpu.h>
N
N
N/*
N*********************************************************************************************************
N*                                          STANDARD DEFINES
N*********************************************************************************************************
N*/
N
N#define  DEF_NULL                                          0
N
N
N                                                                /* ----------------- BOOLEAN DEFINES ------------------ */
N#define  DEF_FALSE                                         0u
N#define  DEF_TRUE                                          1u
N
N#define  DEF_NO                                            0u
N#define  DEF_YES                                           1u
N
N#define  DEF_DISABLED                                      0u
N#define  DEF_ENABLED                                       1u
N
N#define  DEF_INACTIVE                                      0u
N#define  DEF_ACTIVE                                        1u
N
N#define  DEF_INVALID                                       0u
N#define  DEF_VALID                                         1u
N
N#define  DEF_OFF                                           0u
N#define  DEF_ON                                            1u
N
N#define  DEF_CLR                                           0u
N#define  DEF_SET                                           1u
N
N#define  DEF_FAIL                                          0u
N#define  DEF_OK                                            1u
N
N
N                                                                /* ------------------- BIT DEFINES -------------------- */
N#define  DEF_BIT_NONE                                   0x00u
N
N#define  DEF_BIT_00                                     0x01u
N#define  DEF_BIT_01                                     0x02u
N#define  DEF_BIT_02                                     0x04u
N#define  DEF_BIT_03                                     0x08u
N#define  DEF_BIT_04                                     0x10u
N#define  DEF_BIT_05                                     0x20u
N#define  DEF_BIT_06                                     0x40u
N#define  DEF_BIT_07                                     0x80u
N
N#define  DEF_BIT_08                                   0x0100u
N#define  DEF_BIT_09                                   0x0200u
N#define  DEF_BIT_10                                   0x0400u
N#define  DEF_BIT_11                                   0x0800u
N#define  DEF_BIT_12                                   0x1000u
N#define  DEF_BIT_13                                   0x2000u
N#define  DEF_BIT_14                                   0x4000u
N#define  DEF_BIT_15                                   0x8000u
N
N#define  DEF_BIT_16                               0x00010000u
N#define  DEF_BIT_17                               0x00020000u
N#define  DEF_BIT_18                               0x00040000u
N#define  DEF_BIT_19                               0x00080000u
N#define  DEF_BIT_20                               0x00100000u
N#define  DEF_BIT_21                               0x00200000u
N#define  DEF_BIT_22                               0x00400000u
N#define  DEF_BIT_23                               0x00800000u
N
N#define  DEF_BIT_24                               0x01000000u
N#define  DEF_BIT_25                               0x02000000u
N#define  DEF_BIT_26                               0x04000000u
N#define  DEF_BIT_27                               0x08000000u
N#define  DEF_BIT_28                               0x10000000u
N#define  DEF_BIT_29                               0x20000000u
N#define  DEF_BIT_30                               0x40000000u
N#define  DEF_BIT_31                               0x80000000u
N#define  DEF_BIT_32                       0x0000000100000000u
N#define  DEF_BIT_33                       0x0000000200000000u
N#define  DEF_BIT_34                       0x0000000400000000u
N#define  DEF_BIT_35                       0x0000000800000000u
N#define  DEF_BIT_36                       0x0000001000000000u
N#define  DEF_BIT_37                       0x0000002000000000u
N#define  DEF_BIT_38                       0x0000004000000000u
N#define  DEF_BIT_39                       0x0000008000000000u
N
N#define  DEF_BIT_40                       0x0000010000000000u
N#define  DEF_BIT_41                       0x0000020000000000u
N#define  DEF_BIT_42                       0x0000040000000000u
N#define  DEF_BIT_43                       0x0000080000000000u
N#define  DEF_BIT_44                       0x0000100000000000u
N#define  DEF_BIT_45                       0x0000200000000000u
N#define  DEF_BIT_46                       0x0000400000000000u
N#define  DEF_BIT_47                       0x0000800000000000u
N
N#define  DEF_BIT_48                       0x0001000000000000u
N#define  DEF_BIT_49                       0x0002000000000000u
N#define  DEF_BIT_50                       0x0004000000000000u
N#define  DEF_BIT_51                       0x0008000000000000u
N#define  DEF_BIT_52                       0x0010000000000000u
N#define  DEF_BIT_53                       0x0020000000000000u
N#define  DEF_BIT_54                       0x0040000000000000u
N#define  DEF_BIT_55                       0x0080000000000000u
N
N#define  DEF_BIT_56                       0x0100000000000000u
N#define  DEF_BIT_57                       0x0200000000000000u
N#define  DEF_BIT_58                       0x0400000000000000u
N#define  DEF_BIT_59                       0x0800000000000000u
N#define  DEF_BIT_60                       0x1000000000000000u
N#define  DEF_BIT_61                       0x2000000000000000u
N#define  DEF_BIT_62                       0x4000000000000000u
N#define  DEF_BIT_63                       0x8000000000000000u
N
N
N                                                                /* ------------------ ALIGN DEFINES ------------------- */
N#define  DEF_ALIGN_MAX_NBR_OCTETS                       4096u
N
N
N                                                                /* ------------------ OCTET DEFINES ------------------- */
N#define  DEF_OCTET_NBR_BITS                                8u
N#define  DEF_OCTET_MASK                                 0xFFu
N
N#define  DEF_OCTET_TO_BIT_NBR_BITS                         3u
N#define  DEF_OCTET_TO_BIT_SHIFT                          DEF_OCTET_TO_BIT_NBR_BITS
N#define  DEF_OCTET_TO_BIT_MASK                          0x07u
N
N
N#define  DEF_NIBBLE_NBR_BITS                               4u
N#define  DEF_NIBBLE_MASK                                0x0Fu
N
N
N                                                                /* --------------- NUMBER BASE DEFINES ---------------- */
N#define  DEF_NBR_BASE_BIN                                  2u
N#define  DEF_NBR_BASE_OCT                                  8u
N#define  DEF_NBR_BASE_DEC                                 10u
N#define  DEF_NBR_BASE_HEX                                 16u
N
N
N                                                                /* ----------------- INTEGER DEFINES ------------------ */
N#define  DEF_INT_08_NBR_BITS                               8u
N#define  DEF_INT_08_MASK                                0xFFu
N
N#define  DEF_INT_08U_MIN_VAL                               0u
N#define  DEF_INT_08U_MAX_VAL                             255u
N
N#define  DEF_INT_08S_MIN_VAL_ONES_CPL                  (-127)
N#define  DEF_INT_08S_MAX_VAL_ONES_CPL                    127
N
N#define  DEF_INT_08S_MIN_VAL                            (DEF_INT_08S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_08S_MAX_VAL                             DEF_INT_08S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_08U_NBR_DIG_MIN                           1u
N#define  DEF_INT_08U_NBR_DIG_MAX                           3u
N
N#define  DEF_INT_08S_NBR_DIG_MIN                           3u
N#define  DEF_INT_08S_NBR_DIG_MAX                           3u
N
N
N
N#define  DEF_INT_16_NBR_BITS                              16u
N#define  DEF_INT_16_MASK                              0xFFFFu
N
N#define  DEF_INT_16U_MIN_VAL                               0u
N#define  DEF_INT_16U_MAX_VAL                           65535u
N
N#define  DEF_INT_16S_MIN_VAL_ONES_CPL                (-32767)
N#define  DEF_INT_16S_MAX_VAL_ONES_CPL                  32767
N
N#define  DEF_INT_16S_MIN_VAL                            (DEF_INT_16S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_16S_MAX_VAL                             DEF_INT_16S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_16U_NBR_DIG_MIN                           1u
N#define  DEF_INT_16U_NBR_DIG_MAX                           5u
N
N#define  DEF_INT_16S_NBR_DIG_MIN                           5u
N#define  DEF_INT_16S_NBR_DIG_MAX                           5u
N
N
N
N#define  DEF_INT_32_NBR_BITS                              32u
N#define  DEF_INT_32_MASK                          0xFFFFFFFFu
N
N#define  DEF_INT_32U_MIN_VAL                               0u
N#define  DEF_INT_32U_MAX_VAL                      4294967295u
N
N#define  DEF_INT_32S_MIN_VAL_ONES_CPL           (-2147483647)
N#define  DEF_INT_32S_MAX_VAL_ONES_CPL             2147483647
N
N#define  DEF_INT_32S_MIN_VAL                            (DEF_INT_32S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_32S_MAX_VAL                             DEF_INT_32S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_32U_NBR_DIG_MIN                           1u
N#define  DEF_INT_32U_NBR_DIG_MAX                          10u
N
N#define  DEF_INT_32S_NBR_DIG_MIN                          10u
N#define  DEF_INT_32S_NBR_DIG_MAX                          10u
N
N
N
N#define  DEF_INT_64_NBR_BITS                              64u
N#define  DEF_INT_64_MASK                  0xFFFFFFFFFFFFFFFFu
N
N#define  DEF_INT_64U_MIN_VAL                               0u
N#define  DEF_INT_64U_MAX_VAL            18446744073709551615u
N
N#define  DEF_INT_64S_MIN_VAL_ONES_CPL  (-9223372036854775807)
N#define  DEF_INT_64S_MAX_VAL_ONES_CPL    9223372036854775807
N
N#define  DEF_INT_64S_MIN_VAL                            (DEF_INT_64S_MIN_VAL_ONES_CPL - 1)
N#define  DEF_INT_64S_MAX_VAL                             DEF_INT_64S_MAX_VAL_ONES_CPL
N
N#define  DEF_INT_64U_NBR_DIG_MIN                           1u
N#define  DEF_INT_64U_NBR_DIG_MAX                          20u
N
N#define  DEF_INT_64S_NBR_DIG_MIN                          19u
N#define  DEF_INT_64S_NBR_DIG_MAX                          19u
N
N
N                                                                /* --------------- CPU INTEGER DEFINES ---------------- */
N#define  DEF_INT_CPU_NBR_BITS                           (CPU_CFG_DATA_SIZE     * DEF_OCTET_NBR_BITS)
N#define  DEF_INT_CPU_NBR_BITS_MAX                       (CPU_CFG_DATA_SIZE_MAX * DEF_OCTET_NBR_BITS)
N
N
N
N#if     (DEF_INT_CPU_NBR_BITS == DEF_INT_08_NBR_BITS)
X#if     ((4u * 8u) == 8u)
S
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_08_MASK
S
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_08U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_08U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_08S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_08S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_08S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_08S_MAX_VAL_ONES_CPL
S
S
S
S#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_16_NBR_BITS)
X#elif   ((4u * 8u) == 16u)
S
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_16_MASK
S
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_16U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_16U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_16S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_16S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_16S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_16S_MAX_VAL_ONES_CPL
S
S
S
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_32_NBR_BITS)
X#elif   ((4u * 8u) == 32u)
N
N
N#define  DEF_INT_CPU_MASK                                DEF_INT_32_MASK
N
N#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_32U_MIN_VAL
N#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_32U_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_32S_MIN_VAL
N#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_32S_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_32S_MIN_VAL_ONES_CPL
N#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_32S_MAX_VAL_ONES_CPL
N
N
N
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_64_NBR_BITS)
S
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_64_MASK
S
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_64U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_64U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_64S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_64S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_64S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_64S_MAX_VAL_ONES_CPL
S
S
S
S#else
S
S#error  "CPU_CFG_DATA_SIZE  illegally #defined in 'cpu.h'      "
S#error  "                   [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N                                                                /* ------------------- TIME DEFINES ------------------- */
N#define  DEF_TIME_NBR_DAY_PER_WK                           7u
N#define  DEF_TIME_NBR_DAY_PER_YR                         365u
N#define  DEF_TIME_NBR_DAY_PER_YR_LEAP                    366u
N
N#define  DEF_TIME_NBR_HR_PER_DAY                          24u
N#define  DEF_TIME_NBR_HR_PER_WK                         (DEF_TIME_NBR_HR_PER_DAY  * DEF_TIME_NBR_DAY_PER_WK     )
N#define  DEF_TIME_NBR_HR_PER_YR                         (DEF_TIME_NBR_HR_PER_DAY  * DEF_TIME_NBR_DAY_PER_YR     )
N#define  DEF_TIME_NBR_HR_PER_YR_LEAP                    (DEF_TIME_NBR_HR_PER_DAY  * DEF_TIME_NBR_DAY_PER_YR_LEAP)
N
N#define  DEF_TIME_NBR_MIN_PER_HR                          60u
N#define  DEF_TIME_NBR_MIN_PER_DAY                       (DEF_TIME_NBR_MIN_PER_HR  * DEF_TIME_NBR_HR_PER_DAY     )
N#define  DEF_TIME_NBR_MIN_PER_WK                        (DEF_TIME_NBR_MIN_PER_DAY * DEF_TIME_NBR_DAY_PER_WK     )
N#define  DEF_TIME_NBR_MIN_PER_YR                        (DEF_TIME_NBR_MIN_PER_DAY * DEF_TIME_NBR_DAY_PER_YR     )
N#define  DEF_TIME_NBR_MIN_PER_YR_LEAP                   (DEF_TIME_NBR_MIN_PER_DAY * DEF_TIME_NBR_DAY_PER_YR_LEAP)
N
N#define  DEF_TIME_NBR_SEC_PER_MIN                         60u
N#define  DEF_TIME_NBR_SEC_PER_HR                        (DEF_TIME_NBR_SEC_PER_MIN * DEF_TIME_NBR_MIN_PER_HR     )
N#define  DEF_TIME_NBR_SEC_PER_DAY                       (DEF_TIME_NBR_SEC_PER_HR  * DEF_TIME_NBR_HR_PER_DAY     )
N#define  DEF_TIME_NBR_SEC_PER_WK                        (DEF_TIME_NBR_SEC_PER_DAY * DEF_TIME_NBR_DAY_PER_WK     )
N#define  DEF_TIME_NBR_SEC_PER_YR                        (DEF_TIME_NBR_SEC_PER_DAY * DEF_TIME_NBR_DAY_PER_YR     )
N#define  DEF_TIME_NBR_SEC_PER_YR_LEAP                   (DEF_TIME_NBR_SEC_PER_DAY * DEF_TIME_NBR_DAY_PER_YR_LEAP)
N
N#define  DEF_TIME_NBR_mS_PER_SEC                        1000u
N#define  DEF_TIME_NBR_uS_PER_SEC                     1000000u
N#define  DEF_TIME_NBR_nS_PER_SEC                  1000000000u
N
N
N/*
N*********************************************************************************************************
N*                                             ERROR CODES
N*
N* Note(s) : (1) All library error codes are #define'd in 'lib_def.h';
N*********************************************************************************************************
N*/
N
Ntypedef enum lib_err {
N
N    LIB_ERR_NONE                            =         0u,
N
N    LIB_MEM_ERR_NONE                        =     10000u,
N    LIB_MEM_ERR_NULL_PTR                    =     10001u,       /* Ptr arg(s) passed NULL ptr(s).                       */
N
N    LIB_MEM_ERR_INVALID_MEM_SIZE            =     10100u,       /* Invalid mem     size.                                */
N    LIB_MEM_ERR_INVALID_MEM_ALIGN           =     10101u,       /* Invalid mem     align.                               */
N    LIB_MEM_ERR_INVALID_SEG_SIZE            =     10110u,       /* Invalid mem seg size.                                */
N    LIB_MEM_ERR_INVALID_SEG_OVERLAP         =     10111u,       /* Invalid mem seg overlaps other mem seg(s).           */
N    LIB_MEM_ERR_INVALID_SEG_EXISTS          =     10112u,       /* Invalid mem seg already exists.                      */
N    LIB_MEM_ERR_INVALID_POOL                =     10120u,       /* Invalid mem pool.                                    */
N    LIB_MEM_ERR_INVALID_BLK_NBR             =     10130u,       /* Invalid mem pool blk nbr.                            */
N    LIB_MEM_ERR_INVALID_BLK_SIZE            =     10131u,       /* Invalid mem pool blk size.                           */
N    LIB_MEM_ERR_INVALID_BLK_ALIGN           =     10132u,       /* Invalid mem pool blk align.                          */
N    LIB_MEM_ERR_INVALID_BLK_IX              =     10133u,       /* Invalid mem pool ix.                                 */
N    LIB_MEM_ERR_INVALID_BLK_ADDR            =     10135u,       /* Invalid mem pool blk addr.                           */
N    LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL    =     10136u,       /* Mem pool blk addr already in mem pool.               */
N
N    LIB_MEM_ERR_SEG_EMPTY                   =     10200u,       /* Mem seg  empty; i.e. NO avail mem in seg.            */
N    LIB_MEM_ERR_SEG_OVF                     =     10201u,       /* Mem seg  ovf;   i.e. req'd mem ovfs rem mem in seg.  */
N    LIB_MEM_ERR_POOL_FULL                   =     10205u,       /* Mem pool full;  i.e. all mem blks avail in mem pool. */
N    LIB_MEM_ERR_POOL_EMPTY                  =     10206u,       /* Mem pool empty; i.e. NO  mem blks avail in mem pool. */
N    LIB_MEM_ERR_POOL_UNLIMITED              =     10207u,       /* Mem pool is unlimited.                               */
N
N    LIB_MEM_ERR_HEAP_EMPTY                  =     10210u,       /* Heap seg empty; i.e. NO avail mem in heap.           */
N    LIB_MEM_ERR_HEAP_OVF                    =     10211u,       /* Heap seg ovf;   i.e. req'd mem ovfs rem mem in heap. */
N    LIB_MEM_ERR_HEAP_NOT_FOUND              =     10215u        /* Heap seg NOT found.                                  */
N
N} LIB_ERR;
N
N
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               TRACING
N*********************************************************************************************************
N*/
N
N                                                                /* Trace level, default to TRACE_LEVEL_OFF.             */
N#ifndef  TRACE_LEVEL_OFF
N#define  TRACE_LEVEL_OFF                                   0u
N#endif
N
N#ifndef  TRACE_LEVEL_INFO
N#define  TRACE_LEVEL_INFO                                  1u
N#endif
N
N#ifndef  TRACE_LEVEL_DBG
N#define  TRACE_LEVEL_DBG                                   2u
N#endif
N
N#ifndef  TRACE_LEVEL_LOG
N#define  TRACE_LEVEL_LOG                                   3u
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             BIT MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_BIT()
N*
N* Description : Create bit mask with single, specified bit set.
N*
N* Argument(s) : bit         Bit number of bit to set.
N*
N* Return(s)   : Bit mask with single, specified bit set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit' SHOULD be a non-negative integer.
N*
N*               (2) (a) 'bit' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                       or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT(bit)                                                   (1u << (bit))
N
N
N/*
N*********************************************************************************************************
N*                                             DEF_BITxx()
N*
N* Description : Create bit mask of specified bit size with single, specified bit set.
N*
N* Argument(s) : bit         Bit number of bit to set.
N*
N* Return(s)   : Bit mask with single, specified bit set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit' SHOULD be a non-negative integer.
N*
N*               (2) (a) 'bit' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                       or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*
N*                   (b) To avoid overflowing any target CPU &/or compiler's integer data type, unsigned
N*                       bit constant '1' is cast to specified integer data type size.
N*
N*               (3) Ideally, DEF_BITxx() macro's should be named DEF_BIT_xx(); however, these names already
N*                   previously-released for bit constant #define's (see 'STANDARD DEFINES  BIT DEFINES').
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT08(bit)                        ((CPU_INT08U)((CPU_INT08U)1u  << (bit)))
N
N#define  DEF_BIT16(bit)                        ((CPU_INT16U)((CPU_INT16U)1u  << (bit)))
N
N#define  DEF_BIT32(bit)                        ((CPU_INT32U)((CPU_INT32U)1u  << (bit)))
N
N#define  DEF_BIT64(bit)                        ((CPU_INT64U)((CPU_INT64U)1u  << (bit)))
N
N
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_MASK()
N*
N* Description : Shift a bit mask.
N*
N* Argument(s) : bit_mask    Bit mask to shift.
N*
N*               bit_shift   Number of bit positions to left-shift bit mask.
N*
N* Return(s)   : Shifted bit mask.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) 'bit_mask'  SHOULD be an unsigned    integer.
N*
N*                   (b) 'bit_shift' SHOULD be a non-negative integer.
N*
N*               (2) 'bit_shift' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_MASK(bit_mask, bit_shift)                                     ((bit_mask) << (bit_shift))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_MASK_xx()
N*
N* Description : Shift a bit mask of specified bit size.
N*
N* Argument(s) : bit_mask    Bit mask to shift.
N*
N*               bit_shift   Number of bit positions to left-shift bit mask.
N*
N* Return(s)   : Shifted bit mask.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) 'bit_mask'  SHOULD be an unsigned    integer.
N*
N*                   (b) 'bit_shift' SHOULD be a non-negative integer.
N*
N*               (2) 'bit_shift' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_MASK_08(bit_mask, bit_shift)         ((CPU_INT08U)((CPU_INT08U)(bit_mask) << (bit_shift)))
N
N#define  DEF_BIT_MASK_16(bit_mask, bit_shift)         ((CPU_INT16U)((CPU_INT16U)(bit_mask) << (bit_shift)))
N
N#define  DEF_BIT_MASK_32(bit_mask, bit_shift)         ((CPU_INT32U)((CPU_INT32U)(bit_mask) << (bit_shift)))
N
N#define  DEF_BIT_MASK_64(bit_mask, bit_shift)         ((CPU_INT64U)((CPU_INT64U)(bit_mask) << (bit_shift)))
N
N
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_FIELD()
N*
N* Description : Create & shift a contiguous bit field.
N*
N* Argument(s) : bit_field   Number of contiguous bits to set in the bit field.
N*
N*               bit_shift   Number of bit positions   to left-shift bit field.
N*
N* Return(s)   : Shifted bit field.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_field' & 'bit_shift' SHOULD be non-negative integers.
N*
N*               (2) (a) 'bit_field'/'bit_shift' values that overflow the target CPU &/or compiler
N*                       environment (e.g. negative or greater-than-CPU-data-size values) MAY generate
N*                       compiler warnings &/or errors.
N*
N*                   (b) To avoid overflowing any target CPU &/or compiler's integer data type, unsigned
N*                       bit constant '1' is suffixed with 'L'ong integer modifier.
N*
N*                       This may still be insufficient for CPUs &/or compilers that support 'long long'
N*                       integer data types, in which case 'LL' integer modifier should be suffixed.
N*                       However, since almost all 16- & 32-bit CPUs & compilers support 'long' integer
N*                       data types but many may NOT support 'long long' integer data types, only 'long'
N*                       integer data types & modifiers are supported.
N*
N*                       See also 'DEF_BIT_FIELD_xx()  Note #1b'.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD(bit_field, bit_shift)                                 ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)     \
N                                                                                                                     : (DEF_BIT(bit_field) - 1uL)) \
N                                                                                                                            << (bit_shift))
X#define  DEF_BIT_FIELD(bit_field, bit_shift)                                 ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)                                                                                                                          : (DEF_BIT(bit_field) - 1uL))                                                                                                                             << (bit_shift))
N
N/*
N*********************************************************************************************************
N*                                         DEF_BIT_FIELD_xx()
N*
N* Description : Create & shift a contiguous bit field of specified bit size.
N*
N* Argument(s) : bit_field   Number of contiguous bits to set in the bit field.
N*
N*               bit_shift   Number of bit positions   to left-shift bit field.
N*
N* Return(s)   : Shifted bit field.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_field' & 'bit_shift' SHOULD be non-negative integers.
N*
N*               (2) (a) 'bit_field'/'bit_shift' values that overflow the target CPU &/or compiler
N*                       environment (e.g. negative or greater-than-CPU-data-size values) MAY generate
N*                       compiler warnings &/or errors.
N*
N*                   (b) To avoid overflowing any target CPU &/or compiler's integer data type, unsigned
N*                       bit constant '1' is cast to specified integer data type size.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD_08(bit_field, bit_shift)     ((CPU_INT08U)((((CPU_INT08U)(bit_field) >= (CPU_INT08U)DEF_INT_08_NBR_BITS) ? (CPU_INT08U)(DEF_INT_08U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT08U)(DEF_BIT08(bit_field) - (CPU_INT08U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_08(bit_field, bit_shift)     ((CPU_INT08U)((((CPU_INT08U)(bit_field) >= (CPU_INT08U)DEF_INT_08_NBR_BITS) ? (CPU_INT08U)(DEF_INT_08U_MAX_VAL)                                                                                                                                                    : (CPU_INT08U)(DEF_BIT08(bit_field) - (CPU_INT08U)1u))                                                                                                                                                      << (bit_shift)))
N
N#define  DEF_BIT_FIELD_16(bit_field, bit_shift)     ((CPU_INT16U)((((CPU_INT16U)(bit_field) >= (CPU_INT16U)DEF_INT_16_NBR_BITS) ? (CPU_INT16U)(DEF_INT_16U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT16U)(DEF_BIT16(bit_field) - (CPU_INT16U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_16(bit_field, bit_shift)     ((CPU_INT16U)((((CPU_INT16U)(bit_field) >= (CPU_INT16U)DEF_INT_16_NBR_BITS) ? (CPU_INT16U)(DEF_INT_16U_MAX_VAL)                                                                                                                                                    : (CPU_INT16U)(DEF_BIT16(bit_field) - (CPU_INT16U)1u))                                                                                                                                                      << (bit_shift)))
N
N#define  DEF_BIT_FIELD_32(bit_field, bit_shift)     ((CPU_INT32U)((((CPU_INT32U)(bit_field) >= (CPU_INT32U)DEF_INT_32_NBR_BITS) ? (CPU_INT32U)(DEF_INT_32U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT32U)(DEF_BIT32(bit_field) - (CPU_INT32U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_32(bit_field, bit_shift)     ((CPU_INT32U)((((CPU_INT32U)(bit_field) >= (CPU_INT32U)DEF_INT_32_NBR_BITS) ? (CPU_INT32U)(DEF_INT_32U_MAX_VAL)                                                                                                                                                    : (CPU_INT32U)(DEF_BIT32(bit_field) - (CPU_INT32U)1u))                                                                                                                                                      << (bit_shift)))
N
N#define  DEF_BIT_FIELD_64(bit_field, bit_shift)     ((CPU_INT64U)((((CPU_INT64U)(bit_field) >= (CPU_INT64U)DEF_INT_64_NBR_BITS) ? (CPU_INT64U)(DEF_INT_64U_MAX_VAL)                    \
N                                                                                                                                : (CPU_INT64U)(DEF_BIT64(bit_field) - (CPU_INT64U)1u)) \
N                                                                                                                                                     << (bit_shift)))
X#define  DEF_BIT_FIELD_64(bit_field, bit_shift)     ((CPU_INT64U)((((CPU_INT64U)(bit_field) >= (CPU_INT64U)DEF_INT_64_NBR_BITS) ? (CPU_INT64U)(DEF_INT_64U_MAX_VAL)                                                                                                                                                    : (CPU_INT64U)(DEF_BIT64(bit_field) - (CPU_INT64U)1u))                                                                                                                                                      << (bit_shift)))
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_SET()
N*
N* Description : Set specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by setting specified bit(s).
N*
N*               mask        Mask of bits to set.
N*
N* Return(s)   : Modified value with specified bit(s) set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_SET(val, mask)                        ((val) = ((val) | (mask)))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_SET_xx()
N*
N* Description : Set specified bit(s) in a value of specified bit size.
N*
N* Argument(s) : val         Value to modify by setting specified bit(s).
N*
N*               mask        Mask of bits to set.
N*
N* Return(s)   : Modified value with specified bit(s) set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) These macros are deprecated and should be replaced by the DEF_BIT_SET macro.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_SET_08(val, mask)                     DEF_BIT_SET((val), (mask))
N
N#define  DEF_BIT_SET_16(val, mask)                     DEF_BIT_SET((val), (mask))
N
N#define  DEF_BIT_SET_32(val, mask)                     DEF_BIT_SET((val), (mask))
N
N#define  DEF_BIT_SET_64(val, mask)                     DEF_BIT_SET((val), (mask))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_CLR_xx()
N*
N* Description : Clear specified bit(s) in a value of specified bit size.
N*
N* Argument(s) : val         Value to modify by clearing specified bit(s).
N*
N*               mask        Mask of bits to clear.
N*
N* Return(s)   : Modified value with specified bit(s) clear.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#if (CPU_CFG_DATA_SIZE > CPU_WORD_SIZE_08)
X#if (4u > 1u)
N#define  DEF_BIT_CLR_08(val, mask)                     ((val) = ((val) & (~(mask))))
N#else
S#define  DEF_BIT_CLR_08(val, mask)                     ((val) = ((val) & (~((CPU_INT08U)mask))))
N#endif
N
N#if (CPU_CFG_DATA_SIZE > CPU_WORD_SIZE_16)
X#if (4u > 2u)
N#define  DEF_BIT_CLR_16(val, mask)                     ((val) = ((val) & (~(mask))))
N#else
S#define  DEF_BIT_CLR_16(val, mask)                     ((val) = ((val) & (~((CPU_INT16U)mask))))
N#endif
N
N#if (CPU_CFG_DATA_SIZE > CPU_WORD_SIZE_32)
X#if (4u > 4u)
S#define  DEF_BIT_CLR_32(val, mask)                     ((val) = ((val) & (~(mask))))
N#else
N#define  DEF_BIT_CLR_32(val, mask)                     ((val) = ((val) & (~((CPU_INT32U)mask))))
N#endif
N
N#define  DEF_BIT_CLR_64(val, mask)                     ((val) = ((val) & (~((CPU_INT64U)mask))))
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_CLR()
N*
N* Description : Clear specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by clearing specified bit(s).
N*
N*               mask        Mask of bits to clear.
N*
N* Return(s)   : Modified value with specified bit(s) clear.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_08)
X#if     (8u == 1u)
S
S#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) : 0)
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_16)
X#elif   (8u == 2u)
S
S#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :   \
S                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) : 0))
X#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :                                                   ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) : 0))
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_32)
X#elif   (8u == 4u)
S
S#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :    \
S                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :    \
S                                                ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) : 0)))
X#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :                                                    ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :                                                    ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) : 0)))
S
S
N#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_64)
X#elif   (8u == 8u)
N
N#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) :     \
N                                                ((sizeof(val) == CPU_WORD_SIZE_64) ? DEF_BIT_CLR_64(val, mask) : 0))))
X#define  DEF_BIT_CLR(val, mask)                 ((sizeof(val) == CPU_WORD_SIZE_08) ? DEF_BIT_CLR_08(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_16) ? DEF_BIT_CLR_16(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_32) ? DEF_BIT_CLR_32(val, mask) :                                                     ((sizeof(val) == CPU_WORD_SIZE_64) ? DEF_BIT_CLR_64(val, mask) : 0))))
N
N#else
S
S#error  "CPU_CFG_DATA_SIZE_MAX  illegally #defined in 'cpu.h'      "
S#error  "                       [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_TOGGLE()
N*
N* Description : Toggles specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by toggling specified bit(s).
N*
N*               mask        Mask of bits to toggle.
N*
N* Return(s)   : Modified value with specified bit(s) toggled.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_TOGGLE(val, mask)                      ((val) ^= (mask))
N
N
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_FIELD_RD()
N*
N* Description : Reads a 'val' field, masked and shifted, given by mask 'field_mask'.
N*
N* Argument(s) : val         Value to read from.
N*
N*               field_mask  Mask of field to read. See note #1, #2 and #3.
N*
N* Return(s)   : Field value, masked and right-shifted to bit position 0.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'field_mask' argument must NOT be 0.
N*
N*               (2) 'field_mask' argument must contain a mask with contiguous set bits.
N*
N*               (3) 'val' & 'field_mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD_RD(val, field_mask)              (((val) & (field_mask)) / ((field_mask) & ~((field_mask) << 1u)))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_FIELD_ENC()
N*
N* Description : Encodes given 'field_val' at position given by mask 'field_mask'.
N*
N* Argument(s) : field_val   Value to encode.
N*
N*               field_mask  Mask of field to read. See note #1 and #2.
N*
N* Return(s)   : Field value, masked and left-shifted to field position.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'field_mask' argument must contain a mask with contiguous set bits.
N*
N*               (2) 'field_val' & 'field_mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD_ENC(field_val, field_mask)       (((field_val) * ((field_mask) & ~((field_mask) << 1u))) & (field_mask))
N
N
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_FIELD_WR()
N*
N* Description : Writes 'field_val' field at position given by mask 'field_mask' in variable 'var'.
N*
N* Argument(s) : var         Variable to write field to. See note #2.
N*
N*               field_val   Desired value for field. See note #2.
N*
N*               field_mask  Mask of field to write to. See note #1 and #2.
N*
N* Return(s)   : None.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'field_mask' argument must contain a mask with contiguous set bits.
N*
N*               (2) 'var', 'field_val' & 'field_mask' SHOULD be unsigned integers.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD_WR(var, field_val, field_mask)   (var) = (((var) & ~(field_mask)) | DEF_BIT_FIELD_ENC((field_val), (field_mask)))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_SET()
N*
N* Description : Determine if specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set (see Note #2).
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     set in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET(val, mask)                    (((((val) & (mask)) == (mask)) && \
N                                                         ((mask)          !=  0u))    ? (DEF_YES) : (DEF_NO))
X#define  DEF_BIT_IS_SET(val, mask)                    (((((val) & (mask)) == (mask)) &&                                                          ((mask)          !=  0u))    ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_CLR()
N*
N* Description : Determine if specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear (see Note #2).
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     clear in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT clear in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR(val, mask)                    (((((val) & (mask)) ==  0u)  && \
N                                                         ((mask)          !=  0u))  ? (DEF_YES) : (DEF_NO))
X#define  DEF_BIT_IS_CLR(val, mask)                    (((((val) & (mask)) ==  0u)  &&                                                          ((mask)          !=  0u))  ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_SET_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set (see Note #2).
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     set in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET_ANY(val, mask)               ((((val) & (mask)) ==  0u)     ? (DEF_NO ) : (DEF_YES))
N
N
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_CLR_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear (see Note #2).
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     clear in value.
N*
N*               DEF_NO,  if ALL specified bit(s) are NOT clear in value.
N*
N* Note(s)     : (1) 'val' & 'mask' SHOULD be unsigned integers.
N*
N*               (2) NULL 'mask' allowed; returns 'DEF_NO' since NO mask bits specified.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR_ANY(val, mask)               ((((val) & (mask)) == (mask))  ? (DEF_NO ) : (DEF_YES))
N
N
N/*
N*********************************************************************************************************
N*                                            VALUE MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                          DEF_CHK_VAL_MIN()
N*
N* Description : Validate a value as greater than or equal to a specified minimum value.
N*
N* Argument(s) : val        Value to validate.
N*
N*               val_min    Minimum value to test.
N*
N* Return(s)   : DEF_OK,    Value is greater than or equal to minimum value.
N*
N*               DEF_FAIL,  otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) DEF_CHK_VAL_MIN() avoids directly comparing any two values if only one of the values
N*                   is negative since the negative value might be incorrectly promoted to an arbitrary
N*                   unsigned value if the other value to compare is unsigned.
N*
N*               (2) Validation of values is limited to the range supported by the compiler &/or target
N*                   environment.  All other values that underflow/overflow the supported range will
N*                   modulo/wrap into the supported range as arbitrary signed or unsigned values.
N*
N*                   Therefore, any values that underflow the most negative signed value or overflow
N*                   the most positive unsigned value supported by the compiler &/or target environment
N*                   cannot be validated :
N*
N*                           (    N-1       N     ]
N*                           ( -(2   )  ,  2  - 1 ]
N*                           (                    ]
N*
N*                               where
N*                                       N       Number of data word bits supported by the compiler
N*                                                   &/or target environment
N*
N*                   (a) Note that the most negative value, -2^(N-1), is NOT included in the supported
N*                       range since many compilers do NOT always correctly handle this value.
N*
N*               (3) 'val' and 'val_min' are compared to 1 instead of 0 to avoid warning generated for
N*                   unsigned numbers.
N*********************************************************************************************************
N*/
N
N#define  DEF_CHK_VAL_MIN(val, val_min)            (((!(((val)     >= 1) && ((val_min) < 1))) && \
N                                                     ((((val_min) >= 1) && ((val)     < 1))  || \
N                                                       ((val) < (val_min)))) ? DEF_FAIL : DEF_OK)
X#define  DEF_CHK_VAL_MIN(val, val_min)            (((!(((val)     >= 1) && ((val_min) < 1))) &&                                                      ((((val_min) >= 1) && ((val)     < 1))  ||                                                        ((val) < (val_min)))) ? DEF_FAIL : DEF_OK)
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_CHK_VAL_MAX()
N*
N* Description : Validate a value as less than or equal to a specified maximum value.
N*
N* Argument(s) : val        Value to validate.
N*
N*               val_max    Maximum value to test.
N*
N* Return(s)   : DEF_OK,    Value is less than or equal to maximum value.
N*
N*               DEF_FAIL,  otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) DEF_CHK_VAL_MAX() avoids directly comparing any two values if only one of the values
N*                   is negative since the negative value might be incorrectly promoted to an arbitrary
N*                   unsigned value if the other value to compare is unsigned.
N*
N*               (2) Validation of values is limited to the range supported by the compiler &/or target
N*                   environment.  All other values that underflow/overflow the supported range will
N*                   modulo/wrap into the supported range as arbitrary signed or unsigned values.
N*
N*                   Therefore, any values that underflow the most negative signed value or overflow
N*                   the most positive unsigned value supported by the compiler &/or target environment
N*                   cannot be validated :
N*
N*                           (    N-1       N     ]
N*                           ( -(2   )  ,  2  - 1 ]
N*                           (                    ]
N*
N*                               where
N*                                       N       Number of data word bits supported by the compiler
N*                                                   &/or target environment
N*
N*                   (a) Note that the most negative value, -2^(N-1), is NOT included in the supported
N*                       range since many compilers do NOT always correctly handle this value.
N*
N*               (3) 'val' and 'val_max' are compared to 1 instead of 0 to avoid warning generated for
N*                   unsigned numbers.
N*********************************************************************************************************
N*/
N
N#define  DEF_CHK_VAL_MAX(val, val_max)            (((!(((val_max) >= 1) && ((val)     < 1))) && \
N                                                     ((((val)     >= 1) && ((val_max) < 1))  || \
N                                                       ((val) > (val_max)))) ? DEF_FAIL : DEF_OK)
X#define  DEF_CHK_VAL_MAX(val, val_max)            (((!(((val_max) >= 1) && ((val)     < 1))) &&                                                      ((((val)     >= 1) && ((val_max) < 1))  ||                                                        ((val) > (val_max)))) ? DEF_FAIL : DEF_OK)
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_CHK_VAL()
N*
N* Description : Validate a value as greater than or equal to a specified minimum value & less than or
N*                   equal to a specified maximum value.
N*
N* Argument(s) : val        Value to validate.
N*
N*               val_min    Minimum value to test.
N*
N*               val_max    Maximum value to test.
N*
N* Return(s)   : DEF_OK,    Value is greater than or equal to minimum value AND
N*                                   less    than or equal to maximum value.
N*
N*               DEF_FAIL,  otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) DEF_CHK_VAL() avoids directly comparing any two values if only one of the values
N*                   is negative since the negative value might be incorrectly promoted to an arbitrary
N*                   unsigned value if the other value to compare is unsigned.
N*
N*               (2) Validation of values is limited to the range supported by the compiler &/or target
N*                   environment.  All other values that underflow/overflow the supported range will
N*                   modulo/wrap into the supported range as arbitrary signed or unsigned values.
N*
N*                   Therefore, any values that underflow the most negative signed value or overflow
N*                   the most positive unsigned value supported by the compiler &/or target environment
N*                   cannot be validated :
N*
N*                           (    N-1       N     ]
N*                           ( -(2   )  ,  2  - 1 ]
N*                           (                    ]
N*
N*                               where
N*                                       N       Number of data word bits supported by the compiler
N*                                                   &/or target environment
N*
N*                   (a) Note that the most negative value, -2^(N-1), is NOT included in the supported
N*                       range since many compilers do NOT always correctly handle this value.
N*
N*               (3) DEF_CHK_VAL() does NOT validate that the maximum value ('val_max') is greater than
N*                   or equal to the minimum value ('val_min').
N*********************************************************************************************************
N*/
N
N#define  DEF_CHK_VAL(val, val_min, val_max)          (((DEF_CHK_VAL_MIN((val), (val_min)) == DEF_FAIL) ||                  \
N                                                       (DEF_CHK_VAL_MAX((val), (val_max)) == DEF_FAIL)) ? DEF_FAIL : DEF_OK)
X#define  DEF_CHK_VAL(val, val_min, val_max)          (((DEF_CHK_VAL_MIN((val), (val_min)) == DEF_FAIL) ||                                                                         (DEF_CHK_VAL_MAX((val), (val_max)) == DEF_FAIL)) ? DEF_FAIL : DEF_OK)
N
N
N/*
N*********************************************************************************************************
N*                                         DEF_GET_U_MAX_VAL()
N*
N* Description : Get the maximum unsigned value that can be represented in an unsigned integer variable
N*                   of the same data type size as an object.
N*
N* Argument(s) : obj         Object or data type to return maximum unsigned value (see Note #1).
N*
N* Return(s)   : Maximum unsigned integer value that can be represented by the object, if NO error(s).
N*
N*               0,                                                                    otherwise.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'obj' SHOULD be an integer object or data type but COULD also be a character or
N*                   pointer object or data type.
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_08)
X#if     (8u == 1u)
S
S#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL : 0)
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_16)
X#elif   (8u == 2u)
S
S#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :   \
S                                                ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL : 0))
X#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :                                                   ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL : 0))
S
S
S#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_32)
X#elif   (8u == 4u)
S
S#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :    \
S                                                ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :    \
S                                                ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL : 0)))
X#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :                                                    ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :                                                    ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL : 0)))
S
S
N#elif   (CPU_CFG_DATA_SIZE_MAX == CPU_WORD_SIZE_64)
X#elif   (8u == 8u)
N
N#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :     \
N                                                ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :     \
N                                                ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL :     \
N                                                ((sizeof(obj) == CPU_WORD_SIZE_64) ? DEF_INT_64U_MAX_VAL : 0))))
X#define  DEF_GET_U_MAX_VAL(obj)                 ((sizeof(obj) == CPU_WORD_SIZE_08) ? DEF_INT_08U_MAX_VAL :                                                     ((sizeof(obj) == CPU_WORD_SIZE_16) ? DEF_INT_16U_MAX_VAL :                                                     ((sizeof(obj) == CPU_WORD_SIZE_32) ? DEF_INT_32U_MAX_VAL :                                                     ((sizeof(obj) == CPU_WORD_SIZE_64) ? DEF_INT_64U_MAX_VAL : 0))))
N
N#else
S
S#error  "CPU_CFG_DATA_SIZE_MAX  illegally #defined in 'cpu.h'      "
S#error  "                       [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                            MATH MACRO'S
N*
N* Note(s) : (1) Ideally, ALL mathematical macro's & functions SHOULD be defined in the custom mathematics
N*               library ('lib_math.*').  #### However, to maintain backwards compatibility with previously-
N*               released modules, mathematical macro & function definitions should only be moved to the
N*               custom mathematics library once all previously-released modules are updated to include the
N*               custom mathematics library.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_MIN()
N*
N* Description : Determine the minimum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Minimum of the two values.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MIN(a, b)                                  (((a) < (b)) ? (a) : (b))
N
N
N/*
N*********************************************************************************************************
N*                                              DEF_MAX()
N*
N* Description : Determine the maximum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Maximum of the two values.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MAX(a, b)                                  (((a) > (b)) ? (a) : (b))
N
N
N/*
N*********************************************************************************************************
N*                                              DEF_ABS()
N*
N* Description : Determine the absolute value of a value.
N*
N* Argument(s) : a           Value to calculate absolute value.
N*
N* Return(s)   : Absolute value of the value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_ABS(a)                                     (((a) < 0) ? (-(a)) : (a))
N
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                    LIBRARY CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N                                                                /* See 'lib_def.h  Note #1a'.                           */
N#if     (CPU_CORE_VERSION < 12900u)
X#if     (13002u < 12900u)
S#error  "CPU_CORE_VERSION  [SHOULD be >= V1.29.00]"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_def.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib def module include.                       */
N
L 107 "..\..\uCOS-III\uC-CPU\cpu_core.h" 2
N#include  <cpu_cfg.h>
N
N#if (CPU_CFG_NAME_EN == DEF_ENABLED)
X#if (1u == 1u)
N#include  <lib_mem.h>
L 1 "..\..\uCOS-III\uC-LIB\lib_mem.h" 1
N/**********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
N*
N*                  All rights reserved.  Protected by international copyright laws.
N*
N*                  uC/LIB is provided in source form to registered licensees ONLY.  It is
N*                  illegal to distribute this source code to any third party unless you receive
N*                  written permission by an authorized Micrium representative.  Knowledge of
N*                  the source code may NOT be used to develop a similar product.
N*
N*                  Please help us continue to provide the Embedded community with the finest
N*                  software available.  Your honesty is greatly appreciated.
N*
N*                  You can find our product's user manual, API reference, release notes and
N*                  more information at: https://doc.micrium.com
N*
N*                  You can contact us at: http://www.micrium.com
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     STANDARD MEMORY OPERATIONS
N*
N* Filename      : lib_mem.h
N* Version       : V1.38.01
N* Programmer(s) : ITJ
N*                 FBJ
N*                 EJ
N*                 JFD
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*
N*                 (2) Assumes the following versions (or more recent) of software modules are included in
N*                     the project build :
N*
N*                     (a) uC/CPU V1.27
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This memory library header file is protected from multiple pre-processor inclusion through
N*               use of the memory library module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_MEM_MODULE_PRESENT                                 /* See Note #1.                                         */
N#define  LIB_MEM_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Your Product Application>\lib_cfg.h
N*
N*               (b) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Your Product Application>      directory path for Your Product's Application
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Your Product Application>\' directory                            See Note #1a
N*
N*               (b) '\<Custom Library Directory>\' directory                            See Note #1b
N*
N*               (c) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*
N*           (4) NO compiler-supplied standard library functions SHOULD be used.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N#include  <cpu_core.h>
L 1 "..\..\uCOS-III\uC-CPU\cpu_core.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2015; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form to registered licensees ONLY.  It is 
N*               illegal to distribute this source code to any third party unless you receive 
N*               written permission by an authorized Micrium representative.  Knowledge of 
N*               the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest 
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can find our product's user manual, API reference, release notes and
N*               more information at https://doc.micrium.com.
N*               You can contact us at www.micrium.com.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                           CORE CPU MODULE
N*
N* Filename      : cpu_core.h
N* Version       : V1.30.02
N* Programmer(s) : SR
N*                 ITJ
N*********************************************************************************************************
N* Note(s)       : (1) Assumes the following versions (or more recent) of software modules are included in 
N*                     the project build :
N*
N*                     (a) uC/LIB V1.35.00
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This core CPU header file is protected from multiple pre-processor inclusion through use of 
N*               the  core CPU module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CORE_MODULE_PRESENT                                /* See Note #1.                                         */
S#define  CPU_CORE_MODULE_PRESENT
S
S
S/*
S*********************************************************************************************************
S*                                               EXTERNS
S*********************************************************************************************************
S*/
S
S#ifdef   CPU_CORE_MODULE
S#define  CPU_CORE_EXT
S#else
S#define  CPU_CORE_EXT  extern
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                            INCLUDE FILES
S*
S* Note(s) : (1) CPU-configuration software files are located in the following directories :
S*
S*               (a) \<Your Product Application>\cpu_cfg.h
S*
S*               (b) (1) \<CPU-Compiler Directory>\cpu_*.*
S*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
S*
S*                       where
S*                               <Your Product Application>      directory path for Your Product's Application
S*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
S*                               <cpu>                           directory name for specific processor (CPU)
S*                               <compiler>                      directory name for specific compiler
S*
S*           (2) NO compiler-supplied standard library functions SHOULD be used.
S*
S*               (a) Standard library functions are implemented in the custom library module(s) :
S*
S*                       \<Custom Library Directory>\lib_*.*
S*
S*                           where
S*                                   <Custom Library Directory>      directory path for custom library software
S*
S*           (3) Compiler MUST be configured to include as additional include path directories :
S*
S*               (a) '\<Your Product Application>\' directory                            See Note #1a
S*
S*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #1b1
S*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #1b2
S*
S*               (c) '\<Custom Library Directory>\' directory                            See Note #2a
S*********************************************************************************************************
S*/
S
S#include  <cpu.h>
S#include  <lib_def.h>
S#include  <cpu_cfg.h>
S
S#if (CPU_CFG_NAME_EN == DEF_ENABLED)
S#include  <lib_mem.h>
S#include  <lib_str.h>
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                          CPU CONFIGURATION
S*
S* Note(s) : (1) The following pre-processor directives correctly configure CPU parameters.  DO NOT MODIFY.
S*
S*           (2) CPU timestamp timer feature is required for :
S*
S*               (a) CPU timestamps
S*               (b) CPU interrupts disabled time measurement
S*
S*               See also 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
S*                      & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1'.
S*********************************************************************************************************
S*/
S
S#ifdef   CPU_CFG_TS_EN
S#undef   CPU_CFG_TS_EN
S#endif
S
S
S#if    ((CPU_CFG_TS_32_EN == DEF_ENABLED) || \
S        (CPU_CFG_TS_64_EN == DEF_ENABLED))
X#if    ((CPU_CFG_TS_32_EN == DEF_ENABLED) ||         (CPU_CFG_TS_64_EN == DEF_ENABLED))
S#define  CPU_CFG_TS_EN                          DEF_ENABLED
S#else
S#define  CPU_CFG_TS_EN                          DEF_DISABLED
S#endif
S
S#if    ((CPU_CFG_TS_EN == DEF_ENABLED) || \
S(defined(CPU_CFG_INT_DIS_MEAS_EN)))
X#if    ((CPU_CFG_TS_EN == DEF_ENABLED) || (defined(CPU_CFG_INT_DIS_MEAS_EN)))
S#define  CPU_CFG_TS_TMR_EN                      DEF_ENABLED
S#else
S#define  CPU_CFG_TS_TMR_EN                      DEF_DISABLED
S#endif
S
S/*
S*********************************************************************************************************
S*                                          CACHE CONFIGURATION
S*
S* Note(s) : (1) The following pre-processor directives correctly configure CACHE parameters.  DO NOT MODIFY.
S*
S**********************************************************************************************************
S*/
S
S#ifndef CPU_CFG_CACHE_MGMT_EN
S#define CPU_CFG_CACHE_MGMT_EN DEF_DISABLED
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                               DEFINES
S*********************************************************************************************************
S*/
S
S#define  CPU_TIME_MEAS_NBR_MIN                             1u
S#define  CPU_TIME_MEAS_NBR_MAX                           128u
S
S
S/*
S*********************************************************************************************************
S*                                             DATA TYPES
S*********************************************************************************************************
S*/
S
S
S/*
S*********************************************************************************************************
S*                                           CPU ERROR CODES
S*********************************************************************************************************
S*/
S
Stypedef enum cpu_err {
S
S    CPU_ERR_NONE                            =         0u,
S    CPU_ERR_NULL_PTR                        =        10u,
S
S    CPU_ERR_NAME_SIZE                       =      1000u,
S
S    CPU_ERR_TS_FREQ_INVALID                 =      2000u
S
S} CPU_ERR;
S
S
S/*
S*********************************************************************************************************
S*                                      CPU TIMESTAMP DATA TYPES
S*
S* Note(s) : (1) CPU timestamp timer data type defined to the binary-multiple of 8-bit octets as configured 
S*               by 'CPU_CFG_TS_TMR_SIZE' (see 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #2').
S*********************************************************************************************************
S*/
S
Stypedef  CPU_INT32U  CPU_TS32;
Stypedef  CPU_INT64U  CPU_TS64;
S
Stypedef  CPU_TS32    CPU_TS;                                    /* Req'd for backwards-compatibility.                   */
S
S
S#if     (CPU_CFG_TS_TMR_EN   == DEF_ENABLED)                    /* CPU ts tmr defined to cfg'd word size (see Note #1). */
S#if     (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_08)
Stypedef  CPU_INT08U  CPU_TS_TMR;
S#elif   (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_TS_TMR;
S#elif   (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_64)
Stypedef  CPU_INT64U  CPU_TS_TMR;
S#else                                                           /* CPU ts tmr dflt size = 32-bits.                      */
Stypedef  CPU_INT32U  CPU_TS_TMR;
S#endif
S#endif
S
S
S/*
S*********************************************************************************************************
S*                               CPU TIMESTAMP TIMER FREQUENCY DATA TYPE
S*********************************************************************************************************
S*/
S
Stypedef  CPU_INT32U  CPU_TS_TMR_FREQ;
S
S
S/*
S*********************************************************************************************************
S*                                          GLOBAL VARIABLES
S*********************************************************************************************************
S*/
S
S#if    (CPU_CFG_NAME_EN   == DEF_ENABLED)
SCPU_CORE_EXT  CPU_CHAR         CPU_Name[CPU_CFG_NAME_SIZE];     /* CPU host name.                                       */
S#endif
S
S
S#if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
S     (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
X#if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  &&      (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
SCPU_CORE_EXT  CPU_TS32         CPU_TS_32_Accum;                 /* 32-bit accum'd ts  (in ts tmr cnts).                 */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_TS_32_TmrPrev;               /* 32-bit ts prev tmr (in ts tmr cnts).                 */
S#endif
S
S#if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
S     (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
X#if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  &&      (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
SCPU_CORE_EXT  CPU_TS64         CPU_TS_64_Accum;                 /* 64-bit accum'd ts  (in ts tmr cnts).                 */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_TS_64_TmrPrev;               /* 64-bit ts prev tmr (in ts tmr cnts).                 */
S#endif
S
S#if  (CPU_CFG_TS_TMR_EN   == DEF_ENABLED)
SCPU_CORE_EXT  CPU_TS_TMR_FREQ  CPU_TS_TmrFreq_Hz;               /* CPU ts tmr freq (in Hz).                             */
S#endif
S
S
S#ifdef  CPU_CFG_INT_DIS_MEAS_EN
SCPU_CORE_EXT  CPU_INT16U       CPU_IntDisMeasCtr;               /* Nbr tot    ints dis'd ctr.                           */
SCPU_CORE_EXT  CPU_INT16U       CPU_IntDisNestCtr;               /* Nbr nested ints dis'd ctr.                           */
S                                                                /* Ints dis'd time (in ts tmr cnts) : ...               */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasStart_cnts;        /* ...  start time.                                     */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasStop_cnts;         /* ...  stop  time.                                     */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasOvrhd_cnts;        /* ...        time meas ovrhd.                          */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasMaxCur_cnts;       /* ...     resetable max time dis'd.                    */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasMax_cnts;          /* ... non-resetable max time dis'd.                    */
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                               MACRO'S
S*********************************************************************************************************
S*/
S
S/*
S*********************************************************************************************************
S*                                         CPU_SW_EXCEPTION()
S*
S* Description : Trap unrecoverable software exception.
S*
S* Argument(s) : err_rtn_val     Error type &/or value of the calling function to return (see Note #2b).
S*
S* Return(s)   : none.
S*
S* Caller(s)   : various.
S*
S* Note(s)     : (1) CPU_SW_EXCEPTION() deadlocks the current code execution -- whether multi-tasked/
S*                   -processed/-threaded or single-threaded -- when the current code execution cannot 
S*                   gracefully recover or report a fault or exception condition.
S*
S*                   Example CPU_SW_EXCEPTION() call :
S*
S*                       void  Fnct (CPU_ERR  *p_err)
S*                       {
S*                           :
S*
S*                           if (p_err == (CPU_ERR *)0) {        If 'p_err' NULL, cannot return error ...
S*                               CPU_SW_EXCEPTION(;);            ... so trap invalid argument exception.
S*                           }
S*
S*                           :
S*                       }
S*
S*                   See also 'cpu_core.c  CPU_SW_Exception()  Note #1'.
S*
S*               (2) (a) CPU_SW_EXCEPTION()  MAY be developer-implemented to output &/or handle any error or 
S*                       exception conditions; but since CPU_SW_EXCEPTION() is intended to trap unrecoverable 
S*                       software  conditions, it is recommended that developer-implemented versions prevent 
S*                       execution of any code following calls to CPU_SW_EXCEPTION() by deadlocking the code 
S*                       (see Note #1).
S*
S*                           Example CPU_SW_EXCEPTION() :
S*
S*                               #define  CPU_SW_EXCEPTION(err_rtn_val)      do {                         \
S*                                                                               Log(__FILE__, __LINE__); \
S*                                                                               CPU_SW_Exception();      \
S*                                                                           } while (0)
X
S*
S*                   (b) (1) However, if execution of code following calls to CPU_SW_EXCEPTION() is required 
S*                           (e.g. for automated testing); it is recommended that the last statement in 
S*                           developer-implemented versions be to return from the current function to prevent 
S*                           possible software exception(s) in the current function from triggering CPU &/or 
S*                           hardware exception(s).
S*
S*                           Example CPU_SW_EXCEPTION() :
S*
S*                               #define  CPU_SW_EXCEPTION(err_rtn_val)      do {                         \
S*                                                                               Log(__FILE__, __LINE__); \
S*                                                                               return  err_rtn_val;     \
S*                                                                           } while (0)
X
S*
S*                           (A) Note that 'err_rtn_val' in the return statement MUST NOT be enclosed in 
S*                               parentheses.  This allows CPU_SW_EXCEPTION() to return from functions that 
S*                               return 'void', i.e. NO return type or value (see also Note #2b2A).
S*
S*                       (2) In order for CPU_SW_EXCEPTION() to return from functions with various return 
S*                           types/values, each caller function MUST pass an appropriate error return type 
S*                           & value to CPU_SW_EXCEPTION().
S*
S*                           (A) Note that CPU_SW_EXCEPTION()  MUST NOT be passed any return type or value 
S*                               for functions that return 'void', i.e. NO return type or value; but SHOULD 
S*                               instead be passed a single semicolon.  This prevents possible compiler 
S*                               warnings that CPU_SW_EXCEPTION() is passed too few arguments.  However, 
S*                               the compiler may warn that CPU_SW_EXCEPTION() does NOT prevent creating 
S*                               null statements on lines with NO other code statements.
S*
S*                           Example CPU_SW_EXCEPTION() calls :
S*
S*                               void  Fnct (CPU_ERR  *p_err)
S*                               {
S*                                   :
S*
S*                                   if (p_err == (CPU_ERR *)0) {
S*                                       CPU_SW_EXCEPTION(;);            Exception macro returns NO value
S*                                   }                                       (see Note #2b2A)
S*
S*                                   :
S*                               }
S*
S*                               CPU_BOOLEAN  Fnct (CPU_ERR  *p_err)
S*                               {
S*                                   :
S*
S*                                   if (p_err == (CPU_ERR *)0) {
S*                                       CPU_SW_EXCEPTION(DEF_FAIL);     Exception macro returns 'DEF_FAIL'
S*                                   }
S*
S*                                   :
S*                               }
S*
S*                               OBJ  *Fnct (CPU_ERR  *p_err)
S*                               {
S*                                   :
S*
S*                                   if (p_err == (CPU_ERR *)0) {
S*                                       CPU_SW_EXCEPTION((OBJ *)0);     Exception macro returns NULL 'OBJ *'
S*                                   }
S*
S*                                   :
S*                               }
S*
S*********************************************************************************************************
S*/
S
S#ifndef  CPU_SW_EXCEPTION                                                       /* See Note #2.                         */
S#define  CPU_SW_EXCEPTION(err_rtn_val)              do {                    \
S                                                        CPU_SW_Exception(); \
S                                                    } while (0)
X#define  CPU_SW_EXCEPTION(err_rtn_val)              do {                                                                            CPU_SW_Exception();                                                     } while (0)
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                           CPU_VAL_UNUSED()
S*
S* Description : 
S*
S* Argument(s) : none.
S*
S* Return(s)   : none.
S*
S* Caller(s)   : #### various.
S*
S* Note(s)     : none.
S*********************************************************************************************************
S*/
S
S
S#define  CPU_VAL_UNUSED(val)        ((void)&(val));
S
S
S#define  CPU_VAL_IGNORED(val)       CPU_VAL_UNUSED(val)
S
S
S/*
S*********************************************************************************************************
S*                                          CPU_TYPE_CREATE()
S*
S* Description : Creates a generic type value.
S*
S* Argument(s) : char_1      1st ASCII character to create generic type value.
S*
S*               char_2      2nd ASCII character to create generic type value.
S*
S*               char_3      3rd ASCII character to create generic type value.
S*
S*               char_4      4th ASCII character to create generic type value.
S*
S* Return(s)   : 32-bit generic type value.
S*
S* Caller(s)   : various.
S*
S* Note(s)     : (1) (a) Generic type values should be #define'd with large, non-trivial values to trap 
S*                       & discard invalid/corrupted objects based on type value.
S*
S*                       In other words, by assigning large, non-trivial values to valid objects' type 
S*                       fields; the likelihood that an object with an unassigned &/or corrupted type 
S*                       field will contain a value is highly improbable & therefore the object itself 
S*                       will be trapped as invalid.
S*
S*                   (b) (1) CPU_TYPE_CREATE()  creates a 32-bit type value from four values.
S*
S*                       (2) Ideally, generic type values SHOULD be created from 'CPU_CHAR' characters to 
S*                           represent ASCII string abbreviations of the specific object types.  Memory 
S*                           displays of object type values will display the specific object types with 
S*                           their chosen ASCII names.
S*
S*                           Examples :
S*
S*                               #define  FILE_TYPE  CPU_TYPE_CREATE('F', 'I', 'L', 'E')
S*                               #define  BUF_TYPE   CPU_TYPE_CREATE('B', 'U', 'F', ' ')
S*********************************************************************************************************
S*/
S
S#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4))))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4))))
S
S#else
S
S#if    ((CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_64) || \
S        (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_32))
X#if    ((CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_64) ||         (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_32))
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1))) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (1u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (3u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1))) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (3u * DEF_OCTET_NBR_BITS)))
S
S
S#elif   (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_16)
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3))) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (1u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3))) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (1u * DEF_OCTET_NBR_BITS)))
S
S#else                                                           /* Dflt CPU_WORD_SIZE_08.                               */
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4))))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4))))
S#endif
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                         FUNCTION PROTOTYPES
S*
S* Note(s) : (1) CPU interrupts disabled time measurement functions prototyped/defined only if 
S*               CPU_CFG_INT_DIS_MEAS_EN  #define'd in 'cpu_cfg.h'.
S*
S*           (2) (a) CPU_CntLeadZeros()  defined in :
S*
S*                   (1) 'cpu_a.asm',  if CPU_CFG_LEAD_ZEROS_ASM_PRESENT       #define'd in 'cpu.h'/
S*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
S*
S*                   (2) 'cpu_core.c', if CPU_CFG_LEAD_ZEROS_ASM_PRESENT   NOT #define'd in 'cpu.h'/
S*                                         'cpu_cfg.h' to enable C-source-optimized function(s)
S*
S*               (b) CPU_CntTrailZeros() defined in :
S*
S*                   (1) 'cpu_a.asm',  if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT      #define'd in 'cpu.h'/
S*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
S*
S*                   (2) 'cpu_core.c', if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT  NOT #define'd in 'cpu.h'/
S*                                         'cpu_cfg.h' to enable C-source-optimized function(s)
S*********************************************************************************************************
S*/
S
Svoid             CPU_Init                 (void);
S
Svoid             CPU_SW_Exception         (void);
S
S
S
S#if (CPU_CFG_NAME_EN == DEF_ENABLED)                                    /* -------------- CPU NAME FNCTS -------------- */
Svoid             CPU_NameClr              (void);
S
Svoid             CPU_NameGet              (       CPU_CHAR  *p_name,
S                                                  CPU_ERR   *p_err);
S
Svoid             CPU_NameSet              (const  CPU_CHAR  *p_name,
S                                                  CPU_ERR   *p_err);
S#endif
S
S
S
S                                                                        /* --------------- CPU TS FNCTS --------------- */
S#if (CPU_CFG_TS_32_EN == DEF_ENABLED)
SCPU_TS32         CPU_TS_Get32             (void);
S#endif
S
S#if (CPU_CFG_TS_64_EN == DEF_ENABLED)
SCPU_TS64         CPU_TS_Get64             (void);
S#endif
S
S#if (CPU_CFG_TS_EN    == DEF_ENABLED)
Svoid             CPU_TS_Update            (void);
S#endif
S
S
S#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)                                  /* ------------- CPU TS TMR FNCTS ------------- */
SCPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet        (CPU_ERR          *p_err);
S
Svoid             CPU_TS_TmrFreqSet        (CPU_TS_TMR_FREQ   freq_hz);
S#endif
S
S
S
S#ifdef  CPU_CFG_INT_DIS_MEAS_EN                                         /* -------- CPU INT DIS TIME MEAS FNCTS ------- */
S                                                                        /* See Note #1.                                 */
SCPU_TS_TMR       CPU_IntDisMeasMaxCurReset(void);
S
SCPU_TS_TMR       CPU_IntDisMeasMaxCurGet  (void);
S
SCPU_TS_TMR       CPU_IntDisMeasMaxGet     (void);
S
S
Svoid             CPU_IntDisMeasStart      (void);
S
Svoid             CPU_IntDisMeasStop       (void);
S#endif
S
S
S
S                                                                        /* ----------- CPU CNT ZEROS FNCTS ------------ */
S#ifdef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
S#ifdef __cplusplus
Sextern  "C" {
S#endif
S#endif
S
SCPU_DATA         CPU_CntLeadZeros         (CPU_DATA    val);
S
S#ifdef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
S#ifdef __cplusplus
S}
S#endif
S#endif
S
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
SCPU_DATA         CPU_CntLeadZeros08       (CPU_INT08U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
SCPU_DATA         CPU_CntLeadZeros16       (CPU_INT16U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
SCPU_DATA         CPU_CntLeadZeros32       (CPU_INT32U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
SCPU_DATA         CPU_CntLeadZeros64       (CPU_INT64U  val);
S#endif
S
S
S#ifdef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
S#ifdef __cplusplus
Sextern  "C" {
S#endif
S#endif
S  
SCPU_DATA         CPU_CntTrailZeros        (CPU_DATA    val);
S
S#ifdef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
S#ifdef __cplusplus
S}
S#endif
S#endif
S
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
SCPU_DATA         CPU_CntTrailZeros08      (CPU_INT08U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
SCPU_DATA         CPU_CntTrailZeros16      (CPU_INT16U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
SCPU_DATA         CPU_CntTrailZeros32      (CPU_INT32U  val);
S#endif
S#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
SCPU_DATA         CPU_CntTrailZeros64      (CPU_INT64U  val);
S#endif
S
SCPU_INT08U       CPU_PopCnt32             (CPU_INT32U  value);
S
S/*
S*********************************************************************************************************
S*                                         FUNCTION PROTOTYPES
S*                                      DEFINED IN PRODUCT'S BSP
S*********************************************************************************************************
S*/
S
S/*
S*********************************************************************************************************
S*                                          CPU_TS_TmrInit()
S*
S* Description : Initialize & start CPU timestamp timer.
S*
S* Argument(s) : none.
S*
S* Return(s)   : none.
S*
S* Caller(s)   : CPU_TS_Init().
S*
S*               This function is an INTERNAL CPU module function & MUST be implemented by application/
S*               BSP function(s) [see Note #1] but MUST NOT be called by application function(s).
S*
S* Note(s)     : (1) CPU_TS_TmrInit() is an application/BSP function that MUST be defined by the developer 
S*                   if either of the following CPU features is enabled :
S*
S*                   (a) CPU timestamps
S*                   (b) CPU interrupts disabled time measurements
S*
S*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
S*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
S*
S*               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR' 
S*                       data type.
S*
S*                       (1) If timer has more bits, truncate timer values' higher-order bits greater 
S*                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
S*
S*                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR' 
S*                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be 
S*                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
S*
S*                           In other words, if timer size is not a binary-multiple of 8-bit octets 
S*                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple 
S*                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the 
S*                           minimum supported word size for CPU timestamp timers is 8-bits.
S*
S*                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
S*                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
S*
S*                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
S*
S*                   (c) When applicable, timer period SHOULD be less than the typical measured time 
S*                       but MUST be less than the maximum measured time; otherwise, timer resolution 
S*                       inadequate to measure desired times.
S*
S*                   See also 'CPU_TS_TmrRd()  Note #2'.
S*********************************************************************************************************
S*/
S
S#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
Svoid  CPU_TS_TmrInit(void);
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                           CPU_TS_TmrRd()
S*
S* Description : Get current CPU timestamp timer count value.
S*
S* Argument(s) : none.
S*
S* Return(s)   : Timestamp timer count (see Notes #2a & #2b).
S*
S* Caller(s)   : CPU_TS_Init(),
S*               CPU_TS_Get32(),
S*               CPU_TS_Get64(),
S*               CPU_IntDisMeasStart(),
S*               CPU_IntDisMeasStop().
S*
S*               This function is an INTERNAL CPU module function & MUST be implemented by application/
S*               BSP function(s) [see Note #1] but SHOULD NOT be called by application function(s).
S*
S* Note(s)     : (1) CPU_TS_TmrRd() is an application/BSP function that MUST be defined by the developer 
S*                   if either of the following CPU features is enabled :
S*
S*                   (a) CPU timestamps
S*                   (b) CPU interrupts disabled time measurements
S*
S*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
S*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
S*
S*               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR' 
S*                       data type.
S*
S*                       (1) If timer has more bits, truncate timer values' higher-order bits greater 
S*                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
S*
S*                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR' 
S*                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be 
S*                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
S*
S*                           In other words, if timer size is not a binary-multiple of 8-bit octets 
S*                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple 
S*                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the 
S*                           minimum supported word size for CPU timestamp timers is 8-bits.
S*
S*                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
S*                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
S*
S*                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
S*
S*                       (1) If timer is a 'down' counter whose values decrease with each time count,
S*                           then the returned timer value MUST be ones-complemented.
S*
S*                   (c) (1) When applicable, the amount of time measured by CPU timestamps is 
S*                           calculated by either of the following equations :
S*
S*                           (A) Time measured  =  Number timer counts  *  Timer period
S*
S*                                   where
S*
S*                                       Number timer counts     Number of timer counts measured 
S*                                       Timer period            Timer's period in some units of 
S*                                                                   (fractional) seconds
S*                                       Time measured           Amount of time measured, in same 
S*                                                                   units of (fractional) seconds 
S*                                                                   as the Timer period
S*
S*                                                  Number timer counts
S*                           (B) Time measured  =  ---------------------
S*                                                    Timer frequency
S*
S*                                   where
S*
S*                                       Number timer counts     Number of timer counts measured
S*                                       Timer frequency         Timer's frequency in some units 
S*                                                                   of counts per second
S*                                       Time measured           Amount of time measured, in seconds
S*
S*                       (2) Timer period SHOULD be less than the typical measured time but MUST be less 
S*                           than the maximum measured time; otherwise, timer resolution inadequate to 
S*                           measure desired times.
S*********************************************************************************************************
S*/
S
S#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
SCPU_TS_TMR  CPU_TS_TmrRd(void);
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                         CPU_TSxx_to_uSec()
S*
S* Description : Convert a 32-/64-bit CPU timestamp from timer counts to microseconds.
S*
S* Argument(s) : ts_cnts   CPU timestamp (in timestamp timer counts [see Note #2aA]).
S*
S* Return(s)   : Converted CPU timestamp (in microseconds           [see Note #2aD]).
S*
S* Caller(s)   : Application.
S*
S*               This function is an (optional) CPU module application programming interface (API) 
S*               function which MAY be implemented by application/BSP function(s) [see Note #1] & 
S*               MAY be called by application function(s).
S*
S* Note(s)     : (1) CPU_TS32_to_uSec()/CPU_TS64_to_uSec() are application/BSP functions that MAY be 
S*                   optionally defined by the developer when either of the following CPU features is 
S*                   enabled :
S*
S*                   (a) CPU timestamps
S*                   (b) CPU interrupts disabled time measurements
S*
S*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
S*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
S*
S*               (2) (a) The amount of time measured by CPU timestamps is calculated by either of 
S*                       the following equations :
S*
S*                                                                        10^6 microseconds
S*                       (1) Time measured  =   Number timer counts   *  -------------------  *  Timer period
S*                                                                            1 second
S*
S*                                              Number timer counts       10^6 microseconds
S*                       (2) Time measured  =  ---------------------  *  -------------------
S*                                                Timer frequency             1 second
S*
S*                               where
S*
S*                                   (A) Number timer counts     Number of timer counts measured
S*                                   (B) Timer frequency         Timer's frequency in some units 
S*                                                                   of counts per second
S*                                   (C) Timer period            Timer's period in some units of 
S*                                                                   (fractional)  seconds
S*                                   (D) Time measured           Amount of time measured, 
S*                                                                   in microseconds
S*
S*                   (b) Timer period SHOULD be less than the typical measured time but MUST be less 
S*                       than the maximum measured time; otherwise, timer resolution inadequate to 
S*                       measure desired times.
S*
S*                   (c) Specific implementations may convert any number of CPU_TS32 or CPU_TS64 bits 
S*                       -- up to 32 or 64, respectively -- into microseconds.
S*********************************************************************************************************
S*/
S
S#if (CPU_CFG_TS_32_EN == DEF_ENABLED)
SCPU_INT64U  CPU_TS32_to_uSec(CPU_TS32  ts_cnts);
S#endif
S
S#if (CPU_CFG_TS_64_EN == DEF_ENABLED)
SCPU_INT64U  CPU_TS64_to_uSec(CPU_TS64  ts_cnts);
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                        CONFIGURATION ERRORS
S*********************************************************************************************************
S*/
S
S#ifndef  CPU_CFG_NAME_EN
S#error  "CPU_CFG_NAME_EN                       not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_ENABLED ]           "
S#error  "                                [     ||  DEF_DISABLED]           "
S
S#elif  ((CPU_CFG_NAME_EN != DEF_ENABLED ) && \
S        (CPU_CFG_NAME_EN != DEF_DISABLED))
X#elif  ((CPU_CFG_NAME_EN != DEF_ENABLED ) &&         (CPU_CFG_NAME_EN != DEF_DISABLED))
S#error  "CPU_CFG_NAME_EN                 illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_ENABLED ]           "
S#error  "                                [     ||  DEF_DISABLED]           "
S
S
S#elif   (CPU_CFG_NAME_EN == DEF_ENABLED)
S
S#ifndef  CPU_CFG_NAME_SIZE
S#error  "CPU_CFG_NAME_SIZE                     not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  >=   1]                 "
S#error  "                                [     &&  <= 255]                 "
S
S#elif   (DEF_CHK_VAL(CPU_CFG_NAME_SIZE,            \
S                     1,                            \
S                     DEF_INT_08U_MAX_VAL) != DEF_OK)
X#elif   (DEF_CHK_VAL(CPU_CFG_NAME_SIZE,                                 1,                                                 DEF_INT_08U_MAX_VAL) != DEF_OK)
S#error  "CPU_CFG_NAME_SIZE               illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  >=   1]                 "
S#error  "                                [     &&  <= 255]                 "
S#endif
S
S#endif
S
S
S
S
S#ifndef  CPU_CFG_TS_32_EN
S#error  "CPU_CFG_TS_32_EN                      not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((CPU_CFG_TS_32_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_32_EN != DEF_ENABLED ))
X#elif  ((CPU_CFG_TS_32_EN != DEF_DISABLED) &&         (CPU_CFG_TS_32_EN != DEF_ENABLED ))
S#error  "CPU_CFG_TS_32_EN                illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#endif
S
S
S#ifndef  CPU_CFG_TS_64_EN
S#error  "CPU_CFG_TS_64_EN                      not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((CPU_CFG_TS_64_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_64_EN != DEF_ENABLED ))
X#elif  ((CPU_CFG_TS_64_EN != DEF_DISABLED) &&         (CPU_CFG_TS_64_EN != DEF_ENABLED ))
S#error  "CPU_CFG_TS_64_EN                illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#endif
S
S                                                                /* Correctly configured in 'cpu_core.h'; DO NOT MODIFY. */
S#ifndef  CPU_CFG_TS_EN
S#error  "CPU_CFG_TS_EN                         not #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S#elif  ((CPU_CFG_TS_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_EN != DEF_ENABLED ))
X#elif  ((CPU_CFG_TS_EN != DEF_DISABLED) &&         (CPU_CFG_TS_EN != DEF_ENABLED ))
S#error  "CPU_CFG_TS_EN                   illegally #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S#endif
S
S
S                                                                /* Correctly configured in 'cpu_core.h'; DO NOT MODIFY. */
S#ifndef  CPU_CFG_TS_TMR_EN
S#error  "CPU_CFG_TS_TMR_EN                     not #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S#elif  ((CPU_CFG_TS_TMR_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_TMR_EN != DEF_ENABLED ))
X#elif  ((CPU_CFG_TS_TMR_EN != DEF_DISABLED) &&         (CPU_CFG_TS_TMR_EN != DEF_ENABLED ))
S#error  "CPU_CFG_TS_TMR_EN               illegally #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S
S#elif   (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
S
S#ifndef  CPU_CFG_TS_TMR_SIZE
S#error  "CPU_CFG_TS_TMR_SIZE                   not #define'd in 'cpu_cfg.h'       "
S#error  "                                [MUST be  CPU_WORD_SIZE_08   8-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_16  16-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_32  32-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_64  64-bit timer]"
S
S#elif  ((CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_64))
X#elif  ((CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_08) &&         (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_16) &&         (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_32) &&         (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_64))
S#error  "CPU_CFG_TS_TMR_SIZE             illegally #define'd in 'cpu_cfg.h'       "
S#error  "                                [MUST be  CPU_WORD_SIZE_08   8-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_16  16-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_32  32-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_64  64-bit timer]"
S#endif
S
S#endif
S
S
S
S#ifndef  CPU_CFG_INT_DIS_MEAS_EN
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_INT_DIS_MEAS_EN               not #define'd in 'cpu_cfg.h'"
S#endif
S
S#else
S
S#ifndef  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR
S#error  "CPU_CFG_INT_DIS_MEAS_OVRHD_NBR        not #define'd in 'cpu_cfg.h' "
S#error  "                                [MUST be  >= CPU_TIME_MEAS_NBR_MIN]"
S#error  "                                [     ||  <= CPU_TIME_MEAS_NBR_MAX]"
S
S#elif   (DEF_CHK_VAL(CPU_CFG_INT_DIS_MEAS_OVRHD_NBR, \
S                     CPU_TIME_MEAS_NBR_MIN,          \
S                     CPU_TIME_MEAS_NBR_MAX) != DEF_OK)
X#elif   (DEF_CHK_VAL(CPU_CFG_INT_DIS_MEAS_OVRHD_NBR,                      CPU_TIME_MEAS_NBR_MIN,                               CPU_TIME_MEAS_NBR_MAX) != DEF_OK)
S#error  "CPU_CFG_INT_DIS_MEAS_OVRHD_NBR  illegally #define'd in 'cpu_cfg.h' "
S#error  "                                [MUST be  >= CPU_TIME_MEAS_NBR_MIN]"
S#error  "                                [     ||  <= CPU_TIME_MEAS_NBR_MAX]"
S
S#endif
S
S#endif
S
S
S
S
S#ifndef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_LEAD_ZEROS_ASM_PRESENT        not #define'd in 'cpu.h'/'cpu_cfg.h'"
S#endif
S#endif
S
S
S#ifndef  CPU_CFG_TRAIL_ZEROS_ASM_PRESENT
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_TRAIL_ZEROS_ASM_PRESENT       not #define'd in 'cpu.h'/'cpu_cfg.h'"
S#endif
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                    CPU PORT CONFIGURATION ERRORS
S*********************************************************************************************************
S*/
S
S#ifndef  CPU_CFG_ADDR_SIZE
S#error  "CPU_CFG_ADDR_SIZE      not #define'd in 'cpu.h'"
S#endif
S
S#ifndef  CPU_CFG_DATA_SIZE
S#error  "CPU_CFG_DATA_SIZE      not #define'd in 'cpu.h'"
S#endif
S
S#ifndef  CPU_CFG_DATA_SIZE_MAX
S#error  "CPU_CFG_DATA_SIZE_MAX  not #define'd in 'cpu.h'"
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                    LIBRARY CONFIGURATION ERRORS
S*********************************************************************************************************
S*/
S
S                                                                /* See 'cpu_core.h  Note #1a'.                          */
S#if     (LIB_VERSION < 13500u)
S#error  "LIB_VERSION  [SHOULD be >= V1.35.00]"
S#endif
S
S
S/*
S*********************************************************************************************************
S*                                             MODULE END
S*
S* Note(s) : (1) See 'cpu_core.h  MODULE'.
S*********************************************************************************************************
S*/
S
N#endif                                                          /* End of CPU core module include.                      */
N
L 111 "..\..\uCOS-III\uC-LIB\lib_mem.h" 2
N
N#include  <lib_def.h>
N#include  <lib_cfg.h>
L 1 "..\..\User\lib_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                            EXAMPLE CODE
N*
N*               This file is provided as an example on how to use Micrium products.
N*
N*               Please feel free to use any application code labeled as 'EXAMPLE CODE' in
N*               your application products.  Example code may be used as is, in whole or in
N*               part, or may be used as a reference only. This file can be modified as
N*               required to meet the end-product requirements.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*
N*               You can find information about uC/LIB by visiting doc.micrium.com.
N*               You can contact us at: http://www.micrium.com
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                  CUSTOM LIBRARY CONFIGURATION FILE
N*
N*                                              TEMPLATE
N*
N* Filename      : lib_cfg.h
N* Version       : V1.38.01.00
N* Programmer(s) : FBJ
N*                 JFD
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_CFG_MODULE_PRESENT
N#define  LIB_CFG_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*********************************************************************************************************
N*                                    MEMORY LIBRARY CONFIGURATION
N*********************************************************************************************************
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                             MEMORY LIBRARY ARGUMENT CHECK CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_ARG_CHK_EXT_EN to enable/disable the memory library suite external
N*               argument check feature :
N*
N*               (a) When ENABLED,     arguments received from any port interface provided by the developer
N*                   or application are checked/validated.
N*
N*               (b) When DISABLED, NO arguments received from any port interface provided by the developer
N*                   or application are checked/validated.
N*********************************************************************************************************
N*/
N
N                                                                /* External argument check.                             */
N                                                                /* Indicates if arguments received from any port ...    */
N                                                                /* ... interface provided by the developer or ...       */
N                                                                /* ... application are checked/validated.               */
N#define  LIB_MEM_CFG_ARG_CHK_EXT_EN     DEF_DISABLED
N
N
N/*
N*********************************************************************************************************
N*                         MEMORY LIBRARY ASSEMBLY OPTIMIZATION CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_OPTIMIZE_ASM_EN to enable/disable assembly-optimized memory function(s).
N*********************************************************************************************************
N*/
N
N                                                                /* Assembly-optimized function(s).                      */
N                                                                /* Enable/disable assembly-optimized memory ...         */
N                                                                /* ... function(s). [see Note #1]                       */
N#define  LIB_MEM_CFG_OPTIMIZE_ASM_EN        DEF_ENABLED
N
N
N/*
N*********************************************************************************************************
N*                                   MEMORY ALLOCATION CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_DBG_INFO_EN to enable/disable memory allocation usage tracking
N*               that associates a name with each segment or dynamic pool allocated.
N*
N*           (2) (a) Configure LIB_MEM_CFG_HEAP_SIZE with the desired size of heap memory (in octets).
N*
N*               (b) Configure LIB_MEM_CFG_HEAP_BASE_ADDR to specify a base address for heap memory :
N*
N*                   (1) Heap initialized to specified application memory, if LIB_MEM_CFG_HEAP_BASE_ADDR
N*                                                                                #define'd in 'lib_cfg.h';
N*                                                                         CANNOT #define to address 0x0
N*
N*                   (2) Heap declared to Mem_Heap[] in 'lib_mem.c',       if LIB_MEM_CFG_HEAP_BASE_ADDR
N*                                                                            NOT #define'd in 'lib_cfg.h'
N*********************************************************************************************************
N*/
N
N                                                                /* Allocation debugging information.                    */
N                                                                /* Enable/disable allocation of debug information ...   */
N                                                                /* ... associated to each memory allocation.            */
N#define  LIB_MEM_CFG_DBG_INFO_EN        DEF_DISABLED
N
N
N                                                                /* Heap memory size (in bytes).                         */
N                                                                /* Configure the desired size of the heap memory. ...   */
N                                                                /* ... Set to 0 to disable heap allocation features.    */
N#define  LIB_MEM_CFG_HEAP_SIZE             (1u * 1024u)
N
N
N                                                                /* Heap memory padding alignment (in bytes).            */
N                                                                /* Configure the desired size of padding alignment ...  */
N                                                                /* ... of each buffer allocated from the heap.          */
N#define  LIB_MEM_CFG_HEAP_PADDING_ALIGN    LIB_MEM_PADDING_ALIGN_NONE
N
N#if 0                                                           /* Remove this to have heap alloc at specified addr.    */
S#define  LIB_MEM_CFG_HEAP_BASE_ADDR       0x00000000            /* Configure heap memory base address (see Note #2b).   */
N#endif
N
N
N/*
N*********************************************************************************************************
N*********************************************************************************************************
N*                                    STRING LIBRARY CONFIGURATION
N*********************************************************************************************************
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                 STRING FLOATING POINT CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_STR_CFG_FP_EN to enable/disable floating point string function(s).
N*
N*           (2) Configure LIB_STR_CFG_FP_MAX_NBR_DIG_SIG to configure the maximum number of significant
N*               digits to calculate &/or display for floating point string function(s).
N*
N*               See also 'lib_str.h  STRING FLOATING POINT DEFINES  Note #1'.
N*********************************************************************************************************
N*/
N
N                                                                /* Floating point feature(s).                           */
N                                                                /* Enable/disable floating point to string functions.   */
N#define  LIB_STR_CFG_FP_EN                      DEF_DISABLED
N
N
N                                                                /* Floating point number of significant digits.         */
N                                                                /* Configure the maximum number of significant ...      */
N                                                                /* ... digits to calculate &/or display for ...         */
N                                                                /* ... floating point string function(s).               */
N#define  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG         LIB_STR_FP_MAX_NBR_DIG_SIG_DFLT
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib cfg module include.                       */
N
L 114 "..\..\uCOS-III\uC-LIB\lib_mem.h" 2
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_MEM_MODULE
S#define  LIB_MEM_EXT
N#else
N#define  LIB_MEM_EXT  extern
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N#define  LIB_MEM_PADDING_ALIGN_NONE                       1u
N
N#define  LIB_MEM_BLK_QTY_UNLIMITED                        0u
N
N
N/*
N*********************************************************************************************************
N*                                        DEFAULT CONFIGURATION
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                             MEMORY LIBRARY ARGUMENT CHECK CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_ARG_CHK_EXT_EN to enable/disable the memory library suite external
N*               argument check feature :
N*
N*               (a) When ENABLED,      arguments received from any port interface provided by the developer
N*                   or application are checked/validated.
N*
N*               (b) When DISABLED, NO  arguments received from any port interface provided by the developer
N*                   or application are checked/validated.
N*********************************************************************************************************
N*/
N
N                                                                /* Cfg external argument check feature (see Note #1) :  */
N#ifndef  LIB_MEM_CFG_ARG_CHK_EXT_EN
S#define  LIB_MEM_CFG_ARG_CHK_EXT_EN     DEF_DISABLED
S                                                                /* DEF_DISABLED     Argument check DISABLED             */
S                                                                /* DEF_ENABLED      Argument check ENABLED              */
N#endif
N
N
N/*
N*********************************************************************************************************
N*                         MEMORY LIBRARY ASSEMBLY OPTIMIZATION CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_OPTIMIZE_ASM_EN to enable/disable assembly-optimized memory
N*               functions.
N*********************************************************************************************************
N*/
N
N                                                                /* Cfg assembly-optimized function(s) [see Note #1] :   */
N#ifndef  LIB_MEM_CFG_OPTIMIZE_ASM_EN
S#define  LIB_MEM_CFG_OPTIMIZE_ASM_EN    DEF_DISABLED
S                                                                /* DEF_DISABLED     Assembly-optimized fnct(s) DISABLED */
S                                                                /* DEF_ENABLED      Assembly-optimized fnct(s) ENABLED  */
N#endif
N
N
N/*
N*********************************************************************************************************
N*                          MEMORY ALLOCATION DEBUG INFORMATION CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_DBG_INFO_EN to enable/disable debug information associated to each
N*               segment allocation.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_MEM_CFG_DBG_INFO_EN
S#define  LIB_MEM_CFG_DBG_INFO_EN         DEF_DISABLED
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                  HEAP PADDING ALIGN CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_HEAP_PADDING_ALIGN to set the padding alignment of any buffer
N*               allocated from the heap.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_MEM_CFG_HEAP_PADDING_ALIGN
S#define  LIB_MEM_CFG_HEAP_PADDING_ALIGN  LIB_MEM_PADDING_ALIGN_NONE
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                            LIB MEM TYPE
N*
N* Note(s) : (1) 'LIB_MEM_TYPE' declared as 'CPU_INT32U' & all 'LIB_MEM_TYPE's #define'd with large, non-trivial
N*               values to trap & discard invalid/corrupted library memory objects based on 'LIB_MEM_TYPE'.
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT32U  LIB_MEM_TYPE;
N
N
N/*
N*********************************************************************************************************
N*                                MEMORY POOL BLOCK QUANTITY DATA TYPE
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_SIZE_T  MEM_POOL_BLK_QTY;
N
N
N/*
N*********************************************************************************************************
N*                                      MEMORY POOL TABLE IX TYPE
N*********************************************************************************************************
N*/
N
Ntypedef  MEM_POOL_BLK_QTY  MEM_POOL_IX;
N
N
N/*
N*********************************************************************************************************
N*                              MEMORY ALLOCATION TRACKING INFO DATA TYPE
N*********************************************************************************************************
N*/
N
N#if (LIB_MEM_CFG_DBG_INFO_EN  == DEF_ENABLED)
X#if (0u  == 1u)
Stypedef  struct  mem_alloc_info  MEM_ALLOC_INFO;
S
Sstruct  mem_alloc_info  {                                       /* ------------------ MEM ALLOC INFO ------------------ */
S    const  CPU_CHAR        *NamePtr;                            /* Ptr to name.                                         */
S           CPU_SIZE_T       Size;                               /* Total alloc'd size, in bytes.                        */
S           MEM_ALLOC_INFO  *NextPtr;                            /* Ptr to next alloc info in list.                      */
S};
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                     MEMORY SEGMENTS DATA TYPES
N*********************************************************************************************************
N*/
N
Ntypedef  struct  mem_seg  MEM_SEG;                              /* --------------------- SEG DATA --------------------- */
N
Nstruct mem_seg {
N           CPU_ADDR         AddrBase;                           /* Seg start addr.                                      */
N           CPU_ADDR         AddrEnd;                            /* Seg end addr (last addr).                            */
N           CPU_ADDR         AddrNext;                           /* Next free addr.                                      */
N
N           MEM_SEG         *NextPtr;                            /* Ptr to next seg.                                     */
N
N           CPU_SIZE_T       PaddingAlign;                       /* Padding alignment in byte.                           */
N
N#if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
X#if (0u == 1u)
S    const  CPU_CHAR        *NamePtr;                            /* Ptr to seg name.                                     */
S           MEM_ALLOC_INFO  *AllocInfoHeadPtr;                   /* Ptr to head of alloc info struct list.               */
N#endif
N};
N
Ntypedef  struct  mem_seg_info {                                 /* --------------------- SEG INFO --------------------- */
N    CPU_SIZE_T  UsedSize;                                       /* Used size, independently of alignment.               */
N    CPU_SIZE_T  TotalSize;                                      /* Total seg capacity, in octets.                       */
N
N    CPU_ADDR    AddrBase;
N    CPU_ADDR    AddrNextAlloc;                                  /* Next aligned address, 0 if none available.           */
N} MEM_SEG_INFO;
N
N
N/*
N*********************************************************************************************************
N*                                    (STATIC) MEMORY POOL DATA TYPES
N*
N* Note(s) : (1) Free static memory pool blocks are indexed in the 'BlkFreeTbl' table. Newly freed blocks
N*               are added at the first available position in the table and blocks are retrieved from the
N*               last occupied position, in a LIFO fashion.
N*
N*                                 /-------------------------------\
N*                                 |/------------\                 |
X
N*                    BlkFreeTbl   ||  Start     v                 v              End
N*                    /--------\   ||  /--------------------------------------------\
N*                    |p_free_1|---/|  |        |        |        |        |        |
X
N*                    |--------|    |  \--------------------------------------------/
N*                    |p_free_2|----/   ^                                  |        |
N*                    |--------|        |                                  |__Blk___|
N*                    |p_free_3|--------/ (Next block to be retrieved.)       Size
N*                    |--------|
N*                    |        |<-------- (Next block to be freed.)
N*                    \--------/
N*
N*********************************************************************************************************
N*/
N
N                                                                /* --------------------- MEM POOL --------------------- */
Ntypedef  struct  mem_pool {
N    void               *PoolAddrStart;                          /* Ptr   to start of mem seg for mem pool blks.         */
N    void               *PoolAddrEnd;                            /* Ptr   to end   of mem seg for mem pool blks.         */
N    MEM_POOL_BLK_QTY    BlkNbr;                                 /* Nbr   of mem pool   blks.                            */
N    CPU_SIZE_T          BlkSize;                                /* Size  of mem pool   blks (in octets).                */
N    void              **BlkFreeTbl;                             /* Tbl of free mem pool blks.                           */
N    CPU_SIZE_T          BlkFreeTblIx;                           /* Ix of next free blk free tbl entry.                  */
N} MEM_POOL;
N
N
N/*
N*********************************************************************************************************
N*                                     DYNAMIC MEMORY POOL DATA TYPE
N*
N* Note(s) : (1) Dynamic memory pool blocks are not indexed in a table. Only freed blocks are linked using
N*               a singly linked list, in a LIFO fashion; newly freed blocks are inserted at the head of the
N*               list and blocks are also retrieved from the head of the list.
N*
N*           (2) Pointers to the next block are only present when a block is free, using the first location
N*               in the allocated memory block. The user of dynamic memory pool must not assume his data
N*               will not be overwritten when a block is freed.
N*
N*                                   /----------------\
N*                    /----------\   |  /----------\  |    /----------\   /----------\
N*       BlkFreePtr-->|(NextPtr) |---/  |          |  \--->|(NextPtr) |-->|(NextPtr) |--> DEF_NULL
X
N*                    |----------|      |  Blk in  |       |----------|   |----------|
N*                    |          |      |   use    |       |          |   |          |
N*                    |          |      |          |       |          |   |          |
N*                    \----------/      \----------/       \----------/   \----------/
N*
N*********************************************************************************************************
N*/
N
Ntypedef  struct  mem_dyn_pool {                                 /* ---------------- DYN MEM POOL DATA ----------------- */
N           MEM_SEG     *PoolSegPtr;                             /* Mem pool from which blks are alloc'd.                */
N           CPU_SIZE_T   BlkSize;                                /* Size of pool blks, in octets.                        */
N           CPU_SIZE_T   BlkAlign;                               /* Align req'd for blks, in octets.                     */
N           CPU_SIZE_T   BlkPaddingAlign;                        /* Padding alignment in bytes for this mem seg.         */
N           void        *BlkFreePtr;                             /* Ptr to first free blk.                               */
N
N           CPU_SIZE_T   BlkQtyMax;                              /* Max qty of blk in dyn mem pool. 0 = unlimited.       */
N           CPU_SIZE_T   BlkAllocCnt;                            /* Cnt of alloc blk.                                    */
N
N#if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
X#if (0u == 1u)
S    const  CPU_CHAR    *NamePtr;                                /* Ptr to mem pool name.                                */
N#endif
N} MEM_DYN_POOL;
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      MEMORY DATA VALUE MACRO'S
N*
N* Note(s) : (1) (a) Some variables & variable buffers to pass & receive data values MUST start on appropriate
N*                   CPU word-aligned addresses.  This is required because most word-aligned processors are more
N*                   efficient & may even REQUIRE that multi-octet words start on CPU word-aligned addresses.
N*
N*                   (1) For 16-bit word-aligned processors, this means that
N*
N*                           all 16- & 32-bit words MUST start on addresses that are multiples of 2 octets
N*
N*                   (2) For 32-bit word-aligned processors, this means that
N*
N*                           all 16-bit       words MUST start on addresses that are multiples of 2 octets
N*                           all 32-bit       words MUST start on addresses that are multiples of 4 octets
N*
N*               (b) However, some data values macro's appropriately access data values from any CPU addresses,
N*                   word-aligned or not.  Thus for processors that require data word alignment, data words can
N*                   be accessed to/from any CPU address, word-aligned or not, without generating data-word-
N*                   alignment exceptions/faults.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                      ENDIAN WORD ORDER MACRO'S
N*
N* Description : Convert data values to & from big-, little, or host-endian CPU word order.
N*
N* Argument(s) : val       Data value to convert (see Notes #1 & #2).
N*
N* Return(s)   : Converted data value (see Notes #1 & #2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Convert data values to the desired data-word order :
N*
N*                       MEM_VAL_BIG_TO_LITTLE_xx()      Convert big-        endian data values
N*                                                            to little-     endian data values
N*                       MEM_VAL_LITTLE_TO_BIG_xx()      Convert little-     endian data values
N*                                                            to big-        endian data values
N*                       MEM_VAL_xxx_TO_HOST_xx()        Convert big-/little-endian data values
N*                                                            to host-       endian data values
N*                       MEM_VAL_HOST_TO_xxx_xx()        Convert host-       endian data values
N*                                                            to big-/little-endian data values
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) 'val' data value to convert & any variable to receive the returned conversion MUST
N*                   start on appropriate CPU word-aligned addresses.
N*
N*                   See also 'MEMORY DATA VALUE MACRO'S  Note #1a'.
N*
N*               (3) MEM_VAL_COPY_xxx() macro's are more efficient than generic endian word order macro's &
N*                   are also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_GET_xxx()  Note #4'
N*                          & 'MEM_VAL_COPY_SET_xxx()  Note #4'.
N*
N*               (4) Generic endian word order macro's are NOT atomic operations & MUST NOT be used on any
N*                   non-static (i.e. volatile) variables, registers, hardware, etc.; without the caller of
N*                   the macro's providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (5) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N
N#if    ((CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_64) || \
N        (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32))
X#if    ((4u == 8u) ||         (4u == 4u))
N
N#define  MEM_VAL_BIG_TO_LITTLE_16(val)        ((CPU_INT16U)(((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))) | \
N                                                            ((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) << (1u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_BIG_TO_LITTLE_16(val)        ((CPU_INT16U)(((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) << (1u * DEF_OCTET_NBR_BITS)))))
N
N#define  MEM_VAL_BIG_TO_LITTLE_32(val)        ((CPU_INT32U)(((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS))) | \
N                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (1u * DEF_OCTET_NBR_BITS))) | \
N                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) << (1u * DEF_OCTET_NBR_BITS))) | \
N                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) << (3u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_BIG_TO_LITTLE_32(val)        ((CPU_INT32U)(((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) << (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) << (3u * DEF_OCTET_NBR_BITS)))))
N
N#elif   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
S
S#define  MEM_VAL_BIG_TO_LITTLE_16(val)        ((CPU_INT16U)(((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))) | \
S                                                            ((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) << (1u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_BIG_TO_LITTLE_16(val)        ((CPU_INT16U)(((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT16U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) << (1u * DEF_OCTET_NBR_BITS)))))
S
S#define  MEM_VAL_BIG_TO_LITTLE_32(val)        ((CPU_INT32U)(((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (1u * DEF_OCTET_NBR_BITS))) | \
S                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) << (1u * DEF_OCTET_NBR_BITS))) | \
S                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS))) | \
S                                                            ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) << (1u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_BIG_TO_LITTLE_32(val)        ((CPU_INT32U)(((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) << (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS))) |                                                             ((CPU_INT32U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) << (1u * DEF_OCTET_NBR_BITS)))))
S
S#else
S
S#define  MEM_VAL_BIG_TO_LITTLE_16(val)                                                  (val)
S#define  MEM_VAL_BIG_TO_LITTLE_32(val)                                                  (val)
S
N#endif
N
N
N#define  MEM_VAL_LITTLE_TO_BIG_16(val)                          MEM_VAL_BIG_TO_LITTLE_16(val)
N#define  MEM_VAL_LITTLE_TO_BIG_32(val)                          MEM_VAL_BIG_TO_LITTLE_32(val)
N
N
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S
S#define  MEM_VAL_BIG_TO_HOST_16(val)                                                    (val)
S#define  MEM_VAL_BIG_TO_HOST_32(val)                                                    (val)
S#define  MEM_VAL_LITTLE_TO_HOST_16(val)                         MEM_VAL_LITTLE_TO_BIG_16(val)
S#define  MEM_VAL_LITTLE_TO_HOST_32(val)                         MEM_VAL_LITTLE_TO_BIG_32(val)
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2u == 2u)
N
N#define  MEM_VAL_BIG_TO_HOST_16(val)                            MEM_VAL_BIG_TO_LITTLE_16(val)
N#define  MEM_VAL_BIG_TO_HOST_32(val)                            MEM_VAL_BIG_TO_LITTLE_32(val)
N#define  MEM_VAL_LITTLE_TO_HOST_16(val)                                                 (val)
N#define  MEM_VAL_LITTLE_TO_HOST_32(val)                                                 (val)
N
N#else                                                           /* See Note #5.                                         */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N#define  MEM_VAL_HOST_TO_BIG_16(val)                            MEM_VAL_BIG_TO_HOST_16(val)
N#define  MEM_VAL_HOST_TO_BIG_32(val)                            MEM_VAL_BIG_TO_HOST_32(val)
N#define  MEM_VAL_HOST_TO_LITTLE_16(val)                         MEM_VAL_LITTLE_TO_HOST_16(val)
N#define  MEM_VAL_HOST_TO_LITTLE_32(val)                         MEM_VAL_LITTLE_TO_HOST_32(val)
N
N
N/*
N*********************************************************************************************************
N*                                          MEM_VAL_GET_xxx()
N*
N* Description : Decode data values from any CPU memory address.
N*
N* Argument(s) : addr        Lowest CPU memory address of data value to decode (see Notes #2 & #3a).
N*
N* Return(s)   : Decoded data value from CPU memory address (see Notes #1 & #3b).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Decode data values based on the values' data-word order in CPU memory :
N*
N*                       MEM_VAL_GET_xxx_BIG()           Decode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_GET_xxx_LITTLE()        Decode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_GET_xxx()               Decode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) CPU memory addresses/pointers NOT checked for NULL.
N*
N*               (3) (a) MEM_VAL_GET_xxx() macro's decode data values without regard to CPU word-aligned addresses.
N*                       Thus for processors that require data word alignment, data words can be decoded from any
N*                       CPU address, word-aligned or not, without generating data-word-alignment exceptions/faults.
N*
N*                   (b) However, any variable to receive the returned data value MUST start on an appropriate CPU
N*                       word-aligned address.
N*
N*                   See also 'MEMORY DATA VALUE MACRO'S  Note #1'.
N*
N*               (4) MEM_VAL_COPY_GET_xxx() macro's are more efficient than MEM_VAL_GET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_GET_xxx()  Note #4'.
N*
N*               (5) MEM_VAL_GET_xxx() macro's are NOT atomic operations & MUST NOT be used on any non-static
N*                   (i.e. volatile) variables, registers, hardware, etc.; without the caller of the macro's
N*                   providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (6) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N
N#define  MEM_VAL_GET_INT08U_BIG(addr)           ((CPU_INT08U) ((CPU_INT08U)(((CPU_INT08U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))))
N
N#define  MEM_VAL_GET_INT16U_BIG(addr)           ((CPU_INT16U)(((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (1u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (0u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_GET_INT16U_BIG(addr)           ((CPU_INT16U)(((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (1u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (0u * DEF_OCTET_NBR_BITS)))))
N
N#define  MEM_VAL_GET_INT32U_BIG(addr)           ((CPU_INT32U)(((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (3u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (2u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (1u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (0u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_GET_INT32U_BIG(addr)           ((CPU_INT32U)(((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (3u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (2u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (1u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (0u * DEF_OCTET_NBR_BITS)))))
N
N
N
N#define  MEM_VAL_GET_INT08U_LITTLE(addr)        ((CPU_INT08U) ((CPU_INT08U)(((CPU_INT08U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))))
N
N#define  MEM_VAL_GET_INT16U_LITTLE(addr)        ((CPU_INT16U)(((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (1u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_GET_INT16U_LITTLE(addr)        ((CPU_INT16U)(((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT16U)(((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (1u * DEF_OCTET_NBR_BITS)))))
N
N#define  MEM_VAL_GET_INT32U_LITTLE(addr)        ((CPU_INT32U)(((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (1u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (2u * DEF_OCTET_NBR_BITS))) + \
N                                                              ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (3u * DEF_OCTET_NBR_BITS)))))
X#define  MEM_VAL_GET_INT32U_LITTLE(addr)        ((CPU_INT32U)(((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (0u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (1u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (2u * DEF_OCTET_NBR_BITS))) +                                                               ((CPU_INT32U)(((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (3u * DEF_OCTET_NBR_BITS)))))
N
N
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S
S#define  MEM_VAL_GET_INT08U(addr)                               MEM_VAL_GET_INT08U_BIG(addr)
S#define  MEM_VAL_GET_INT16U(addr)                               MEM_VAL_GET_INT16U_BIG(addr)
S#define  MEM_VAL_GET_INT32U(addr)                               MEM_VAL_GET_INT32U_BIG(addr)
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2u == 2u)
N
N#define  MEM_VAL_GET_INT08U(addr)                               MEM_VAL_GET_INT08U_LITTLE(addr)
N#define  MEM_VAL_GET_INT16U(addr)                               MEM_VAL_GET_INT16U_LITTLE(addr)
N#define  MEM_VAL_GET_INT32U(addr)                               MEM_VAL_GET_INT32U_LITTLE(addr)
N
N#else                                                           /* See Note #6.                                         */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                          MEM_VAL_SET_xxx()
N*
N* Description : Encode data values to any CPU memory address.
N*
N* Argument(s) : addr        Lowest CPU memory address to encode data value (see Notes #2 & #3a).
N*
N*               val         Data value to encode (see Notes #1 & #3b).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Encode data values into CPU memory based on the values' data-word order :
N*
N*                       MEM_VAL_SET_xxx_BIG()           Encode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_SET_xxx_LITTLE()        Encode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_SET_xxx()               Encode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) CPU memory addresses/pointers NOT checked for NULL.
N*
N*               (3) (a) MEM_VAL_SET_xxx() macro's encode data values without regard to CPU word-aligned addresses.
N*                       Thus for processors that require data word alignment, data words can be encoded to any
N*                       CPU address, word-aligned or not, without generating data-word-alignment exceptions/faults.
N*
N*                   (b) However, 'val' data value to encode MUST start on an appropriate CPU word-aligned address.
N*
N*                   See also 'MEMORY DATA VALUE MACRO'S  Note #1'.
N*
N*               (4) MEM_VAL_COPY_SET_xxx() macro's are more efficient than MEM_VAL_SET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_SET_xxx()  Note #4'.
N*
N*               (5) MEM_VAL_SET_xxx() macro's are NOT atomic operations & MUST NOT be used on any non-static
N*                   (i.e. volatile) variables, registers, hardware, etc.; without the caller of the macro's
N*                   providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (6) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N
N#define  MEM_VAL_SET_INT08U_BIG(addr, val)                     do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT08U)(val)) & (CPU_INT08U)      0xFFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
N
N#define  MEM_VAL_SET_INT16U_BIG(addr, val)                     do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
X#define  MEM_VAL_SET_INT16U_BIG(addr, val)                     do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
N
N#define  MEM_VAL_SET_INT32U_BIG(addr, val)                     do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (2u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
X#define  MEM_VAL_SET_INT32U_BIG(addr, val)                     do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (2u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
N
N
N
N#define  MEM_VAL_SET_INT08U_LITTLE(addr, val)                  do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT08U)(val)) & (CPU_INT08U)      0xFFu) >> (0u * DEF_OCTET_NBR_BITS))); } while (0)
N
N#define  MEM_VAL_SET_INT16U_LITTLE(addr, val)                  do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) >> (0u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))); } while (0)
X#define  MEM_VAL_SET_INT16U_LITTLE(addr, val)                  do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0x00FFu) >> (0u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) & (CPU_INT16U)    0xFF00u) >> (1u * DEF_OCTET_NBR_BITS))); } while (0)
N
N#define  MEM_VAL_SET_INT32U_LITTLE(addr, val)                  do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) >> (0u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (2u * DEF_OCTET_NBR_BITS))); \
N                                                                    (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS))); } while (0)
X#define  MEM_VAL_SET_INT32U_LITTLE(addr, val)                  do { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x000000FFu) >> (0u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x0000FF00u) >> (1u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0x00FF0000u) >> (2u * DEF_OCTET_NBR_BITS)));                                                                     (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & (CPU_INT32U)0xFF000000u) >> (3u * DEF_OCTET_NBR_BITS))); } while (0)
N
N
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S
S#define  MEM_VAL_SET_INT08U(addr, val)                          MEM_VAL_SET_INT08U_BIG(addr, val)
S#define  MEM_VAL_SET_INT16U(addr, val)                          MEM_VAL_SET_INT16U_BIG(addr, val)
S#define  MEM_VAL_SET_INT32U(addr, val)                          MEM_VAL_SET_INT32U_BIG(addr, val)
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2u == 2u)
N
N#define  MEM_VAL_SET_INT08U(addr, val)                          MEM_VAL_SET_INT08U_LITTLE(addr, val)
N#define  MEM_VAL_SET_INT16U(addr, val)                          MEM_VAL_SET_INT16U_LITTLE(addr, val)
N#define  MEM_VAL_SET_INT32U(addr, val)                          MEM_VAL_SET_INT32U_LITTLE(addr, val)
N
N#else                                                           /* See Note #6.                                         */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                       MEM_VAL_COPY_GET_xxx()
N*
N* Description : Copy & decode data values from any CPU memory address to any CPU memory address.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy/decode source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy/decode
N*                                   (see Notes #2 & #3).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Copy/decode data values based on the values' data-word order :
N*
N*                       MEM_VAL_COPY_GET_xxx_BIG()      Decode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_GET_xxx_LITTLE()   Decode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_GET_xxx()          Decode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) (a) CPU memory addresses/pointers NOT checked for NULL.
N*
N*                   (b) CPU memory addresses/buffers  NOT checked for overlapping.
N*
N*                       (1) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that
N*                           "copying ... between objects that overlap ... is undefined".
N*
N*               (3) MEM_VAL_COPY_GET_xxx() macro's copy/decode data values without regard to CPU word-aligned
N*                   addresses.  Thus for processors that require data word alignment, data words can be copied/
N*                   decoded to/from any CPU address, word-aligned or not, without generating data-word-alignment
N*                   exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_GET_xxx() macro's are more efficient than MEM_VAL_GET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_GET_xxx()  Note #4'.
N*
N*               (5) Since octet-order copy/conversion are inverse operations, MEM_VAL_COPY_GET_xxx() &
N*                   MEM_VAL_COPY_SET_xxx() macros are inverse, but identical, operations & are provided
N*                   in both forms for semantics & consistency.
N*
N*                   See also 'MEM_VAL_COPY_SET_xxx()  Note #5'.
N*
N*               (6) MEM_VAL_COPY_GET_xxx() macro's are NOT atomic operations & MUST NOT be used on any non-
N*                   static (i.e. volatile) variables, registers, hardware, etc.; without the caller of the
N*                   macro's providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (7) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S
S
S#define  MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
S
S#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
X#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
S
S#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
X#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
S
S
S
S#define  MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
S
S#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
X#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
S
S#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
S                                                                    (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
X#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
S
S
S
S#define  MEM_VAL_COPY_GET_INT08U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)
S#define  MEM_VAL_COPY_GET_INT16U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)
S#define  MEM_VAL_COPY_GET_INT32U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)
S
S
S
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2u == 2u)
N
N
N#define  MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
N
N#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
X#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
N
N#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
X#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)      do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
N
N
N
N#define  MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
N
N#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
X#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
N
N#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
X#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)   do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
N
N
N
N#define  MEM_VAL_COPY_GET_INT08U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_GET_INT16U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_GET_INT32U(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)
N
N
N
N
N#else                                                           /* See Note #7.                                         */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                     MEM_VAL_COPY_GET_INTU_xxx()
N*
N* Description : Copy & decode data values from any CPU memory address to any CPU memory address for
N*                   any sized data values.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy/decode source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy/decode
N*                                   (see Notes #2 & #3).
N*
N*               val_size        Number of data value octets to copy/decode.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Copy/decode data values based on the values' data-word order :
N*
N*                       MEM_VAL_COPY_GET_INTU_BIG()     Decode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_GET_INTU_LITTLE()  Decode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_GET_INTU()         Decode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) (a) CPU memory addresses/pointers NOT checked for NULL.
N*
N*                   (b) CPU memory addresses/buffers  NOT checked for overlapping.
N*
N*                       (1) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that
N*                           "copying ... between objects that overlap ... is undefined".
N*
N*               (3) MEM_VAL_COPY_GET_INTU_xxx() macro's copy/decode data values without regard to CPU word-
N*                   aligned addresses.  Thus for processors that require data word alignment, data words
N*                   can be copied/decoded to/from any CPU address, word-aligned or not, without generating
N*                   data-word-alignment exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_GET_xxx() macro's are more efficient than MEM_VAL_COPY_GET_INTU_xxx()
N*                   macro's & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_GET_xxx()  Note #4'.
N*
N*               (5) Since octet-order copy/conversion are inverse operations, MEM_VAL_COPY_GET_INTU_xxx() &
N*                   MEM_VAL_COPY_SET_INTU_xxx() macros are inverse, but identical, operations & are provided
N*                   in both forms for semantics & consistency.
N*
N*                   See also 'MEM_VAL_COPY_SET_INTU_xxx()  Note #5'.
N*
N*               (6) MEM_VAL_COPY_GET_INTU_xxx() macro's are NOT atomic operations & MUST NOT be used on any
N*                   non-static (i.e. volatile) variables, registers, hardware, etc.; without the caller of
N*                   the macro's providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (7) MISRA-C 2004 Rule 5.2 states that "identifiers in an inner scope shall not use the same
N*                   name as an indentifier in an outer scope, and therefore hide that identifier".
N*
N*                   Therefore, to avoid possible redeclaration of commonly-used loop counter identifier names,
N*                   'i' & 'j', MEM_VAL_COPY_GET_INTU_xxx() loop counter identifier names are prefixed with a
N*                   single underscore.
N*
N*               (8) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S
S
S#define  MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)       do {                                                                                  \
S                                                                            CPU_SIZE_T  _i;                                                                   \
S                                                                                                                                                              \
S                                                                            for (_i = 0; _i < (val_size); _i++) {                                             \
S                                                                                (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _i)); \
S                                                                            }                                                                                 \
S                                                                        } while (0)
X#define  MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)       do {                                                                                                                                                              CPU_SIZE_T  _i;                                                                                                                                                                                                                                                                                                             for (_i = 0; _i < (val_size); _i++) {                                                                                                                             (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _i));                                                                             }                                                                                                                                                         } while (0)
S
S
S#define  MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)    do {                                                                                  \
S                                                                            CPU_SIZE_T  _i;                                                                   \
S                                                                            CPU_SIZE_T  _j;                                                                   \
S                                                                                                                                                              \
S                                                                                                                                                              \
S                                                                            _j = (val_size) - 1;                                                              \
S                                                                                                                                                              \
S                                                                            for (_i = 0; _i < (val_size); _i++) {                                             \
S                                                                                (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _j)); \
S                                                                                _j--;                                                                         \
S                                                                            }                                                                                 \
S                                                                        } while (0)
X#define  MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)    do {                                                                                                                                                              CPU_SIZE_T  _i;                                                                                                                                               CPU_SIZE_T  _j;                                                                                                                                                                                                                                                                                                                                                                                                                                                                           _j = (val_size) - 1;                                                                                                                                                                                                                                                                                                        for (_i = 0; _i < (val_size); _i++) {                                                                                                                             (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _j));                                                                                 _j--;                                                                                                                                                     }                                                                                                                                                         } while (0)
S
S
S#define  MEM_VAL_COPY_GET_INTU(addr_dest, addr_src, val_size)           MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)
S
S
S
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2u == 2u)
N
N
N#define  MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)       do {                                                                                  \
N                                                                            CPU_SIZE_T  _i;                                                                   \
N                                                                            CPU_SIZE_T  _j;                                                                   \
N                                                                                                                                                              \
N                                                                                                                                                              \
N                                                                            _j = (val_size) - 1;                                                              \
N                                                                                                                                                              \
N                                                                            for (_i = 0; _i < (val_size); _i++) {                                             \
N                                                                                (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _j)); \
N                                                                                _j--;                                                                         \
N                                                                            }                                                                                 \
N                                                                        } while (0)
X#define  MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)       do {                                                                                                                                                              CPU_SIZE_T  _i;                                                                                                                                               CPU_SIZE_T  _j;                                                                                                                                                                                                                                                                                                                                                                                                                                                                           _j = (val_size) - 1;                                                                                                                                                                                                                                                                                                        for (_i = 0; _i < (val_size); _i++) {                                                                                                                             (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _j));                                                                                 _j--;                                                                                                                                                     }                                                                                                                                                         } while (0)
N
N
N#define  MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)    do {                                                                                  \
N                                                                            CPU_SIZE_T  _i;                                                                   \
N                                                                                                                                                              \
N                                                                            for (_i = 0; _i < (val_size); _i++) {                                             \
N                                                                                (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _i)); \
N                                                                            }                                                                                 \
N                                                                        } while (0)
X#define  MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)    do {                                                                                                                                                              CPU_SIZE_T  _i;                                                                                                                                                                                                                                                                                                             for (_i = 0; _i < (val_size); _i++) {                                                                                                                             (*(((CPU_INT08U *)(addr_dest)) + _i)) = (*(((CPU_INT08U *)(addr_src)) + _i));                                                                             }                                                                                                                                                         } while (0)
N
N
N#define  MEM_VAL_COPY_GET_INTU(addr_dest, addr_src, val_size)           MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)
N
N
N
N
N#else                                                           /* See Note #8.                                         */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                       MEM_VAL_COPY_SET_xxx()
N*
N* Description : Copy & encode data values from any CPU memory address to any CPU memory address.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy/encode source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy/encode
N*                                   (see Notes #2 & #3).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Copy/encode data values based on the values' data-word order :
N*
N*                       MEM_VAL_COPY_SET_xxx_BIG()      Encode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_SET_xxx_LITTLE()   Encode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_SET_xxx()          Encode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) (a) CPU memory addresses/pointers NOT checked for NULL.
N*
N*                   (b) CPU memory addresses/buffers  NOT checked for overlapping.
N*
N*                       (1) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that
N*                           "copying ... between objects that overlap ... is undefined".
N*
N*               (3) MEM_VAL_COPY_SET_xxx() macro's copy/encode data values without regard to CPU word-aligned
N*                   addresses.  Thus for processors that require data word alignment, data words can be copied/
N*                   encoded to/from any CPU address, word-aligned or not, without generating data-word-alignment
N*                   exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_SET_xxx() macro's are more efficient than MEM_VAL_SET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_SET_xxx()  Note #4'.
N*
N*               (5) Since octet-order copy/conversion are inverse operations, MEM_VAL_COPY_GET_xxx() &
N*                   MEM_VAL_COPY_SET_xxx() macros are inverse, but identical, operations & are provided
N*                   in both forms for semantics & consistency.
N*
N*                   See also 'MEM_VAL_COPY_GET_xxx()  Note #5'.
N*
N*               (6) MEM_VAL_COPY_SET_xxx() macro's are NOT atomic operations & MUST NOT be used on any
N*                   non-static (i.e. volatile) variables, registers, hardware, etc.; without the caller
N*                   of the  macro's providing some form of additional protection (e.g. mutual exclusion).
N*********************************************************************************************************
N*/
N
N                                                                /* See Note #5.                                         */
N#define  MEM_VAL_COPY_SET_INT08U_BIG(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT16U_BIG(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT32U_BIG(addr_dest, addr_src)               MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)
N
N#define  MEM_VAL_COPY_SET_INT08U_LITTLE(addr_dest, addr_src)            MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT16U_LITTLE(addr_dest, addr_src)            MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT32U_LITTLE(addr_dest, addr_src)            MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)
N
N
N#define  MEM_VAL_COPY_SET_INT08U(addr_dest, addr_src)                   MEM_VAL_COPY_GET_INT08U(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT16U(addr_dest, addr_src)                   MEM_VAL_COPY_GET_INT16U(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT32U(addr_dest, addr_src)                   MEM_VAL_COPY_GET_INT32U(addr_dest, addr_src)
N
N
N/*
N*********************************************************************************************************
N*                                     MEM_VAL_COPY_SET_INTU_xxx()
N*
N* Description : Copy & encode data values from any CPU memory address to any CPU memory address for
N*                   any sized data values.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy/encode source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy/encode
N*                                   (see Notes #2 & #3).
N*
N*               val_size        Number of data value octets to copy/encode.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Copy/encode data values based on the values' data-word order :
N*
N*                       MEM_VAL_COPY_SET_INTU_BIG()     Encode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_SET_INTU_LITTLE()  Encode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_SET_INTU()         Encode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) (a) CPU memory addresses/pointers NOT checked for NULL.
N*
N*                   (b) CPU memory addresses/buffers  NOT checked for overlapping.
N*
N*                       (1) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that
N*                           "copying ... between objects that overlap ... is undefined".
N*
N*               (3) MEM_VAL_COPY_SET_INTU_xxx() macro's copy/encode data values without regard to CPU word-
N*                   aligned addresses.  Thus for processors that require data word alignment, data words
N*                   can be copied/encoded to/from any CPU address, word-aligned or not, without generating
N*                   data-word-alignment exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_SET_xxx() macro's are more efficient than MEM_VAL_COPY_SET_INTU_xxx()
N*                   macro's & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_SET_xxx()  Note #4'.
N*
N*               (5) Since octet-order copy/conversion are inverse operations, MEM_VAL_COPY_GET_INTU_xxx() &
N*                   MEM_VAL_COPY_SET_INTU_xxx() macros are inverse, but identical, operations & are provided
N*                   in both forms for semantics & consistency.
N*
N*                   See also 'MEM_VAL_COPY_GET_INTU_xxx()  Note #5'.
N*
N*               (6) MEM_VAL_COPY_SET_INTU_xxx() macro's are NOT atomic operations & MUST NOT be used on any
N*                   non-static (i.e. volatile) variables, registers, hardware, etc.; without the caller of
N*                   the macro's providing some form of additional protection (e.g. mutual exclusion).
N*********************************************************************************************************
N*/
N
N                                                                /* See Note #5.                                         */
N#define  MEM_VAL_COPY_SET_INTU_BIG(addr_dest, addr_src, val_size)       MEM_VAL_COPY_GET_INTU_BIG(addr_dest, addr_src, val_size)
N#define  MEM_VAL_COPY_SET_INTU_LITTLE(addr_dest, addr_src, val_size)    MEM_VAL_COPY_GET_INTU_LITTLE(addr_dest, addr_src, val_size)
N#define  MEM_VAL_COPY_SET_INTU(addr_dest, addr_src, val_size)           MEM_VAL_COPY_GET_INTU(addr_dest, addr_src, val_size)
N
N
N/*
N*********************************************************************************************************
N*                                         MEM_VAL_COPY_xxx()
N*
N* Description : Copy data values from any CPU memory address to any CPU memory address.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy
N*                                   (see Notes #2 & #3).
N*
N*               val_size        Number of data value octets to copy.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) MEM_VAL_COPY_xxx() macro's copy data values based on CPU's native data-word order.
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) (a) CPU memory addresses/pointers NOT checked for NULL.
N*
N*                   (b) CPU memory addresses/buffers  NOT checked for overlapping.
N*
N*                       (1) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that
N*                           "copying ... between objects that overlap ... is undefined".
N*
N*               (3) MEM_VAL_COPY_xxx() macro's copy data values without regard to CPU word-aligned addresses.
N*                   Thus for processors that require data word alignment, data words can be copied to/from any
N*                   CPU address, word-aligned or not, without generating data-word-alignment exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_xxx() macro's are more efficient than MEM_VAL_COPY() macro & SHOULD be
N*                   used whenever possible.
N*
N*               (5) MEM_VAL_COPY_xxx() macro's are NOT atomic operations & MUST NOT be used on any non-static
N*                   (i.e. volatile) variables, registers, hardware, etc.; without the caller of the macro's
N*                   providing some form of additional protection (e.g. mutual exclusion).
N*
N*               (6) MISRA-C 2004 Rule 5.2 states that "identifiers in an inner scope shall not use the same
N*                   name as an indentifier in an outer scope, and therefore hide that identifier".
N*
N*                   Therefore, to avoid possible redeclaration of commonly-used loop counter identifier name,
N*                   'i', MEM_VAL_COPY() loop counter identifier name is prefixed with a single underscore.
N*********************************************************************************************************
N*/
N
N#define  MEM_VAL_COPY_08(addr_dest, addr_src)                  do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); } while (0)
N
N#define  MEM_VAL_COPY_16(addr_dest, addr_src)                  do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
X#define  MEM_VAL_COPY_16(addr_dest, addr_src)                  do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); } while (0)
N
N#define  MEM_VAL_COPY_32(addr_dest, addr_src)                  do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
X#define  MEM_VAL_COPY_32(addr_dest, addr_src)                  do { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                     (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); } while (0)
N
N
N#define  MEM_VAL_COPY(addr_dest, addr_src, val_size)        do {                                                                                \
N                                                                CPU_SIZE_T  _i;                                                                 \
N                                                                                                                                                \
N                                                                for (_i = 0; _i < (val_size); _i++) {                                           \
N                                                                    (*(((CPU_INT08U *)(addr_dest)) +_i)) = (*(((CPU_INT08U *)(addr_src)) +_i)); \
N                                                                }                                                                               \
N                                                            } while (0)
X#define  MEM_VAL_COPY(addr_dest, addr_src, val_size)        do {                                                                                                                                                CPU_SIZE_T  _i;                                                                                                                                                                                                                                                                                 for (_i = 0; _i < (val_size); _i++) {                                                                                                               (*(((CPU_INT08U *)(addr_dest)) +_i)) = (*(((CPU_INT08U *)(addr_src)) +_i));                                                                 }                                                                                                                                           } while (0)
N
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid               Mem_Init                 (       void);
N
N                                                                /* ------------------ MEM API  FNCTS ------------------ */
Nvoid               Mem_Clr                  (       void              *pmem,
N                                                    CPU_SIZE_T         size);
N
Nvoid               Mem_Set                  (       void              *pmem,
N                                                    CPU_INT08U         data_val,
N                                                    CPU_SIZE_T         size);
N
Nvoid               Mem_Copy                 (       void              *pdest,
N                                             const  void              *psrc,
N                                                    CPU_SIZE_T         size);
N
Nvoid               Mem_Move                 (       void              *pdest,
N                                             const  void              *psrc,
N                                                    CPU_SIZE_T         size);
N
NCPU_BOOLEAN        Mem_Cmp                  (const  void              *p1_mem,
N                                             const  void              *p2_mem,
N                                                    CPU_SIZE_T         size);
N
N
N                                                                /* ----------- MEM HEAP FNCTS (DEPRECATED) ------------ */
N#if (LIB_MEM_CFG_HEAP_SIZE > 0u)
X#if ((1u * 1024u) > 0u)
Nvoid              *Mem_HeapAlloc            (       CPU_SIZE_T         size,
N                                                    CPU_SIZE_T         align,
N                                                    CPU_SIZE_T        *p_bytes_reqd,
N                                                    LIB_ERR           *p_err);
N
NCPU_SIZE_T         Mem_HeapGetSizeRem       (       CPU_SIZE_T         align,
N                                                    LIB_ERR           *p_err);
N#endif
N
N                                                                /* ------------------ MEM SEG FNCTS ------------------- */
Nvoid               Mem_SegCreate            (const  CPU_CHAR          *p_name,
N                                                    MEM_SEG           *p_seg,
N                                                    CPU_ADDR           seg_base_addr,
N                                                    CPU_SIZE_T         size,
N                                                    CPU_SIZE_T         padding_align,
N                                                    LIB_ERR           *p_err);
N
Nvoid               Mem_SegClr               (       MEM_SEG           *p_seg,
N                                                    LIB_ERR           *p_err);
N
Nvoid              *Mem_SegAlloc             (const  CPU_CHAR          *p_name,
N                                                    MEM_SEG           *p_seg,
N                                                    CPU_SIZE_T         size,
N                                                    LIB_ERR           *p_err);
N
Nvoid              *Mem_SegAllocExt          (const  CPU_CHAR          *p_name,
N                                                    MEM_SEG           *p_seg,
N                                                    CPU_SIZE_T         size,
N                                                    CPU_SIZE_T         align,
N                                                    CPU_SIZE_T        *p_bytes_reqd,
N                                                    LIB_ERR           *p_err);
N
Nvoid              *Mem_SegAllocHW           (const  CPU_CHAR          *p_name,
N                                                    MEM_SEG           *p_seg,
N                                                    CPU_SIZE_T         size,
N                                                    CPU_SIZE_T         align,
N                                                    CPU_SIZE_T        *p_bytes_reqd,
N                                                    LIB_ERR           *p_err);
N
NCPU_SIZE_T         Mem_SegRemSizeGet        (       MEM_SEG           *p_seg,
N                                                    CPU_SIZE_T         align,
N                                                    MEM_SEG_INFO      *p_seg_info,
N                                                    LIB_ERR           *p_err);
N
N#if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid               Mem_OutputUsage          (       void             (*out_fnct) (CPU_CHAR *),
S                                                    LIB_ERR           *p_err);
N#endif
N
N                                                                /* -------- STATIC MEM POOL FNCTS (DEPRECATED) -------- */
Nvoid               Mem_PoolCreate           (       MEM_POOL          *p_pool,
N                                                    void              *p_mem_base,
N                                                    CPU_SIZE_T         mem_size,
N                                                    MEM_POOL_BLK_QTY   blk_nbr,
N                                                    CPU_SIZE_T         blk_size,
N                                                    CPU_SIZE_T         blk_align,
N                                                    CPU_SIZE_T        *p_bytes_reqd,
N                                                    LIB_ERR           *p_err);
N
Nvoid               Mem_PoolClr              (       MEM_POOL          *p_pool,
N                                                    LIB_ERR           *p_err);
N
Nvoid              *Mem_PoolBlkGet           (       MEM_POOL          *p_pool,
N                                                    CPU_SIZE_T         size,
N                                                    LIB_ERR           *p_err);
N
Nvoid               Mem_PoolBlkFree          (       MEM_POOL          *p_pool,
N                                                    void              *p_blk,
N                                                    LIB_ERR           *p_err);
N
NMEM_POOL_BLK_QTY   Mem_PoolBlkGetNbrAvail   (       MEM_POOL          *p_pool,
N                                                    LIB_ERR           *p_err);
N
N                                                                /* -------------- DYNAMIC MEM POOL FNCTS -------------- */
Nvoid               Mem_DynPoolCreate        (const  CPU_CHAR          *p_name,
N                                                    MEM_DYN_POOL      *p_pool,
N                                                    MEM_SEG           *p_seg,
N                                                    CPU_SIZE_T         blk_size,
N                                                    CPU_SIZE_T         blk_align,
N                                                    CPU_SIZE_T         blk_qty_init,
N                                                    CPU_SIZE_T         blk_qty_max,
N                                                    LIB_ERR           *p_err);
N
Nvoid               Mem_DynPoolCreateHW      (const  CPU_CHAR          *p_name,
N                                                    MEM_DYN_POOL      *p_pool,
N                                                    MEM_SEG           *p_seg,
N                                                    CPU_SIZE_T         blk_size,
N                                                    CPU_SIZE_T         blk_align,
N                                                    CPU_SIZE_T         blk_qty_init,
N                                                    CPU_SIZE_T         blk_qty_max,
N                                                    LIB_ERR           *p_err);
N
Nvoid              *Mem_DynPoolBlkGet        (       MEM_DYN_POOL      *p_pool,
N                                                    LIB_ERR           *p_err);
N
Nvoid               Mem_DynPoolBlkFree       (       MEM_DYN_POOL      *p_pool,
N                                                    void              *p_blk,
N                                                    LIB_ERR           *p_err);
N
NCPU_SIZE_T         Mem_DynPoolBlkNbrAvailGet(       MEM_DYN_POOL      *p_pool,
N                                                    LIB_ERR           *p_err);
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_MEM_CFG_ARG_CHK_EXT_EN
S#error  "LIB_MEM_CFG_ARG_CHK_EXT_EN         not #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  DEF_DISABLED]           "
S#error  "                             [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_MEM_CFG_ARG_CHK_EXT_EN != DEF_DISABLED) && \
S        (LIB_MEM_CFG_ARG_CHK_EXT_EN != DEF_ENABLED ))
X#elif  ((0u != 0u) &&         (0u != 1u ))
S#error  "LIB_MEM_CFG_ARG_CHK_EXT_EN   illegally #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  DEF_DISABLED]           "
S#error  "                             [     ||  DEF_ENABLED ]           "
N#endif
N
N
N
N#ifndef  LIB_MEM_CFG_OPTIMIZE_ASM_EN
S#error  "LIB_MEM_CFG_OPTIMIZE_ASM_EN        not #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  DEF_DISABLED]           "
S#error  "                             [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_DISABLED) && \
S        (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED ))
X#elif  ((1u != 0u) &&         (1u != 1u ))
S#error  "LIB_MEM_CFG_OPTIMIZE_ASM_EN  illegally #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  DEF_DISABLED]           "
S#error  "                             [     ||  DEF_ENABLED ]           "
N#endif
N
N
N#ifndef  LIB_MEM_CFG_HEAP_SIZE
S#error  "LIB_MEM_CFG_HEAP_SIZE              not #define'd in 'lib_cfg.h'"
S#error  "                                   [MUST be  >= 0]             "
N#endif
N
N
N#ifdef   LIB_MEM_CFG_HEAP_BASE_ADDR
S#if     (LIB_MEM_CFG_HEAP_BASE_ADDR == 0x0)
S#error  "LIB_MEM_CFG_HEAP_BASE_ADDR   illegally #define'd in 'lib_cfg.h'"
S#error  "                             [MUST be  > 0x0]                  "
S#endif
N#endif
N
N
N#if    ((LIB_MEM_CFG_DBG_INFO_EN != DEF_DISABLED) && \
N        (LIB_MEM_CFG_DBG_INFO_EN != DEF_ENABLED ))
X#if    ((0u != 0u) &&         (0u != 1u ))
S#error  "LIB_MEM_CFG_DBG_INFO_EN illegally defined in 'lib_cfg.h'"
S#error  "                        [MUST be  DEF_DISABLED]         "
S#error  "                        [     ||  DEF_ENABLED ]         "
S
S#elif  ((LIB_MEM_CFG_HEAP_SIZE   == 0u) &&           \
S        (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED))
X#elif  (((1u * 1024u)   == 0u) &&                   (0u == 1u))
S#error  "LIB_MEM_CFG_HEAP_SIZE illegally defined in 'lib_cfg.h'                         "
S#error  "                      [MUST be > 0 when LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED]"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                    LIBRARY CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N                                                                /* See 'lib_mem.h  Note #2a'.                           */
N#if     (CPU_CORE_VERSION < 127u)
X#if     (13002u < 127u)
S#error  "CPU_CORE_VERSION  [SHOULD be >= V1.27]"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_mem.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib mem module include.                       */
N
L 111 "..\..\uCOS-III\uC-CPU\cpu_core.h" 2
N#include  <lib_str.h>
L 1 "..\..\uCOS-III\uC-LIB\lib_str.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
N*
N*                  All rights reserved.  Protected by international copyright laws.
N*
N*                  uC/LIB is provided in source form to registered licensees ONLY.  It is
N*                  illegal to distribute this source code to any third party unless you receive
N*                  written permission by an authorized Micrium representative.  Knowledge of
N*                  the source code may NOT be used to develop a similar product.
N*
N*                  Please help us continue to provide the Embedded community with the finest
N*                  software available.  Your honesty is greatly appreciated.
N*
N*                  You can find our product's user manual, API reference, release notes and
N*                  more information at: https://doc.micrium.com
N*
N*                  You can contact us at: http://www.micrium.com
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                       ASCII STRING MANAGEMENT
N*
N* Filename      : lib_str.h
N* Version       : V1.38.01
N* Programmer(s) : ITJ
N*                 JDH
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This string library header file is protected from multiple pre-processor inclusion through
N*               use of the string library module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_STR_MODULE_PRESENT                                 /* See Note #1.                                         */
N#define  LIB_STR_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                 ASCII STRING CONFIGURATION DEFINES
N*
N* Note(s) : (1) Some ASCII string configuration #define's MUST be available PRIOR to including any
N*               application configuration (see 'INCLUDE FILES  Note #1a').
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                    STRING FLOATING POINT DEFINES
N*
N* Note(s) : (1) (a) (1) The maximum accuracy for 32-bit floating-point numbers :
N*
N*
N*                             Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
N*                       32-bit Floating-point Number  =  -----------------------------------------------------
N*                                                                         log [External-Base]
N*
N*                                                         log [2 ^ 24]
N*                                                     =  --------------
N*                                                           log [10]
N*
N*                                                     <  7.225  Base-10 Digits
N*
N*                           where
N*                                   Internal-Base                   Internal number base of floating-
N*                                                                       point numbers (i.e.  2)
N*                                   External-Base                   External number base of floating-
N*                                                                       point numbers (i.e. 10)
N*                                   Number-Internal-Base-Digits     Number of internal number base
N*                                                                       significant digits (i.e. 24)
N*
N*                   (2) Also, since some 32-bit floating-point calculations are converted to 32-bit
N*                       unsigned numbers, the maximum accuracy is limited to the maximum accuracy
N*                       for 32-bit unsigned numbers of 9 digits.
N*
N*               (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the
N*                   maximum accuracy.
N*********************************************************************************************************
N*/
N
N#define  LIB_STR_FP_MAX_NBR_DIG_SIG_MIN                    1u
N#define  LIB_STR_FP_MAX_NBR_DIG_SIG_MAX                    9u   /* See Note #1a2.                                       */
N#define  LIB_STR_FP_MAX_NBR_DIG_SIG_DFLT                   7u   /* See Note #1a1.                                       */
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Your Product Application>\lib_cfg.h
N*
N*               (b) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Your Product Application>      directory path for Your Product's Application
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Your Product Application>\' directory                            See Note #1a
N*
N*               (b) '\<Custom Library Directory>\' directory                            See Note #1b
N*
N*               (c) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*
N*           (4) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               #### The reference to standard library header files SHOULD be removed once all custom
N*               library functions are implemented WITHOUT reference to ANY standard library function(s).
N*
N*               See also 'STANDARD LIBRARY MACRO'S  Note #1'.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N
N#include  <lib_def.h>
N#include  <lib_ascii.h>
L 1 "..\..\uCOS-III\uC-LIB\lib_ascii.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/LIB
N*                                        CUSTOM LIBRARY MODULES
N*
N*                         (c) Copyright 2004-2014; Micrium, Inc.; Weston, FL
N*
N*                  All rights reserved.  Protected by international copyright laws.
N*
N*                  uC/LIB is provided in source form to registered licensees ONLY.  It is
N*                  illegal to distribute this source code to any third party unless you receive
N*                  written permission by an authorized Micrium representative.  Knowledge of
N*                  the source code may NOT be used to develop a similar product.
N*
N*                  Please help us continue to provide the Embedded community with the finest
N*                  software available.  Your honesty is greatly appreciated.
N*
N*                  You can find our product's user manual, API reference, release notes and
N*                  more information at: https://doc.micrium.com
N*
N*                  You can contact us at: http://www.micrium.com
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     ASCII CHARACTER OPERATIONS
N*
N* Filename      : lib_ascii.h
N* Version       : V1.38.01
N* Programmer(s) : BAN
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib_*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*
N*
N*                 (2) (a) ECMA-6 '7-Bit coded Character Set' (6th edition), which corresponds to the
N*                         3rd edition of ISO 646, specifies several versions of a 7-bit character set :
N*
N*                         (1) THE GENERAL VERSION, which allows characters at 0x23 and 0x24 to be given a
N*                             set alternate form and allows the characters 0x40, 0x5B, 0x5D, 0x60, 0x7B &
N*                             0x7D to be assigned a "unique graphic character" or to be declared as unused.
N*                             All other characters are explicitly specified.
N*
N*                         (2) THE INTERNATIONAL REFERENCE VERSION, which explicitly specifies all characters
N*                             in the 7-bit character set.
N*
N*                         (3) NATIONAL & APPLICATION-ORIENTED VERSIONS, which may be derived from the
N*                             standard in specified ways.
N*
N*                     (b) The character set represented in this file reproduces the Internation Reference
N*                         Version.  This is identical to the 7-bit character set which occupies Unicode
N*                         characters 0x0000 through 0x007F.  The character names are taken from v5.0 of the
N*                         Unicode specification, with certain abbreviations so that the resulting #define
N*                         names will not violate ANSI C naming restriction :
N*
N*                         (1) For the Latin capital & lowercase letters, the name components 'LETTER_CAPITAL'
N*                             & 'LETTER_SMALL' are replaced by 'UPPER' & 'LOWER', respectively.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*
N* Note(s) : (1) This ASCII library header file is protected from multiple pre-processor inclusion through
N*               use of the ASCII library module present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_ASCII_MODULE_PRESENT                               /* See Note #1.                                         */
N#define  LIB_ASCII_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The custom library software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib_*.*
N*
N*                       where
N*                               <Custom Library Directory>      directory path for custom library software
N*
N*           (2) CPU-configuration  software files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_*.*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>        directory path for common CPU-compiler software
N*                               <cpu>                           directory name for specific processor (CPU)
N*                               <compiler>                      directory name for specific compiler
N*
N*           (3) Compiler MUST be configured to include as additional include path directories :
N*
N*               (a) '\<Custom Library Directory>\' directory                            See Note #1a
N*
N*               (b) (1) '\<CPU-Compiler Directory>\'                  directory         See Note #2a
N*                   (2) '\<CPU-Compiler Directory>\<cpu>\<compiler>\' directory         See Note #2b
N*
N*           (4) NO compiler-supplied standard library functions SHOULD be used.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N#include  <lib_def.h>
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_ASCII_MODULE
S#define  LIB_ASCII_EXT
N#else
N#define  LIB_ASCII_EXT  extern
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                         ASCII CHARACTER DEFINES
N*********************************************************************************************************
N*/
N
N                                                                /* -------------------- C0 CONTROLS ------------------- */
N#define  ASCII_CHAR_NULL                                0x00    /* '\0'                                                 */
N#define  ASCII_CHAR_START_OF_HEADING                    0x01
N#define  ASCII_CHAR_START_OF_TEXT                       0x02
N#define  ASCII_CHAR_END_OF_TEXT                         0x03
N#define  ASCII_CHAR_END_OF_TRANSMISSION                 0x04
N#define  ASCII_CHAR_ENQUIRY                             0x05
N#define  ASCII_CHAR_ACKNOWLEDGE                         0x06
N#define  ASCII_CHAR_BELL                                0x07    /* '\a'                                                 */
N#define  ASCII_CHAR_BACKSPACE                           0x08    /* '\b'                                                 */
N#define  ASCII_CHAR_CHARACTER_TABULATION                0x09    /* '\t'                                                 */
N#define  ASCII_CHAR_LINE_FEED                           0x0A    /* '\n'                                                 */
N#define  ASCII_CHAR_LINE_TABULATION                     0x0B    /* '\v'                                                 */
N#define  ASCII_CHAR_FORM_FEED                           0x0C    /* '\f'                                                 */
N#define  ASCII_CHAR_CARRIAGE_RETURN                     0x0D    /* '\r'                                                 */
N#define  ASCII_CHAR_SHIFT_OUT                           0x0E
N#define  ASCII_CHAR_SHIFT_IN                            0x0F
N#define  ASCII_CHAR_DATA_LINK_ESCAPE                    0x10
N#define  ASCII_CHAR_DEVICE_CONTROL_ONE                  0x11
N#define  ASCII_CHAR_DEVICE_CONTROL_TWO                  0x12
N#define  ASCII_CHAR_DEVICE_CONTROL_THREE                0x13
N#define  ASCII_CHAR_DEVICE_CONTROL_FOUR                 0x14
N#define  ASCII_CHAR_NEGATIVE_ACKNOWLEDGE                0x15
N#define  ASCII_CHAR_SYNCHRONOUS_IDLE                    0x16
N#define  ASCII_CHAR_END_OF_TRANSMISSION_BLOCK           0x17
N#define  ASCII_CHAR_CANCEL                              0x18
N#define  ASCII_CHAR_END_OF_MEDIUM                       0x19
N#define  ASCII_CHAR_SUBSITUTE                           0x1A
N#define  ASCII_CHAR_ESCAPE                              0x1B
N#define  ASCII_CHAR_INFO_SEPARATOR_FOUR                 0x1C
N#define  ASCII_CHAR_INFO_SEPARATOR_THREE                0x1D
N#define  ASCII_CHAR_INFO_SEPARATOR_TWO                  0x1E
N#define  ASCII_CHAR_INFO_SEPARATOR_ONE                  0x1F
N
N#define  ASCII_CHAR_NUL                                 ASCII_CHAR_NULL
N#define  ASCII_CHAR_SOH                                 ASCII_CHAR_START_OF_HEADING
N#define  ASCII_CHAR_START_HEADING                       ASCII_CHAR_START_OF_HEADING
N#define  ASCII_CHAR_STX                                 ASCII_CHAR_START_OF_TEXT
N#define  ASCII_CHAR_START_TEXT                          ASCII_CHAR_START_OF_TEXT
N#define  ASCII_CHAR_ETX                                 ASCII_CHAR_END_OF_TEXT
N#define  ASCII_CHAR_END_TEXT                            ASCII_CHAR_END_OF_TEXT
N#define  ASCII_CHAR_EOT                                 ASCII_CHAR_END_OF_TRANSMISSION
N#define  ASCII_CHAR_END_TRANSMISSION                    ASCII_CHAR_END_OF_TRANSMISSION
N#define  ASCII_CHAR_ENQ                                 ASCII_CHAR_ENQUIRY
N#define  ASCII_CHAR_ACK                                 ASCII_CHAR_ACKNOWLEDGE
N#define  ASCII_CHAR_BEL                                 ASCII_CHAR_BELL
N#define  ASCII_CHAR_BS                                  ASCII_CHAR_BACKSPACE
N#define  ASCII_CHAR_HT                                  ASCII_CHAR_CHARACTER_TABULATION
N#define  ASCII_CHAR_TAB                                 ASCII_CHAR_CHARACTER_TABULATION
N#define  ASCII_CHAR_LF                                  ASCII_CHAR_LINE_FEED
N#define  ASCII_CHAR_VT                                  ASCII_CHAR_LINE_TABULATION
N#define  ASCII_CHAR_FF                                  ASCII_CHAR_FORM_FEED
N#define  ASCII_CHAR_CR                                  ASCII_CHAR_CARRIAGE_RETURN
N#define  ASCII_CHAR_SO                                  ASCII_CHAR_SHIFT_OUT
N#define  ASCII_CHAR_SI                                  ASCII_CHAR_SHIFT_IN
N#define  ASCII_CHAR_DLE                                 ASCII_CHAR_DATA_LINK_ESCAPE
N#define  ASCII_CHAR_DC1                                 ASCII_CHAR_DEVICE_CONTROL_ONE
N#define  ASCII_CHAR_DC2                                 ASCII_CHAR_DEVICE_CONTROL_TWO
N#define  ASCII_CHAR_DC3                                 ASCII_CHAR_DEVICE_CONTROL_THREE
N#define  ASCII_CHAR_DC4                                 ASCII_CHAR_DEVICE_CONTROL_FOUR
N#define  ASCII_CHAR_DEV_CTRL_ONE                        ASCII_CHAR_DEVICE_CONTROL_ONE
N#define  ASCII_CHAR_DEV_CTRL_TWO                        ASCII_CHAR_DEVICE_CONTROL_TWO
N#define  ASCII_CHAR_DEV_CTRL_THREE                      ASCII_CHAR_DEVICE_CONTROL_THREE
N#define  ASCII_CHAR_DEV_CTRL_FOUR                       ASCII_CHAR_DEVICE_CONTROL_FOUR
N#define  ASCII_CHAR_NAK                                 ASCII_CHAR_NEGATIVE_ACKNOWLEDGE
N#define  ASCII_CHAR_NEG_ACK                             ASCII_CHAR_NEGATIVE_ACKNOWLEDGE
N#define  ASCII_CHAR_SYN                                 ASCII_CHAR_SYNCHRONOUS_IDLE
N#define  ASCII_CHAR_SYNC_IDLE                           ASCII_CHAR_SYNCHRONOUS_IDLE
N#define  ASCII_CHAR_ETB                                 ASCII_CHAR_END_OF_TRANSMISSION_BLOCK
N#define  ASCII_CHAR_END_TRANSMISSION_BLK                ASCII_CHAR_END_OF_TRANSMISSION_BLOCK
N#define  ASCII_CHAR_CAN                                 ASCII_CHAR_CANCEL
N#define  ASCII_CHAR_EM                                  ASCII_CHAR_END_OF_MEDIUM
N#define  ASCII_CHAR_END_MEDIUM                          ASCII_CHAR_END_OF_MEDIUM
N#define  ASCII_CHAR_SUB                                 ASCII_CHAR_SUBSITUTE
N#define  ASCII_CHAR_ESC                                 ASCII_CHAR_ESCAPE
N#define  ASCII_CHAR_IS1                                 ASCII_CHAR_INFO_SEPARATOR_ONE
N#define  ASCII_CHAR_IS2                                 ASCII_CHAR_INFO_SEPARATOR_TWO
N#define  ASCII_CHAR_IS3                                 ASCII_CHAR_INFO_SEPARATOR_THREE
N#define  ASCII_CHAR_IS4                                 ASCII_CHAR_INFO_SEPARATOR_FOUR
N
N
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_SPACE                               0x20    /* ' '                                                  */
N#define  ASCII_CHAR_EXCLAMATION_MARK                    0x21    /* '!'                                                  */
N#define  ASCII_CHAR_QUOTATION_MARK                      0x22    /* '\"'                                                 */
N#define  ASCII_CHAR_NUMBER_SIGN                         0x23    /* '#'                                                  */
N#define  ASCII_CHAR_DOLLAR_SIGN                         0x24    /* '$'                                                  */
N#define  ASCII_CHAR_PERCENTAGE_SIGN                     0x25    /* '%'                                                  */
N#define  ASCII_CHAR_AMPERSAND                           0x26    /* '&'                                                  */
N#define  ASCII_CHAR_APOSTROPHE                          0x27    /* '\''                                                 */
N#define  ASCII_CHAR_LEFT_PARENTHESIS                    0x28    /* '('                                                  */
N#define  ASCII_CHAR_RIGHT_PARENTHESIS                   0x29    /* ')'                                                  */
N#define  ASCII_CHAR_ASTERISK                            0x2A    /* '*'                                                  */
N#define  ASCII_CHAR_PLUS_SIGN                           0x2B    /* '+'                                                  */
N#define  ASCII_CHAR_COMMA                               0x2C    /* ','                                                  */
N#define  ASCII_CHAR_HYPHEN_MINUS                        0x2D    /* '-'                                                  */
N#define  ASCII_CHAR_FULL_STOP                           0x2E    /* '.'                                                  */
N#define  ASCII_CHAR_SOLIDUS                             0x2F    /* '/'                                                  */
N
N#define  ASCII_CHAR_PAREN_LEFT                          ASCII_CHAR_LEFT_PARENTHESIS
N#define  ASCII_CHAR_PAREN_RIGHT                         ASCII_CHAR_RIGHT_PARENTHESIS
N
N
N                                                                /* ------------------- ASCII DIGITS ------------------- */
N#define  ASCII_CHAR_DIGIT_ZERO                          0x30    /* '0'                                                  */
N#define  ASCII_CHAR_DIGIT_ONE                           0x31    /* '1'                                                  */
N#define  ASCII_CHAR_DIGIT_TWO                           0x32    /* '2'                                                  */
N#define  ASCII_CHAR_DIGIT_THREE                         0x33    /* '3'                                                  */
N#define  ASCII_CHAR_DIGIT_FOUR                          0x34    /* '4'                                                  */
N#define  ASCII_CHAR_DIGIT_FIVE                          0x35    /* '5'                                                  */
N#define  ASCII_CHAR_DIGIT_SIX                           0x36    /* '6'                                                  */
N#define  ASCII_CHAR_DIGIT_SEVEN                         0x37    /* '7'                                                  */
N#define  ASCII_CHAR_DIGIT_EIGHT                         0x38    /* '8'                                                  */
N#define  ASCII_CHAR_DIGIT_NINE                          0x39    /* '9'                                                  */
N
N#define  ASCII_CHAR_DIG_ZERO                            ASCII_CHAR_DIGIT_ZERO
N#define  ASCII_CHAR_DIG_ONE                             ASCII_CHAR_DIGIT_ONE
N#define  ASCII_CHAR_DIG_TWO                             ASCII_CHAR_DIGIT_TWO
N#define  ASCII_CHAR_DIG_THREE                           ASCII_CHAR_DIGIT_THREE
N#define  ASCII_CHAR_DIG_FOUR                            ASCII_CHAR_DIGIT_FOUR
N#define  ASCII_CHAR_DIG_FIVE                            ASCII_CHAR_DIGIT_FIVE
N#define  ASCII_CHAR_DIG_SIX                             ASCII_CHAR_DIGIT_SIX
N#define  ASCII_CHAR_DIG_SEVEN                           ASCII_CHAR_DIGIT_SEVEN
N#define  ASCII_CHAR_DIG_EIGHT                           ASCII_CHAR_DIGIT_EIGHT
N#define  ASCII_CHAR_DIG_NINE                            ASCII_CHAR_DIGIT_NINE
N
N
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_COLON                               0x3A    /* ':'                                                  */
N#define  ASCII_CHAR_SEMICOLON                           0x3B    /* ';'                                                  */
N#define  ASCII_CHAR_LESS_THAN_SIGN                      0x3C    /* '<'                                                  */
N#define  ASCII_CHAR_EQUALS_SIGN                         0x3D    /* '='                                                  */
N#define  ASCII_CHAR_GREATER_THAN_SIGN                   0x3E    /* '>'                                                  */
N#define  ASCII_CHAR_QUESTION_MARK                       0x3F    /* '\?'                                                 */
N#define  ASCII_CHAR_COMMERCIAL_AT                       0x40    /* '@'                                                  */
N
N#define  ASCII_CHAR_AT_SIGN                             ASCII_CHAR_COMMERCIAL_AT
N
N
N                                                                /* ------------- UPPERCASE LATIN ALPHABET ------------- */
N#define  ASCII_CHAR_LATIN_UPPER_A                       0x41    /* 'A'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_B                       0x42    /* 'B'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_C                       0x43    /* 'C'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_D                       0x44    /* 'D'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_E                       0x45    /* 'E'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_F                       0x46    /* 'F'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_G                       0x47    /* 'G'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_H                       0x48    /* 'H'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_I                       0x49    /* 'I'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_J                       0x4A    /* 'J'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_K                       0x4B    /* 'K'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_L                       0x4C    /* 'L'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_M                       0x4D    /* 'M'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_N                       0x4E    /* 'N'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_O                       0x4F    /* 'O'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_P                       0x50    /* 'P'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_Q                       0x51    /* 'Q'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_R                       0x52    /* 'R'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_S                       0x53    /* 'S'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_T                       0x54    /* 'T'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_U                       0x55    /* 'U'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_V                       0x56    /* 'V'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_W                       0x57    /* 'W'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_X                       0x58    /* 'X'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_Y                       0x59    /* 'Y'                                                  */
N#define  ASCII_CHAR_LATIN_UPPER_Z                       0x5A    /* 'Z'                                                  */
N
N
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_LEFT_SQUARE_BRACKET                 0x5B    /* '['                                                  */
N#define  ASCII_CHAR_REVERSE_SOLIDUS                     0x5C    /* '\\'                                                 */
N#define  ASCII_CHAR_RIGHT_SQUARE_BRACKET                0x5D    /* ']'                                                  */
N#define  ASCII_CHAR_CIRCUMFLEX_ACCENT                   0x5E    /* '^'                                                  */
N#define  ASCII_CHAR_LOW_LINE                            0x5F    /* '_'                                                  */
N#define  ASCII_CHAR_GRAVE_ACCENT                        0x60    /* '`'                                                  */
N
N#define  ASCII_CHAR_BRACKET_SQUARE_LEFT                 ASCII_CHAR_LEFT_SQUARE_BRACKET
N#define  ASCII_CHAR_BRACKET_SQUARE_RIGHT                ASCII_CHAR_RIGHT_SQUARE_BRACKET
N
N
N                                                                /* ------------- LOWERCASE LATIN ALPHABET ------------- */
N#define  ASCII_CHAR_LATIN_LOWER_A                       0x61    /* 'a'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_B                       0x62    /* 'b'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_C                       0x63    /* 'c'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_D                       0x64    /* 'd'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_E                       0x65    /* 'e'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_F                       0x66    /* 'f'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_G                       0x67    /* 'g'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_H                       0x68    /* 'h'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_I                       0x69    /* 'i'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_J                       0x6A    /* 'j'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_K                       0x6B    /* 'k'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_L                       0x6C    /* 'l'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_M                       0x6D    /* 'm'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_N                       0x6E    /* 'n'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_O                       0x6F    /* 'o'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_P                       0x70    /* 'p'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_Q                       0x71    /* 'q'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_R                       0x72    /* 'r'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_S                       0x73    /* 's'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_T                       0x74    /* 't'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_U                       0x75    /* 'u'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_V                       0x76    /* 'v'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_W                       0x77    /* 'w'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_X                       0x78    /* 'x'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_Y                       0x79    /* 'y'                                                  */
N#define  ASCII_CHAR_LATIN_LOWER_Z                       0x7A    /* 'z'                                                  */
N
N
N                                                                /* ------------ ASCII PUNCTUATION & SYMBOLS ----------- */
N#define  ASCII_CHAR_LEFT_CURLY_BRACKET                  0x7B    /* '{'                                                  */
N#define  ASCII_CHAR_VERTICAL_LINE                       0x7C    /* '|'                                                  */
N#define  ASCII_CHAR_RIGHT_CURLY_BRACKET                 0x7D    /* '}'                                                  */
N#define  ASCII_CHAR_TILDE                               0x7E    /* '~'                                                  */
N
N#define  ASCII_CHAR_BRACKET_CURLY_LEFT                  ASCII_CHAR_LEFT_CURLY_BRACKET
N#define  ASCII_CHAR_BRACKET_CURLY_RIGHT                 ASCII_CHAR_RIGHT_CURLY_BRACKET
N
N
N                                                                /* ---------------- CONTROL CHARACTERS ---------------- */
N#define  ASCII_CHAR_DELETE                              0x7F
N
N#define  ASCII_CHAR_DEL                                 ASCII_CHAR_DELETE
N
N
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                               ASCII CHARACTER CLASSIFICATION MACRO's
N*
N* Note(s) : (1) ISO/IEC 9899:TC2, Section 7.4.1.(1) states that "character classification functions ...
N*               return nonzero (true) if and only if the value of the argument 'c' conforms to ... the
N*               description of the function."
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                           ASCII_IS_DIG()
N*
N* Description : Determine whether a character is a decimal-digit character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a decimal-digit character.
N*
N*               DEF_NO,     if character is NOT a decimal-digit character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.5.(2)  states that "isdigit()  ... tests for any
N*                   decimal-digit character".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_DIG(c)               ((((c) >= ASCII_CHAR_DIG_ZERO) && ((c) <= ASCII_CHAR_DIG_NINE)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                         ASCII_IS_DIG_OCT()
N*
N* Description : Determine whether a character is an octal-digit character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an octal-digit character.
N*
N*               DEF_NO,     if character is NOT an octal-digit character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_DIG_OCT(c)          ((((c) >= ASCII_CHAR_DIG_ZERO) && ((c) <= ASCII_CHAR_DIG_SEVEN)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                         ASCII_IS_DIG_HEX()
N*
N* Description : Determine whether a character is a hexadecimal-digit character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a hexadecimal-digit character.
N*
N*               DEF_NO,     if character is NOT a hexadecimal-digit character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.12.(2) states that "isxdigit() ... tests for any
N*                   hexadecimal-digit character".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_DIG_HEX(c)          (((((c) >= ASCII_CHAR_DIG_ZERO     ) && ((c) <= ASCII_CHAR_DIG_NINE     )) || \
N                                        (((c) >= ASCII_CHAR_LATIN_UPPER_A) && ((c) <= ASCII_CHAR_LATIN_UPPER_F)) || \
N                                        (((c) >= ASCII_CHAR_LATIN_LOWER_A) && ((c) <= ASCII_CHAR_LATIN_LOWER_F))) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_DIG_HEX(c)          (((((c) >= ASCII_CHAR_DIG_ZERO     ) && ((c) <= ASCII_CHAR_DIG_NINE     )) ||                                         (((c) >= ASCII_CHAR_LATIN_UPPER_A) && ((c) <= ASCII_CHAR_LATIN_UPPER_F)) ||                                         (((c) >= ASCII_CHAR_LATIN_LOWER_A) && ((c) <= ASCII_CHAR_LATIN_LOWER_F))) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_LOWER()
N*
N* Description : Determine whether a character is a lowercase alphabetic character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a lowercase alphabetic character.
N*
N*               DEF_NO,     if character is NOT a lowercase alphabetic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.7.(2)  states that "islower() returns true only for
N*                   the lowercase letters".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_LOWER(c)             ((((c) >= ASCII_CHAR_LATIN_LOWER_A) && ((c) <= ASCII_CHAR_LATIN_LOWER_Z)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_UPPER()
N*
N* Description : Determine whether a character is an uppercase alphabetic character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an uppercase alphabetic character.
N*
N*               DEF_NO,     if character is NOT an uppercase alphabetic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.11.(2) states that "isupper() returns true only for
N*                   the uppercase letters".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_UPPER(c)             ((((c) >= ASCII_CHAR_LATIN_UPPER_A) && ((c) <= ASCII_CHAR_LATIN_UPPER_Z)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_ALPHA()
N*
N* Description : Determine whether a character is an alphabetic character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an alphabetic character.
N*
N*               DEF_NO,     if character is NOT an alphabetic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.2.(2) states that "isalpha() returns true only for the
N*                   characters for which isupper() or islower() is true".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_ALPHA(c)             ((((ASCII_IS_UPPER(c)) == DEF_YES) || \
N                                         ((ASCII_IS_LOWER(c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_ALPHA(c)             ((((ASCII_IS_UPPER(c)) == DEF_YES) ||                                          ((ASCII_IS_LOWER(c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                        ASCII_IS_ALPHA_NUM()
N*
N* Description : Determine whether a character is an alphanumeric character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     an alphanumeric character.
N*
N*               DEF_NO,     if character is NOT an alphanumeric character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.1.(2) states that "isalnum() ... tests for any character
N*                   for which isalpha() or isdigit() is true".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_ALPHA_NUM(c)         ((((ASCII_IS_ALPHA(c)) == DEF_YES) || \
N                                         ((ASCII_IS_DIG  (c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_ALPHA_NUM(c)         ((((ASCII_IS_ALPHA(c)) == DEF_YES) ||                                          ((ASCII_IS_DIG  (c)) == DEF_YES)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_BLANK()
N*
N* Description : Determine whether a character is a standard blank character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a standard blank character.
N*
N*               DEF_NO,     if character is NOT a standard blank character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) states that "isblank() returns true only for
N*                       the standard blank characters".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.1.3.(2) defines "the standard blank characters" as
N*                       the "space (' '), and horizontal tab ('\t')".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_BLANK(c)             ((((c) == ASCII_CHAR_SPACE) || ((c) == ASCII_CHAR_HT)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_SPACE()
N*
N* Description : Determine whether a character is a white-space character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a white-space character.
N*
N*               DEF_NO,     if character is NOT a white-space character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) states that "isspace() returns true only
N*                       for the standard white-space characters".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.1.10.(2) defines "the standard white-space characters"
N*                       as the "space (' '), form feed ('\f'), new-line ('\n'), carriage return ('\r'),
N*                       horizontal tab ('\t'), and vertical tab ('\v')".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_SPACE(c)             ((((c) == ASCII_CHAR_SPACE) || ((c) == ASCII_CHAR_CR) || \
N                                         ((c) == ASCII_CHAR_LF   ) || ((c) == ASCII_CHAR_FF) || \
N                                         ((c) == ASCII_CHAR_HT   ) || ((c) == ASCII_CHAR_VT)) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_SPACE(c)             ((((c) == ASCII_CHAR_SPACE) || ((c) == ASCII_CHAR_CR) ||                                          ((c) == ASCII_CHAR_LF   ) || ((c) == ASCII_CHAR_FF) ||                                          ((c) == ASCII_CHAR_HT   ) || ((c) == ASCII_CHAR_VT)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_PRINT()
N*
N* Description : Determine whether a character is a printing character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a printing character.
N*
N*               DEF_NO,     if character is NOT a printing character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.8.(2) states that "isprint() ... tests for any
N*                       printing character including space (' ')".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
N*                       ASCII character set, the printing characters are those whose values lie from
N*                       0x20 (space) through 0x7E (tilde)".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_PRINT(c)             ((((c) >= ASCII_CHAR_SPACE) && ((c) <= ASCII_CHAR_TILDE)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_GRAPH()
N*
N* Description : Determine whether a character is any printing character except a space character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a graphic character.
N*
N*               DEF_NO,     if character is NOT a graphic character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.6.(2) states that "isgraph() ... tests for any
N*                       printing character except space (' ')".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
N*                       ASCII character set, the printing characters are those whose values lie from
N*                       0x20 (space) through 0x7E (tilde)".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_GRAPH(c)             ((((c) >= ASCII_CHAR_EXCLAMATION_MARK) && ((c) <= ASCII_CHAR_TILDE)) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_IS_PUNCT()
N*
N* Description : Determine whether a character is a punctuation character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a punctuation character.
N*
N*               DEF_NO,     if character is NOT a punctuation character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) ISO/IEC 9899:TC2, Section 7.4.1.9.(2) states that "ispunct() returns true for every
N*                   printing character for which neither isspace() nor isalnum() is true".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_PUNCT(c)             ((((ASCII_IS_PRINT(c)) == DEF_YES) && \
N                                         ((ASCII_IS_SPACE(c)) == DEF_NO ) && \
N                                         ((ASCII_IS_ALPHA_NUM(c)) == DEF_NO )) ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_PUNCT(c)             ((((ASCII_IS_PRINT(c)) == DEF_YES) &&                                          ((ASCII_IS_SPACE(c)) == DEF_NO ) &&                                          ((ASCII_IS_ALPHA_NUM(c)) == DEF_NO )) ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                           ASCII_IS_CTRL()
N*
N* Description : Determine whether a character is a control character.
N*
N* Argument(s) : c           Character to examine.
N*
N* Return(s)   : DEF_YES, if character is     a control character.
N*
N*               DEF_NO,     if character is NOT a control character.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.1.4.(2) states that "iscntrl() ... tests for any
N*                       control character".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.(3), Note 169, states that in "the seven-bit US
N*                       ASCII character set, ... the control characters are those whose values lie from
N*                       0 (NUL) through 0x1F (US), and the character 0x7F (DEL)".
N*********************************************************************************************************
N*/
N
N#define  ASCII_IS_CTRL(c)             (((((CPU_INT08S)(c) >= ASCII_CHAR_NULL  ) && ((c) <= ASCII_CHAR_IS1)) || \
N                                                                                   ((c) == ASCII_CHAR_DEL))  ? (DEF_YES) : (DEF_NO))
X#define  ASCII_IS_CTRL(c)             (((((CPU_INT08S)(c) >= ASCII_CHAR_NULL  ) && ((c) <= ASCII_CHAR_IS1)) ||                                                                                    ((c) == ASCII_CHAR_DEL))  ? (DEF_YES) : (DEF_NO))
N
N
N/*
N*********************************************************************************************************
N*                                ASCII CHARACTER CASE MAPPING MACRO's
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                          ASCII_TO_LOWER()
N*
N* Description : Convert uppercase alphabetic character to its corresponding lowercase alphabetic character.
N*
N* Argument(s) : c           Character to convert.
N*
N* Return(s)   : Lowercase equivalent of 'c', if character 'c' is an uppercase character (see Note #1b1).
N*
N*               Character 'c',               otherwise                                  (see Note #1b2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.1.(2) states that "tolower() ... converts an
N*                       uppercase letter to a corresponding lowercase letter".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.2.1.(3) states that :
N*
N*                       (1) (A) "if the argument is a character for which isupper() is true and there are
N*                                one or more corresponding characters ... for which islower() is true," ...
N*                           (B) "tolower() ... returns one of the corresponding characters;" ...
N*
N*                       (2) "otherwise, the argument is returned unchanged."
N*********************************************************************************************************
N*/
N
N#define  ASCII_TO_LOWER(c)              (((ASCII_IS_UPPER(c)) == DEF_YES) ? ((c) + (ASCII_CHAR_LATIN_LOWER_A - ASCII_CHAR_LATIN_UPPER_A)) : (c))
N
N
N/*
N*********************************************************************************************************
N*                                          ASCII_TO_UPPER()
N*
N* Description : Convert lowercase alphabetic character to its corresponding uppercase alphabetic character.
N*
N* Argument(s) : c           Character to convert.
N*
N* Return(s)   : Uppercase equivalent of 'c', if character 'c' is a lowercase character (see Note #1b1).
N*
N*               Character 'c',               otherwise                                 (see Note #1b2).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) (a) ISO/IEC 9899:TC2, Section 7.4.2.2.(2) states that "toupper() ... converts a
N*                       lowercase letter to a corresponding uppercase letter".
N*
N*                   (b) ISO/IEC 9899:TC2, Section 7.4.2.2.(3) states that :
N*
N*                       (1) (A) "if the argument is a character for which islower() is true and there are
N*                                one or more corresponding characters ... for which isupper() is true," ...
N*                           (B) "toupper() ... returns one of the corresponding characters;" ...
N*
N*                       (2) "otherwise, the argument is returned unchanged."
N*********************************************************************************************************
N*/
N
N#define  ASCII_TO_UPPER(c)              (((ASCII_IS_LOWER(c)) == DEF_YES) ? ((c) - (ASCII_CHAR_LATIN_LOWER_A - ASCII_CHAR_LATIN_UPPER_A)) : (c))
N
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
NCPU_BOOLEAN  ASCII_IsAlpha   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsAlphaNum(CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsLower   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsUpper   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsDig     (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsDigOct  (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsDigHex  (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsBlank   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsSpace   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsPrint   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsGraph   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsPunct   (CPU_CHAR  c);
N
NCPU_BOOLEAN  ASCII_IsCtrl    (CPU_CHAR  c);
N
N
NCPU_CHAR     ASCII_ToLower   (CPU_CHAR  c);
N
NCPU_CHAR     ASCII_ToUpper   (CPU_CHAR  c);
N
N
NCPU_BOOLEAN  ASCII_Cmp       (CPU_CHAR  c1,
N                              CPU_CHAR  c2);
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_ascii.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib ascii module include.                     */
N
L 160 "..\..\uCOS-III\uC-LIB\lib_str.h" 2
N
N#include  <lib_cfg.h>
N
N#if 0                                                           /* See Note #4.                                         */
S#include  <stdio.h>
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_STR_MODULE
S#define  LIB_STR_EXT
N#else
N#define  LIB_STR_EXT  extern
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                        DEFAULT CONFIGURATION
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                 STRING FLOATING POINT CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_STR_CFG_FP_EN to enable/disable floating point string function(s).
N*
N*           (2) Configure LIB_STR_CFG_FP_MAX_NBR_DIG_SIG to configure the maximum number of significant
N*               digits to calculate &/or display for floating point string function(s).
N*
N*               See also 'STRING FLOATING POINT DEFINES  Note #1'.
N*********************************************************************************************************
N*/
N
N                                                                /* Configure floating point feature(s) [see Note #1] :  */
N#ifndef  LIB_STR_CFG_FP_EN
S#define  LIB_STR_CFG_FP_EN                      DEF_DISABLED
S                                                                /*   DEF_DISABLED     Floating point functions DISABLED */
S                                                                /*   DEF_ENABLED      Floating point functions ENABLED  */
N#endif
N
N                                                                /* Configure floating point feature(s)' number of ...   */
N                                                                /* ... significant digits (see Note #2).                */
N#ifndef  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG
S#define  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG         LIB_STR_FP_MAX_NBR_DIG_SIG_DFLT
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N#define  STR_CR_LF                     "\r\n"
N#define  STR_LF_CR                     "\n\r"
N#define  STR_NEW_LINE                   STR_CR_LF
N#define  STR_PARENT_PATH               ".."
N
N#define  STR_CR_LF_LEN                 (sizeof(STR_CR_LF)       - 1)
N#define  STR_LF_CR_LEN                 (sizeof(STR_LF_CR)       - 1)
N#define  STR_NEW_LINE_LEN              (sizeof(STR_NEW_LINE)    - 1)
N#define  STR_PARENT_PATH_LEN           (sizeof(STR_PARENT_PATH) - 1)
N
N
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      STANDARD LIBRARY MACRO'S
N*
N* Note(s) : (1) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               #### The reference to standard memory functions SHOULD be removed once all custom library
N*               functions are implemented WITHOUT reference to ANY standard library function(s).
N*
N*               See also 'INCLUDE FILES  Note #3'.
N*********************************************************************************************************
N*/
N
N                                                                /* See Note #1.                                         */
N#define  Str_FmtPrint                   snprintf
N#define  Str_FmtScan                    sscanf
N
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N                                                                /* ------------------ STR LEN  FNCTS ------------------ */
NCPU_SIZE_T   Str_Len            (const  CPU_CHAR      *pstr);
N
NCPU_SIZE_T   Str_Len_N          (const  CPU_CHAR      *pstr,
N                                        CPU_SIZE_T     len_max);
N
N
N                                                                       /* ------------------ STR COPY FNCTS ------------------ */
NCPU_CHAR    *Str_Copy           (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_src);
N
NCPU_CHAR    *Str_Copy_N         (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_src,
N                                        CPU_SIZE_T     len_max);
N
N
NCPU_CHAR    *Str_Cat            (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_cat);
N
NCPU_CHAR    *Str_Cat_N          (       CPU_CHAR      *pstr_dest,
N                                 const  CPU_CHAR      *pstr_cat,
N                                        CPU_SIZE_T     len_max);
N
N
N                                                                       /* ------------------ STR CMP  FNCTS ------------------ */
NCPU_INT16S   Str_Cmp            (const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str);
N
NCPU_INT16S   Str_Cmp_N          (const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str,
N                                        CPU_SIZE_T     len_max);
N
NCPU_INT16S   Str_CmpIgnoreCase  (const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str);
N
NCPU_INT16S   Str_CmpIgnoreCase_N(const  CPU_CHAR      *p1_str,
N                                 const  CPU_CHAR      *p2_str,
N                                        CPU_SIZE_T     len_max);
N
N
N                                                                       /* ------------------ STR SRCH FNCTS ------------------ */
NCPU_CHAR    *Str_Char           (const  CPU_CHAR      *pstr,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_N         (const  CPU_CHAR      *pstr,
N                                        CPU_SIZE_T     len_max,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_Last      (const  CPU_CHAR      *pstr,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_Last_N    (const  CPU_CHAR      *pstr,
N                                        CPU_SIZE_T     len_max,
N                                        CPU_CHAR       srch_char);
N
NCPU_CHAR    *Str_Char_Replace   (       CPU_CHAR      *pstr,
N                                        CPU_CHAR       char_srch,
N                                        CPU_CHAR       char_replace);
N
NCPU_CHAR    *Str_Char_Replace_N (       CPU_CHAR      *pstr,
N                                        CPU_CHAR       char_srch,
N                                        CPU_CHAR       char_replace,
N                                        CPU_SIZE_T     len_max);
N
NCPU_CHAR    *Str_Str            (const  CPU_CHAR      *pstr,
N                                 const  CPU_CHAR      *pstr_srch);
N
NCPU_CHAR    *Str_Str_N          (const  CPU_CHAR      *pstr,
N                                 const  CPU_CHAR      *pstr_srch,
N                                        CPU_SIZE_T     len_max);
N
N
N                                                                       /* ------------------ STR FMT  FNCTS ------------------ */
NCPU_CHAR    *Str_FmtNbr_Int32U  (       CPU_INT32U     nbr,
N                                        CPU_INT08U     nbr_dig,
N                                        CPU_INT08U     nbr_base,
N                                        CPU_CHAR       lead_char,
N                                        CPU_BOOLEAN    lower_case,
N                                        CPU_BOOLEAN    nul,
N                                        CPU_CHAR      *pstr);
N
NCPU_CHAR    *Str_FmtNbr_Int32S  (       CPU_INT32S     nbr,
N                                        CPU_INT08U     nbr_dig,
N                                        CPU_INT08U     nbr_base,
N                                        CPU_CHAR       lead_char,
N                                        CPU_BOOLEAN    lower_case,
N                                        CPU_BOOLEAN    nul,
N                                        CPU_CHAR      *pstr);
N
N#if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
X#if (0u == 1u)
SCPU_CHAR    *Str_FmtNbr_32      (       CPU_FP32       nbr,
S                                        CPU_INT08U     nbr_dig,
S                                        CPU_INT08U     nbr_dp,
S                                        CPU_CHAR       lead_char,
S                                        CPU_BOOLEAN    nul,
S                                        CPU_CHAR      *pstr);
N#endif
N
N
N                                                                       /* ----------------- STR PARSE FNCTS ------------------ */
NCPU_INT32U   Str_ParseNbr_Int32U(const  CPU_CHAR      *pstr,
N                                        CPU_CHAR     **pstr_next,
N                                        CPU_INT08U     nbr_base);
N
NCPU_INT32S   Str_ParseNbr_Int32S(const  CPU_CHAR      *pstr,
N                                        CPU_CHAR     **pstr_next,
N                                        CPU_INT08U     nbr_base);
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_STR_CFG_FP_EN
S#error  "LIB_STR_CFG_FP_EN                     not #define'd in 'lib_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_STR_CFG_FP_EN != DEF_DISABLED) && \
S        (LIB_STR_CFG_FP_EN != DEF_ENABLED ))
X#elif  ((0u != 0u) &&         (0u != 1u ))
S#error  "LIB_STR_CFG_FP_EN               illegally #define'd in 'lib_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S
S#elif   (LIB_STR_CFG_FP_EN == DEF_ENABLED)
X#elif   (0u == 1u)
S
S#ifndef  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG
S#error  "LIB_STR_CFG_FP_MAX_NBR_DIG_SIG        not #define'd in 'lib_cfg.h'          "
S#error  "                                [MUST be  >= LIB_STR_FP_MAX_NBR_DIG_SIG_MIN]"
S#error  "                                [     &&  <= LIB_STR_FP_MAX_NBR_DIG_SIG_MAX]"
S
S#elif   (DEF_CHK_VAL(LIB_STR_CFG_FP_MAX_NBR_DIG_SIG,          \
S                     LIB_STR_FP_MAX_NBR_DIG_SIG_MIN,          \
S                     LIB_STR_FP_MAX_NBR_DIG_SIG_MAX) != DEF_OK)
X#elif   (DEF_CHK_VAL(LIB_STR_CFG_FP_MAX_NBR_DIG_SIG,                               LIB_STR_FP_MAX_NBR_DIG_SIG_MIN,                               LIB_STR_FP_MAX_NBR_DIG_SIG_MAX) != DEF_OK)
S#error  "LIB_STR_CFG_FP_MAX_NBR_DIG_SIG  illegally #define'd in 'lib_cfg.h'          "
S#error  "                                [MUST be  >= LIB_STR_FP_MAX_NBR_DIG_SIG_MIN]"
S#error  "                                [     &&  <= LIB_STR_FP_MAX_NBR_DIG_SIG_MAX]"
S#endif
S
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'lib_str.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib str module include.                       */
N
L 112 "..\..\uCOS-III\uC-CPU\cpu_core.h" 2
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                          CPU CONFIGURATION
N*
N* Note(s) : (1) The following pre-processor directives correctly configure CPU parameters.  DO NOT MODIFY.
N*
N*           (2) CPU timestamp timer feature is required for :
N*
N*               (a) CPU timestamps
N*               (b) CPU interrupts disabled time measurement
N*
N*               See also 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
N*                      & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1'.
N*********************************************************************************************************
N*/
N
N#ifdef   CPU_CFG_TS_EN
S#undef   CPU_CFG_TS_EN
N#endif
N
N
N#if    ((CPU_CFG_TS_32_EN == DEF_ENABLED) || \
N        (CPU_CFG_TS_64_EN == DEF_ENABLED))
X#if    ((1u == 1u) ||         (0u == 1u))
N#define  CPU_CFG_TS_EN                          DEF_ENABLED
N#else
S#define  CPU_CFG_TS_EN                          DEF_DISABLED
N#endif
N
N#if    ((CPU_CFG_TS_EN == DEF_ENABLED) || \
N(defined(CPU_CFG_INT_DIS_MEAS_EN)))
X#if    ((1u == 1u) || (1L))
N#define  CPU_CFG_TS_TMR_EN                      DEF_ENABLED
N#else
S#define  CPU_CFG_TS_TMR_EN                      DEF_DISABLED
N#endif
N
N/*
N*********************************************************************************************************
N*                                          CACHE CONFIGURATION
N*
N* Note(s) : (1) The following pre-processor directives correctly configure CACHE parameters.  DO NOT MODIFY.
N*
N**********************************************************************************************************
N*/
N
N#ifndef CPU_CFG_CACHE_MGMT_EN
S#define CPU_CFG_CACHE_MGMT_EN DEF_DISABLED
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N#define  CPU_TIME_MEAS_NBR_MIN                             1u
N#define  CPU_TIME_MEAS_NBR_MAX                           128u
N
N
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                           CPU ERROR CODES
N*********************************************************************************************************
N*/
N
Ntypedef enum cpu_err {
N
N    CPU_ERR_NONE                            =         0u,
N    CPU_ERR_NULL_PTR                        =        10u,
N
N    CPU_ERR_NAME_SIZE                       =      1000u,
N
N    CPU_ERR_TS_FREQ_INVALID                 =      2000u
N
N} CPU_ERR;
N
N
N/*
N*********************************************************************************************************
N*                                      CPU TIMESTAMP DATA TYPES
N*
N* Note(s) : (1) CPU timestamp timer data type defined to the binary-multiple of 8-bit octets as configured 
N*               by 'CPU_CFG_TS_TMR_SIZE' (see 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #2').
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT32U  CPU_TS32;
Ntypedef  CPU_INT64U  CPU_TS64;
N
Ntypedef  CPU_TS32    CPU_TS;                                    /* Req'd for backwards-compatibility.                   */
N
N
N#if     (CPU_CFG_TS_TMR_EN   == DEF_ENABLED)                    /* CPU ts tmr defined to cfg'd word size (see Note #1). */
X#if     (1u   == 1u)                     
N#if     (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_08)
X#if     (4u == 1u)
Stypedef  CPU_INT08U  CPU_TS_TMR;
S#elif   (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_16)
X#elif   (4u == 2u)
Stypedef  CPU_INT16U  CPU_TS_TMR;
S#elif   (CPU_CFG_TS_TMR_SIZE == CPU_WORD_SIZE_64)
X#elif   (4u == 8u)
Stypedef  CPU_INT64U  CPU_TS_TMR;
N#else                                                           /* CPU ts tmr dflt size = 32-bits.                      */
Ntypedef  CPU_INT32U  CPU_TS_TMR;
N#endif
N#endif
N
N
N/*
N*********************************************************************************************************
N*                               CPU TIMESTAMP TIMER FREQUENCY DATA TYPE
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT32U  CPU_TS_TMR_FREQ;
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N#if    (CPU_CFG_NAME_EN   == DEF_ENABLED)
X#if    (1u   == 1u)
NCPU_CORE_EXT  CPU_CHAR         CPU_Name[CPU_CFG_NAME_SIZE];     /* CPU host name.                                       */
Xextern  CPU_CHAR         CPU_Name[16];      
N#endif
N
N
N#if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
N     (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
X#if ((1u    == 1u)  &&      (4u <  4u))
SCPU_CORE_EXT  CPU_TS32         CPU_TS_32_Accum;                 /* 32-bit accum'd ts  (in ts tmr cnts).                 */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_TS_32_TmrPrev;               /* 32-bit ts prev tmr (in ts tmr cnts).                 */
N#endif
N
N#if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
N     (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
X#if ((0u    == 1u)  &&      (4u <  8u))
SCPU_CORE_EXT  CPU_TS64         CPU_TS_64_Accum;                 /* 64-bit accum'd ts  (in ts tmr cnts).                 */
SCPU_CORE_EXT  CPU_TS_TMR       CPU_TS_64_TmrPrev;               /* 64-bit ts prev tmr (in ts tmr cnts).                 */
N#endif
N
N#if  (CPU_CFG_TS_TMR_EN   == DEF_ENABLED)
X#if  (1u   == 1u)
NCPU_CORE_EXT  CPU_TS_TMR_FREQ  CPU_TS_TmrFreq_Hz;               /* CPU ts tmr freq (in Hz).                             */
Xextern  CPU_TS_TMR_FREQ  CPU_TS_TmrFreq_Hz;                
N#endif
N
N
N#ifdef  CPU_CFG_INT_DIS_MEAS_EN
NCPU_CORE_EXT  CPU_INT16U       CPU_IntDisMeasCtr;               /* Nbr tot    ints dis'd ctr.                           */
Xextern  CPU_INT16U       CPU_IntDisMeasCtr;                
NCPU_CORE_EXT  CPU_INT16U       CPU_IntDisNestCtr;               /* Nbr nested ints dis'd ctr.                           */
Xextern  CPU_INT16U       CPU_IntDisNestCtr;                
N                                                                /* Ints dis'd time (in ts tmr cnts) : ...               */
NCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasStart_cnts;        /* ...  start time.                                     */
Xextern  CPU_TS_TMR       CPU_IntDisMeasStart_cnts;         
NCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasStop_cnts;         /* ...  stop  time.                                     */
Xextern  CPU_TS_TMR       CPU_IntDisMeasStop_cnts;          
NCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasOvrhd_cnts;        /* ...        time meas ovrhd.                          */
Xextern  CPU_TS_TMR       CPU_IntDisMeasOvrhd_cnts;         
NCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasMaxCur_cnts;       /* ...     resetable max time dis'd.                    */
Xextern  CPU_TS_TMR       CPU_IntDisMeasMaxCur_cnts;        
NCPU_CORE_EXT  CPU_TS_TMR       CPU_IntDisMeasMax_cnts;          /* ... non-resetable max time dis'd.                    */
Xextern  CPU_TS_TMR       CPU_IntDisMeasMax_cnts;           
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                         CPU_SW_EXCEPTION()
N*
N* Description : Trap unrecoverable software exception.
N*
N* Argument(s) : err_rtn_val     Error type &/or value of the calling function to return (see Note #2b).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : various.
N*
N* Note(s)     : (1) CPU_SW_EXCEPTION() deadlocks the current code execution -- whether multi-tasked/
N*                   -processed/-threaded or single-threaded -- when the current code execution cannot 
N*                   gracefully recover or report a fault or exception condition.
N*
N*                   Example CPU_SW_EXCEPTION() call :
N*
N*                       void  Fnct (CPU_ERR  *p_err)
N*                       {
N*                           :
N*
N*                           if (p_err == (CPU_ERR *)0) {        If 'p_err' NULL, cannot return error ...
N*                               CPU_SW_EXCEPTION(;);            ... so trap invalid argument exception.
N*                           }
N*
N*                           :
N*                       }
N*
N*                   See also 'cpu_core.c  CPU_SW_Exception()  Note #1'.
N*
N*               (2) (a) CPU_SW_EXCEPTION()  MAY be developer-implemented to output &/or handle any error or 
N*                       exception conditions; but since CPU_SW_EXCEPTION() is intended to trap unrecoverable 
N*                       software  conditions, it is recommended that developer-implemented versions prevent 
N*                       execution of any code following calls to CPU_SW_EXCEPTION() by deadlocking the code 
N*                       (see Note #1).
N*
N*                           Example CPU_SW_EXCEPTION() :
N*
N*                               #define  CPU_SW_EXCEPTION(err_rtn_val)      do {                         \
N*                                                                               Log(__FILE__, __LINE__); \
N*                                                                               CPU_SW_Exception();      \
N*                                                                           } while (0)
X
N*
N*                   (b) (1) However, if execution of code following calls to CPU_SW_EXCEPTION() is required 
N*                           (e.g. for automated testing); it is recommended that the last statement in 
N*                           developer-implemented versions be to return from the current function to prevent 
N*                           possible software exception(s) in the current function from triggering CPU &/or 
N*                           hardware exception(s).
N*
N*                           Example CPU_SW_EXCEPTION() :
N*
N*                               #define  CPU_SW_EXCEPTION(err_rtn_val)      do {                         \
N*                                                                               Log(__FILE__, __LINE__); \
N*                                                                               return  err_rtn_val;     \
N*                                                                           } while (0)
X
N*
N*                           (A) Note that 'err_rtn_val' in the return statement MUST NOT be enclosed in 
N*                               parentheses.  This allows CPU_SW_EXCEPTION() to return from functions that 
N*                               return 'void', i.e. NO return type or value (see also Note #2b2A).
N*
N*                       (2) In order for CPU_SW_EXCEPTION() to return from functions with various return 
N*                           types/values, each caller function MUST pass an appropriate error return type 
N*                           & value to CPU_SW_EXCEPTION().
N*
N*                           (A) Note that CPU_SW_EXCEPTION()  MUST NOT be passed any return type or value 
N*                               for functions that return 'void', i.e. NO return type or value; but SHOULD 
N*                               instead be passed a single semicolon.  This prevents possible compiler 
N*                               warnings that CPU_SW_EXCEPTION() is passed too few arguments.  However, 
N*                               the compiler may warn that CPU_SW_EXCEPTION() does NOT prevent creating 
N*                               null statements on lines with NO other code statements.
N*
N*                           Example CPU_SW_EXCEPTION() calls :
N*
N*                               void  Fnct (CPU_ERR  *p_err)
N*                               {
N*                                   :
N*
N*                                   if (p_err == (CPU_ERR *)0) {
N*                                       CPU_SW_EXCEPTION(;);            Exception macro returns NO value
N*                                   }                                       (see Note #2b2A)
N*
N*                                   :
N*                               }
N*
N*                               CPU_BOOLEAN  Fnct (CPU_ERR  *p_err)
N*                               {
N*                                   :
N*
N*                                   if (p_err == (CPU_ERR *)0) {
N*                                       CPU_SW_EXCEPTION(DEF_FAIL);     Exception macro returns 'DEF_FAIL'
N*                                   }
N*
N*                                   :
N*                               }
N*
N*                               OBJ  *Fnct (CPU_ERR  *p_err)
N*                               {
N*                                   :
N*
N*                                   if (p_err == (CPU_ERR *)0) {
N*                                       CPU_SW_EXCEPTION((OBJ *)0);     Exception macro returns NULL 'OBJ *'
N*                                   }
N*
N*                                   :
N*                               }
N*
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_SW_EXCEPTION                                                       /* See Note #2.                         */
N#define  CPU_SW_EXCEPTION(err_rtn_val)              do {                    \
N                                                        CPU_SW_Exception(); \
N                                                    } while (0)
X#define  CPU_SW_EXCEPTION(err_rtn_val)              do {                                                                            CPU_SW_Exception();                                                     } while (0)
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                           CPU_VAL_UNUSED()
N*
N* Description : 
N*
N* Argument(s) : none.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : #### various.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N
N#define  CPU_VAL_UNUSED(val)        ((void)&(val));
N
N
N#define  CPU_VAL_IGNORED(val)       CPU_VAL_UNUSED(val)
N
N
N/*
N*********************************************************************************************************
N*                                          CPU_TYPE_CREATE()
N*
N* Description : Creates a generic type value.
N*
N* Argument(s) : char_1      1st ASCII character to create generic type value.
N*
N*               char_2      2nd ASCII character to create generic type value.
N*
N*               char_3      3rd ASCII character to create generic type value.
N*
N*               char_4      4th ASCII character to create generic type value.
N*
N* Return(s)   : 32-bit generic type value.
N*
N* Caller(s)   : various.
N*
N* Note(s)     : (1) (a) Generic type values should be #define'd with large, non-trivial values to trap 
N*                       & discard invalid/corrupted objects based on type value.
N*
N*                       In other words, by assigning large, non-trivial values to valid objects' type 
N*                       fields; the likelihood that an object with an unassigned &/or corrupted type 
N*                       field will contain a value is highly improbable & therefore the object itself 
N*                       will be trapped as invalid.
N*
N*                   (b) (1) CPU_TYPE_CREATE()  creates a 32-bit type value from four values.
N*
N*                       (2) Ideally, generic type values SHOULD be created from 'CPU_CHAR' characters to 
N*                           represent ASCII string abbreviations of the specific object types.  Memory 
N*                           displays of object type values will display the specific object types with 
N*                           their chosen ASCII names.
N*
N*                           Examples :
N*
N*                               #define  FILE_TYPE  CPU_TYPE_CREATE('F', 'I', 'L', 'E')
N*                               #define  BUF_TYPE   CPU_TYPE_CREATE('B', 'U', 'F', ' ')
N*********************************************************************************************************
N*/
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2u == 1u)
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4))))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4))))
S
N#else
N
N#if    ((CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_64) || \
N        (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_32))
X#if    ((4u   == 8u) ||         (4u   == 4u))
N#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1))) | \
N                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (1u * DEF_OCTET_NBR_BITS)) | \
N                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (2u * DEF_OCTET_NBR_BITS)) | \
N                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (3u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1))) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (3u * DEF_OCTET_NBR_BITS)))
N
N
N#elif   (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_16)
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3))) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4)) << (1u * DEF_OCTET_NBR_BITS)))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3))) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4)) << (1u * DEF_OCTET_NBR_BITS)))
S
S#else                                                           /* Dflt CPU_WORD_SIZE_08.                               */
S#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) | \
S                                                                 ((CPU_INT32U)((CPU_INT08U)(char_4))))
X#define  CPU_TYPE_CREATE(char_1, char_2, char_3, char_4)        (((CPU_INT32U)((CPU_INT08U)(char_1)) << (3u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_2)) << (2u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_3)) << (1u * DEF_OCTET_NBR_BITS)) |                                                                  ((CPU_INT32U)((CPU_INT08U)(char_4))))
N#endif
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*
N* Note(s) : (1) CPU interrupts disabled time measurement functions prototyped/defined only if 
N*               CPU_CFG_INT_DIS_MEAS_EN  #define'd in 'cpu_cfg.h'.
N*
N*           (2) (a) CPU_CntLeadZeros()  defined in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_LEAD_ZEROS_ASM_PRESENT       #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_LEAD_ZEROS_ASM_PRESENT   NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s)
N*
N*               (b) CPU_CntTrailZeros() defined in :
N*
N*                   (1) 'cpu_a.asm',  if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT      #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable assembly-optimized function(s)
N*
N*                   (2) 'cpu_core.c', if CPU_CFG_TRAIL_ZEROS_ASM_PRESENT  NOT #define'd in 'cpu.h'/
N*                                         'cpu_cfg.h' to enable C-source-optimized function(s)
N*********************************************************************************************************
N*/
N
Nvoid             CPU_Init                 (void);
N
Nvoid             CPU_SW_Exception         (void);
N
N
N
N#if (CPU_CFG_NAME_EN == DEF_ENABLED)                                    /* -------------- CPU NAME FNCTS -------------- */
X#if (1u == 1u)                                     
Nvoid             CPU_NameClr              (void);
N
Nvoid             CPU_NameGet              (       CPU_CHAR  *p_name,
N                                                  CPU_ERR   *p_err);
N
Nvoid             CPU_NameSet              (const  CPU_CHAR  *p_name,
N                                                  CPU_ERR   *p_err);
N#endif
N
N
N
N                                                                        /* --------------- CPU TS FNCTS --------------- */
N#if (CPU_CFG_TS_32_EN == DEF_ENABLED)
X#if (1u == 1u)
NCPU_TS32         CPU_TS_Get32             (void);
N#endif
N
N#if (CPU_CFG_TS_64_EN == DEF_ENABLED)
X#if (0u == 1u)
SCPU_TS64         CPU_TS_Get64             (void);
N#endif
N
N#if (CPU_CFG_TS_EN    == DEF_ENABLED)
X#if (1u    == 1u)
Nvoid             CPU_TS_Update            (void);
N#endif
N
N
N#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)                                  /* ------------- CPU TS TMR FNCTS ------------- */
X#if (1u == 1u)                                   
NCPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet        (CPU_ERR          *p_err);
N
Nvoid             CPU_TS_TmrFreqSet        (CPU_TS_TMR_FREQ   freq_hz);
N#endif
N
N
N
N#ifdef  CPU_CFG_INT_DIS_MEAS_EN                                         /* -------- CPU INT DIS TIME MEAS FNCTS ------- */
N                                                                        /* See Note #1.                                 */
NCPU_TS_TMR       CPU_IntDisMeasMaxCurReset(void);
N
NCPU_TS_TMR       CPU_IntDisMeasMaxCurGet  (void);
N
NCPU_TS_TMR       CPU_IntDisMeasMaxGet     (void);
N
N
Nvoid             CPU_IntDisMeasStart      (void);
N
Nvoid             CPU_IntDisMeasStop       (void);
N#endif
N
N
N
N                                                                        /* ----------- CPU CNT ZEROS FNCTS ------------ */
N#ifdef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
N#ifdef __cplusplus
Sextern  "C" {
N#endif
N#endif
N
NCPU_DATA         CPU_CntLeadZeros         (CPU_DATA    val);
N
N#ifdef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
N#ifdef __cplusplus
S}
N#endif
N#endif
N
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
X#if     (8u >= 1u)
NCPU_DATA         CPU_CntLeadZeros08       (CPU_INT08U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
X#if     (8u >= 2u)
NCPU_DATA         CPU_CntLeadZeros16       (CPU_INT16U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
X#if     (8u >= 4u)
NCPU_DATA         CPU_CntLeadZeros32       (CPU_INT32U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
X#if     (8u >= 8u)
NCPU_DATA         CPU_CntLeadZeros64       (CPU_INT64U  val);
N#endif
N
N
N#ifdef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
N#ifdef __cplusplus
Sextern  "C" {
N#endif
N#endif
N  
NCPU_DATA         CPU_CntTrailZeros        (CPU_DATA    val);
N
N#ifdef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
N#ifdef __cplusplus
S}
N#endif
N#endif
N
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
X#if     (8u >= 1u)
NCPU_DATA         CPU_CntTrailZeros08      (CPU_INT08U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
X#if     (8u >= 2u)
NCPU_DATA         CPU_CntTrailZeros16      (CPU_INT16U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
X#if     (8u >= 4u)
NCPU_DATA         CPU_CntTrailZeros32      (CPU_INT32U  val);
N#endif
N#if     (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
X#if     (8u >= 8u)
NCPU_DATA         CPU_CntTrailZeros64      (CPU_INT64U  val);
N#endif
N
NCPU_INT08U       CPU_PopCnt32             (CPU_INT32U  value);
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*                                      DEFINED IN PRODUCT'S BSP
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                          CPU_TS_TmrInit()
N*
N* Description : Initialize & start CPU timestamp timer.
N*
N* Argument(s) : none.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : CPU_TS_Init().
N*
N*               This function is an INTERNAL CPU module function & MUST be implemented by application/
N*               BSP function(s) [see Note #1] but MUST NOT be called by application function(s).
N*
N* Note(s)     : (1) CPU_TS_TmrInit() is an application/BSP function that MUST be defined by the developer 
N*                   if either of the following CPU features is enabled :
N*
N*                   (a) CPU timestamps
N*                   (b) CPU interrupts disabled time measurements
N*
N*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
N*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
N*
N*               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR' 
N*                       data type.
N*
N*                       (1) If timer has more bits, truncate timer values' higher-order bits greater 
N*                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
N*
N*                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR' 
N*                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be 
N*                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
N*
N*                           In other words, if timer size is not a binary-multiple of 8-bit octets 
N*                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple 
N*                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the 
N*                           minimum supported word size for CPU timestamp timers is 8-bits.
N*
N*                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
N*                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
N*
N*                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
N*
N*                   (c) When applicable, timer period SHOULD be less than the typical measured time 
N*                       but MUST be less than the maximum measured time; otherwise, timer resolution 
N*                       inadequate to measure desired times.
N*
N*                   See also 'CPU_TS_TmrRd()  Note #2'.
N*********************************************************************************************************
N*/
N
N#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid  CPU_TS_TmrInit(void);
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                           CPU_TS_TmrRd()
N*
N* Description : Get current CPU timestamp timer count value.
N*
N* Argument(s) : none.
N*
N* Return(s)   : Timestamp timer count (see Notes #2a & #2b).
N*
N* Caller(s)   : CPU_TS_Init(),
N*               CPU_TS_Get32(),
N*               CPU_TS_Get64(),
N*               CPU_IntDisMeasStart(),
N*               CPU_IntDisMeasStop().
N*
N*               This function is an INTERNAL CPU module function & MUST be implemented by application/
N*               BSP function(s) [see Note #1] but SHOULD NOT be called by application function(s).
N*
N* Note(s)     : (1) CPU_TS_TmrRd() is an application/BSP function that MUST be defined by the developer 
N*                   if either of the following CPU features is enabled :
N*
N*                   (a) CPU timestamps
N*                   (b) CPU interrupts disabled time measurements
N*
N*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
N*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
N*
N*               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR' 
N*                       data type.
N*
N*                       (1) If timer has more bits, truncate timer values' higher-order bits greater 
N*                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
N*
N*                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR' 
N*                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be 
N*                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
N*
N*                           In other words, if timer size is not a binary-multiple of 8-bit octets 
N*                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple 
N*                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the 
N*                           minimum supported word size for CPU timestamp timers is 8-bits.
N*
N*                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
N*                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
N*
N*                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
N*
N*                       (1) If timer is a 'down' counter whose values decrease with each time count,
N*                           then the returned timer value MUST be ones-complemented.
N*
N*                   (c) (1) When applicable, the amount of time measured by CPU timestamps is 
N*                           calculated by either of the following equations :
N*
N*                           (A) Time measured  =  Number timer counts  *  Timer period
N*
N*                                   where
N*
N*                                       Number timer counts     Number of timer counts measured 
N*                                       Timer period            Timer's period in some units of 
N*                                                                   (fractional) seconds
N*                                       Time measured           Amount of time measured, in same 
N*                                                                   units of (fractional) seconds 
N*                                                                   as the Timer period
N*
N*                                                  Number timer counts
N*                           (B) Time measured  =  ---------------------
N*                                                    Timer frequency
N*
N*                                   where
N*
N*                                       Number timer counts     Number of timer counts measured
N*                                       Timer frequency         Timer's frequency in some units 
N*                                                                   of counts per second
N*                                       Time measured           Amount of time measured, in seconds
N*
N*                       (2) Timer period SHOULD be less than the typical measured time but MUST be less 
N*                           than the maximum measured time; otherwise, timer resolution inadequate to 
N*                           measure desired times.
N*********************************************************************************************************
N*/
N
N#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
X#if (1u == 1u)
NCPU_TS_TMR  CPU_TS_TmrRd(void);
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                         CPU_TSxx_to_uSec()
N*
N* Description : Convert a 32-/64-bit CPU timestamp from timer counts to microseconds.
N*
N* Argument(s) : ts_cnts   CPU timestamp (in timestamp timer counts [see Note #2aA]).
N*
N* Return(s)   : Converted CPU timestamp (in microseconds           [see Note #2aD]).
N*
N* Caller(s)   : Application.
N*
N*               This function is an (optional) CPU module application programming interface (API) 
N*               function which MAY be implemented by application/BSP function(s) [see Note #1] & 
N*               MAY be called by application function(s).
N*
N* Note(s)     : (1) CPU_TS32_to_uSec()/CPU_TS64_to_uSec() are application/BSP functions that MAY be 
N*                   optionally defined by the developer when either of the following CPU features is 
N*                   enabled :
N*
N*                   (a) CPU timestamps
N*                   (b) CPU interrupts disabled time measurements
N*
N*                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
N*                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
N*
N*               (2) (a) The amount of time measured by CPU timestamps is calculated by either of 
N*                       the following equations :
N*
N*                                                                        10^6 microseconds
N*                       (1) Time measured  =   Number timer counts   *  -------------------  *  Timer period
N*                                                                            1 second
N*
N*                                              Number timer counts       10^6 microseconds
N*                       (2) Time measured  =  ---------------------  *  -------------------
N*                                                Timer frequency             1 second
N*
N*                               where
N*
N*                                   (A) Number timer counts     Number of timer counts measured
N*                                   (B) Timer frequency         Timer's frequency in some units 
N*                                                                   of counts per second
N*                                   (C) Timer period            Timer's period in some units of 
N*                                                                   (fractional)  seconds
N*                                   (D) Time measured           Amount of time measured, 
N*                                                                   in microseconds
N*
N*                   (b) Timer period SHOULD be less than the typical measured time but MUST be less 
N*                       than the maximum measured time; otherwise, timer resolution inadequate to 
N*                       measure desired times.
N*
N*                   (c) Specific implementations may convert any number of CPU_TS32 or CPU_TS64 bits 
N*                       -- up to 32 or 64, respectively -- into microseconds.
N*********************************************************************************************************
N*/
N
N#if (CPU_CFG_TS_32_EN == DEF_ENABLED)
X#if (1u == 1u)
NCPU_INT64U  CPU_TS32_to_uSec(CPU_TS32  ts_cnts);
N#endif
N
N#if (CPU_CFG_TS_64_EN == DEF_ENABLED)
X#if (0u == 1u)
SCPU_INT64U  CPU_TS64_to_uSec(CPU_TS64  ts_cnts);
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_NAME_EN
S#error  "CPU_CFG_NAME_EN                       not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_ENABLED ]           "
S#error  "                                [     ||  DEF_DISABLED]           "
S
S#elif  ((CPU_CFG_NAME_EN != DEF_ENABLED ) && \
S        (CPU_CFG_NAME_EN != DEF_DISABLED))
X#elif  ((1u != 1u ) &&         (1u != 0u))
S#error  "CPU_CFG_NAME_EN                 illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_ENABLED ]           "
S#error  "                                [     ||  DEF_DISABLED]           "
S
S
N#elif   (CPU_CFG_NAME_EN == DEF_ENABLED)
X#elif   (1u == 1u)
N
N#ifndef  CPU_CFG_NAME_SIZE
S#error  "CPU_CFG_NAME_SIZE                     not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  >=   1]                 "
S#error  "                                [     &&  <= 255]                 "
S
S#elif   (DEF_CHK_VAL(CPU_CFG_NAME_SIZE,            \
S                     1,                            \
S                     DEF_INT_08U_MAX_VAL) != DEF_OK)
X#elif   (((((((!((((16)) >= 1) && (((1)) < 1))) && (((((1)) >= 1) && (((16)) < 1)) || (((16)) < ((1))))) ? 0u : 1u) == 0u) || ((((!((((255u)) >= 1) && (((16)) < 1))) && (((((16)) >= 1) && (((255u)) < 1)) || (((16)) > ((255u))))) ? 0u : 1u) == 0u)) ? 0u : 1u) != 1u)
S#error  "CPU_CFG_NAME_SIZE               illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  >=   1]                 "
S#error  "                                [     &&  <= 255]                 "
N#endif
N
N#endif
N
N
N
N
N#ifndef  CPU_CFG_TS_32_EN
S#error  "CPU_CFG_TS_32_EN                      not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((CPU_CFG_TS_32_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_32_EN != DEF_ENABLED ))
X#elif  ((1u != 0u) &&         (1u != 1u ))
S#error  "CPU_CFG_TS_32_EN                illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
N#endif
N
N
N#ifndef  CPU_CFG_TS_64_EN
S#error  "CPU_CFG_TS_64_EN                      not #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
S#elif  ((CPU_CFG_TS_64_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_64_EN != DEF_ENABLED ))
X#elif  ((0u != 0u) &&         (0u != 1u ))
S#error  "CPU_CFG_TS_64_EN                illegally #define'd in 'cpu_cfg.h'"
S#error  "                                [MUST be  DEF_DISABLED]           "
S#error  "                                [     ||  DEF_ENABLED ]           "
S
N#endif
N
N                                                                /* Correctly configured in 'cpu_core.h'; DO NOT MODIFY. */
N#ifndef  CPU_CFG_TS_EN
S#error  "CPU_CFG_TS_EN                         not #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S#elif  ((CPU_CFG_TS_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_EN != DEF_ENABLED ))
X#elif  ((1u != 0u) &&         (1u != 1u ))
S#error  "CPU_CFG_TS_EN                   illegally #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
N#endif
N
N
N                                                                /* Correctly configured in 'cpu_core.h'; DO NOT MODIFY. */
N#ifndef  CPU_CFG_TS_TMR_EN
S#error  "CPU_CFG_TS_TMR_EN                     not #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S#elif  ((CPU_CFG_TS_TMR_EN != DEF_DISABLED) && \
S        (CPU_CFG_TS_TMR_EN != DEF_ENABLED ))
X#elif  ((1u != 0u) &&         (1u != 1u ))
S#error  "CPU_CFG_TS_TMR_EN               illegally #define'd in 'cpu_core.h'"
S#error  "                                [MUST be  DEF_DISABLED]            "
S#error  "                                [     ||  DEF_ENABLED ]            "
S
S
N#elif   (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
X#elif   (1u == 1u)
N
N#ifndef  CPU_CFG_TS_TMR_SIZE
S#error  "CPU_CFG_TS_TMR_SIZE                   not #define'd in 'cpu_cfg.h'       "
S#error  "                                [MUST be  CPU_WORD_SIZE_08   8-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_16  16-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_32  32-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_64  64-bit timer]"
S
S#elif  ((CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_08) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_16) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_32) && \
S        (CPU_CFG_TS_TMR_SIZE != CPU_WORD_SIZE_64))
X#elif  ((4u != 1u) &&         (4u != 2u) &&         (4u != 4u) &&         (4u != 8u))
S#error  "CPU_CFG_TS_TMR_SIZE             illegally #define'd in 'cpu_cfg.h'       "
S#error  "                                [MUST be  CPU_WORD_SIZE_08   8-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_16  16-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_32  32-bit timer]"
S#error  "                                [     ||  CPU_WORD_SIZE_64  64-bit timer]"
N#endif
N
N#endif
N
N
N
N#ifndef  CPU_CFG_INT_DIS_MEAS_EN
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_INT_DIS_MEAS_EN               not #define'd in 'cpu_cfg.h'"
S#endif
S
N#else
N
N#ifndef  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR
S#error  "CPU_CFG_INT_DIS_MEAS_OVRHD_NBR        not #define'd in 'cpu_cfg.h' "
S#error  "                                [MUST be  >= CPU_TIME_MEAS_NBR_MIN]"
S#error  "                                [     ||  <= CPU_TIME_MEAS_NBR_MAX]"
S
S#elif   (DEF_CHK_VAL(CPU_CFG_INT_DIS_MEAS_OVRHD_NBR, \
S                     CPU_TIME_MEAS_NBR_MIN,          \
S                     CPU_TIME_MEAS_NBR_MAX) != DEF_OK)
X#elif   (((((((!((((1u)) >= 1) && (((1u)) < 1))) && (((((1u)) >= 1) && (((1u)) < 1)) || (((1u)) < ((1u))))) ? 0u : 1u) == 0u) || ((((!((((128u)) >= 1) && (((1u)) < 1))) && (((((1u)) >= 1) && (((128u)) < 1)) || (((1u)) > ((128u))))) ? 0u : 1u) == 0u)) ? 0u : 1u) != 1u)
S#error  "CPU_CFG_INT_DIS_MEAS_OVRHD_NBR  illegally #define'd in 'cpu_cfg.h' "
S#error  "                                [MUST be  >= CPU_TIME_MEAS_NBR_MIN]"
S#error  "                                [     ||  <= CPU_TIME_MEAS_NBR_MAX]"
S
N#endif
N
N#endif
N
N
N
N
N#ifndef  CPU_CFG_LEAD_ZEROS_ASM_PRESENT
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_LEAD_ZEROS_ASM_PRESENT        not #define'd in 'cpu.h'/'cpu_cfg.h'"
S#endif
N#endif
N
N
N#ifndef  CPU_CFG_TRAIL_ZEROS_ASM_PRESENT
S#if 0                                                           /* Optionally configured in 'cpu_cfg.h'; DO NOT MODIFY. */
S#error  "CPU_CFG_TRAIL_ZEROS_ASM_PRESENT       not #define'd in 'cpu.h'/'cpu_cfg.h'"
S#endif
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                    CPU PORT CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_ADDR_SIZE
S#error  "CPU_CFG_ADDR_SIZE      not #define'd in 'cpu.h'"
N#endif
N
N#ifndef  CPU_CFG_DATA_SIZE
S#error  "CPU_CFG_DATA_SIZE      not #define'd in 'cpu.h'"
N#endif
N
N#ifndef  CPU_CFG_DATA_SIZE_MAX
S#error  "CPU_CFG_DATA_SIZE_MAX  not #define'd in 'cpu.h'"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                    LIBRARY CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N                                                                /* See 'cpu_core.h  Note #1a'.                          */
N#if     (LIB_VERSION < 13500u)
X#if     (13801u < 13500u)
S#error  "LIB_VERSION  [SHOULD be >= V1.35.00]"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*
N* Note(s) : (1) See 'cpu_core.h  MODULE'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of CPU core module include.                      */
N
L 58 "..\..\uCOS-III\uCOS-III\Source\os.h" 2
N#include <lib_def.h>
N#include "os_type.h"
L 1 "..\..\uCOS-III\uCOS-III\Source\os_type.h" 1
N/*
N************************************************************************************************************************
N*                                                      uC/OS-III
N*                                                 The Real-Time Kernel
N*
N*                                  (c) Copyright 2009-2015; Micrium, Inc.; Weston, FL
N*                           All rights reserved.  Protected by international copyright laws.
N*
N* File    : OS_TYPE.H
N* By      : JJL
N* Version : V3.05.00
N*
N* LICENSING TERMS:
N* ---------------
N*           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
N*           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
N*           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
N*           application/product.   We provide ALL the source code for your convenience and to help you
N*           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
N*           it commercially without paying a licensing fee.
N*
N*           Knowledge of the source code may NOT be used to develop a similar product.
N*
N*           Please help us continue to provide the embedded community with the finest software available.
N*           Your honesty is greatly appreciated.
N*
N*           You can find our product's user manual, API reference, release notes and
N*           more information at https://doc.micrium.com.
N*           You can contact us at www.micrium.com.
N************************************************************************************************************************
N*/
N
N#ifndef   OS_TYPE_H
N#define   OS_TYPE_H
N
N#ifdef    VSC_INCLUDE_H_FILE_NAMES
Sconst     CPU_CHAR  *os_type__h = "$Id: $";
N#endif
N
N/*
N************************************************************************************************************************
N*                                                 INCLUDE HEADER FILES
N************************************************************************************************************************
N*/
N
N                                                       /*       Description                                    # Bits */
N                                                       /*                                               <recommended> */
N                                                       /* ----------------------------------------------------------- */
N
Ntypedef   CPU_INT16U      OS_CPU_USAGE;                /* CPU Usage 0..10000                                  <16>/32 */
N
Ntypedef   CPU_INT32U      OS_CTR;                      /* Counter,                                                 32 */
N
Ntypedef   CPU_INT32U      OS_CTX_SW_CTR;               /* Counter of context switches,                             32 */
N
Ntypedef   CPU_INT32U      OS_CYCLES;                   /* CPU clock cycles,                                   <32>/64 */
N
Ntypedef   CPU_INT32U      OS_FLAGS;                    /* Event flags,                                      8/16/<32> */
N
Ntypedef   CPU_INT32U      OS_IDLE_CTR;                 /* Holds the number of times the idle task runs,       <32>/64 */
N
Ntypedef   CPU_INT16U      OS_MEM_QTY;                  /* Number of memory blocks,                            <16>/32 */
Ntypedef   CPU_INT16U      OS_MEM_SIZE;                 /* Size in bytes of a memory block,                    <16>/32 */
N
Ntypedef   CPU_INT16U      OS_MSG_QTY;                  /* Number of OS_MSGs in the msg pool,                  <16>/32 */
Ntypedef   CPU_INT16U      OS_MSG_SIZE;                 /* Size of messages in number of bytes,                <16>/32 */
N
Ntypedef   CPU_INT08U      OS_NESTING_CTR;              /* Interrupt and scheduler nesting,                  <8>/16/32 */
N
Ntypedef   CPU_INT16U      OS_OBJ_QTY;                  /* Number of kernel objects counter,                   <16>/32 */
Ntypedef   CPU_INT32U      OS_OBJ_TYPE;                 /* Special flag to determine object type,                   32 */
N
Ntypedef   CPU_INT16U      OS_OPT;                      /* Holds function options,                             <16>/32 */
N
Ntypedef   CPU_INT32U      OS_MON_RES;                  /* Monitor result flags,                                       */
N
Ntypedef   CPU_INT08U      OS_PRIO;                     /* Priority of a task,                               <8>/16/32 */
N
Ntypedef   CPU_INT16U      OS_QTY;                      /* Quantity                                            <16>/32 */
N
Ntypedef   CPU_INT32U      OS_RATE_HZ;                  /* Rate in Hertz                                            32 */
N
N#if (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_64)            /* Task register                                  8/16/<32/64> */
X#if (4u == 8u)             
Stypedef   CPU_INT64U      OS_REG;
N#else
Ntypedef   CPU_INT32U      OS_REG;
N#endif
Ntypedef   CPU_INT08U      OS_REG_ID;                   /* Index to task register                            <8>/16/32 */
N
Ntypedef   CPU_INT32U      OS_SEM_CTR;                  /* Semaphore value                                     16/<32> */
N
Ntypedef   CPU_INT08U      OS_STATE;                    /* State variable                                    <8>/16/32 */
N
Ntypedef   CPU_INT08U      OS_STATUS;                   /* Status                                            <8>/16/32 */
N
Ntypedef   CPU_INT32U      OS_TICK;                     /* Clock tick counter                                  <32>/64 */
N
N#endif
L 60 "..\..\uCOS-III\uCOS-III\Source\os.h" 2
N#include <os_cpu.h>
L 1 "..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView\os_cpu.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/OS-III
N*                                          The Real-Time Kernel
N*
N*
N*                           (c) Copyright 2009-2015; Micrium, Inc.; Weston, FL
N*                    All rights reserved.  Protected by international copyright laws.
N*
N*                                           ARM Cortex-M3 Port
N*
N* File      : OS_CPU.H
N* Version   : V3.05.00
N* By        : JJL
N*
N* LICENSING TERMS:
N* ---------------
N*             uC/OS-III is provided in source form to registered licensees ONLY.  It is 
N*             illegal to distribute this source code to any third party unless you receive 
N*             written permission by an authorized Micrium representative.  Knowledge of 
N*             the source code may NOT be used to develop a similar product.
N*
N*             Please help us continue to provide the Embedded community with the finest
N*             software available.  Your honesty is greatly appreciated.
N*
N*             You can find our product's user manual, API reference, release notes and
N*             more information at https://doc.micrium.com.
N*             You can contact us at www.micrium.com.
N*
N* For       : ARMv7M Cortex-M3
N* Mode      : Thumb2
N* Toolchain : RealView
N*********************************************************************************************************
N*/
N
N#ifndef  OS_CPU_H
N#define  OS_CPU_H
N
N#ifdef   OS_CPU_GLOBALS
S#define  OS_CPU_EXT
N#else
N#define  OS_CPU_EXT  extern
N#endif
N
N#ifdef __cplusplus
Sextern  "C" {
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               MACROS
N*********************************************************************************************************
N*/
N
N#ifndef  NVIC_INT_CTRL
N#define  NVIC_INT_CTRL                      *((CPU_REG32 *)0xE000ED04u)
N#endif
N
N#ifndef  NVIC_PENDSVSET
N#define  NVIC_PENDSVSET                                    0x10000000u
N#endif
N
N#define  OS_TASK_SW()               NVIC_INT_CTRL = NVIC_PENDSVSET
N#define  OSIntCtxSw()               NVIC_INT_CTRL = NVIC_PENDSVSET
N
N#define  OS_TASK_SW_SYNC()          __isb(0xF)
N
N
N/*
N*********************************************************************************************************
N*                                       TIMESTAMP CONFIGURATION
N*
N* Note(s) : (1) OS_TS_GET() is generally defined as CPU_TS_Get32() to allow CPU timestamp timer to be of
N*               any data type size.
N*
N*           (2) For architectures that provide 32-bit or higher precision free running counters 
N*               (i.e. cycle count registers):
N*
N*               (a) OS_TS_GET() may be defined as CPU_TS_TmrRd() to improve performance when retrieving
N*                   the timestamp.
N*
N*               (b) CPU_TS_TmrRd() MUST be configured to be greater or equal to 32-bits to avoid
N*                   truncation of TS.
N*********************************************************************************************************
N*/
N
N#if      OS_CFG_TS_EN == 1u
X#if      1u == 1u
N#define  OS_TS_GET()               (CPU_TS)CPU_TS_TmrRd()   /* See Note #2a.                                          */
N#else
S#define  OS_TS_GET()               (CPU_TS)0u
N#endif
N
N#if (CPU_CFG_TS_32_EN    == DEF_ENABLED) && \
N    (CPU_CFG_TS_TMR_SIZE  < CPU_WORD_SIZE_32)
X#if (1u    == 1u) &&     (4u  < 4u)
S                                                            /* CPU_CFG_TS_TMR_SIZE MUST be >= 32-bit (see Note #2b).  */
S#error  "cpu_cfg.h, CPU_CFG_TS_TMR_SIZE MUST be >= CPU_WORD_SIZE_32"
N#endif
N
N
N/*
N*********************************************************************************************************
N*                              OS TICK INTERRUPT PRIORITY CONFIGURATION
N*
N* Note(s) : (1) For systems that don't need any high, real-time priority interrupts; the tick interrupt
N*               should be configured as the highest priority interrupt but won't adversely affect system
N*               operations.
N*
N*           (2) For systems that need one or more high, real-time interrupts; these should be configured
N*               higher than the tick interrupt which MAY delay execution of the tick interrupt.
N*
N*               (a) If the higher priority interrupts do NOT continually consume CPU cycles but only
N*                   occasionally delay tick interrupts, then the real-time interrupts can successfully
N*                   handle their intermittent/periodic events with the system not losing tick interrupts
N*                   but only increasing the jitter.
N*
N*               (b) If the higher priority interrupts consume enough CPU cycles to continually delay the
N*                   tick interrupt, then the CPU/system is most likely over-burdened & can't be expected
N*                   to handle all its interrupts/tasks. The system time reference gets compromised as a
N*                   result of losing tick interrupts.
N*********************************************************************************************************
N*/
N
N#define  OS_CPU_CFG_SYSTICK_PRIO           0u
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
NOS_CPU_EXT  CPU_STK  *OS_CPU_ExceptStkBase;
Xextern  CPU_STK  *OS_CPU_ExceptStkBase;
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid  OSStartHighRdy       (void);
N
Nvoid  OS_CPU_PendSVHandler (void);
N
N
Nvoid  OS_CPU_SysTickHandler(void);
Nvoid  OS_CPU_SysTickInit   (CPU_INT32U  cnts);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 61 "..\..\uCOS-III\uCOS-III\Source\os.h" 2
N#if     (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
X#if     (1L && (0u == 1u))
S#include <trace_os.h>
N#endif
N
N
N/*
N************************************************************************************************************************
N*                                              COMPATIBILITY CONFIGURATIONS
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_MON_EN
S#define  OS_CFG_MON_EN                   DEF_DISABLED
N#endif
N
N#ifndef OS_CFG_MON_DEL_EN
S#define  OS_CFG_MON_DEL_EN               DEF_DISABLED
N#endif
N
N#ifndef OS_CFG_TASK_TICK_EN
S#define  OS_CFG_TASK_TICK_EN             DEF_ENABLED
N#endif
N
N#ifndef OS_CFG_TASK_IDLE_EN
S#define  OS_CFG_TASK_IDLE_EN             DEF_ENABLED
N#endif
N
N#ifndef OS_CFG_TASK_STK_REDZONE_EN
S#define  OS_CFG_TASK_STK_REDZONE_EN      DEF_DISABLED
N#endif
N
N#ifndef OS_CFG_INVALID_OS_CALLS_CHK_EN
S#define  OS_CFG_INVALID_OS_CALLS_CHK_EN  DEF_DISABLED
N#endif
N
N
N/*
N************************************************************************************************************************
N*                                               CRITICAL SECTION HANDLING
N************************************************************************************************************************
N*/
N
N
N#if      OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u && defined(CPU_CFG_INT_DIS_MEAS_EN)
X#if      0u > 0u && 1L
S#define  OS_SCHED_LOCK_TIME_MEAS_START()    OS_SchedLockTimeMeasStart()
N#else
N#define  OS_SCHED_LOCK_TIME_MEAS_START()
N#endif
N
N
N#if      OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u && defined(CPU_CFG_INT_DIS_MEAS_EN)
X#if      0u > 0u && 1L
S#define  OS_SCHED_LOCK_TIME_MEAS_STOP()     OS_SchedLockTimeMeasStop()
N#else
N#define  OS_SCHED_LOCK_TIME_MEAS_STOP()
N#endif
N
N#if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)                 /* Deferred ISR Posts ------------------------------ */
X#if (0u == 1u)                  
S                                                                 /* Lock the scheduler                                */
S#define  OS_CRITICAL_ENTER()                                       \
S         do {                                                      \
S             CPU_CRITICAL_ENTER();                                 \
S             OSSchedLockNestingCtr++;                              \
S             if (OSSchedLockNestingCtr == 1u) {                    \
S                 OS_SCHED_LOCK_TIME_MEAS_START();                  \
S             }                                                     \
S             CPU_CRITICAL_EXIT();                                  \
S         } while (0)
X#define  OS_CRITICAL_ENTER()                                                do {                                                                   CPU_CRITICAL_ENTER();                                              OSSchedLockNestingCtr++;                                           if (OSSchedLockNestingCtr == 1u) {                                     OS_SCHED_LOCK_TIME_MEAS_START();                               }                                                                  CPU_CRITICAL_EXIT();                                           } while (0)
S                                                                 /* Lock the scheduler but re-enable interrupts       */
S#define  OS_CRITICAL_ENTER_CPU_EXIT()                              \
S         do {                                                      \
S             OSSchedLockNestingCtr++;                              \
S                                                                   \
S             if (OSSchedLockNestingCtr == 1u) {                    \
S                 OS_SCHED_LOCK_TIME_MEAS_START();                  \
S             }                                                     \
S             CPU_CRITICAL_EXIT();                                  \
S         } while (0)
X#define  OS_CRITICAL_ENTER_CPU_EXIT()                                       do {                                                                   OSSchedLockNestingCtr++;                                                                                                              if (OSSchedLockNestingCtr == 1u) {                                     OS_SCHED_LOCK_TIME_MEAS_START();                               }                                                                  CPU_CRITICAL_EXIT();                                           } while (0)
S
S                                                                 /* Scheduling occurs only if an interrupt occurs     */
S#define  OS_CRITICAL_EXIT()                                        \
S         do {                                                      \
S             CPU_CRITICAL_ENTER();                                 \
S             OSSchedLockNestingCtr--;                              \
S             if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {     \
S                 OS_SCHED_LOCK_TIME_MEAS_STOP();                   \
S                 if (OSIntQNbrEntries > (OS_OBJ_QTY)0) {           \
S                     CPU_CRITICAL_EXIT();                          \
S                     OS_Sched0();                                  \
S                 } else {                                          \
S                     CPU_CRITICAL_EXIT();                          \
S                 }                                                 \
S             } else {                                              \
S                 CPU_CRITICAL_EXIT();                              \
S             }                                                     \
S         } while (0)
X#define  OS_CRITICAL_EXIT()                                                 do {                                                                   CPU_CRITICAL_ENTER();                                              OSSchedLockNestingCtr--;                                           if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {                      OS_SCHED_LOCK_TIME_MEAS_STOP();                                    if (OSIntQNbrEntries > (OS_OBJ_QTY)0) {                                CPU_CRITICAL_EXIT();                                               OS_Sched0();                                                   } else {                                                               CPU_CRITICAL_EXIT();                                           }                                                              } else {                                                               CPU_CRITICAL_EXIT();                                           }                                                              } while (0)
S
S#define  OS_CRITICAL_EXIT_NO_SCHED()                               \
S         do {                                                      \
S             CPU_CRITICAL_ENTER();                                 \
S             OSSchedLockNestingCtr--;                              \
S             if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {     \
S                 OS_SCHED_LOCK_TIME_MEAS_STOP();                   \
S             }                                                     \
S             CPU_CRITICAL_EXIT();                                  \
S         } while (0)
X#define  OS_CRITICAL_EXIT_NO_SCHED()                                        do {                                                                   CPU_CRITICAL_ENTER();                                              OSSchedLockNestingCtr--;                                           if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {                      OS_SCHED_LOCK_TIME_MEAS_STOP();                                }                                                                  CPU_CRITICAL_EXIT();                                           } while (0)
S
S
N#else                                                            /* Direct ISR Posts -------------------------------- */
N
N
N#define  OS_CRITICAL_ENTER()                    CPU_CRITICAL_ENTER()
N
N#define  OS_CRITICAL_ENTER_CPU_EXIT()
N
N#define  OS_CRITICAL_EXIT()                     CPU_CRITICAL_EXIT()
N
N#define  OS_CRITICAL_EXIT_NO_SCHED()            CPU_CRITICAL_EXIT()
N
N#endif
N
N/*
N************************************************************************************************************************
N*                                                     MISCELLANEOUS
N************************************************************************************************************************
N*/
N
N#ifdef   OS_GLOBALS
S#define  OS_EXT
N#else
N#define  OS_EXT  extern
N#endif
N
N
N#define  OS_PRIO_TBL_SIZE          ((OS_CFG_PRIO_MAX - 1u) / (DEF_INT_CPU_NBR_BITS) + 1u)
N
N#define  OS_MSG_EN                 (((OS_CFG_TASK_Q_EN == DEF_ENABLED) || (OS_CFG_Q_EN == DEF_ENABLED)) ? DEF_ENABLED : DEF_DISABLED)
N
N#define  OS_OBJ_TYPE_REQ           (((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED) || (OS_CFG_PEND_MULTI_EN == DEF_ENABLED) \
N                                   || (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)) ? DEF_ENABLED : DEF_DISABLED)
X#define  OS_OBJ_TYPE_REQ           (((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED) || (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)                                    || (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)) ? DEF_ENABLED : DEF_DISABLED)
N
N
N/*
N************************************************************************************************************************
N************************************************************************************************************************
N*                                                   # D E F I N E S
N************************************************************************************************************************
N************************************************************************************************************************
N*/
N
N/*
N========================================================================================================================
N*                                                      TASK STATUS
N========================================================================================================================
N*/
N
N#define  OS_STATE_OS_STOPPED                    (OS_STATE)(0u)
N#define  OS_STATE_OS_RUNNING                    (OS_STATE)(1u)
N
N#define  OS_STATE_NOT_RDY                    (CPU_BOOLEAN)(0u)
N#define  OS_STATE_RDY                        (CPU_BOOLEAN)(1u)
N
N
N                                                                /* ------------------- TASK STATES ------------------ */
N#define  OS_TASK_STATE_BIT_DLY               (OS_STATE)(0x01u)  /*   /-------- SUSPENDED bit                          */
N                                                                /*   |                                                */
N#define  OS_TASK_STATE_BIT_PEND              (OS_STATE)(0x02u)  /*   | /-----  PEND      bit                          */
N                                                                /*   | |                                              */
N#define  OS_TASK_STATE_BIT_SUSPENDED         (OS_STATE)(0x04u)  /*   | | /---  Delayed/Timeout bit                    */
N                                                                /*   | | |                                            */
N                                                                /*   V V V                                            */
N
N#define  OS_TASK_STATE_RDY                    (OS_STATE)(  0u)  /*   0 0 0     Ready                                  */
N#define  OS_TASK_STATE_DLY                    (OS_STATE)(  1u)  /*   0 0 1     Delayed or Timeout                     */
N#define  OS_TASK_STATE_PEND                   (OS_STATE)(  2u)  /*   0 1 0     Pend                                   */
N#define  OS_TASK_STATE_PEND_TIMEOUT           (OS_STATE)(  3u)  /*   0 1 1     Pend + Timeout                         */
N#define  OS_TASK_STATE_SUSPENDED              (OS_STATE)(  4u)  /*   1 0 0     Suspended                              */
N#define  OS_TASK_STATE_DLY_SUSPENDED          (OS_STATE)(  5u)  /*   1 0 1     Suspended + Delayed or Timeout         */
N#define  OS_TASK_STATE_PEND_SUSPENDED         (OS_STATE)(  6u)  /*   1 1 0     Suspended + Pend                       */
N#define  OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED (OS_STATE)(  7u)  /*   1 1 1     Suspended + Pend + Timeout             */
N#define  OS_TASK_STATE_DEL                    (OS_STATE)(255u)
N
N                                                                /* ----------------- PENDING ON ... ----------------- */
N#define  OS_TASK_PEND_ON_NOTHING              (OS_STATE)(  0u)  /* Pending on nothing                                 */
N#define  OS_TASK_PEND_ON_FLAG                 (OS_STATE)(  1u)  /* Pending on event flag group                        */
N#define  OS_TASK_PEND_ON_TASK_Q               (OS_STATE)(  2u)  /* Pending on message to be sent to task              */
N#define  OS_TASK_PEND_ON_MULTI                (OS_STATE)(  3u)  /* Pending on multiple semaphores and/or queues       */
N#define  OS_TASK_PEND_ON_MUTEX                (OS_STATE)(  4u)  /* Pending on mutual exclusion semaphore              */
N#define  OS_TASK_PEND_ON_Q                    (OS_STATE)(  5u)  /* Pending on queue                                   */
N#define  OS_TASK_PEND_ON_SEM                  (OS_STATE)(  6u)  /* Pending on semaphore                               */
N#define  OS_TASK_PEND_ON_TASK_SEM             (OS_STATE)(  7u)  /* Pending on signal  to be sent to task              */
N#define  OS_TASK_PEND_ON_COND_VAR             (OS_STATE)(  8u)  /* Pending on condition variable                      */
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                    TASK PEND STATUS
N*                                      (Status codes for OS_TCBs field .PendStatus)
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#define  OS_STATUS_PEND_OK                   (OS_STATUS)(  0u)  /* Pending status OK, !pending, or pending complete   */
N#define  OS_STATUS_PEND_ABORT                (OS_STATUS)(  1u)  /* Pending aborted                                    */
N#define  OS_STATUS_PEND_DEL                  (OS_STATUS)(  2u)  /* Pending object deleted                             */
N#define  OS_STATUS_PEND_TIMEOUT              (OS_STATUS)(  3u)  /* Pending timed out                                  */
N
N/*
N========================================================================================================================
N*                                                   OS OBJECT TYPES
N*
N* Note(s) : (1) OS_OBJ_TYPE_&&& #define values specifically chosen as ASCII representations of the kernel
N*               object types.  Memory displays of kernel objects will display the kernel object TYPEs with
N*               their chosen ASCII names.
N========================================================================================================================
N*/
N
N#define  OS_OBJ_TYPE_NONE                    (OS_OBJ_TYPE)CPU_TYPE_CREATE('N', 'O', 'N', 'E')
N#define  OS_OBJ_TYPE_FLAG                    (OS_OBJ_TYPE)CPU_TYPE_CREATE('F', 'L', 'A', 'G')
N#define  OS_OBJ_TYPE_MEM                     (OS_OBJ_TYPE)CPU_TYPE_CREATE('M', 'E', 'M', ' ')
N#define  OS_OBJ_TYPE_MUTEX                   (OS_OBJ_TYPE)CPU_TYPE_CREATE('M', 'U', 'T', 'X')
N#define  OS_OBJ_TYPE_Q                       (OS_OBJ_TYPE)CPU_TYPE_CREATE('Q', 'U', 'E', 'U')
N#define  OS_OBJ_TYPE_SEM                     (OS_OBJ_TYPE)CPU_TYPE_CREATE('S', 'E', 'M', 'A')
N#define  OS_OBJ_TYPE_MON                     (OS_OBJ_TYPE)CPU_TYPE_CREATE('M', 'O', 'N', ' ')
N#define  OS_OBJ_TYPE_TASK_MSG                (OS_OBJ_TYPE)CPU_TYPE_CREATE('T', 'M', 'S', 'G')
N#define  OS_OBJ_TYPE_TASK_RESUME             (OS_OBJ_TYPE)CPU_TYPE_CREATE('T', 'R', 'E', 'S')
N#define  OS_OBJ_TYPE_TASK_SIGNAL             (OS_OBJ_TYPE)CPU_TYPE_CREATE('T', 'S', 'I', 'G')
N#define  OS_OBJ_TYPE_TASK_SUSPEND            (OS_OBJ_TYPE)CPU_TYPE_CREATE('T', 'S', 'U', 'S')
N#define  OS_OBJ_TYPE_TICK                    (OS_OBJ_TYPE)CPU_TYPE_CREATE('T', 'I', 'C', 'K')
N#define  OS_OBJ_TYPE_TMR                     (OS_OBJ_TYPE)CPU_TYPE_CREATE('T', 'M', 'R', ' ')
N
N/*
N========================================================================================================================
N*                                           Possible values for 'opt' argument
N========================================================================================================================
N*/
N
N#define  OS_OPT_NONE                         (OS_OPT)(0x0000u)
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                    DELETE OPTIONS
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#define  OS_OPT_DEL_NO_PEND                  (OS_OPT)(0x0000u)
N#define  OS_OPT_DEL_ALWAYS                   (OS_OPT)(0x0001u)
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                     PEND OPTIONS
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#define  OS_OPT_PEND_FLAG_MASK               (OS_OPT)(0x000Fu)
N#define  OS_OPT_PEND_FLAG_CLR_ALL            (OS_OPT)(0x0001u)  /* Wait for ALL    the bits specified to be CLR       */
N#define  OS_OPT_PEND_FLAG_CLR_AND            (OS_OPT)(0x0001u)
N
N#define  OS_OPT_PEND_FLAG_CLR_ANY            (OS_OPT)(0x0002u)  /* Wait for ANY of the bits specified to be CLR       */
N#define  OS_OPT_PEND_FLAG_CLR_OR             (OS_OPT)(0x0002u)
N
N#define  OS_OPT_PEND_FLAG_SET_ALL            (OS_OPT)(0x0004u)  /* Wait for ALL    the bits specified to be SET       */
N#define  OS_OPT_PEND_FLAG_SET_AND            (OS_OPT)(0x0004u)
N
N#define  OS_OPT_PEND_FLAG_SET_ANY            (OS_OPT)(0x0008u)  /* Wait for ANY of the bits specified to be SET       */
N#define  OS_OPT_PEND_FLAG_SET_OR             (OS_OPT)(0x0008u)
N
N#define  OS_OPT_PEND_FLAG_CONSUME            (OS_OPT)(0x0100u)  /* Consume the flags if condition(s) satisfied        */
N
N
N#define  OS_OPT_PEND_BLOCKING                (OS_OPT)(0x0000u)
N#define  OS_OPT_PEND_NON_BLOCKING            (OS_OPT)(0x8000u)
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                  PEND ABORT OPTIONS
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#define  OS_OPT_PEND_ABORT_1                 (OS_OPT)(0x0000u)  /* Pend abort a single waiting task                   */
N#define  OS_OPT_PEND_ABORT_ALL               (OS_OPT)(0x0100u)  /* Pend abort ALL tasks waiting                       */
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                     POST OPTIONS
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N
N#define  OS_OPT_POST_NONE                    (OS_OPT)(0x0000u)
N
N#define  OS_OPT_POST_FLAG_SET                (OS_OPT)(0x0000u)
N#define  OS_OPT_POST_FLAG_CLR                (OS_OPT)(0x0001u)
N
N#define  OS_OPT_POST_FIFO                    (OS_OPT)(0x0000u)  /* Default is to post FIFO                            */
N#define  OS_OPT_POST_LIFO                    (OS_OPT)(0x0010u)  /* Post to highest priority task waiting              */
N#define  OS_OPT_POST_1                       (OS_OPT)(0x0000u)  /* Post message to highest priority task waiting      */
N#define  OS_OPT_POST_ALL                     (OS_OPT)(0x0200u)  /* Broadcast message to ALL tasks waiting             */
N
N#define  OS_OPT_POST_NO_SCHED                (OS_OPT)(0x8000u)  /* Do not call the scheduler if this is selected      */
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                     TASK OPTIONS
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#define  OS_OPT_TASK_NONE                    (OS_OPT)(0x0000u)  /* No option selected                                 */
N#define  OS_OPT_TASK_STK_CHK                 (OS_OPT)(0x0001u)  /* Enable stack checking for the task                 */
N#define  OS_OPT_TASK_STK_CLR                 (OS_OPT)(0x0002u)  /* Clear the stack when the task is create            */
N#define  OS_OPT_TASK_SAVE_FP                 (OS_OPT)(0x0004u)  /* Save the contents of any floating-point registers  */
N#define  OS_OPT_TASK_NO_TLS                  (OS_OPT)(0x0008u)  /* Specifies the task DOES NOT require TLS support    */
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                     TIME OPTIONS
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#define  OS_OPT_TIME_DLY                             DEF_BIT_NONE
N#define  OS_OPT_TIME_TIMEOUT                ((OS_OPT)DEF_BIT_01)
N#define  OS_OPT_TIME_MATCH                  ((OS_OPT)DEF_BIT_02)
N#define  OS_OPT_TIME_PERIODIC               ((OS_OPT)DEF_BIT_03)
N
N#define  OS_OPT_TIME_HMSM_STRICT            ((OS_OPT)DEF_BIT_NONE)
N#define  OS_OPT_TIME_HMSM_NON_STRICT        ((OS_OPT)DEF_BIT_04)
N
N#define  OS_OPT_TIME_MASK                   ((OS_OPT)(OS_OPT_TIME_DLY      | \
N                                                      OS_OPT_TIME_TIMEOUT  | \
N                                                      OS_OPT_TIME_PERIODIC | \
N                                                      OS_OPT_TIME_MATCH))
X#define  OS_OPT_TIME_MASK                   ((OS_OPT)(OS_OPT_TIME_DLY      |                                                       OS_OPT_TIME_TIMEOUT  |                                                       OS_OPT_TIME_PERIODIC |                                                       OS_OPT_TIME_MATCH))
N
N#define  OS_OPT_TIME_OPTS_MASK                       (OS_OPT_TIME_DLY            | \
N                                                      OS_OPT_TIME_TIMEOUT        | \
N                                                      OS_OPT_TIME_PERIODIC       | \
N                                                      OS_OPT_TIME_MATCH          | \
N                                                      OS_OPT_TIME_HMSM_NON_STRICT)
X#define  OS_OPT_TIME_OPTS_MASK                       (OS_OPT_TIME_DLY            |                                                       OS_OPT_TIME_TIMEOUT        |                                                       OS_OPT_TIME_PERIODIC       |                                                       OS_OPT_TIME_MATCH          |                                                       OS_OPT_TIME_HMSM_NON_STRICT)
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                    TIMER OPTIONS
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#define  OS_OPT_TMR_NONE                          (OS_OPT)(0u)  /* No option selected                                 */
N
N#define  OS_OPT_TMR_ONE_SHOT                      (OS_OPT)(1u)  /* Timer will not auto restart when it expires        */
N#define  OS_OPT_TMR_PERIODIC                      (OS_OPT)(2u)  /* Timer will     auto restart when it expires        */
N
N#define  OS_OPT_TMR_CALLBACK                      (OS_OPT)(3u)  /* OSTmrStop() option to call 'callback' w/ timer arg */
N#define  OS_OPT_TMR_CALLBACK_ARG                  (OS_OPT)(4u)  /* OSTmrStop() option to call 'callback' w/ new   arg */
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                     TIMER STATES
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#define  OS_TMR_STATE_UNUSED                    (OS_STATE)(0u)
N#define  OS_TMR_STATE_STOPPED                   (OS_STATE)(1u)
N#define  OS_TMR_STATE_RUNNING                   (OS_STATE)(2u)
N#define  OS_TMR_STATE_COMPLETED                 (OS_STATE)(3u)
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                       PRIORITY
N------------------------------------------------------------------------------------------------------------------------
N*/
N                                                                    /* Dflt prio to init task TCB                     */
N#define  OS_PRIO_INIT                       (OS_PRIO)(OS_CFG_PRIO_MAX)
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                 TIMER TICK THRESHOLDS
N------------------------------------------------------------------------------------------------------------------------
N*/
N                                                                    /* Threshold to init previous tick time           */
N#define  OS_TICK_TH_INIT                    (OS_TICK)(DEF_BIT       ((sizeof(OS_TICK) * DEF_OCTET_NBR_BITS) - 1u))
N
N                                                                    /* Threshold to check if tick time already ready  */
N#define  OS_TICK_TH_RDY                     (OS_TICK)(DEF_BIT_FIELD(((sizeof(OS_TICK) * DEF_OCTET_NBR_BITS) / 2u), \
N                                                                    ((sizeof(OS_TICK) * DEF_OCTET_NBR_BITS) / 2u)))
X#define  OS_TICK_TH_RDY                     (OS_TICK)(DEF_BIT_FIELD(((sizeof(OS_TICK) * DEF_OCTET_NBR_BITS) / 2u),                                                                     ((sizeof(OS_TICK) * DEF_OCTET_NBR_BITS) / 2u)))
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                   MONITOR RESULTS
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#define  OS_MON_RES_ALLOW                   (OS_MON_RES)(0x0000u)
N#define  OS_MON_RES_BLOCK                   (OS_MON_RES)(0x0001u)
N#define  OS_MON_RES_STOP_EVAL               (OS_MON_RES)(0x0002u)
N#define  OS_MON_RES_ACQUIRE                 (OS_MON_RES)(0x0004u)
N#define  OS_MON_RES_RELEASE                 (OS_MON_RES)(0x0008u)
N#define  OS_MON_RES_SUBSCRIBE               (OS_MON_RES)(0x0010u)
N#define  OS_MON_RES_UNSUBSCRIBE             (OS_MON_RES)(0x0020u)
N#define  OS_MON_RES_TRY_FAIL                (OS_MON_RES)(0x0040u)
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                   STACK REDZONE
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#define  OS_STACK_CHECK_VAL                 0x5432DCBAABCD2345UL
N#define  OS_STACK_CHECK_DEPTH               8u
N
N
N/*
N************************************************************************************************************************
N************************************************************************************************************************
N*                                                E N U M E R A T I O N S
N************************************************************************************************************************
N************************************************************************************************************************
N*/
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                      ERROR CODES
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Ntypedef  enum  os_err {
N    OS_ERR_NONE                      =     0u,
N
N    OS_ERR_A                         = 10000u,
N    OS_ERR_ACCEPT_ISR                = 10001u,
N
N    OS_ERR_B                         = 11000u,
N
N    OS_ERR_C                         = 12000u,
N    OS_ERR_CREATE_ISR                = 12001u,
N
N    OS_ERR_D                         = 13000u,
N    OS_ERR_DEL_ISR                   = 13001u,
N
N    OS_ERR_E                         = 14000u,
N
N    OS_ERR_F                         = 15000u,
N    OS_ERR_FATAL_RETURN              = 15001u,
N
N    OS_ERR_FLAG_GRP_DEPLETED         = 15101u,
N    OS_ERR_FLAG_NOT_RDY              = 15102u,
N    OS_ERR_FLAG_PEND_OPT             = 15103u,
N    OS_ERR_FLUSH_ISR                 = 15104u,
N
N    OS_ERR_G                         = 16000u,
N
N    OS_ERR_H                         = 17000u,
N
N    OS_ERR_I                         = 18000u,
N    OS_ERR_ILLEGAL_CREATE_RUN_TIME   = 18001u,
N    OS_ERR_INT_Q                     = 18002u,
N    OS_ERR_INT_Q_FULL                = 18003u,
N    OS_ERR_INT_Q_SIZE                = 18004u,
N    OS_ERR_INT_Q_STK_INVALID         = 18005u,
N    OS_ERR_INT_Q_STK_SIZE_INVALID    = 18006u,
N    OS_ERR_ILLEGAL_DEL_RUN_TIME      = 18007u,
N
N    OS_ERR_J                         = 19000u,
N
N    OS_ERR_K                         = 20000u,
N
N    OS_ERR_L                         = 21000u,
N    OS_ERR_LOCK_NESTING_OVF          = 21001u,
N
N    OS_ERR_M                         = 22000u,
N
N    OS_ERR_MEM_CREATE_ISR            = 22201u,
N    OS_ERR_MEM_FULL                  = 22202u,
N    OS_ERR_MEM_INVALID_P_ADDR        = 22203u,
N    OS_ERR_MEM_INVALID_BLKS          = 22204u,
N    OS_ERR_MEM_INVALID_PART          = 22205u,
N    OS_ERR_MEM_INVALID_P_BLK         = 22206u,
N    OS_ERR_MEM_INVALID_P_MEM         = 22207u,
N    OS_ERR_MEM_INVALID_P_DATA        = 22208u,
N    OS_ERR_MEM_INVALID_SIZE          = 22209u,
N    OS_ERR_MEM_NO_FREE_BLKS          = 22210u,
N
N    OS_ERR_MSG_POOL_EMPTY            = 22301u,
N    OS_ERR_MSG_POOL_NULL_PTR         = 22302u,
N
N    OS_ERR_MUTEX_NOT_OWNER           = 22401u,
N    OS_ERR_MUTEX_OWNER               = 22402u,
N    OS_ERR_MUTEX_NESTING             = 22403u,
N    OS_ERR_MUTEX_OVF                 = 22404u,
N
N    OS_ERR_N                         = 23000u,
N    OS_ERR_NAME                      = 23001u,
N    OS_ERR_NO_MORE_ID_AVAIL          = 23002u,
N
N    OS_ERR_O                         = 24000u,
N    OS_ERR_OBJ_CREATED               = 24001u,
N    OS_ERR_OBJ_DEL                   = 24002u,
N    OS_ERR_OBJ_PTR_NULL              = 24003u,
N    OS_ERR_OBJ_TYPE                  = 24004u,
N
N    OS_ERR_OPT_INVALID               = 24101u,
N
N    OS_ERR_OS_NOT_RUNNING            = 24201u,
N    OS_ERR_OS_RUNNING                = 24202u,
N    OS_ERR_OS_NOT_INIT               = 24203u,
N    OS_ERR_OS_NO_APP_TASK            = 24204u,
N
N    OS_ERR_P                         = 25000u,
N    OS_ERR_PEND_ABORT                = 25001u,
N    OS_ERR_PEND_ABORT_ISR            = 25002u,
N    OS_ERR_PEND_ABORT_NONE           = 25003u,
N    OS_ERR_PEND_ABORT_SELF           = 25004u,
N    OS_ERR_PEND_DEL                  = 25005u,
N    OS_ERR_PEND_ISR                  = 25006u,
N    OS_ERR_PEND_LOCKED               = 25007u,
N    OS_ERR_PEND_WOULD_BLOCK          = 25008u,
N
N    OS_ERR_POST_NULL_PTR             = 25101u,
N    OS_ERR_POST_ISR                  = 25102u,
N
N    OS_ERR_PRIO_EXIST                = 25201u,
N    OS_ERR_PRIO                      = 25202u,
N    OS_ERR_PRIO_INVALID              = 25203u,
N
N    OS_ERR_PTR_INVALID               = 25301u,
N
N    OS_ERR_Q                         = 26000u,
N    OS_ERR_Q_FULL                    = 26001u,
N    OS_ERR_Q_EMPTY                   = 26002u,
N    OS_ERR_Q_MAX                     = 26003u,
N    OS_ERR_Q_SIZE                    = 26004u,
N
N    OS_ERR_R                         = 27000u,
N    OS_ERR_REG_ID_INVALID            = 27001u,
N    OS_ERR_ROUND_ROBIN_1             = 27002u,
N    OS_ERR_ROUND_ROBIN_DISABLED      = 27003u,
N
N    OS_ERR_S                         = 28000u,
N    OS_ERR_SCHED_INVALID_TIME_SLICE  = 28001u,
N    OS_ERR_SCHED_LOCK_ISR            = 28002u,
N    OS_ERR_SCHED_LOCKED              = 28003u,
N    OS_ERR_SCHED_NOT_LOCKED          = 28004u,
N    OS_ERR_SCHED_UNLOCK_ISR          = 28005u,
N
N    OS_ERR_SEM_OVF                   = 28101u,
N    OS_ERR_SET_ISR                   = 28102u,
N
N    OS_ERR_STAT_RESET_ISR            = 28201u,
N    OS_ERR_STAT_PRIO_INVALID         = 28202u,
N    OS_ERR_STAT_STK_INVALID          = 28203u,
N    OS_ERR_STAT_STK_SIZE_INVALID     = 28204u,
N    OS_ERR_STATE_INVALID             = 28205u,
N    OS_ERR_STATUS_INVALID            = 28206u,
N    OS_ERR_STK_INVALID               = 28207u,
N    OS_ERR_STK_SIZE_INVALID          = 28208u,
N    OS_ERR_STK_LIMIT_INVALID         = 28209u,
N
N    OS_ERR_T                         = 29000u,
N    OS_ERR_TASK_CHANGE_PRIO_ISR      = 29001u,
N    OS_ERR_TASK_CREATE_ISR           = 29002u,
N    OS_ERR_TASK_DEL                  = 29003u,
N    OS_ERR_TASK_DEL_IDLE             = 29004u,
N    OS_ERR_TASK_DEL_INVALID          = 29005u,
N    OS_ERR_TASK_DEL_ISR              = 29006u,
N    OS_ERR_TASK_INVALID              = 29007u,
N    OS_ERR_TASK_NO_MORE_TCB          = 29008u,
N    OS_ERR_TASK_NOT_DLY              = 29009u,
N    OS_ERR_TASK_NOT_EXIST            = 29010u,
N    OS_ERR_TASK_NOT_SUSPENDED        = 29011u,
N    OS_ERR_TASK_OPT                  = 29012u,
N    OS_ERR_TASK_RESUME_ISR           = 29013u,
N    OS_ERR_TASK_RESUME_PRIO          = 29014u,
N    OS_ERR_TASK_RESUME_SELF          = 29015u,
N    OS_ERR_TASK_RUNNING              = 29016u,
N    OS_ERR_TASK_STK_CHK_ISR          = 29017u,
N    OS_ERR_TASK_SUSPENDED            = 29018u,
N    OS_ERR_TASK_SUSPEND_IDLE         = 29019u,
N    OS_ERR_TASK_SUSPEND_INT_HANDLER  = 29020u,
N    OS_ERR_TASK_SUSPEND_ISR          = 29021u,
N    OS_ERR_TASK_SUSPEND_PRIO         = 29022u,
N    OS_ERR_TASK_WAITING              = 29023u,
N    OS_ERR_TASK_SUSPEND_CTR_OVF      = 29024u,
N
N    OS_ERR_TCB_INVALID               = 29101u,
N
N    OS_ERR_TLS_ID_INVALID            = 29120u,
N    OS_ERR_TLS_ISR                   = 29121u,
N    OS_ERR_TLS_NO_MORE_AVAIL         = 29122u,
N    OS_ERR_TLS_NOT_EN                = 29123u,
N    OS_ERR_TLS_DESTRUCT_ASSIGNED     = 29124u,
N
N    OS_ERR_TICK_PRIO_INVALID         = 29201u,
N    OS_ERR_TICK_STK_INVALID          = 29202u,
N    OS_ERR_TICK_STK_SIZE_INVALID     = 29203u,
N    OS_ERR_TICK_WHEEL_SIZE           = 29204u,
N
N    OS_ERR_TIME_DLY_ISR              = 29301u,
N    OS_ERR_TIME_DLY_RESUME_ISR       = 29302u,
N    OS_ERR_TIME_GET_ISR              = 29303u,
N    OS_ERR_TIME_INVALID_HOURS        = 29304u,
N    OS_ERR_TIME_INVALID_MINUTES      = 29305u,
N    OS_ERR_TIME_INVALID_SECONDS      = 29306u,
N    OS_ERR_TIME_INVALID_MILLISECONDS = 29307u,
N    OS_ERR_TIME_NOT_DLY              = 29308u,
N    OS_ERR_TIME_SET_ISR              = 29309u,
N    OS_ERR_TIME_ZERO_DLY             = 29310u,
N
N    OS_ERR_TIMEOUT                   = 29401u,
N
N    OS_ERR_TMR_INACTIVE              = 29501u,
N    OS_ERR_TMR_INVALID_DEST          = 29502u,
N    OS_ERR_TMR_INVALID_DLY           = 29503u,
N    OS_ERR_TMR_INVALID_PERIOD        = 29504u,
N    OS_ERR_TMR_INVALID_STATE         = 29505u,
N    OS_ERR_TMR_INVALID               = 29506u,
N    OS_ERR_TMR_ISR                   = 29507u,
N    OS_ERR_TMR_NO_CALLBACK           = 29508u,
N    OS_ERR_TMR_NON_AVAIL             = 29509u,
N    OS_ERR_TMR_PRIO_INVALID          = 29510u,
N    OS_ERR_TMR_STK_INVALID           = 29511u,
N    OS_ERR_TMR_STK_SIZE_INVALID      = 29512u,
N    OS_ERR_TMR_STOPPED               = 29513u,
N    OS_ERR_TMR_INVALID_CALLBACK      = 29514u,
N
N    OS_ERR_U                         = 30000u,
N
N    OS_ERR_V                         = 31000u,
N
N    OS_ERR_W                         = 32000u,
N
N    OS_ERR_X                         = 33000u,
N
N    OS_ERR_Y                         = 34000u,
N    OS_ERR_YIELD_ISR                 = 34001u,
N
N    OS_ERR_Z                         = 35000u
N} OS_ERR;
N
N
N/*
N************************************************************************************************************************
N************************************************************************************************************************
N*                                                  D A T A   T Y P E S
N************************************************************************************************************************
N************************************************************************************************************************
N*/
N
Ntypedef  struct  os_flag_grp         OS_FLAG_GRP;
N
Ntypedef  struct  os_mem              OS_MEM;
N
Ntypedef  struct  os_msg              OS_MSG;
Ntypedef  struct  os_msg_pool         OS_MSG_POOL;
Ntypedef  struct  os_msg_q            OS_MSG_Q;
N
Ntypedef  struct  os_mutex            OS_MUTEX;
N
Ntypedef  struct  os_int_q            OS_INT_Q;
N
Ntypedef  struct  os_q                OS_Q;
N
Ntypedef  struct  os_mon              OS_MON;
Ntypedef  struct  os_mon_data         OS_MON_DATA;
Ntypedef  struct  os_mon_ctx          OS_MON_CTX;
N
Ntypedef  struct  os_sem              OS_SEM;
N
Ntypedef  void                      (*OS_TASK_PTR)(void *p_arg);
N
Ntypedef  OS_MON_RES                (*OS_MON_ON_ENTER_PTR)(OS_MON *p_mon, void *p_data);
Ntypedef  OS_MON_RES                (*OS_MON_ON_EVAL_PTR)(OS_MON *p_mon, void *p_eval_data, void *p_scan_data);
N
Ntypedef  struct  os_tcb              OS_TCB;
N
N#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
X#if 1L && (0u > 0u)
Stypedef  void                       *OS_TLS;
S
Stypedef  CPU_DATA                    OS_TLS_ID;
S
Stypedef  void                      (*OS_TLS_DESTRUCT_PTR)(OS_TCB    *p_tcb,
S                                                          OS_TLS_ID  id,
S                                                          OS_TLS     value);
N#endif
N
Ntypedef  struct  os_rdy_list         OS_RDY_LIST;
N
Ntypedef  struct  os_tick_list        OS_TICK_LIST;
N
Ntypedef  void                      (*OS_TMR_CALLBACK_PTR)(void *p_tmr, void *p_arg);
Ntypedef  struct  os_tmr              OS_TMR;
N
Ntypedef  struct  os_pend_data        OS_PEND_DATA;
Ntypedef  struct  os_pend_list        OS_PEND_LIST;
Ntypedef  struct  os_pend_obj         OS_PEND_OBJ;
N
N#if (OS_CFG_APP_HOOKS_EN == DEF_ENABLED)
X#if (1u == 1u)
Ntypedef  void                      (*OS_APP_HOOK_VOID)(void);
Ntypedef  void                      (*OS_APP_HOOK_TCB)(OS_TCB *p_tcb);
N#endif
N
N
N/*
N************************************************************************************************************************
N************************************************************************************************************************
N*                                          D A T A   S T R U C T U R E S
N************************************************************************************************************************
N************************************************************************************************************************
N*/
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                    ISR POST DATA
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N#if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
X#if (0u == 1u)
Sstruct  os_int_q {
S    OS_OBJ_TYPE          Type;                              /* Type of object placed in the circular list             */
S    OS_INT_Q            *NextPtr;                           /* Pointer to next OS_INT_Q in  circular list             */
S    void                *ObjPtr;                            /* Pointer to object placed in the queue                  */
S    void                *MsgPtr;                            /* Pointer to message if posting to a message queue       */
S    OS_MSG_SIZE          MsgSize;                           /* Message Size       if posting to a message queue       */
S    OS_FLAGS             Flags;                             /* Value of flags if posting to an event flag group       */
S    OS_OPT               Opt;                               /* Post Options                                           */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S    CPU_TS               TS;                                /* Timestamp                                              */
S#endif
S};
N#endif
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                      READY LIST
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Nstruct  os_rdy_list {
N    OS_TCB              *HeadPtr;                           /* Pointer to task that will run at selected priority     */
N    OS_TCB              *TailPtr;                           /* Pointer to last task          at selected priority     */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_OBJ_QTY           NbrEntries;                        /* Number of entries             at selected priority     */
N#endif
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                PEND DATA and PEND LIST
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Nstruct  os_pend_data {
N    OS_PEND_DATA        *PrevPtr;
N    OS_PEND_DATA        *NextPtr;
N    OS_TCB              *TCBPtr;
N    OS_PEND_OBJ         *PendObjPtr;
N    OS_PEND_OBJ         *RdyObjPtr;
N    void                *RdyMsgPtr;
N    OS_MSG_SIZE          RdyMsgSize;
N#if (OS_CFG_TS_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_TS               RdyTS;
N#endif
N};
N
N
Nstruct  os_pend_list {
N    OS_PEND_DATA        *HeadPtr;
N    OS_PEND_DATA        *TailPtr;
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_OBJ_QTY           NbrEntries;
N#endif
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                       PEND OBJ
N*
N* Note(s) : (1) The 'os_pend_obj' structure data type is a template/subset for specific kernel objects' data types:
N*               'os_flag_grp', 'os_mutex', 'os_q', and 'os_sem'.  Each specific kernel object data type MUST define
N*               ALL generic OS pend object parameters, synchronized in both the sequential order & data type of each
N*               parameter.
N*
N*               Thus, ANY modification to the sequential order or data types of OS pend object parameters MUST be
N*               appropriately synchronized between the generic OS pend object data type & ALL specific kernel objects'
N*               data types.
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Nstruct  os_pend_obj {
N#if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u) || (0u == 1u) || (0u == 1u)) ? 1u : 0u) == 1u)
N    OS_OBJ_TYPE          Type;
N#endif
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_CHAR            *NamePtr;
N#endif
N    OS_PEND_LIST         PendList;                          /* List of tasks pending on object                        */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    void                *DbgPrevPtr;
N    void                *DbgNextPtr;
N    CPU_CHAR            *DbgNamePtr;
N#endif
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                     EVENT FLAGS
N*
N* Note(s) : See  PEND OBJ  Note #1'.
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N
Nstruct  os_flag_grp {                                       /* Event Flag Group                                       */
N                                                            /* ------------------ GENERIC  MEMBERS ------------------ */
N#if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u) || (0u == 1u) || (0u == 1u)) ? 1u : 0u) == 1u)
N    OS_OBJ_TYPE          Type;                              /* Should be set to OS_OBJ_TYPE_FLAG                      */
N#endif
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_CHAR            *NamePtr;                           /* Pointer to Event Flag Name (NUL terminated ASCII)      */
N#endif
N    OS_PEND_LIST         PendList;                          /* List of tasks waiting on event flag group              */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_FLAG_GRP         *DbgPrevPtr;
N    OS_FLAG_GRP         *DbgNextPtr;
N    CPU_CHAR            *DbgNamePtr;
N#endif
N                                                            /* ------------------ SPECIFIC MEMBERS ------------------ */
N    OS_FLAGS             Flags;                             /* 8, 16 or 32 bit flags                                  */
N#if (OS_CFG_TS_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_TS               TS;                                /* Timestamp of when last post occurred                   */
N#endif
N#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
X#if (1L && (0u == 1u))
S    CPU_INT32U           FlagID;                            /* Unique ID for third-party debuggers and tracers.       */
N#endif
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                   MEMORY PARTITIONS
N------------------------------------------------------------------------------------------------------------------------
N*/
N
N
Nstruct os_mem {                                             /* MEMORY CONTROL BLOCK                                   */
N#if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u) || (0u == 1u) || (0u == 1u)) ? 1u : 0u) == 1u)
N    OS_OBJ_TYPE          Type;                              /* Should be set to OS_OBJ_TYPE_MEM                       */
N#endif
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_CHAR            *NamePtr;
N#endif
N    void                *AddrPtr;                           /* Pointer to beginning of memory partition               */
N    void                *FreeListPtr;                       /* Pointer to list of free memory blocks                  */
N    OS_MEM_SIZE          BlkSize;                           /* Size (in bytes) of each block of memory                */
N    OS_MEM_QTY           NbrMax;                            /* Total number of blocks in this partition               */
N    OS_MEM_QTY           NbrFree;                           /* Number of memory blocks remaining in this partition    */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_MEM              *DbgPrevPtr;
N    OS_MEM              *DbgNextPtr;
N#endif
N#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
X#if (1L && (0u == 1u))
S    CPU_INT32U           MemID;                             /* Unique ID for third-party debuggers and tracers.       */
N#endif
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                       MESSAGES
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Nstruct  os_msg {                                            /* MESSAGE CONTROL BLOCK                                  */
N    OS_MSG              *NextPtr;                           /* Pointer to next message                                */
N    void                *MsgPtr;                            /* Actual message                                         */
N    OS_MSG_SIZE          MsgSize;                           /* Size of the message (in # bytes)                       */
N#if (OS_CFG_TS_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_TS               MsgTS;                             /* Time stamp of when message was sent                    */
N#endif
N};
N
N
N
N
Nstruct  os_msg_pool {                                       /* OS_MSG POOL                                            */
N    OS_MSG              *NextPtr;                           /* Pointer to next message                                */
N    OS_MSG_QTY           NbrFree;                           /* Number of messages available from this pool            */
N    OS_MSG_QTY           NbrUsed;                           /* Current number of messages used                        */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_MSG_QTY           NbrUsedMax;                        /* Peak number of messages used                           */
N#endif
N};
N
N
N
Nstruct  os_msg_q {                                          /* OS_MSG_Q                                               */
N    OS_MSG              *InPtr;                             /* Pointer to next OS_MSG to be inserted  in   the queue  */
N    OS_MSG              *OutPtr;                            /* Pointer to next OS_MSG to be extracted from the queue  */
N    OS_MSG_QTY           NbrEntriesSize;                    /* Maximum allowable number of entries in the queue       */
N    OS_MSG_QTY           NbrEntries;                        /* Current number of entries in the queue                 */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_MSG_QTY           NbrEntriesMax;                     /* Peak number of entries in the queue                    */
N#endif
N#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
X#if (1L && (0u == 1u))
S    CPU_INT32U           MsgQID;                            /* Unique ID for third-party debuggers and tracers.       */
N#endif
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                              MUTUAL EXCLUSION SEMAPHORES
N*
N* Note(s) : See  PEND OBJ  Note #1'.
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Nstruct  os_mutex {                                          /* Mutual Exclusion Semaphore                             */
N                                                            /* ------------------ GENERIC  MEMBERS ------------------ */
N#if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u) || (0u == 1u) || (0u == 1u)) ? 1u : 0u) == 1u)
N    OS_OBJ_TYPE          Type;                              /* Should be set to OS_OBJ_TYPE_MUTEX                     */
N#endif
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_CHAR            *NamePtr;                           /* Pointer to Mutex Name (NUL terminated ASCII)           */
N#endif
N    OS_PEND_LIST         PendList;                          /* List of tasks waiting on mutex                         */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_MUTEX            *DbgPrevPtr;
N    OS_MUTEX            *DbgNextPtr;
N    CPU_CHAR            *DbgNamePtr;
N#endif
N                                                            /* ------------------ SPECIFIC MEMBERS ------------------ */
N    OS_MUTEX            *MutexGrpNextPtr;
N    OS_TCB              *OwnerTCBPtr;
N    OS_NESTING_CTR       OwnerNestingCtr;                   /* Mutex is available when the counter is 0               */
N#if (OS_CFG_TS_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_TS               TS;
N#endif
N#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
X#if (1L && (0u == 1u))
S    CPU_INT08U           MutexID;                           /* Unique ID for third-party debuggers and tracers.       */
N#endif
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                    MESSAGE QUEUES
N*
N* Note(s) : See  PEND OBJ  Note #1'.
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Nstruct  os_q {                                              /* Message Queue                                          */
N                                                            /* ------------------ GENERIC  MEMBERS ------------------ */
N#if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u) || (0u == 1u) || (0u == 1u)) ? 1u : 0u) == 1u)
N    OS_OBJ_TYPE          Type;                              /* Should be set to OS_OBJ_TYPE_Q                         */
N#endif
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_CHAR            *NamePtr;                           /* Pointer to Message Queue Name (NUL terminated ASCII)   */
N#endif
N    OS_PEND_LIST         PendList;                          /* List of tasks waiting on message queue                 */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_Q                *DbgPrevPtr;
N    OS_Q                *DbgNextPtr;
N    CPU_CHAR            *DbgNamePtr;
N#endif
N                                                            /* ------------------ SPECIFIC MEMBERS ------------------ */
N    OS_MSG_Q             MsgQ;                              /* List of messages                                       */
N#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
X#if (1L && (0u == 1u))
S    CPU_INT08U           MsgQID;                            /* Unique ID for third-party debuggers and tracers.       */
N#endif
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                      SEMAPHORES
N*
N* Note(s) : See  PEND OBJ  Note #1'.
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Nstruct  os_sem {                                            /* Semaphore                                              */
N                                                            /* ------------------ GENERIC  MEMBERS ------------------ */
N#if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u) || (0u == 1u) || (0u == 1u)) ? 1u : 0u) == 1u)
N    OS_OBJ_TYPE          Type;                              /* Should be set to OS_OBJ_TYPE_SEM                       */
N#endif
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_CHAR            *NamePtr;                           /* Pointer to Semaphore Name (NUL terminated ASCII)       */
N#endif
N    OS_PEND_LIST         PendList;                          /* List of tasks waiting on semaphore                     */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_SEM              *DbgPrevPtr;
N    OS_SEM              *DbgNextPtr;
N    CPU_CHAR            *DbgNamePtr;
N#endif
N                                                            /* ------------------ SPECIFIC MEMBERS ------------------ */
N    OS_SEM_CTR           Ctr;
N#if (OS_CFG_TS_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_TS               TS;
N#endif
N#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
X#if (1L && (0u == 1u))
S    CPU_INT08U           SemID;                             /* Unique ID for third-party debuggers and tracers.       */
N#endif
N};
N
N
N
Nstruct  os_mon {                                            /* Monitor                                                */
N                                                            /* ------------------ GENERIC  MEMBERS ------------------ */
N#if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u) || (0u == 1u) || (0u == 1u)) ? 1u : 0u) == 1u)
N    OS_OBJ_TYPE          Type;                              /* Should be set to OS_OBJ_TYPE_MON                       */
N#endif
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_CHAR            *NamePtr;                           /* Pointer to Semaphore Name (NUL terminated ASCII)       */
N#endif
N    OS_PEND_LIST         PendList;                          /* List of tasks waiting on semaphore                     */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_MON              *DbgPrevPtr;
N    OS_MON              *DbgNextPtr;
N    CPU_CHAR            *DbgNamePtr;
N#endif
N                                                            /* ------------------ SPECIFIC MEMBERS ------------------ */
N    void                *MonDataPtr;
N};
N
Nstruct  os_mon_data {
N    void                 *p_eval_data;
N    OS_MON_ON_EVAL_PTR    p_on_eval;
N};
N
Nstruct  os_mon_ctx {
N    void * a;
N    void * b;
N    void * c;
N    void * d;
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                  TASK CONTROL BLOCK
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Nstruct os_tcb {
N    CPU_STK             *StkPtr;                            /* Pointer to current top of stack                        */
N
N    void                *ExtPtr;                            /* Pointer to user definable data for TCB extension       */
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_CHAR            *NamePtr;                           /* Pointer to task name                                   */
N#endif
N
N#if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
X#if ((1u == 1u) || (1u == 1u))
N    CPU_STK             *StkLimitPtr;                       /* Pointer used to set stack 'watermark' limit            */
N#endif
N
N    OS_TCB              *NextPtr;                           /* Pointer to next     TCB in the TCB list                */
N    OS_TCB              *PrevPtr;                           /* Pointer to previous TCB in the TCB list                */
N
N#if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_TCB              *TickNextPtr;
N    OS_TCB              *TickPrevPtr;
N
N    OS_TICK_LIST        *TickListPtr;                       /* Pointer to tick list if task is in a tick list         */
N#endif
N
N#if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED) || (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED))
X#if ((1u == 1u) || (1u == 1u) || (0u == 1u))
N    CPU_STK             *StkBasePtr;                        /* Pointer to base address of stack                       */
N#endif
N
N#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
X#if 1L && (0u > 0u)
S    OS_TLS               TLS_Tbl[OS_CFG_TLS_TBL_SIZE];
N#endif
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_TASK_PTR          TaskEntryAddr;                     /* Pointer to task entry point address                    */
N    void                *TaskEntryArg;                      /* Argument passed to task when it was created            */
N#endif
N
N    OS_PEND_DATA        *PendDataTblPtr;                    /* Pointer to list containing objects pended on           */
N    OS_STATE             PendOn;                            /* Indicates what task is pending on                      */
N    OS_STATUS            PendStatus;                        /* Pend status                                            */
N
N    OS_STATE             TaskState;                         /* See OS_TASK_STATE_xxx                                  */
N    OS_PRIO              Prio;                              /* Task priority (0 == highest)                           */
N#if (OS_CFG_MUTEX_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_PRIO              BasePrio;                          /* Base priority (Not inherited)                          */
N    OS_MUTEX            *MutexGrpHeadPtr;                   /* Owned mutex group head pointer                         */
N#endif
N
N#if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED) || (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED))
X#if ((1u == 1u) || (1u == 1u) || (0u == 1u))
N    CPU_STK_SIZE         StkSize;                           /* Size of task stack (in number of stack elements)       */
N#endif
N    OS_OPT               Opt;                               /* Task options as passed by OSTaskCreate()               */
N
N#if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
X#if (0u == 1u)
S    OS_OBJ_QTY           PendDataTblEntries;                /* Size of array of objects to pend on                    */
N#endif
N#if (OS_CFG_TS_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_TS               TS;                                /* Timestamp                                              */
N#endif
N#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
X#if (1L && (0u == 1u))
S    CPU_INT08U           SemID;                             /* Unique ID for third-party debuggers and tracers.       */
N#endif
N    OS_SEM_CTR           SemCtr;                            /* Task specific semaphore counter                        */
N
N                                                            /* DELAY / TIMEOUT                                        */
N#if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_TICK              TickRemain;                        /* Number of ticks remaining (updated by OS_TickTask()    */
N    OS_TICK              TickCtrPrev;                       /* Used by OSTimeDlyXX() in PERIODIC mode                 */
N#endif
N
N#if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
X#if (0u == 1u)
S    OS_TICK              TimeQuanta;
S    OS_TICK              TimeQuantaCtr;
N#endif
N
N#if (OS_MSG_EN == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u)) ? 1u : 0u) == 1u)
N    void                *MsgPtr;                            /* Message received                                       */
N    OS_MSG_SIZE          MsgSize;
N#endif
N
N#if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_MSG_Q             MsgQ;                              /* Message queue associated with task                     */
N#if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_TS               MsgQPendTime;                      /* Time it took for signal to be received                 */
N    CPU_TS               MsgQPendTimeMax;                   /* Max amount of time it took for signal to be received   */
N#endif
N#endif
N
N#if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
X#if (1u > 0u)
N    OS_REG               RegTbl[OS_CFG_TASK_REG_TBL_SIZE];  /* Task specific registers                                */
X    OS_REG               RegTbl[1u];   
N#endif
N
N#if (OS_CFG_FLAG_EN == DEF_ENABLED)
X#if (0u == 1u)
S    OS_FLAGS             FlagsPend;                         /* Event flag(s) to wait on                               */
S    OS_FLAGS             FlagsRdy;                          /* Event flags that made task ready to run                */
S    OS_OPT               FlagsOpt;                          /* Options (See OS_OPT_FLAG_xxx)                          */
N#endif
N
N#if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_NESTING_CTR       SuspendCtr;                        /* Nesting counter for OSTaskSuspend()                    */
N#endif
N
N#if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_CPU_USAGE         CPUUsage;                          /* CPU Usage of task (0.00-100.00%)                       */
N    OS_CPU_USAGE         CPUUsageMax;                       /* CPU Usage of task (0.00-100.00%) - Peak                */
N    OS_CTX_SW_CTR        CtxSwCtr;                          /* Number of time the task was switched in                */
N    CPU_TS               CyclesDelta;                       /* value of OS_TS_GET() - .CyclesStart                    */
N    CPU_TS               CyclesStart;                       /* Snapshot of cycle counter at start of task resumption  */
N    OS_CYCLES            CyclesTotal;                       /* Total number of # of cycles the task has been running  */
N    OS_CYCLES            CyclesTotalPrev;                   /* Snapshot of previous # of cycles                       */
N
N    CPU_TS               SemPendTime;                       /* Time it took for signal to be received                 */
N    CPU_TS               SemPendTimeMax;                    /* Max amount of time it took for signal to be received   */
N#endif
N
N#if (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_STK_SIZE         StkUsed;                           /* Number of stack elements used from the stack           */
N    CPU_STK_SIZE         StkFree;                           /* Number of stack elements free on   the stack           */
N#endif
N
N#ifdef CPU_CFG_INT_DIS_MEAS_EN
N    CPU_TS               IntDisTimeMax;                     /* Maximum interrupt disable time                         */
N#endif
N#if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
X#if (0u == 1u)
S    CPU_TS               SchedLockTimeMax;                  /* Maximum scheduler lock time                            */
N#endif
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_TCB              *DbgPrevPtr;
N    OS_TCB              *DbgNextPtr;
N    CPU_CHAR            *DbgNamePtr;
N#endif
N#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
X#if (1L && (0u == 1u))
S    CPU_INT08U           TaskID;                            /* Unique ID for third-party debuggers and tracers.       */
N#endif
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                    TICK DATA TYPE
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Nstruct  os_tick_list {
N    OS_TCB              *TCB_Ptr;                           /* Pointer to list of tasks in tick list                 */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_OBJ_QTY           NbrEntries;                        /* Current number of entries in the tick list            */
N    OS_OBJ_QTY           NbrUpdated;                        /* Number of entries updated                             */
N#endif
N};
N
N
N/*
N------------------------------------------------------------------------------------------------------------------------
N*                                                   TIMER DATA TYPES
N------------------------------------------------------------------------------------------------------------------------
N*/
N
Nstruct  os_tmr {
N#if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u) || (0u == 1u) || (0u == 1u)) ? 1u : 0u) == 1u)
N    OS_OBJ_TYPE          Type;
N#endif
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    CPU_CHAR            *NamePtr;                           /* Name to give the timer                                 */
N#endif
N    OS_TMR_CALLBACK_PTR  CallbackPtr;                       /* Function to call when timer expires                    */
N    void                *CallbackPtrArg;                    /* Argument to pass to function when timer expires        */
N    OS_TMR              *NextPtr;                           /* Double link list pointers                              */
N    OS_TMR              *PrevPtr;
N    OS_TICK              Remain;                            /* Amount of time remaining before timer expires          */
N    OS_TICK              Dly;                               /* Delay before start of repeat                           */
N    OS_TICK              Period;                            /* Period to repeat timer                                 */
N    OS_OPT               Opt;                               /* Options (see OS_OPT_TMR_xxx)                           */
N    OS_STATE             State;
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
N    OS_TMR              *DbgPrevPtr;
N    OS_TMR              *DbgNextPtr;
N#endif
N};
N
N
N/*
N************************************************************************************************************************
N************************************************************************************************************************
N*                                           G L O B A L   V A R I A B L E S
N************************************************************************************************************************
N************************************************************************************************************************
N*/
N                                                                        /* APPLICATION HOOKS ------------------------ */
N#if (OS_CFG_APP_HOOKS_EN == DEF_ENABLED)
X#if (1u == 1u)
N#if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_EXT           OS_APP_HOOK_TCB            OS_AppRedzoneHitHookPtr;
N#endif
NOS_EXT           OS_APP_HOOK_TCB            OS_AppTaskCreateHookPtr;
Xextern           OS_APP_HOOK_TCB            OS_AppTaskCreateHookPtr;
NOS_EXT           OS_APP_HOOK_TCB            OS_AppTaskDelHookPtr;
Xextern           OS_APP_HOOK_TCB            OS_AppTaskDelHookPtr;
NOS_EXT           OS_APP_HOOK_TCB            OS_AppTaskReturnHookPtr;
Xextern           OS_APP_HOOK_TCB            OS_AppTaskReturnHookPtr;
N
NOS_EXT           OS_APP_HOOK_VOID           OS_AppIdleTaskHookPtr;
Xextern           OS_APP_HOOK_VOID           OS_AppIdleTaskHookPtr;
NOS_EXT           OS_APP_HOOK_VOID           OS_AppStatTaskHookPtr;
Xextern           OS_APP_HOOK_VOID           OS_AppStatTaskHookPtr;
NOS_EXT           OS_APP_HOOK_VOID           OS_AppTaskSwHookPtr;
Xextern           OS_APP_HOOK_VOID           OS_AppTaskSwHookPtr;
NOS_EXT           OS_APP_HOOK_VOID           OS_AppTimeTickHookPtr;
Xextern           OS_APP_HOOK_VOID           OS_AppTimeTickHookPtr;
N#endif
N
N                                                                        /* IDLE TASK -------------------------------- */
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            OS_IDLE_CTR               OSIdleTaskCtr;
Xextern            OS_IDLE_CTR               OSIdleTaskCtr;
N#endif
N#if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            OS_TCB                    OSIdleTaskTCB;
Xextern            OS_TCB                    OSIdleTaskTCB;
N#endif
N
N                                                                        /* MISCELLANEOUS ---------------------------- */
NOS_EXT            OS_NESTING_CTR            OSIntNestingCtr;            /* Interrupt nesting level                    */
Xextern            OS_NESTING_CTR            OSIntNestingCtr;             
N#ifdef CPU_CFG_INT_DIS_MEAS_EN
N#if (OS_CFG_TS_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            CPU_TS                    OSIntDisTimeMax;            /* Overall interrupt disable time             */
Xextern            CPU_TS                    OSIntDisTimeMax;             
N#endif
N#endif
N
NOS_EXT            OS_STATE                  OSRunning;                  /* Flag indicating the kernel is running      */
Xextern            OS_STATE                  OSRunning;                   
NOS_EXT            OS_STATE                  OSInitialized;              /* Flag indicating the kernel is initialized  */
Xextern            OS_STATE                  OSInitialized;               
N
N
N                                                                        /* ISR HANDLER TASK ------------------------- */
N#if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_EXT            OS_INT_Q                 *OSIntQInPtr;
SOS_EXT            OS_INT_Q                 *OSIntQOutPtr;
SOS_EXT            OS_OBJ_QTY                OSIntQNbrEntries;
SOS_EXT            OS_OBJ_QTY                OSIntQNbrEntriesMax;
SOS_EXT            OS_OBJ_QTY                OSIntQOvfCtr;
SOS_EXT            OS_TCB                    OSIntQTaskTCB;
S#if (OS_CFG_TS_EN == DEF_ENABLED)
SOS_EXT            CPU_TS                    OSIntQTaskTimeMax;
S#endif
N#endif
N
N                                                                        /* FLAGS ------------------------------------ */
N#if (OS_CFG_FLAG_EN == DEF_ENABLED)
X#if (0u == 1u)
S#if (OS_CFG_DBG_EN  == DEF_ENABLED)
SOS_EXT            OS_FLAG_GRP              *OSFlagDbgListPtr;
SOS_EXT            OS_OBJ_QTY                OSFlagQty;
S#endif
N#endif
N
N                                                                        /* MEMORY MANAGEMENT ------------------------ */
N#if (OS_CFG_MEM_EN == DEF_ENABLED)
X#if (0u == 1u)
S#if (OS_CFG_DBG_EN == DEF_ENABLED)
SOS_EXT            OS_MEM                   *OSMemDbgListPtr;
SOS_EXT            OS_OBJ_QTY                OSMemQty;                   /* Number of memory partitions created        */
S#endif
N#endif
N
N                                                                        /* OS_MSG POOL ------------------------------ */
N#if (OS_MSG_EN == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u)) ? 1u : 0u) == 1u)
NOS_EXT            OS_MSG_POOL               OSMsgPool;                  /* Pool of OS_MSG                             */
Xextern            OS_MSG_POOL               OSMsgPool;                   
N#endif
N
N                                                                        /* MUTEX MANAGEMENT ------------------------- */
N#if (OS_CFG_MUTEX_EN == DEF_ENABLED)
X#if (1u == 1u)
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            OS_MUTEX                 *OSMutexDbgListPtr;
Xextern            OS_MUTEX                 *OSMutexDbgListPtr;
NOS_EXT            OS_OBJ_QTY                OSMutexQty;                 /* Number of mutexes created                  */
Xextern            OS_OBJ_QTY                OSMutexQty;                  
N#endif
N#endif
N
N                                                                        /* PRIORITIES ------------------------------- */
NOS_EXT            OS_PRIO                   OSPrioCur;                  /* Priority of current task                   */
Xextern            OS_PRIO                   OSPrioCur;                   
NOS_EXT            OS_PRIO                   OSPrioHighRdy;              /* Priority of highest priority task          */
Xextern            OS_PRIO                   OSPrioHighRdy;               
N#if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_EXT            OS_PRIO                   OSPrioSaved;                /* Saved priority level when Post Deferred    */
N#endif
Nextern            CPU_DATA                  OSPrioTbl[OS_PRIO_TBL_SIZE];
Xextern            CPU_DATA                  OSPrioTbl[((32u - 1u) / ((4u * 8u)) + 1u)];
N
N                                                                        /* QUEUES ----------------------------------- */
N#if (OS_CFG_Q_EN == DEF_ENABLED)
X#if (1u == 1u)
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            OS_Q                     *OSQDbgListPtr;
Xextern            OS_Q                     *OSQDbgListPtr;
NOS_EXT            OS_OBJ_QTY                OSQQty;                     /* Number of message queues created           */
Xextern            OS_OBJ_QTY                OSQQty;                      
N#endif
N#endif
N
N
N
N                                                                        /* READY LIST ------------------------------- */
NOS_EXT            OS_RDY_LIST               OSRdyList[OS_CFG_PRIO_MAX]; /* Table of tasks ready to run                */
Xextern            OS_RDY_LIST               OSRdyList[32u];  
N
N
N#ifdef OS_SAFETY_CRITICAL_IEC61508
SOS_EXT            CPU_BOOLEAN               OSSafetyCriticalStartFlag;  /* Flag indicating that all init. done        */
N#endif
N                                                                        /* SCHEDULER -------------------------------- */
N#if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_EXT            CPU_TS_TMR                OSSchedLockTimeBegin;       /* Scheduler lock time measurement            */
SOS_EXT            CPU_TS_TMR                OSSchedLockTimeMax;
SOS_EXT            CPU_TS_TMR                OSSchedLockTimeMaxCur;
N#endif
N
NOS_EXT            OS_NESTING_CTR            OSSchedLockNestingCtr;      /* Lock nesting level                         */
Xextern            OS_NESTING_CTR            OSSchedLockNestingCtr;       
N#if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_EXT            OS_TICK                   OSSchedRoundRobinDfltTimeQuanta;
SOS_EXT            CPU_BOOLEAN               OSSchedRoundRobinEn;        /* Enable/Disable round-robin scheduling      */
N#endif
N                                                                        /* SEMAPHORES ------------------------------- */
N#if (OS_CFG_SEM_EN == DEF_ENABLED)
X#if (1u == 1u)
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            OS_SEM                   *OSSemDbgListPtr;
Xextern            OS_SEM                   *OSSemDbgListPtr;
NOS_EXT            OS_OBJ_QTY                OSSemQty;                   /* Number of semaphores created               */
Xextern            OS_OBJ_QTY                OSSemQty;                    
N#endif
N#endif
N
N                                                                        /* MONITORS --------------------------------- */
N#if (OS_CFG_MON_EN == DEF_ENABLED)
X#if (1u == 1u)
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            OS_MON                   *OSMonDbgListPtr;
Xextern            OS_MON                   *OSMonDbgListPtr;
NOS_EXT            OS_OBJ_QTY                OSMonQty;                   /* Number of monitors created                 */
Xextern            OS_OBJ_QTY                OSMonQty;                    
N#endif
N#endif
N
N                                                                        /* STATISTICS ------------------------------- */
N#if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_EXT            CPU_BOOLEAN               OSStatResetFlag;            /* Force the reset of the computed statistics */
SOS_EXT            OS_CPU_USAGE              OSStatTaskCPUUsage;         /* CPU Usage in %                             */
SOS_EXT            OS_CPU_USAGE              OSStatTaskCPUUsageMax;      /* CPU Usage in % (Peak)                      */
SOS_EXT            OS_TICK                   OSStatTaskCtr;
SOS_EXT            OS_TICK                   OSStatTaskCtrMax;
SOS_EXT            OS_TICK                   OSStatTaskCtrRun;
SOS_EXT            CPU_BOOLEAN               OSStatTaskRdy;
SOS_EXT            OS_TCB                    OSStatTaskTCB;
S#if (OS_CFG_TS_EN == DEF_ENABLED)
SOS_EXT            CPU_TS                    OSStatTaskTimeMax;
S#endif
N#endif
N
N                                                                        /* TASKS ------------------------------------ */
N#if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) || (OS_CFG_DBG_EN == DEF_ENABLED))
X#if ((1u == 1u) || (1u == 1u))
NOS_EXT            OS_CTX_SW_CTR             OSTaskCtxSwCtr;             /* Number of context switches                 */
Xextern            OS_CTX_SW_CTR             OSTaskCtxSwCtr;              
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            OS_TCB                   *OSTaskDbgListPtr;
Xextern            OS_TCB                   *OSTaskDbgListPtr;
N#endif
N#endif
N
NOS_EXT            OS_OBJ_QTY                OSTaskQty;                  /* Number of tasks created                    */
Xextern            OS_OBJ_QTY                OSTaskQty;                   
N
N#if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
X#if (1u > 0u)
NOS_EXT            OS_REG_ID                 OSTaskRegNextAvailID;       /* Next available Task Register ID            */
Xextern            OS_REG_ID                 OSTaskRegNextAvailID;        
N#endif
N
N                                                                        /* TICK TASK -------------------------------- */
N#if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            OS_TICK                   OSTickCtr;                  /* Cnts the #ticks since startup or last set  */
Xextern            OS_TICK                   OSTickCtr;                   
N#if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_EXT            OS_TICK                   OSTickCtrStep;              /* Number of ticks to the next tick task call.*/
SOS_EXT            OS_TICK                   OSTickCtrPend;              /* Number of ticks waiting to be processed.   */
N#endif
NOS_EXT            OS_TCB                    OSTickTaskTCB;
Xextern            OS_TCB                    OSTickTaskTCB;
N#if (OS_CFG_TS_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            CPU_TS                    OSTickTaskTimeMax;
Xextern            CPU_TS                    OSTickTaskTimeMax;
N#endif
NOS_EXT            OS_TICK_LIST              OSTickListDly;
Xextern            OS_TICK_LIST              OSTickListDly;
NOS_EXT            OS_TICK_LIST              OSTickListTimeout;
Xextern            OS_TICK_LIST              OSTickListTimeout;
N#endif
N
N
N
N#if (OS_CFG_TMR_EN == DEF_ENABLED)                                      /* TIMERS ----------------------------------- */
X#if (1u == 1u)                                       
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            OS_TMR                   *OSTmrDbgListPtr;
Xextern            OS_TMR                   *OSTmrDbgListPtr;
NOS_EXT            OS_OBJ_QTY                OSTmrListEntries;           /* Doubly-linked list of timers               */
Xextern            OS_OBJ_QTY                OSTmrListEntries;            
N#endif
NOS_EXT            OS_TMR                   *OSTmrListPtr;
Xextern            OS_TMR                   *OSTmrListPtr;
N#if (OS_CFG_MUTEX_EN == DEF_ENABLED)                                    /* Use a Mutex (if available) to protect tmrs */
X#if (1u == 1u)                                     
NOS_EXT            OS_MUTEX                  OSTmrMutex;
Xextern            OS_MUTEX                  OSTmrMutex;
N#endif
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            OS_OBJ_QTY                OSTmrQty;                   /* Number of timers created                   */
Xextern            OS_OBJ_QTY                OSTmrQty;                    
N#endif
NOS_EXT            OS_TCB                    OSTmrTaskTCB;               /* TCB of timer task                          */
Xextern            OS_TCB                    OSTmrTaskTCB;                
N#if (OS_CFG_TS_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_EXT            CPU_TS                    OSTmrTaskTimeMax;
Xextern            CPU_TS                    OSTmrTaskTimeMax;
N#endif
NOS_EXT            OS_TICK                   OSTmrTickCtr;               /* Current time for the timers                */
Xextern            OS_TICK                   OSTmrTickCtr;                
NOS_EXT            OS_CTR                    OSTmrUpdateCnt;             /* Counter for updating timers                */
Xextern            OS_CTR                    OSTmrUpdateCnt;              
NOS_EXT            OS_CTR                    OSTmrUpdateCtr;
Xextern            OS_CTR                    OSTmrUpdateCtr;
N#endif
N
N
N
N
N                                                                        /* TCBs ------------------------------------- */
NOS_EXT            OS_TCB                   *OSTCBCurPtr;                /* Pointer to currently running TCB           */
Xextern            OS_TCB                   *OSTCBCurPtr;                 
NOS_EXT            OS_TCB                   *OSTCBHighRdyPtr;            /* Pointer to highest priority  TCB           */
Xextern            OS_TCB                   *OSTCBHighRdyPtr;             
N
N
N/*
N************************************************************************************************************************
N************************************************************************************************************************
N*                                                   E X T E R N A L S
N************************************************************************************************************************
N************************************************************************************************************************
N*/
N
Nextern  CPU_STK     * const OSCfg_IdleTaskStkBasePtr;
Nextern  CPU_STK_SIZE  const OSCfg_IdleTaskStkLimit;
Nextern  CPU_STK_SIZE  const OSCfg_IdleTaskStkSize;
Nextern  CPU_INT32U    const OSCfg_IdleTaskStkSizeRAM;
N
Nextern  OS_INT_Q    * const OSCfg_IntQBasePtr;
Nextern  OS_OBJ_QTY    const OSCfg_IntQSize;
Nextern  CPU_INT32U    const OSCfg_IntQSizeRAM;
Nextern  CPU_STK     * const OSCfg_IntQTaskStkBasePtr;
Nextern  CPU_STK_SIZE  const OSCfg_IntQTaskStkLimit;
Nextern  CPU_STK_SIZE  const OSCfg_IntQTaskStkSize;
Nextern  CPU_INT32U    const OSCfg_IntQTaskStkSizeRAM;
N
Nextern  CPU_STK     * const OSCfg_ISRStkBasePtr;
Nextern  CPU_STK_SIZE  const OSCfg_ISRStkSize;
Nextern  CPU_INT32U    const OSCfg_ISRStkSizeRAM;
N
Nextern  OS_MSG_SIZE   const OSCfg_MsgPoolSize;
Nextern  CPU_INT32U    const OSCfg_MsgPoolSizeRAM;
Nextern  OS_MSG      * const OSCfg_MsgPoolBasePtr;
N
Nextern  OS_PRIO       const OSCfg_StatTaskPrio;
Nextern  OS_RATE_HZ    const OSCfg_StatTaskRate_Hz;
Nextern  CPU_STK     * const OSCfg_StatTaskStkBasePtr;
Nextern  CPU_STK_SIZE  const OSCfg_StatTaskStkLimit;
Nextern  CPU_STK_SIZE  const OSCfg_StatTaskStkSize;
Nextern  CPU_INT32U    const OSCfg_StatTaskStkSizeRAM;
N
Nextern  CPU_STK_SIZE  const OSCfg_StkSizeMin;
N
Nextern  OS_RATE_HZ    const OSCfg_TickRate_Hz;
Nextern  OS_PRIO       const OSCfg_TickTaskPrio;
Nextern  CPU_STK     * const OSCfg_TickTaskStkBasePtr;
Nextern  CPU_STK_SIZE  const OSCfg_TickTaskStkLimit;
Nextern  CPU_STK_SIZE  const OSCfg_TickTaskStkSize;
Nextern  CPU_INT32U    const OSCfg_TickTaskStkSizeRAM;
N
Nextern  OS_PRIO       const OSCfg_TmrTaskPrio;
Nextern  OS_RATE_HZ    const OSCfg_TmrTaskRate_Hz;
Nextern  CPU_STK     * const OSCfg_TmrTaskStkBasePtr;
Nextern  CPU_STK_SIZE  const OSCfg_TmrTaskStkLimit;
Nextern  CPU_STK_SIZE  const OSCfg_TmrTaskStkSize;
Nextern  CPU_INT32U    const OSCfg_TmrTaskStkSizeRAM;
N
N#if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
X#if (1u == 1u)
Nextern  CPU_STK        OSCfg_IdleTaskStk[];
N#endif
N
N#if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
X#if (0u == 1u)
Sextern  CPU_STK        OSCfg_IntQTaskStk[];
Sextern  OS_INT_Q       OSCfg_IntQ[];
N#endif
N
Nextern  CPU_STK        OSCfg_ISRStk[];
N
N#if (OS_MSG_EN == DEF_ENABLED)
X#if ((((1u == 1u) || (1u == 1u)) ? 1u : 0u) == 1u)
Nextern  OS_MSG         OSCfg_MsgPool[];
N#endif
N
N#if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
X#if (0u == 1u)
Sextern  CPU_STK        OSCfg_StatTaskStk[];
N#endif
N
Nextern  CPU_STK        OSCfg_TickTaskStk[];
N
N#if (OS_CFG_TMR_EN == DEF_ENABLED)
X#if (1u == 1u)
Nextern  CPU_STK        OSCfg_TmrTaskStk[];
N#endif
N
N/*
N************************************************************************************************************************
N************************************************************************************************************************
N*                                        F U N C T I O N   P R O T O T Y P E S
N************************************************************************************************************************
N************************************************************************************************************************
N*/
N
N/* ================================================================================================================== */
N/*                                                    EVENT FLAGS                                                     */
N/* ================================================================================================================== */
N
N#if (OS_CFG_FLAG_EN == DEF_ENABLED)
X#if (0u == 1u)
S
Svoid          OSFlagCreate              (OS_FLAG_GRP           *p_grp,
S                                         CPU_CHAR              *p_name,
S                                         OS_FLAGS               flags,
S                                         OS_ERR                *p_err);
S
S#if (OS_CFG_FLAG_DEL_EN == DEF_ENABLED)
SOS_OBJ_QTY    OSFlagDel                 (OS_FLAG_GRP           *p_grp,
S                                         OS_OPT                 opt,
S                                         OS_ERR                *p_err);
S#endif
S
SOS_FLAGS      OSFlagPend                (OS_FLAG_GRP           *p_grp,
S                                         OS_FLAGS               flags,
S                                         OS_TICK                timeout,
S                                         OS_OPT                 opt,
S                                         CPU_TS                *p_ts,
S                                         OS_ERR                *p_err);
S
S#if (OS_CFG_FLAG_PEND_ABORT_EN == DEF_ENABLED)
SOS_OBJ_QTY    OSFlagPendAbort           (OS_FLAG_GRP           *p_grp,
S                                         OS_OPT                 opt,
S                                         OS_ERR                *p_err);
S#endif
S
SOS_FLAGS      OSFlagPendGetFlagsRdy     (OS_ERR                *p_err);
S
SOS_FLAGS      OSFlagPost                (OS_FLAG_GRP           *p_grp,
S                                         OS_FLAGS               flags,
S                                         OS_OPT                 opt,
S                                         OS_ERR                *p_err);
S
S/* ------------------------------------------------ INTERNAL FUNCTIONS ---------------------------------------------- */
S
Svoid          OS_FlagClr                (OS_FLAG_GRP           *p_grp);
S
Svoid          OS_FlagBlock              (OS_PEND_DATA          *p_pend_data,
S                                         OS_FLAG_GRP           *p_grp,
S                                         OS_FLAGS               flags,
S                                         OS_OPT                 opt,
S                                         OS_TICK                timeout);
S
S#if (OS_CFG_DBG_EN == DEF_ENABLED)
Svoid          OS_FlagDbgListAdd         (OS_FLAG_GRP           *p_grp);
S
Svoid          OS_FlagDbgListRemove      (OS_FLAG_GRP           *p_grp);
S#endif
S
SOS_FLAGS      OS_FlagPost               (OS_FLAG_GRP           *p_grp,
S                                         OS_FLAGS               flags,
S                                         OS_OPT                 opt,
S                                         CPU_TS                 ts,
S                                         OS_ERR                *p_err);
S
Svoid          OS_FlagTaskRdy            (OS_TCB                *p_tcb,
S                                         OS_FLAGS               flags_rdy,
S                                         CPU_TS                 ts);
N#endif
N
N
N/* ================================================================================================================== */
N/*                                          FIXED SIZE MEMORY BLOCK MANAGEMENT                                        */
N/* ================================================================================================================== */
N
N#if (OS_CFG_MEM_EN == DEF_ENABLED)
X#if (0u == 1u)
S
Svoid          OSMemCreate               (OS_MEM                *p_mem,
S                                         CPU_CHAR              *p_name,
S                                         void                  *p_addr,
S                                         OS_MEM_QTY             n_blks,
S                                         OS_MEM_SIZE            blk_size,
S                                         OS_ERR                *p_err);
S
Svoid         *OSMemGet                  (OS_MEM                *p_mem,
S                                         OS_ERR                *p_err);
S
Svoid          OSMemPut                  (OS_MEM                *p_mem,
S                                         void                  *p_blk,
S                                         OS_ERR                *p_err);
S
S/* ------------------------------------------------ INTERNAL FUNCTIONS ---------------------------------------------- */
S
S#if (OS_CFG_DBG_EN == DEF_ENABLED)
Svoid          OS_MemDbgListAdd          (OS_MEM                *p_mem);
S#endif
S
Svoid          OS_MemInit                (OS_ERR                *p_err);
S
N#endif
N
N
N/* ================================================================================================================== */
N/*                                                     MONITORS                                                       */
N/* ================================================================================================================== */
N
N#if (OS_CFG_MON_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OSMonCreate               (OS_MON                *p_mon,
N                                         CPU_CHAR              *p_name,
N                                         void                  *p_mon_data,
N                                         OS_ERR                *p_err);
N
Nvoid          OSMonOp                   (OS_MON                *p_mon,
N                                         OS_TICK                timeout,
N                                         void                  *p_arg,
N                                         OS_MON_ON_ENTER_PTR    p_on_enter,
N                                         OS_MON_ON_EVAL_PTR     p_on_eval,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_MON_DEL_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_OBJ_QTY    OSMonDel                  (OS_MON                *p_mon,
S                                         OS_OPT                 opt,
S                                         OS_ERR                *p_err);
N#endif
N
N/* ------------------------------------------------ INTERNAL FUNCTIONS ---------------------------------------------- */
N
Nvoid          OS_MonClr                 (OS_MON                *p_mon);
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_MonDbgListAdd          (OS_MON                *p_mon);
N
Nvoid          OS_MonDbgListRemove       (OS_MON                *p_mon);
N#endif
N
N#endif
N
N
N/* ================================================================================================================== */
N/*                                             MUTUAL EXCLUSION SEMAPHORES                                            */
N/* ================================================================================================================== */
N
N#if (OS_CFG_MUTEX_EN == DEF_ENABLED)
X#if (1u == 1u)
N
Nvoid          OSMutexCreate             (OS_MUTEX              *p_mutex,
N                                         CPU_CHAR              *p_name,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_MUTEX_DEL_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_OBJ_QTY    OSMutexDel                (OS_MUTEX              *p_mutex,
S                                         OS_OPT                 opt,
S                                         OS_ERR                *p_err);
N#endif
N
Nvoid          OSMutexPend               (OS_MUTEX              *p_mutex,
N                                         OS_TICK                timeout,
N                                         OS_OPT                 opt,
N                                         CPU_TS                *p_ts,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_MUTEX_PEND_ABORT_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_OBJ_QTY    OSMutexPendAbort          (OS_MUTEX              *p_mutex,
S                                         OS_OPT                 opt,
S                                         OS_ERR                *p_err);
N#endif
N
Nvoid          OSMutexPost               (OS_MUTEX              *p_mutex,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N
N
N/* ------------------------------------------------ INTERNAL FUNCTIONS ---------------------------------------------- */
N
Nvoid          OS_MutexClr               (OS_MUTEX              *p_mutex);
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_MutexDbgListAdd        (OS_MUTEX              *p_mutex);
N
Nvoid          OS_MutexDbgListRemove     (OS_MUTEX              *p_mutex);
N#endif
N
Nvoid          OS_MutexGrpAdd            (OS_TCB                *p_tcb,
N                                         OS_MUTEX              *p_mutex);
N
Nvoid          OS_MutexGrpRemove         (OS_TCB                *p_tcb,
N                                         OS_MUTEX              *p_mutex);
N
NOS_PRIO       OS_MutexGrpPrioFindHighest(OS_TCB                *p_tcb);
N
Nvoid          OS_MutexGrpPostAll        (OS_TCB                *p_tcb);
N#endif
N
N
N/* ================================================================================================================== */
N/*                                                    MULTI PEND                                                      */
N/* ================================================================================================================== */
N
N#if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
X#if (0u == 1u)
S
SOS_OBJ_QTY    OSPendMulti               (OS_PEND_DATA          *p_pend_data_tbl,
S                                         OS_OBJ_QTY             tbl_size,
S                                         OS_TICK                timeout,
S                                         OS_OPT                 opt,
S                                         OS_ERR                *p_err);
S
S/* ------------------------------------------------ INTERNAL FUNCTIONS ---------------------------------------------- */
S
SOS_OBJ_QTY    OS_PendMultiGetRdy        (OS_PEND_DATA          *p_pend_data_tbl,
S                                         OS_OBJ_QTY             tbl_size);
S
SCPU_BOOLEAN   OS_PendMultiValidate      (OS_PEND_DATA          *p_pend_data_tbl,
S                                         OS_OBJ_QTY             tbl_size);
S
Svoid          OS_PendMultiWait          (OS_PEND_DATA          *p_pend_data_tbl,
S                                         OS_OBJ_QTY             tbl_size,
S                                         OS_TICK                timeout);
N#endif
N
N
N/* ================================================================================================================== */
N/*                                                   MESSAGE QUEUES                                                   */
N/* ================================================================================================================== */
N
N#if (OS_CFG_Q_EN == DEF_ENABLED)
X#if (1u == 1u)
N
Nvoid          OSQCreate                 (OS_Q                  *p_q,
N                                         CPU_CHAR              *p_name,
N                                         OS_MSG_QTY             max_qty,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_Q_DEL_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_OBJ_QTY    OSQDel                    (OS_Q                  *p_q,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N#endif
N
N#if (OS_CFG_Q_FLUSH_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_MSG_QTY    OSQFlush                  (OS_Q                  *p_q,
N                                         OS_ERR                *p_err);
N#endif
N
Nvoid         *OSQPend                   (OS_Q                  *p_q,
N                                         OS_TICK                timeout,
N                                         OS_OPT                 opt,
N                                         OS_MSG_SIZE           *p_msg_size,
N                                         CPU_TS                *p_ts,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_Q_PEND_ABORT_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_OBJ_QTY    OSQPendAbort              (OS_Q                  *p_q,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N#endif
N
Nvoid          OSQPost                   (OS_Q                  *p_q,
N                                         void                  *p_void,
N                                         OS_MSG_SIZE            msg_size,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N
N/* ------------------------------------------------ INTERNAL FUNCTIONS ---------------------------------------------- */
N
Nvoid          OS_QClr                   (OS_Q                  *p_q);
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_QDbgListAdd            (OS_Q                  *p_q);
N
Nvoid          OS_QDbgListRemove         (OS_Q                  *p_q);
N#endif
N
Nvoid          OS_QPost                  (OS_Q                  *p_q,
N                                         void                  *p_void,
N                                         OS_MSG_SIZE            msg_size,
N                                         OS_OPT                 opt,
N                                         CPU_TS                 ts,
N                                         OS_ERR                *p_err);
N#endif
N
N
N/* ================================================================================================================== */
N/*                                                     SEMAPHORES                                                     */
N/* ================================================================================================================== */
N
N#if (OS_CFG_SEM_EN == DEF_ENABLED)
X#if (1u == 1u)
N
Nvoid          OSSemCreate               (OS_SEM                *p_sem,
N                                         CPU_CHAR              *p_name,
N                                         OS_SEM_CTR             cnt,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_SEM_DEL_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_OBJ_QTY    OSSemDel                  (OS_SEM                *p_sem,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N#endif
N
NOS_SEM_CTR    OSSemPend                 (OS_SEM                *p_sem,
N                                         OS_TICK                timeout,
N                                         OS_OPT                 opt,
N                                         CPU_TS                *p_ts,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_SEM_PEND_ABORT_EN== DEF_ENABLED)
X#if (1u== 1u)
NOS_OBJ_QTY    OSSemPendAbort            (OS_SEM                *p_sem,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N#endif
N
NOS_SEM_CTR    OSSemPost                 (OS_SEM                *p_sem,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_SEM_SET_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OSSemSet                  (OS_SEM                *p_sem,
N                                         OS_SEM_CTR             cnt,
N                                         OS_ERR                *p_err);
N#endif
N
N/* ------------------------------------------------ INTERNAL FUNCTIONS ---------------------------------------------- */
N
Nvoid          OS_SemClr                 (OS_SEM                *p_sem);
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_SemDbgListAdd          (OS_SEM                *p_sem);
N
Nvoid          OS_SemDbgListRemove       (OS_SEM                *p_sem);
N#endif
N
NOS_SEM_CTR    OS_SemPost                (OS_SEM                *p_sem,
N                                         OS_OPT                 opt,
N                                         CPU_TS                 ts,
N                                         OS_ERR                *p_err);
N#endif
N
N
N/* ================================================================================================================== */
N/*                                                 TASK MANAGEMENT                                                    */
N/* ================================================================================================================== */
N
N#if (OS_CFG_TASK_CHANGE_PRIO_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OSTaskChangePrio          (OS_TCB                *p_tcb,
S                                         OS_PRIO                prio_new,
S                                         OS_ERR                *p_err);
N#endif
N
Nvoid          OSTaskCreate              (OS_TCB                *p_tcb,
N                                         CPU_CHAR              *p_name,
N                                         OS_TASK_PTR            p_task,
N                                         void                  *p_arg,
N                                         OS_PRIO                prio,
N                                         CPU_STK               *p_stk_base,
N                                         CPU_STK_SIZE           stk_limit,
N                                         CPU_STK_SIZE           stk_size,
N                                         OS_MSG_QTY             q_size,
N                                         OS_TICK                time_quanta,
N                                         void                  *p_ext,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OSTaskDel                 (OS_TCB                *p_tcb,
S                                         OS_ERR                *p_err);
N#endif
N
N#if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
X#if (1u == 1u)
NOS_MSG_QTY    OSTaskQFlush              (OS_TCB                *p_tcb,
N                                         OS_ERR                *p_err);
N
Nvoid         *OSTaskQPend               (OS_TICK                timeout,
N                                         OS_OPT                 opt,
N                                         OS_MSG_SIZE           *p_msg_size,
N                                         CPU_TS                *p_ts,
N                                         OS_ERR                *p_err);
N
NCPU_BOOLEAN   OSTaskQPendAbort          (OS_TCB                *p_tcb,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N
Nvoid          OSTaskQPost               (OS_TCB                *p_tcb,
N                                         void                  *p_void,
N                                         OS_MSG_SIZE            msg_size,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N
N#endif
N
N#if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
X#if (1u > 0u)
NOS_REG        OSTaskRegGet              (OS_TCB                *p_tcb,
N                                         OS_REG_ID              id,
N                                         OS_ERR                *p_err);
N
NOS_REG_ID     OSTaskRegGetID            (OS_ERR                *p_err);
N
Nvoid          OSTaskRegSet              (OS_TCB                *p_tcb,
N                                         OS_REG_ID              id,
N                                         OS_REG                 value,
N                                         OS_ERR                *p_err);
N#endif
N
N#if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OSTaskResume              (OS_TCB                *p_tcb,
N                                         OS_ERR                *p_err);
N
Nvoid          OSTaskSuspend             (OS_TCB                *p_tcb,
N                                         OS_ERR                *p_err);
N#endif
N
NOS_SEM_CTR    OSTaskSemPend             (OS_TICK                timeout,
N                                         OS_OPT                 opt,
N                                         CPU_TS                *p_ts,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_TASK_SEM_PEND_ABORT_EN == DEF_ENABLED)
X#if (1u == 1u)
NCPU_BOOLEAN   OSTaskSemPendAbort        (OS_TCB                *p_tcb,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N#endif
N
NOS_SEM_CTR    OSTaskSemPost             (OS_TCB                *p_tcb,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N
NOS_SEM_CTR    OSTaskSemSet              (OS_TCB                *p_tcb,
N                                         OS_SEM_CTR             cnt,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OSTaskStkChk              (OS_TCB                *p_tcb,
N                                         CPU_STK_SIZE          *p_free,
N                                         CPU_STK_SIZE          *p_used,
N                                         OS_ERR                *p_err);
N#endif
N
N#if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
X#if (0u == 1u)
SCPU_BOOLEAN   OSTaskStkRedzoneChk       (OS_TCB                *p_tcb);
N#endif
N
N#if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OSTaskTimeQuantaSet       (OS_TCB                *p_tcb,
S                                         OS_TICK                time_quanta,
S                                         OS_ERR                *p_err);
N#endif
N
N/* ------------------------------------------------ INTERNAL FUNCTIONS ---------------------------------------------- */
N
Nvoid          OS_TaskBlock              (OS_TCB                *p_tcb,
N                                         OS_TICK                timeout);
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_TaskDbgListAdd         (OS_TCB                *p_tcb);
N
Nvoid          OS_TaskDbgListRemove      (OS_TCB                *p_tcb);
N#endif
N
Nvoid          OS_TaskInit               (OS_ERR                *p_err);
N
Nvoid          OS_TaskInitTCB            (OS_TCB                *p_tcb);
N
Nvoid          OS_TaskQPost              (OS_TCB                *p_tcb,
N                                         void                  *p_void,
N                                         OS_MSG_SIZE            msg_size,
N                                         OS_OPT                 opt,
N                                         CPU_TS                 ts,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_TaskResume             (OS_TCB                *p_tcb,
N                                         OS_ERR                *p_err);
N#endif
N
Nvoid          OS_TaskReturn             (void);
N
NOS_SEM_CTR    OS_TaskSemPost            (OS_TCB                *p_tcb,
N                                         OS_OPT                 opt,
N                                         CPU_TS                 ts,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
X#if (0u == 1u)
SCPU_BOOLEAN   OS_TaskStkRedzoneChk      (CPU_STK               *p_base,
S                                         CPU_STK_SIZE           stk_size);
S
Svoid          OS_TaskStkRedzoneInit     (CPU_STK               *p_base,
S                                         CPU_STK_SIZE           stk_size);
N#endif
N
N#if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_TaskSuspend            (OS_TCB                *p_tcb,
N                                         OS_ERR                *p_err);
N#endif
N
Nvoid          OS_TaskChangePrio(         OS_TCB                *p_tcb,
N                                         OS_PRIO                prio_new);
N
N
N/* ================================================================================================================== */
N/*                                                 TIME MANAGEMENT                                                    */
N/* ================================================================================================================== */
N
Nvoid          OSTimeDly                 (OS_TICK                dly,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N
N#if (OS_CFG_TIME_DLY_HMSM_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OSTimeDlyHMSM             (CPU_INT16U             hours,
N                                         CPU_INT16U             minutes,
N                                         CPU_INT16U             seconds,
N                                         CPU_INT32U             milli,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N#endif
N
N#if (OS_CFG_TIME_DLY_RESUME_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OSTimeDlyResume           (OS_TCB                *p_tcb,
S                                         OS_ERR                *p_err);
N#endif
N
NOS_TICK       OSTimeGet                 (OS_ERR                *p_err);
N
Nvoid          OSTimeSet                 (OS_TICK                ticks,
N                                         OS_ERR                *p_err);
N
Nvoid          OSTimeTick                (void);
Nvoid          OSTimeDynTick             (OS_TICK                ticks);
N
N
N/* ================================================================================================================== */
N/*                                                 TIMER MANAGEMENT                                                   */
N/* ================================================================================================================== */
N
N#if (OS_CFG_TMR_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OSTmrCreate               (OS_TMR                *p_tmr,
N                                         CPU_CHAR              *p_name,
N                                         OS_TICK                dly,
N                                         OS_TICK                period,
N                                         OS_OPT                 opt,
N                                         OS_TMR_CALLBACK_PTR    p_callback,
N                                         void                  *p_callback_arg,
N                                         OS_ERR                *p_err);
N
NCPU_BOOLEAN   OSTmrDel                  (OS_TMR                *p_tmr,
N                                         OS_ERR                *p_err);
N
Nvoid          OSTmrSet (                 OS_TMR                *p_tmr,
N                                         OS_TICK                dly,
N                                         OS_TICK                period,
N                                         OS_TMR_CALLBACK_PTR    p_callback,
N                                         void                  *p_callback_arg,
N                                         OS_ERR                *p_err);
N
NOS_TICK       OSTmrRemainGet            (OS_TMR                *p_tmr,
N                                         OS_ERR                *p_err);
N
NCPU_BOOLEAN   OSTmrStart                (OS_TMR                *p_tmr,
N                                         OS_ERR                *p_err);
N
NOS_STATE      OSTmrStateGet             (OS_TMR                *p_tmr,
N                                         OS_ERR                *p_err);
N
NCPU_BOOLEAN   OSTmrStop                 (OS_TMR                *p_tmr,
N                                         OS_OPT                 opt,
N                                         void                  *p_callback_arg,
N                                         OS_ERR                *p_err);
N
N/* ------------------------------------------------ INTERNAL FUNCTIONS ---------------------------------------------- */
N
Nvoid          OS_TmrClr                 (OS_TMR                *p_tmr);
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_TmrDbgListAdd          (OS_TMR                *p_tmr);
N
Nvoid          OS_TmrDbgListRemove       (OS_TMR                *p_tmr);
N#endif
N
Nvoid          OS_TmrInit                (OS_ERR                *p_err);
N
Nvoid          OS_TmrLink                (OS_TMR                *p_tmr,
N                                         OS_OPT                 opt);
N
Nvoid          OS_TmrUnlink              (OS_TMR                *p_tmr);
N
Nvoid          OS_TmrTask                (void                  *p_arg);
N
N#endif
N
N
N/* ================================================================================================================== */
N/*                                          TASK LOCAL STORAGE (TLS) SUPPORT                                          */
N/* ================================================================================================================== */
N
N#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
X#if 1L && (0u > 0u)
SOS_TLS_ID  OS_TLS_GetID       (OS_ERR              *p_err);
S
SOS_TLS     OS_TLS_GetValue    (OS_TCB              *p_tcb,
S                               OS_TLS_ID            id,
S                               OS_ERR              *p_err);
S
Svoid       OS_TLS_Init        (OS_ERR              *p_err);
S
Svoid       OS_TLS_SetValue    (OS_TCB              *p_tcb,
S                               OS_TLS_ID            id,
S                               OS_TLS               value,
S                               OS_ERR              *p_err);
S
Svoid       OS_TLS_SetDestruct (OS_TLS_ID            id,
S                               OS_TLS_DESTRUCT_PTR  p_destruct,
S                               OS_ERR              *p_err);
S
Svoid       OS_TLS_TaskCreate  (OS_TCB              *p_tcb);
S
Svoid       OS_TLS_TaskDel     (OS_TCB              *p_tcb);
S
Svoid       OS_TLS_TaskSw      (void);
N#endif
N
N
N/* ================================================================================================================== */
N/*                                                    MISCELLANEOUS                                                   */
N/* ================================================================================================================== */
N
Nvoid          OSInit                    (OS_ERR                *p_err);
N
Nvoid          OSIntEnter                (void);
Nvoid          OSIntExit                 (void);
N
N#if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OSSchedRoundRobinCfg      (CPU_BOOLEAN            en,
S                                         OS_TICK                dflt_time_quanta,
S                                         OS_ERR                *p_err);
S
Svoid          OSSchedRoundRobinYield    (OS_ERR                *p_err);
S
N#endif
N
Nvoid          OSSched                   (void);
N
Nvoid          OSSchedLock               (OS_ERR                *p_err);
Nvoid          OSSchedUnlock             (OS_ERR                *p_err);
N
Nvoid          OSStart                   (OS_ERR                *p_err);
N
N#if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OSStatReset               (OS_ERR                *p_err);
S
Svoid          OSStatTaskCPUUsageInit    (OS_ERR                *p_err);
N#endif
N
NCPU_INT16U    OSVersion                 (OS_ERR                *p_err);
N
N/* ------------------------------------------------ INTERNAL FUNCTIONS ---------------------------------------------- */
N
Nvoid          OS_IdleTask               (void                  *p_arg);
N
Nvoid          OS_IdleTaskInit           (OS_ERR                *p_err);
N
N#if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OS_StatTask               (void                  *p_arg);
N#endif
N
Nvoid          OS_StatTaskInit           (OS_ERR                *p_err);
N
Nvoid          OS_TickTask               (void                  *p_arg);
Nvoid          OS_TickTaskInit           (OS_ERR                *p_err);
N
N
N/*
N************************************************************************************************************************
N************************************************************************************************************************
N*                                    T A R G E T   S P E C I F I C   F U N C T I O N S
N************************************************************************************************************************
N************************************************************************************************************************
N*/
N
N#ifdef __cplusplus
Sextern  "C" {
N#endif
N
Nvoid          OSIdleTaskHook            (void);
N
Nvoid          OSInitHook                (void);
N
N#if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OSRedzoneHitHook          (OS_TCB                *p_tcb);
N#endif
N
Nvoid          OSStatTaskHook            (void);
N
Nvoid          OSTaskCreateHook          (OS_TCB                *p_tcb);
N
Nvoid          OSTaskDelHook             (OS_TCB                *p_tcb);
N
Nvoid          OSTaskReturnHook          (OS_TCB                *p_tcb);
N
NCPU_STK      *OSTaskStkInit             (OS_TASK_PTR            p_task,
N                                         void                  *p_arg,
N                                         CPU_STK               *p_stk_base,
N                                         CPU_STK               *p_stk_limit,
N                                         CPU_STK_SIZE           stk_size,
N                                         OS_OPT                 opt);
N
Nvoid          OSTaskSwHook              (void);
N
Nvoid          OSTimeTickHook            (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N
N/*
N************************************************************************************************************************
N************************************************************************************************************************
N*                   u C / O S - I I I   I N T E R N A L   F U N C T I O N   P R O T O T Y P E S
N************************************************************************************************************************
N************************************************************************************************************************
N*/
N
Nvoid          OSCfg_Init                (void);
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_Dbg_Init               (void);
N#endif
N
N
N#if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OS_IntQTaskInit           (OS_ERR                *p_err);
S
Svoid          OS_IntQPost               (OS_OBJ_TYPE            type,
S                                         void                  *p_obj,
S                                         void                  *p_void,
S                                         OS_MSG_SIZE            msg_size,
S                                         OS_FLAGS               flags,
S                                         OS_OPT                 opt,
S                                         CPU_TS                 ts,
S                                         OS_ERR                *p_err);
S
Svoid          OS_IntQRePost             (void);
S
Svoid          OS_IntQTask               (void                  *p_arg);
N#endif
N
N/* ----------------------------------------------- MESSAGE MANAGEMENT ----------------------------------------------- */
N
Nvoid          OS_MsgPoolInit            (OS_ERR                *p_err);
N
NOS_MSG_QTY    OS_MsgQFreeAll            (OS_MSG_Q              *p_msg_q);
N
Nvoid         *OS_MsgQGet                (OS_MSG_Q              *p_msg_q,
N                                         OS_MSG_SIZE           *p_msg_size,
N                                         CPU_TS                *p_ts,
N                                         OS_ERR                *p_err);
N
Nvoid          OS_MsgQInit               (OS_MSG_Q              *p_msg_q,
N                                         OS_MSG_QTY             size);
N
Nvoid          OS_MsgQPut                (OS_MSG_Q              *p_msg_q,
N                                         void                  *p_void,
N                                         OS_MSG_SIZE            msg_size,
N                                         OS_OPT                 opt,
N                                         CPU_TS                 ts,
N                                         OS_ERR                *p_err);
N
N/* ---------------------------------------------- PEND/POST MANAGEMENT ---------------------------------------------- */
N
Nvoid          OS_Pend                   (OS_PEND_DATA          *p_pend_data,
N                                         OS_PEND_OBJ           *p_obj,
N                                         OS_STATE               pending_on,
N                                         OS_TICK                timeout);
N
Nvoid          OS_PendAbort              (OS_PEND_OBJ           *p_obj,
N                                         OS_TCB                *p_tcb,
N                                         CPU_TS                 ts);
N#if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OS_PendAbort1             (OS_PEND_OBJ           *p_obj,
S                                         OS_TCB                *p_tcb,
S                                         CPU_TS                 ts);
N#endif
Nvoid          OS_PendObjDel             (OS_PEND_OBJ           *p_obj,
N                                         OS_TCB                *p_tcb,
N                                         CPU_TS                 ts);
N#if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OS_PendObjDel1            (OS_PEND_OBJ           *p_obj,
S                                         OS_TCB                *p_tcb,
S                                         CPU_TS                 ts);
N#endif
Nvoid          OS_Post                   (OS_PEND_OBJ           *p_obj,
N                                         OS_TCB                *p_tcb,
N                                         void                  *p_void,
N                                         OS_MSG_SIZE            msg_size,
N                                         CPU_TS                 ts);
N#if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OS_Post1                  (OS_PEND_OBJ           *p_obj,
S                                         OS_TCB                *p_tcb,
S                                         void                  *p_void,
S                                         OS_MSG_SIZE            msg_size,
S                                         CPU_TS                 ts);
N#endif
N/* ----------------------------------------------- PRIORITY MANAGEMENT ---------------------------------------------- */
N
Nvoid          OS_PrioInit               (void);
N
Nvoid          OS_PrioInsert             (OS_PRIO                prio);
N
Nvoid          OS_PrioRemove             (OS_PRIO                prio);
N
NOS_PRIO       OS_PrioGetHighest         (void);
N
N/* --------------------------------------------------- SCHEDULING --------------------------------------------------- */
N
N#if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OS_Sched0                 (void);
N#endif
N
N#if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OS_SchedLockTimeMeasStart (void);
Svoid          OS_SchedLockTimeMeasStop  (void);
N#endif
N
N#if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
X#if (0u == 1u)
Svoid          OS_SchedRoundRobin        (OS_RDY_LIST           *p_rdy_list);
N#endif
N
N/* --------------------------------------------- READY LIST MANAGEMENT ---------------------------------------------- */
N
Nvoid          OS_RdyListInit            (void);
N
Nvoid          OS_RdyListInsert          (OS_TCB                *p_tcb);
N
Nvoid          OS_RdyListInsertHead      (OS_TCB                *p_tcb);
N
Nvoid          OS_RdyListInsertTail      (OS_TCB                *p_tcb);
N
Nvoid          OS_RdyListMoveHeadToTail  (OS_RDY_LIST           *p_rdy_list);
N
Nvoid          OS_RdyListRemove          (OS_TCB                *p_tcb);
N
N/* ---------------------------------------------- PEND LIST MANAGEMENT ---------------------------------------------- */
N
Nvoid          OS_PendDataInit           (OS_TCB                *p_tcb,
N                                         OS_PEND_DATA          *p_pend_data_tbl,
N                                         OS_OBJ_QTY             tbl_size);
N
N#if (OS_CFG_DBG_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_PendDbgNameAdd         (OS_PEND_OBJ           *p_obj,
N                                         OS_TCB                *p_tcb);
N
Nvoid          OS_PendDbgNameRemove      (OS_PEND_OBJ           *p_obj,
N                                         OS_TCB                *p_tcb);
N#endif
N
NOS_PEND_LIST *OS_PendListGetPtr         (OS_PEND_OBJ           *p_obj);
N
Nvoid          OS_PendListInit           (OS_PEND_LIST          *p_pend_list);
N
Nvoid          OS_PendListInsertHead     (OS_PEND_LIST          *p_pend_list,
N                                         OS_PEND_DATA          *p_pend_data);
N
Nvoid          OS_PendListInsertPrio     (OS_PEND_LIST          *p_pend_list,
N                                         OS_PEND_DATA          *p_pend_data);
N
Nvoid          OS_PendListChangePrio     (OS_TCB                *p_tcb);
N
Nvoid          OS_PendListRemove         (OS_TCB                *p_tcb);
N
Nvoid          OS_PendListRemove1        (OS_PEND_LIST          *p_pend_list,
N                                         OS_PEND_DATA          *p_pend_data);
N
N/* ---------------------------------------------- TICK LIST MANAGEMENT ---------------------------------------------- */
N#if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
X#if (1u == 1u)
Nvoid          OS_TickListInsert         (OS_TICK_LIST          *p_list,
N                                         OS_TCB                *p_tcb,
N                                         OS_TICK                time);
N
Nvoid          OS_TickListInsertDly      (OS_TCB                *p_tcb,
N                                         OS_TICK                time,
N                                         OS_OPT                 opt,
N                                         OS_ERR                *p_err);
N
Nvoid          OS_TickListRemove         (OS_TCB                *p_tcb);
N
N#if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
X#if (0u == 1u)
SOS_TICK       BSP_OS_TickGet            (void);
S
SOS_TICK       BSP_OS_TickNextSet        (OS_TICK                ticks);
N#endif
N#endif
N
N
N/*
N************************************************************************************************************************
N*                                          LOOK FOR MISSING #define CONSTANTS
N*
N* This section is used to generate ERROR messages at compile time if certain #define constants are
N* MISSING in OS_CFG.H.  This allows you to quickly determine the source of the error.
N*
N* You SHOULD NOT change this section UNLESS you would like to add more comments as to the source of the
N* compile time error.
N************************************************************************************************************************
N*/
N
N/*
N************************************************************************************************************************
N*                                                     MISCELLANEOUS
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_APP_HOOKS_EN
S#error  "OS_CFG.H, Missing OS_CFG_APP_HOOKS_EN: Enable (1) or Disable (0) application specific hook functions"
N#endif
N
N
N#ifndef OS_CFG_ARG_CHK_EN
S#error  "OS_CFG.H, Missing OS_CFG_ARG_CHK_EN: Enable (1) or Disable (0) argument checking"
N#endif
N
N
N#ifndef OS_CFG_DBG_EN
S#error  "OS_CFG.H, Missing OS_CFG_DBG_EN: Allows you to include variables for debugging or not"
N#endif
N
N
N#ifndef OS_CFG_CALLED_FROM_ISR_CHK_EN
S#error  "OS_CFG.H, Missing OS_CFG_CALLED_FROM_ISR_CHK_EN: Enable (1) or Disable (0) checking whether in an ISR in kernel services"
N#endif
N
N
N#ifndef OS_CFG_OBJ_TYPE_CHK_EN
S#error  "OS_CFG.H, Missing OS_CFG_OBJ_TYPE_CHK_EN: Enable (1) or Disable (0) checking for proper object types in kernel services"
N#endif
N
N
N#ifndef OS_CFG_PEND_MULTI_EN
S#error  "OS_CFG.H, Missing OS_CFG_PEND_MULTI_EN: Enable (1) or Disable (0) multi-pend feature"
N#endif
N
N
N#if     OS_CFG_PRIO_MAX < 8u
X#if     32u < 8u
S#error  "OS_CFG.H,         OS_CFG_PRIO_MAX must be >= 8"
N#endif
N
N
N#ifndef OS_CFG_SCHED_LOCK_TIME_MEAS_EN
S#error  "OS_CFG.H, Missing OS_CFG_SCHED_LOCK_TIME_MEAS_EN: Include code to measure scheduler lock time"
N#else
N    #if    (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED) && \
N           (OS_CFG_TS_EN                   == DEF_DISABLED)
X    #if    (0u == 1u) &&            (1u                   == 0u)
S    #error  "OS_CFG.H,         OS_CFG_TS_EN must be Enabled (1) to measure scheduler lock time"
N    #endif
N#endif
N
N
N#ifndef OS_CFG_SCHED_ROUND_ROBIN_EN
S#error  "OS_CFG.H, Missing OS_CFG_SCHED_ROUND_ROBIN_EN: Include code for Round Robin Scheduling"
N#endif
N
N
N#ifndef OS_CFG_STK_SIZE_MIN
S#error  "OS_CFG.H, Missing OS_CFG_STK_SIZE_MIN: Determines the minimum size for a task stack"
N#endif
N
N#ifndef OS_CFG_TS_EN
S#error  "OS_CFG.H, Missing OS_CFG_TS_EN: Determines whether time stamping is enabled"
N#else
N    #if    (OS_CFG_TS_EN  == DEF_ENABLED) && \
N           (CPU_CFG_TS_EN == DEF_DISABLED)
X    #if    (1u  == 1u) &&            (1u == 0u)
S    #error  "CPU_CFG.H,        CPU_CFG_TS_32_EN must be Enabled (1) to use time stamp feature"
N    #endif
N#endif
N
N/*
N************************************************************************************************************************
N*                                                     EVENT FLAGS
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_FLAG_EN
S#error  "OS_CFG.H, Missing OS_CFG_FLAG_EN: Enable (1) or Disable (0) code generation for Event Flags"
N#else
N    #ifndef OS_CFG_FLAG_DEL_EN
S    #error  "OS_CFG.H, Missing OS_CFG_FLAG_DEL_EN: Include code for OSFlagDel()"
N    #endif
N
N    #ifndef OS_CFG_FLAG_MODE_CLR_EN
S    #error  "OS_CFG.H, Missing OS_CFG_FLAG_MODE_CLR_EN: Include code for Wait on Clear EVENT FLAGS"
N    #endif
N
N    #ifndef OS_CFG_FLAG_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_CFG_FLAG_PEND_ABORT_EN: Include code for aborting pends from another task"
N    #endif
N#endif
N
N/*
N************************************************************************************************************************
N*                                                  MEMORY MANAGEMENT
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_MEM_EN
S#error  "OS_CFG.H, Missing OS_CFG_MEM_EN: Enable (1) or Disable (0) code generation for MEMORY MANAGER"
N#endif
N
N/*
N************************************************************************************************************************
N*                                              MUTUAL EXCLUSION SEMAPHORES
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_MUTEX_EN
S#error  "OS_CFG.H, Missing OS_CFG_MUTEX_EN: Enable (1) or Disable (0) code generation for MUTEX"
N#else
N    #ifndef OS_CFG_MUTEX_DEL_EN
S    #error  "OS_CFG.H, Missing OS_CFG_MUTEX_DEL_EN: Include code for OSMutexDel()"
N    #endif
N
N    #ifndef OS_CFG_MUTEX_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_CFG_MUTEX_PEND_ABORT_EN: Include code for OSMutexPendAbort()"
N    #endif
N#endif
N
N/*
N************************************************************************************************************************
N*                                                    MESSAGE QUEUES
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_Q_EN
S#error  "OS_CFG.H, Missing OS_CFG_Q_EN: Enable (1) or Disable (0) code generation for QUEUES"
N#else
N    #ifndef OS_CFG_Q_DEL_EN
S    #error  "OS_CFG.H, Missing OS_CFG_Q_DEL_EN: Include code for OSQDel()"
N    #endif
N
N    #ifndef OS_CFG_Q_FLUSH_EN
S    #error  "OS_CFG.H, Missing OS_CFG_Q_FLUSH_EN: Include code for OSQFlush()"
N    #endif
N
N    #ifndef OS_CFG_Q_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_CFG_Q_PEND_ABORT_EN: Include code for OSQPendAbort()"
N    #endif
N#endif
N
N/*
N************************************************************************************************************************
N*                                                      SEMAPHORES
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_SEM_EN
S#error  "OS_CFG.H, Missing OS_CFG_SEM_EN: Enable (1) or Disable (0) code generation for SEMAPHORES"
N#else
N    #ifndef OS_CFG_SEM_DEL_EN
S    #error  "OS_CFG.H, Missing OS_CFG_SEM_DEL_EN: Include code for OSSemDel()"
N    #endif
N
N    #ifndef OS_CFG_SEM_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_CFG_SEM_PEND_ABORT_EN: Include code for OSSemPendAbort()"
N    #endif
N
N    #ifndef OS_CFG_SEM_SET_EN
S    #error  "OS_CFG.H, Missing OS_CFG_SEM_SET_EN: Include code for OSSemSet()"
N    #endif
N#endif
N
N/*
N************************************************************************************************************************
N*                                                   TASK MANAGEMENT
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_STAT_TASK_EN
S#error  "OS_CFG.H, Missing OS_CFG_STAT_TASK_EN: Enable (1) or Disable(0) the statistics task"
N#endif
N
N#ifndef OS_CFG_STAT_TASK_STK_CHK_EN
S#error  "OS_CFG.H, Missing OS_CFG_STAT_TASK_STK_CHK_EN: Check task stacks from statistics task"
N#endif
N
N#ifndef OS_CFG_TASK_CHANGE_PRIO_EN
S#error  "OS_CFG.H, Missing OS_CFG_TASK_CHANGE_PRIO_EN: Include code for OSTaskChangePrio()"
N#endif
N
N#ifndef OS_CFG_TASK_DEL_EN
S#error  "OS_CFG.H, Missing OS_CFG_TASK_DEL_EN: Include code for OSTaskDel()"
N#endif
N
N#ifndef OS_CFG_TASK_Q_EN
S#error  "OS_CFG.H, Missing OS_CFG_TASK_Q_EN: Include code for OSTaskQxxx()"
N#endif
N
N#ifndef OS_CFG_TASK_Q_PEND_ABORT_EN
S#error  "OS_CFG.H, Missing OS_CFG_TASK_Q_PEND_ABORT_EN: Include code for OSTaskQPendAbort()"
N#endif
N
N#ifndef OS_CFG_TASK_PROFILE_EN
S#error  "OS_CFG.H, Missing OS_CFG_TASK_PROFILE_EN: Include code for task profiling"
N#else
N#if    (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) && \
N       (OS_CFG_TASK_IDLE_EN == DEF_DISABLED)
X#if    (1u == 1u) &&        (1u == 0u)
S#error  "OS_CFG.H,         OS_CFG_TASK_IDLE_EN must be Enabled (1) to use the task profiling feature"
N#endif
N#endif
N
N#ifndef OS_CFG_TASK_REG_TBL_SIZE
S#error  "OS_CFG.H, Missing OS_CFG_TASK_REG_TBL_SIZE: Include support for task specific registers"
N#endif
N
N#ifndef OS_CFG_TASK_SEM_PEND_ABORT_EN
S#error  "OS_CFG.H, Missing OS_CFG_TASK_SEM_PEND_ABORT_EN: Include code for OSTaskSemPendAbort()"
N#endif
N
N#ifndef OS_CFG_TASK_SUSPEND_EN
S#error  "OS_CFG.H, Missing OS_CFG_TASK_SUSPEND_EN: Include code for OSTaskSuspend() and OSTaskResume()"
N#endif
N
N/*
N************************************************************************************************************************
N*                                                  TIME MANAGEMENT
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_TIME_DLY_HMSM_EN
S#error  "OS_CFG.H, Missing OS_CFG_TIME_DLY_HMSM_EN: Include code for OSTimeDlyHMSM()"
N#endif
N
N#ifndef OS_CFG_TIME_DLY_RESUME_EN
S#error  "OS_CFG.H, Missing OS_CFG_TIME_DLY_RESUME_EN: Include code for OSTimeDlyResume()"
N#endif
N
N/*
N************************************************************************************************************************
N*                                                  TIMER MANAGEMENT
N************************************************************************************************************************
N*/
N
N#ifndef OS_CFG_TMR_EN
S#error  "OS_CFG.H, Missing OS_CFG_TMR_EN: When (1) enables code generation for Timer Management"
N#else
N    #ifndef OS_CFG_TMR_DEL_EN
S    #error  "OS_CFG.H, Missing OS_CFG_TMR_DEL_EN: Enables (1) or Disables (0) code for OSTmrDel()"
N    #endif
N#endif
N
N/*
N************************************************************************************************************************
N*                                             LIBRARY CONFIGURATION ERRORS
N************************************************************************************************************************
N*/
N
N                                                                /* See 'os.h  Note #1a'.                              */
N#if LIB_VERSION < 13801u
X#if 13801u < 13801u
S#error  "lib_def.h, LIB_VERSION SHOULD be >= V1.38.01"
N#endif
N
N
N                                                                /* See 'os.h  Note #1b'.                              */
N#if CPU_CORE_VERSION < 13002u
X#if 13002u < 13002u
S#error  "cpu_core.h, CPU_CORE_VERSION SHOULD be >= V1.30.02"
N#endif
N
N
N/*
N************************************************************************************************************************
N*                                                 uC/OS-III MODULE END
N************************************************************************************************************************
N*/
N
N#endif
L 37 "..\..\uCOS-III\uCOS-III\Source\os_flag.c" 2
N
N#ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
Sconst  CPU_CHAR  *os_flag__c = "$Id: $";
N#endif
N
N
N#if (OS_CFG_FLAG_EN == DEF_ENABLED)
X#if (0u == 1u)
S
S/*
S************************************************************************************************************************
S*                                                 CREATE AN EVENT FLAG
S*
S* Description: This function is called to create an event flag group.
S*
S* Arguments  : p_grp          is a pointer to the event flag group to create
S*
S*              p_name         is the name of the event flag group
S*
S*              flags          contains the initial value to store in the event flag group (typically 0).
S*
S*              p_err          is a pointer to an error code which will be returned to your application:
S*
S*                                 OS_ERR_NONE                    If the call was successful
S*                                 OS_ERR_CREATE_ISR              If you attempted to create an Event Flag from an ISR
S*                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the Event Flag after you
S*                                                                   called OSStart().
S*                                 OS_ERR_OBJ_PTR_NULL            If 'p_grp' is a NULL pointer
S*
S* Returns    : none
S************************************************************************************************************************
S*/
S
Svoid  OSFlagCreate (OS_FLAG_GRP  *p_grp,
S                    CPU_CHAR     *p_name,
S                    OS_FLAGS      flags,
S                    OS_ERR       *p_err)
S{
S    CPU_SR_ALLOC();
S
S
S
S#ifdef OS_SAFETY_CRITICAL
S    if (p_err == DEF_NULL) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return;
S    }
S#endif
S
S#ifdef OS_SAFETY_CRITICAL_IEC61508
S    if (OSSafetyCriticalStartFlag == DEF_TRUE) {
S       *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
S        return;
S    }
S#endif
S
S#if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
S    if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
S       *p_err = OS_ERR_CREATE_ISR;                              /* ... can't CREATE from an ISR                         */
S        return;
S    }
S#endif
S
S#if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
S    if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
S       *p_err = OS_ERR_OBJ_PTR_NULL;
S        return;
S    }
S#endif
S
S    OS_CRITICAL_ENTER();
S#if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
S    p_grp->Type    = OS_OBJ_TYPE_FLAG;                          /* Set to event flag group type                         */
S#endif
S#if (OS_CFG_DBG_EN == DEF_ENABLED)
S    p_grp->NamePtr = p_name;
S#else
S    (void)&p_name;
S#endif
S    p_grp->Flags   = flags;                                     /* Set to desired initial value                         */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S    p_grp->TS      = 0u;
S#endif
S    OS_PendListInit(&p_grp->PendList);
S
S#if (OS_CFG_DBG_EN == DEF_ENABLED)
S    OS_FlagDbgListAdd(p_grp);
S    OSFlagQty++;
S#endif
S
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S    TRACE_OS_FLAG_CREATE(p_grp, p_name);                        /* Record the event.                                    */
S#endif
S    
S    OS_CRITICAL_EXIT_NO_SCHED();
S   *p_err = OS_ERR_NONE;
S}
S
S
S/*
S************************************************************************************************************************
S*                                             DELETE AN EVENT FLAG GROUP
S*
S* Description: This function deletes an event flag group and readies all tasks pending on the event flag group.
S*
S* Arguments  : p_grp     is a pointer to the desired event flag group.
S*
S*              opt       determines delete options as follows:
S*
S*                            OS_OPT_DEL_NO_PEND           Deletes the event flag group ONLY if no task pending
S*                            OS_OPT_DEL_ALWAYS            Deletes the event flag group even if tasks are waiting.
S*                                                         In this case, all the tasks pending will be readied.
S*
S*              p_err     is a pointer to an error code that can contain one of the following values:
S*
S*                            OS_ERR_NONE                    The call was successful and the event flag group was deleted
S*                            OS_ERR_DEL_ISR                 If you attempted to delete the event flag group from an ISR
S*                            OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the event flag group after you
S*                                                             called OSStart()
S*                            OS_ERR_OBJ_PTR_NULL            If 'p_grp' is a NULL pointer
S*                            OS_ERR_OBJ_TYPE                If you didn't pass a pointer to an event flag group
S*                            OS_ERR_OPT_INVALID             An invalid option was specified
S*                            OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
S*                            OS_ERR_TASK_WAITING            One or more tasks were waiting on the event flag group
S*
S* Returns    : == 0          if no tasks were waiting on the event flag group, or upon error.
S*              >  0          if one or more tasks waiting on the event flag group are now readied and informed.
S*
S* Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the event flag
S*                 group MUST check the return code of OSFlagPost and OSFlagPend().
S************************************************************************************************************************
S*/
S
S#if (OS_CFG_FLAG_DEL_EN == DEF_ENABLED)
SOS_OBJ_QTY  OSFlagDel (OS_FLAG_GRP  *p_grp,
S                       OS_OPT        opt,
S                       OS_ERR       *p_err)
S{
S    OS_OBJ_QTY        nbr_tasks;
S    OS_PEND_DATA     *p_pend_data;
S    OS_PEND_LIST     *p_pend_list;
S    OS_TCB           *p_tcb;
S    CPU_TS            ts;
S    CPU_SR_ALLOC();
S
S
S
S#ifdef OS_SAFETY_CRITICAL
S    if (p_err == DEF_NULL) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return (0u);
S    }
S#endif
S
S#ifdef OS_SAFETY_CRITICAL_IEC61508
S    if (OSSafetyCriticalStartFlag == DEF_TRUE) {
S       *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
S    if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
S       *p_err = OS_ERR_DEL_ISR;                                 /* ... can't DELETE from an ISR                         */
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?.                              */
S    if (OSRunning != OS_STATE_OS_RUNNING) {
S       *p_err = OS_ERR_OS_NOT_RUNNING;
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
S    if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
S       *p_err  = OS_ERR_OBJ_PTR_NULL;
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
S    if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Validate event group object                          */
S       *p_err = OS_ERR_OBJ_TYPE;
S        return (0u);
S    }
S#endif
S    OS_CRITICAL_ENTER();
S    p_pend_list = &p_grp->PendList;
S    nbr_tasks   = 0u;
S    switch (opt) {
S        case OS_OPT_DEL_NO_PEND:                                /* Delete group if no task waiting                      */
S             if (p_pend_list->HeadPtr == DEF_NULL) {
S#if (OS_CFG_DBG_EN == DEF_ENABLED)
S                 OS_FlagDbgListRemove(p_grp);
S                 OSFlagQty--;
S#endif
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S                 TRACE_OS_FLAG_DEL(p_grp);                      /* Record the event.                                    */
S#endif
S                 OS_FlagClr(p_grp);
S
S                 OS_CRITICAL_EXIT();
S
S                *p_err = OS_ERR_NONE;
S             } else {
S                 OS_CRITICAL_EXIT();
S                *p_err = OS_ERR_TASK_WAITING;
S             }
S             break;
S
S        case OS_OPT_DEL_ALWAYS:                                 /* Always delete the event flag group                   */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S             ts = OS_TS_GET();                                  /* Get local time stamp so all tasks get the same time  */
S#else
S             ts = 0u;
S#endif
S             while (p_pend_list->HeadPtr != DEF_NULL) {         /* Remove all tasks from the pend list                  */
S                 p_pend_data = p_pend_list->HeadPtr;
S                 p_tcb       = p_pend_data->TCBPtr;
S                 OS_PendObjDel((OS_PEND_OBJ *)((void *)p_grp),
S                               p_tcb,
S                               ts);
S                 nbr_tasks++;
S             }
S#if (OS_CFG_DBG_EN == DEF_ENABLED)
S             OS_FlagDbgListRemove(p_grp);
S             OSFlagQty--;
S#endif
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S             TRACE_OS_FLAG_DEL(p_grp);                          /* Record the event.                                    */
S#endif
S             OS_FlagClr(p_grp);
S             OS_CRITICAL_EXIT_NO_SCHED();
S
S             OSSched();                                         /* Find highest priority task ready to run              */
S            *p_err = OS_ERR_NONE;
S             break;
S
S        default:
S             OS_CRITICAL_EXIT();
S            *p_err = OS_ERR_OPT_INVALID;
S             break;
S    }
S    return (nbr_tasks);
S}
S#endif
S
S/*
S************************************************************************************************************************
S*                                             WAIT ON AN EVENT FLAG GROUP
S*
S* Description: This function is called to wait for a combination of bits to be set in an event flag group.  Your
S*              application can wait for ANY bit to be set or ALL bits to be set.
S*
S* Arguments  : p_grp         is a pointer to the desired event flag group.
S*
S*              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
S*                            The bits you want are specified by setting the corresponding bits in 'flags'.
S*                            e.g. if your application wants to wait for bits 0 and 1 then 'flags' would contain 0x03.
S*
S*              timeout       is an optional timeout (in clock ticks) that your task will wait for the
S*                            desired bit combination.  If you specify 0, however, your task will wait
S*                            forever at the specified event flag group or, until a message arrives.
S*
S*              opt           specifies whether you want ALL bits to be set or ANY of the bits to be set.
S*                            You can specify the 'ONE' of the following arguments:
S*
S*                                OS_OPT_PEND_FLAG_CLR_ALL   You will wait for ALL bits in 'flags' to be clear (0)
S*                                OS_OPT_PEND_FLAG_CLR_ANY   You will wait for ANY bit  in 'flags' to be clear (0)
S*                                OS_OPT_PEND_FLAG_SET_ALL   You will wait for ALL bits in 'flags' to be set   (1)
S*                                OS_OPT_PEND_FLAG_SET_ANY   You will wait for ANY bit  in 'flags' to be set   (1)
S*
S*                            You can 'ADD' OS_OPT_PEND_FLAG_CONSUME if you want the event flag to be 'consumed' by
S*                                      the call.  Example, to wait for any flag in a group AND then clear
S*                                      the flags that are present, set 'wait_opt' to:
S*
S*                                      OS_OPT_PEND_FLAG_SET_ANY + OS_OPT_PEND_FLAG_CONSUME
S*
S*                            You can also 'ADD' the type of pend with 'ONE' of the two option:
S*
S*                                OS_OPT_PEND_NON_BLOCKING   Task will NOT block if flags are not available
S*                                OS_OPT_PEND_BLOCKING       Task will     block if flags are not available
S*
S*              p_ts          is a pointer to a variable that will receive the timestamp of when the event flag group was
S*                            posted, aborted or the event flag group deleted.  If you pass a NULL pointer (i.e. (CPU_TS *)0)
S*                            then you will not get the timestamp.  In other words, passing a NULL pointer is valid and
S*                            indicates that you don't need the timestamp.
S*
S*              p_err         is a pointer to an error code and can be:
S*
S*                                OS_ERR_NONE                The desired bits have been set within the specified 'timeout'
S*                                OS_ERR_OBJ_DEL             If the event group was deleted
S*                                OS_ERR_OBJ_PTR_NULL        If 'p_grp' is a NULL pointer.
S*                                OS_ERR_OBJ_TYPE            You are not pointing to an event flag group
S*                                OS_ERR_OPT_INVALID         You didn't specify a proper 'opt' argument
S*                                OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
S*                                OS_ERR_PEND_ABORT          The wait on the flag was aborted
S*                                OS_ERR_PEND_ISR            If you tried to PEND from an ISR
S*                                OS_ERR_PEND_WOULD_BLOCK    If you specified non-blocking but the flags were not
S*                                                           available
S*                                OS_ERR_SCHED_LOCKED        If you called this function when the scheduler is locked
S*                                OS_ERR_STATUS_INVALID      If the pend status has an invalid value
S*                                OS_ERR_TIMEOUT             The bit(s) have not been set in the specified 'timeout'
S*
S* Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
S*              occurred.
S*
S* Note(s)    : none
S************************************************************************************************************************
S*/
S
SOS_FLAGS  OSFlagPend (OS_FLAG_GRP  *p_grp,
S                      OS_FLAGS      flags,
S                      OS_TICK       timeout,
S                      OS_OPT        opt,
S                      CPU_TS       *p_ts,
S                      OS_ERR       *p_err)
S{
S    CPU_BOOLEAN   consume;
S    OS_FLAGS      flags_rdy;
S    OS_OPT        mode;
S    OS_PEND_DATA  pend_data;
S    CPU_SR_ALLOC();
S
S
S#ifdef OS_SAFETY_CRITICAL
S    if (p_err == DEF_NULL) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
S    if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S        TRACE_OS_FLAG_PEND_FAILED(p_grp);                       /* Record the event.                                    */
S#endif
S       *p_err = OS_ERR_PEND_ISR;                                /* ... can't PEND from an ISR                           */
S        return ((OS_FLAGS)0);
S    }
S#endif
S
S#if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
S    if (OSRunning != OS_STATE_OS_RUNNING) {
S       *p_err = OS_ERR_OS_NOT_RUNNING;
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
S    if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S        TRACE_OS_FLAG_PEND_FAILED(p_grp);                       /* Record the event.                                    */
S#endif
S       *p_err = OS_ERR_OBJ_PTR_NULL;
S        return (0u);
S    }
S    switch (opt) {                                              /* Validate 'opt'                                       */
S        case OS_OPT_PEND_FLAG_CLR_ALL:
S        case OS_OPT_PEND_FLAG_CLR_ANY:
S        case OS_OPT_PEND_FLAG_SET_ALL:
S        case OS_OPT_PEND_FLAG_SET_ANY:
S        case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME:
S        case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME:
S        case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME:
S        case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME:
S        case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_NON_BLOCKING:
S        case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_NON_BLOCKING:
S        case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_NON_BLOCKING:
S        case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_NON_BLOCKING:
S        case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
S        case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
S        case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
S        case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
S             break;
S
S        default:
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S             TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
S#endif
S            *p_err = OS_ERR_OPT_INVALID;
S             return (0u);
S    }
S#endif
S
S#if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
S    if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Validate that we are pointing at an event flag       */
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S        TRACE_OS_FLAG_PEND_FAILED(p_grp);                       /* Record the event.                                    */
S#endif
S       *p_err = OS_ERR_OBJ_TYPE;
S        return (0u);
S    }
S#endif
S
S    if ((opt & OS_OPT_PEND_FLAG_CONSUME) != 0u) {               /* See if we need to consume the flags                  */
S        consume = DEF_TRUE;
S    } else {
S        consume = DEF_FALSE;
S    }
S
S    if (p_ts != DEF_NULL) {
S       *p_ts = 0u;                                              /* Initialize the returned timestamp                    */
S    }
S
S    mode = opt & OS_OPT_PEND_FLAG_MASK;
S    CPU_CRITICAL_ENTER();
S    switch (mode) {
S        case OS_OPT_PEND_FLAG_SET_ALL:                          /* See if all required flags are set                    */
S             flags_rdy = (p_grp->Flags & flags);                /* Extract only the bits we want                        */
S             if (flags_rdy == flags) {                          /* Must match ALL the bits that we want                 */
S                 if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
S                     p_grp->Flags &= ~flags_rdy;                /* Clear ONLY the flags that we wanted                  */
S                 }
S                 OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S                 if (p_ts != DEF_NULL) {
S                    *p_ts = p_grp->TS;
S                 }
S#endif
S                 CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S                 TRACE_OS_FLAG_PEND(p_grp);                     /* Record the event.                                    */
S#endif
S                *p_err = OS_ERR_NONE;
S                 return (flags_rdy);
S             } else {                                           /* Block task until events occur or timeout             */
S                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
S                     CPU_CRITICAL_EXIT();
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S                     TRACE_OS_FLAG_PEND_FAILED(p_grp);          /* Record the event.                                    */
S#endif
S                    *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
S                     return ((OS_FLAGS)0);
S                 } else {                                       /* Specified blocking so check is scheduler is locked   */
S                     if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
S                         CPU_CRITICAL_EXIT();
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S                         TRACE_OS_FLAG_PEND_FAILED(p_grp);      /* Record the event.                                    */
S#endif
S                        *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
S                         return (0u);
S                     }
S                 }
S                                                                /* Lock the scheduler/re-enable interrupts              */
S                 OS_CRITICAL_ENTER_CPU_EXIT();              
S                 OS_FlagBlock(&pend_data,
S                              p_grp,
S                              flags,
S                              opt,
S                              timeout);
S                 OS_CRITICAL_EXIT_NO_SCHED();
S             }
S             break;
S
S        case OS_OPT_PEND_FLAG_SET_ANY:
S             flags_rdy = (p_grp->Flags & flags);                /* Extract only the bits we want                        */
S             if (flags_rdy != 0u) {                             /* See if any flag set                                  */
S                 if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
S                     p_grp->Flags &= ~flags_rdy;                /* Clear ONLY the flags that we got                     */
S                 }
S                 OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S                 if (p_ts != DEF_NULL) {
S                    *p_ts  = p_grp->TS;
S                 }
S#endif
S                 CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S                 TRACE_OS_FLAG_PEND(p_grp);                     /* Record the event.                                    */
S#endif
S                *p_err = OS_ERR_NONE;
S                 return (flags_rdy);
S             } else {                                           /* Block task until events occur or timeout             */
S                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
S                     CPU_CRITICAL_EXIT();
S                    *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
S                     return ((OS_FLAGS)0);
S                 } else {                                       /* Specified blocking so check is scheduler is locked   */
S                     if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
S                         CPU_CRITICAL_EXIT();
S                        *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
S                         return ((OS_FLAGS)0);
S                     }
S                 }
S                                                                /* Lock the scheduler/re-enable interrupts              */
S                 OS_CRITICAL_ENTER_CPU_EXIT();              
S                 OS_FlagBlock(&pend_data,
S                              p_grp,
S                              flags,
S                              opt,
S                              timeout);
S                 OS_CRITICAL_EXIT_NO_SCHED();
S             }
S             break;
S
S#if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
S        case OS_OPT_PEND_FLAG_CLR_ALL:                          /* See if all required flags are cleared                */
S             flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags);     /* Extract only the bits we want                        */
S             if (flags_rdy == flags) {                          /* Must match ALL the bits that we want                 */
S                 if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
S                     p_grp->Flags |= flags_rdy;                 /* Set ONLY the flags that we wanted                    */
S                 }
S                 OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S                 if (p_ts != DEF_NULL) {
S                    *p_ts  = p_grp->TS;
S                 }
S#endif
S                 CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S                 TRACE_OS_FLAG_PEND(p_grp);                     /* Record the event.                                    */
S#endif                 
S                *p_err = OS_ERR_NONE;
S                 return (flags_rdy);
S             } else {                                           /* Block task until events occur or timeout             */
S                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
S                     CPU_CRITICAL_EXIT();
S                    *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
S                     return ((OS_FLAGS)0);
S                 } else {                                       /* Specified blocking so check is scheduler is locked   */
S                     if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
S                         CPU_CRITICAL_EXIT();
S                        *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
S                         return (0);
S                     }
S                 }
S                                                            
S                 OS_CRITICAL_ENTER_CPU_EXIT();                  /* Lock the scheduler/re-enable interrupts              */
S                 OS_FlagBlock(&pend_data,
S                              p_grp,
S                              flags,
S                              opt,
S                              timeout);
S                 OS_CRITICAL_EXIT_NO_SCHED();
S             }
S             break;
S
S        case OS_OPT_PEND_FLAG_CLR_ANY:
S             flags_rdy = (~p_grp->Flags & flags);               /* Extract only the bits we want                        */
S             if (flags_rdy != 0u) {                             /* See if any flag cleared                              */
S                 if (consume == DEF_TRUE) {                     /* See if we need to consume the flags                  */
S                     p_grp->Flags |= flags_rdy;                 /* Set ONLY the flags that we got                       */
S                 }
S                 OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S                 if (p_ts != DEF_NULL) {
S                    *p_ts  = p_grp->TS;
S                 }
S#endif
S                 CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S                 TRACE_OS_FLAG_PEND(p_grp);                     /* Record the event.                                    */
S#endif
S                *p_err = OS_ERR_NONE;
S                 return (flags_rdy);
S             } else {                                           /* Block task until events occur or timeout             */
S                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
S                     CPU_CRITICAL_EXIT();
S                    *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
S                     return ((OS_FLAGS)0);
S                 } else {                                       /* Specified blocking so check is scheduler is locked   */
S                     if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
S                         CPU_CRITICAL_EXIT();
S                        *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
S                         return (0u);
S                     }
S                 }
S                                                            
S                 OS_CRITICAL_ENTER_CPU_EXIT();                  /* Lock the scheduler/re-enable interrupts              */
S                 OS_FlagBlock(&pend_data,              
S                              p_grp,
S                              flags,
S                              opt,
S                              timeout);
S                 OS_CRITICAL_EXIT_NO_SCHED();
S             }
S             break;
S#endif
S
S        default:
S             CPU_CRITICAL_EXIT();
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S             TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
S#endif
S            *p_err = OS_ERR_OPT_INVALID;
S             return (0u);
S    }
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S    TRACE_OS_FLAG_PEND_BLOCK(p_grp);                            /* Record the event.                                    */
S#endif
S    OSSched();                                                  /* Find next HPT ready to run                           */
S
S    CPU_CRITICAL_ENTER();
S    switch (OSTCBCurPtr->PendStatus) {
S        case OS_STATUS_PEND_OK:                                 /* We got the event flags                               */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S             if (p_ts != DEF_NULL) {
S                *p_ts = OSTCBCurPtr->TS;
S             }
S#endif
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S             TRACE_OS_FLAG_PEND(p_grp);                         /* Record the event.                                    */
S#endif
S            *p_err = OS_ERR_NONE;
S             break;
S
S        case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S             if (p_ts != DEF_NULL) {
S                *p_ts = OSTCBCurPtr->TS;
S             }
S#endif
S             CPU_CRITICAL_EXIT();
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S             TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
S#endif
S            *p_err = OS_ERR_PEND_ABORT;
S             break;
S
S        case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get semaphore within timeout */
S             if (p_ts != DEF_NULL) {
S                *p_ts = 0u;
S             }
S             CPU_CRITICAL_EXIT();
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S             TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
S#endif
S            *p_err = OS_ERR_TIMEOUT;
S             break;
S
S        case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S             if (p_ts != DEF_NULL) {
S                *p_ts = OSTCBCurPtr->TS;
S             }
S#endif
S             CPU_CRITICAL_EXIT();
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S             TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
S#endif
S            *p_err = OS_ERR_OBJ_DEL;
S             break;
S
S        default:
S             CPU_CRITICAL_EXIT();
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S             TRACE_OS_FLAG_PEND_FAILED(p_grp);                  /* Record the event.                                    */
S#endif
S            *p_err = OS_ERR_STATUS_INVALID;
S             break;
S    }
S    if (*p_err != OS_ERR_NONE) {
S        return (0u);
S    }
S
S    flags_rdy = OSTCBCurPtr->FlagsRdy;
S    if (consume == DEF_TRUE) {                                  /* See if we need to consume the flags                  */
S        switch (mode) {
S            case OS_OPT_PEND_FLAG_SET_ALL:
S            case OS_OPT_PEND_FLAG_SET_ANY:                      /* Clear ONLY the flags we got                          */
S                 p_grp->Flags &= ~flags_rdy;
S                 break;
S
S#if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
S            case OS_OPT_PEND_FLAG_CLR_ALL:
S            case OS_OPT_PEND_FLAG_CLR_ANY:                      /* Set   ONLY the flags we got                          */
S                 p_grp->Flags |=  flags_rdy;
S                 break;
S#endif
S            default:
S                 CPU_CRITICAL_EXIT();
S                *p_err = OS_ERR_OPT_INVALID;
S                 return (0u);
S        }
S    }
S    CPU_CRITICAL_EXIT();
S   *p_err = OS_ERR_NONE;                                        /* Event(s) must have occurred                          */
S    return (flags_rdy);
S}
S
S
S/*
S************************************************************************************************************************
S*                                          ABORT WAITING ON AN EVENT FLAG GROUP
S*
S* Description: This function aborts & readies any tasks currently waiting on an event flag group.  This function should
S*              be used to fault-abort the wait on the event flag group, rather than to normally post to the event flag
S*              group OSFlagPost().
S*
S* Arguments  : p_grp     is a pointer to the event flag group
S*
S*              opt       determines the type of ABORT performed:
S*
S*                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the event flag
S*                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the event flag
S*                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
S*
S*              p_err     is a pointer to a variable that will contain an error code returned by this function.
S*
S*                            OS_ERR_NONE                  At least one task waiting on the event flag group and was
S*                                                         readied and informed of the aborted wait; check return value
S*                                                         for the number of tasks whose wait on the event flag group
S*                                                         was aborted
S*                            OS_ERR_OBJ_PTR_NULL          If 'p_grp' is a NULL pointer
S*                            OS_ERR_OBJ_TYPE              If 'p_grp' is not pointing at an event flag group
S*                            OS_ERR_OPT_INVALID           If you specified an invalid option
S*                            OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
S*                            OS_ERR_PEND_ABORT_ISR        If you called this function from an ISR
S*                            OS_ERR_PEND_ABORT_NONE       No task were pending
S*
S* Returns    : == 0          if no tasks were waiting on the event flag group, or upon error.
S*              >  0          if one or more tasks waiting on the event flag group are now readied and informed.
S*
S* Note(s)    : none
S************************************************************************************************************************
S*/
S
S#if (OS_CFG_FLAG_PEND_ABORT_EN == DEF_ENABLED)
SOS_OBJ_QTY  OSFlagPendAbort (OS_FLAG_GRP  *p_grp,
S                             OS_OPT        opt,
S                             OS_ERR       *p_err)
S{
S    OS_PEND_LIST  *p_pend_list;
S    OS_TCB        *p_tcb;
S    CPU_TS         ts;
S    OS_OBJ_QTY     nbr_tasks;
S    CPU_SR_ALLOC();
S
S
S
S#ifdef OS_SAFETY_CRITICAL
S    if (p_err == DEF_NULL) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return ((OS_OBJ_QTY)0u);
S    }
S#endif
S
S#if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
S    if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
S       *p_err = OS_ERR_PEND_ABORT_ISR;
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
S    if (OSRunning != OS_STATE_OS_RUNNING) {
S       *p_err = OS_ERR_OS_NOT_RUNNING;
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
S    if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
S       *p_err  =  OS_ERR_OBJ_PTR_NULL;
S        return (0u);
S    }
S    switch (opt) {                                              /* Validate 'opt'                                       */
S        case OS_OPT_PEND_ABORT_1:
S        case OS_OPT_PEND_ABORT_ALL:
S        case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
S        case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
S             break;
S
S        default:
S            *p_err = OS_ERR_OPT_INVALID;
S             return (0u);
S    }
S#endif
S
S#if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
S    if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Make sure event flag group was created               */
S       *p_err = OS_ERR_OBJ_TYPE;
S        return (0u);
S    }
S#endif
S
S    CPU_CRITICAL_ENTER();
S    p_pend_list = &p_grp->PendList;
S    if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on flag group?                      */
S        CPU_CRITICAL_EXIT();                                    /* No                                                   */
S       *p_err = OS_ERR_PEND_ABORT_NONE;
S        return (0u);
S    }
S
S    OS_CRITICAL_ENTER_CPU_EXIT();
S    nbr_tasks = 0u;
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S    ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
S#else
S    ts        = 0u;
S#endif
S
S    while (p_pend_list->HeadPtr != DEF_NULL) {
S        p_tcb = p_pend_list->HeadPtr->TCBPtr;
S        OS_PendAbort((OS_PEND_OBJ *)((void *)p_grp),
S                     p_tcb,
S                     ts);
S        nbr_tasks++;
S        if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
S            break;                                              /* No                                                   */
S        }
S    }
S    OS_CRITICAL_EXIT_NO_SCHED();
S
S    if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
S        OSSched();                                              /* Run the scheduler                                    */
S    }
S
S   *p_err = OS_ERR_NONE;
S    return (nbr_tasks);
S}
S#endif
S
S
S/*
S************************************************************************************************************************
S*                                       GET FLAGS WHO CAUSED TASK TO BECOME READY
S*
S* Description: This function is called to obtain the flags that caused the task to become ready to run.
S*              In other words, this function allows you to tell "Who done it!".
S*
S* Arguments  : p_err     is a pointer to an error code
S*
S*                            OS_ERR_NONE              If the call was successful
S*                            OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
S*                            OS_ERR_PEND_ISR          If called from an ISR
S*
S* Returns    : The flags that caused the task to be ready.
S*
S* Note(s)    : none
S************************************************************************************************************************
S*/
S
SOS_FLAGS  OSFlagPendGetFlagsRdy (OS_ERR  *p_err)
S{
S    OS_FLAGS   flags;
S    CPU_SR_ALLOC();
S
S
S
S#ifdef OS_SAFETY_CRITICAL
S    if (p_err == DEF_NULL) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return ((OS_FLAGS)0);
S    }
S#endif
S
S#if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
S    if (OSRunning != OS_STATE_OS_RUNNING) {
S       *p_err = OS_ERR_OS_NOT_RUNNING;
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
S    if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
S       *p_err = OS_ERR_PEND_ISR;                                /* ... can't get from an ISR                            */
S        return (0u);
S    }
S#endif
S
S    CPU_CRITICAL_ENTER();
S    flags = OSTCBCurPtr->FlagsRdy;
S    CPU_CRITICAL_EXIT();
S   *p_err = OS_ERR_NONE;
S    return (flags);
S}
S
S
S/*
S************************************************************************************************************************
S*                                                POST EVENT FLAG BIT(S)
S*
S* Description: This function is called to set or clear some bits in an event flag group.  The bits to set or clear are
S*              specified by a 'bit mask'.
S*
S* Arguments  : p_grp         is a pointer to the desired event flag group.
S*
S*              flags         If 'opt' (see below) is OS_OPT_POST_FLAG_SET, each bit that is set in 'flags' will
S*                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
S*                            and 5 you would set 'flags' to:
S*
S*                                0x31     (note, bit 0 is least significant bit)
S*
S*                            If 'opt' (see below) is OS_OPT_POST_FLAG_CLR, each bit that is set in 'flags' will
S*                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
S*                            4 and 5 you would specify 'flags' as:
S*
S*                                0x31     (note, bit 0 is least significant bit)
S*
S*              opt           indicates whether the flags will be:
S*
S*                                OS_OPT_POST_FLAG_SET       set
S*                                OS_OPT_POST_FLAG_CLR       cleared
S*
S*                            you can also 'add' OS_OPT_POST_NO_SCHED to prevent the scheduler from being called.
S*
S*              p_err         is a pointer to an error code and can be:
S*
S*                                OS_ERR_NONE                The call was successful
S*                                OS_ERR_INT_Q_FULL          If the deferred interrupt post queue is full
S*                                OS_ERR_OBJ_PTR_NULL        You passed a NULL pointer
S*                                OS_ERR_OBJ_TYPE            You are not pointing to an event flag group
S*                                OS_ERR_OPT_INVALID         You specified an invalid option
S*                                OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
S*
S* Returns    : the new value of the event flags bits that are still set.
S*
S* Note(s)    : 1) The execution time of this function depends on the number of tasks waiting on the event flag group.
S************************************************************************************************************************
S*/
S
SOS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,
S                      OS_FLAGS      flags,
S                      OS_OPT        opt,
S                      OS_ERR       *p_err)
S{
S    OS_FLAGS  flags_cur;
S    CPU_TS    ts;
S
S
S
S#ifdef OS_SAFETY_CRITICAL
S    if (p_err == DEF_NULL) {
S        OS_SAFETY_CRITICAL_EXCEPTION();
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
S    if (OSRunning != OS_STATE_OS_RUNNING) {
S       *p_err = OS_ERR_OS_NOT_RUNNING;
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
S    if (p_grp == DEF_NULL) {                                    /* Validate 'p_grp'                                     */
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S        TRACE_OS_FLAG_POST_FAILED(p_grp);                       /* Record the event.                                    */
S#endif
S       *p_err  = OS_ERR_OBJ_PTR_NULL;
S        return (0u);
S    }
S    switch (opt) {                                              /* Validate 'opt'                                       */
S        case OS_OPT_POST_FLAG_SET:
S        case OS_OPT_POST_FLAG_CLR:
S        case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
S        case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
S             break;
S
S        default:
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S             TRACE_OS_FLAG_POST_FAILED(p_grp);                  /* Record the event.                                    */
S#endif
S            *p_err = OS_ERR_OPT_INVALID;
S             return (0u);
S    }
S#endif
S
S#if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
S    if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Make sure we are pointing to an event flag grp       */
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S        TRACE_OS_FLAG_POST_FAILED(p_grp);                       /* Record the event.                                    */
S#endif
S       *p_err = OS_ERR_OBJ_TYPE;
S        return (0u);
S    }
S#endif
S
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S    ts = OS_TS_GET();                                           /* Get timestamp                                        */
S#else
S    ts = 0u;
S#endif
S#if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
S    if (OSIntNestingCtr > 0u) {                                 /* See if called from an ISR                            */
S        OS_IntQPost(OS_OBJ_TYPE_FLAG,                           /* Post to ISR queue                                    */
S                    (void *)p_grp,
S                    DEF_NULL,
S                    0u,
S                    flags,
S                    opt,
S                    ts,
S                    p_err);
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S        TRACE_OS_FLAG_POST(p_grp);                              /* Record the event.                                    */
S#endif
S        return (0u);
S    }
S#endif
S
S    flags_cur = OS_FlagPost(p_grp,
S                            flags,
S                            opt,
S                            ts,
S                            p_err);
S
S#if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
S    TRACE_OS_FLAG_POST(p_grp);                                  /* Record the event.                                    */
S#endif    
S
S    return (flags_cur);
S}
S
S
S/*
S************************************************************************************************************************
S*                         SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
S*
S* Description: This function is internal to uC/OS-III and is used to put a task to sleep until the desired
S*              event flag bit(s) are set.
S*
S* Arguments  : p_pend_data    is a pointer to an object used to link the task being blocked to the list of task(s)
S*              -----------    pending on the desired event flag group.
S*
S*              p_grp         is a pointer to the desired event flag group.
S*              -----
S*
S*              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
S*                            The bits you want are specified by setting the corresponding bits in
S*                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
S*                            'flags' would contain 0x03.
S*
S*              opt           specifies whether you want ALL bits to be set/cleared or ANY of the bits
S*                            to be set/cleared.
S*                            You can specify the following argument:
S*
S*                                OS_OPT_PEND_FLAG_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
S*                                OS_OPT_PEND_FLAG_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
S*                                OS_OPT_PEND_FLAG_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
S*                                OS_OPT_PEND_FLAG_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
S*
S*              timeout       is the desired amount of time that the task will wait for the event flag
S*                            bit(s) to be set.
S*
S* Returns    : none
S*
S* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
S************************************************************************************************************************
S*/
S
Svoid  OS_FlagBlock (OS_PEND_DATA  *p_pend_data,
S                    OS_FLAG_GRP   *p_grp,
S                    OS_FLAGS       flags,
S                    OS_OPT         opt,
S                    OS_TICK        timeout)
S{
S    OSTCBCurPtr->FlagsPend = flags;                             /* Save the flags that we need to wait for              */
S    OSTCBCurPtr->FlagsOpt  = opt;                               /* Save the type of wait we are doing                   */
S    OSTCBCurPtr->FlagsRdy  = 0u;
S
S    OS_Pend(p_pend_data,
S            (OS_PEND_OBJ *)((void *)p_grp),
S             OS_TASK_PEND_ON_FLAG,
S             timeout);
S}
S
S
S/*
S************************************************************************************************************************
S*                                      CLEAR THE CONTENTS OF AN EVENT FLAG GROUP
S*
S* Description: This function is called by OSFlagDel() to clear the contents of an event flag group
S*
S
S* Argument(s): p_grp     is a pointer to the event flag group to clear
S*              -----
S*
S* Returns    : none
S*
S* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
S************************************************************************************************************************
S*/
S
Svoid  OS_FlagClr (OS_FLAG_GRP  *p_grp)
S{
S    OS_PEND_LIST  *p_pend_list;
S
S
S#if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
S    p_grp->Type             = OS_OBJ_TYPE_NONE;
S#endif
S#if (OS_CFG_DBG_EN == DEF_ENABLED)
S    p_grp->NamePtr          = (CPU_CHAR *)((void *)"?FLAG");    /* Unknown name                                         */
S#endif
S    p_grp->Flags            =  0u;
S    p_pend_list             = &p_grp->PendList;
S    OS_PendListInit(p_pend_list);
S}
S
S
S/*
S************************************************************************************************************************
S*                                    ADD/REMOVE EVENT FLAG GROUP TO/FROM DEBUG LIST
S*
S* Description: These functions are called by uC/OS-III to add or remove an event flag group from the event flag debug
S*              list.
S*
S* Arguments  : p_grp     is a pointer to the event flag group to add/remove
S*
S* Returns    : none
S*
S* Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
S************************************************************************************************************************
S*/
S
S#if (OS_CFG_DBG_EN == DEF_ENABLED)
Svoid  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
S{
S    p_grp->DbgNamePtr                = (CPU_CHAR *)((void *)" ");
S    p_grp->DbgPrevPtr                = DEF_NULL;
S    if (OSFlagDbgListPtr == DEF_NULL) {
S        p_grp->DbgNextPtr            = DEF_NULL;
S    } else {
S        p_grp->DbgNextPtr            = OSFlagDbgListPtr;
S        OSFlagDbgListPtr->DbgPrevPtr = p_grp;
S    }
S    OSFlagDbgListPtr                 = p_grp;
S}
S
S
S
Svoid  OS_FlagDbgListRemove (OS_FLAG_GRP  *p_grp)
S{
S    OS_FLAG_GRP  *p_grp_next;
S    OS_FLAG_GRP  *p_grp_prev;
S
S
S    p_grp_prev = p_grp->DbgPrevPtr;
S    p_grp_next = p_grp->DbgNextPtr;
S
S    if (p_grp_prev == DEF_NULL) {
S        OSFlagDbgListPtr = p_grp_next;
S        if (p_grp_next != DEF_NULL) {
S            p_grp_next->DbgPrevPtr = DEF_NULL;
S        }
S        p_grp->DbgNextPtr = DEF_NULL;
S
S    } else if (p_grp_next == DEF_NULL) {
S        p_grp_prev->DbgNextPtr = DEF_NULL;
S        p_grp->DbgPrevPtr      = DEF_NULL;
S
S    } else {
S        p_grp_prev->DbgNextPtr =  p_grp_next;
S        p_grp_next->DbgPrevPtr =  p_grp_prev;
S        p_grp->DbgNextPtr      = DEF_NULL;
S        p_grp->DbgPrevPtr      = DEF_NULL;
S    }
S}
S#endif
S
S
S/*
S************************************************************************************************************************
S*                                                POST EVENT FLAG BIT(S)
S*
S* Description: This function is called to set or clear some bits in an event flag group.  The bits to set or clear are
S*              specified by a 'bit mask'.
S*
S* Arguments  : p_grp         is a pointer to the desired event flag group.
S*
S*              flags         If 'opt' (see below) is OS_OPT_POST_FLAG_SET, each bit that is set in 'flags' will
S*                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
S*                            and 5 you would set 'flags' to:
S*
S*                                0x31     (note, bit 0 is least significant bit)
S*
S*                            If 'opt' (see below) is OS_OPT_POST_FLAG_CLR, each bit that is set in 'flags' will
S*                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
S*                            4 and 5 you would specify 'flags' as:
S*
S*                                0x31     (note, bit 0 is least significant bit)
S*
S*              opt           indicates whether the flags will be:
S*
S*                                OS_OPT_POST_FLAG_SET       set
S*                                OS_OPT_POST_FLAG_CLR       cleared
S*
S*                            you can also 'add' OS_OPT_POST_NO_SCHED to prevent the scheduler from being called.
S*
S*              ts            is the timestamp of the post
S*
S*              p_err         is a pointer to an error code and can be:
S*
S*                                OS_ERR_NONE                The call was successful
S*                                OS_ERR_OBJ_PTR_NULL        You passed a NULL pointer
S*                                OS_ERR_OBJ_TYPE            You are not pointing to an event flag group
S*                                OS_ERR_FLAG_PEND_OPT       You specified an invalid option
S*
S* Returns    : the new value of the event flags bits that are still set.
S*
S* Note(s)    : 1) The execution time of this function depends on the number of tasks waiting on the event flag group.
S************************************************************************************************************************
S*/
S
SOS_FLAGS  OS_FlagPost (OS_FLAG_GRP  *p_grp,
S                       OS_FLAGS      flags,
S                       OS_OPT        opt,
S                       CPU_TS        ts,
S                       OS_ERR       *p_err)
S{
S    OS_FLAGS        flags_cur;
S    OS_FLAGS        flags_rdy;
S    OS_OPT          mode;
S    OS_PEND_DATA   *p_pend_data;
S    OS_PEND_DATA   *p_pend_data_next;
S    OS_PEND_LIST   *p_pend_list;
S    OS_TCB         *p_tcb;
S    CPU_SR_ALLOC();
S
S
S#if (OS_CFG_TS_EN == DEF_DISABLED)
S    (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
S#endif
S
S    CPU_CRITICAL_ENTER();
S    switch (opt) {
S        case OS_OPT_POST_FLAG_SET:
S        case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
S             p_grp->Flags |=  flags;                            /* Set   the flags specified in the group               */
S             break;
S
S        case OS_OPT_POST_FLAG_CLR:
S        case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
S             p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group               */
S             break;
S
S        default:
S             CPU_CRITICAL_EXIT();                               /* INVALID option                                       */
S            *p_err = OS_ERR_OPT_INVALID;
S             return (0u);
S    }
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S    p_grp->TS   = ts;
S#endif
S    p_pend_list = &p_grp->PendList;
S    if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on event flag group?                */
S        CPU_CRITICAL_EXIT();                                    /* No                                                   */
S       *p_err = OS_ERR_NONE;
S        return (p_grp->Flags);
S    }
S
S    OS_CRITICAL_ENTER_CPU_EXIT();
S    p_pend_data = p_pend_list->HeadPtr;
S    p_tcb       = p_pend_data->TCBPtr;
S    while (p_tcb != DEF_NULL) {                                 /* Go through all tasks waiting on event flag(s)        */
S        p_pend_data_next = p_pend_data->NextPtr;
S        mode             = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
S        switch (mode) {
S            case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all req. flags are set for current node       */
S                 flags_rdy = (p_grp->Flags & p_tcb->FlagsPend);
S                 if (flags_rdy == p_tcb->FlagsPend) {
S                     OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
S                                    flags_rdy,
S                                    ts);
S                 }
S                 break;
S
S            case OS_OPT_PEND_FLAG_SET_ANY:                      /* See if any flag set                                  */
S                 flags_rdy = (p_grp->Flags & p_tcb->FlagsPend);
S                 if (flags_rdy != 0u) {
S                     OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
S                                    flags_rdy,
S                                    ts);
S                 }
S                 break;
S
S#if (OS_CFG_FLAG_MODE_CLR_EN == DEF_ENABLED)
S            case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all req. flags are set for current node       */
S                 flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
S                 if (flags_rdy == p_tcb->FlagsPend) {
S                     OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
S                                    flags_rdy,
S                                    ts);
S                 }
S                 break;
S
S            case OS_OPT_PEND_FLAG_CLR_ANY:                      /* See if any flag set                                  */
S                 flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
S                 if (flags_rdy != 0u) {
S                     OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
S                                    flags_rdy,
S                                    ts);
S                 }
S                 break;
S#endif
S            default:
S                 OS_CRITICAL_EXIT();
S                *p_err = OS_ERR_FLAG_PEND_OPT;
S                 return (0u);
S        }
S        p_pend_data = p_pend_data_next;                         /* Point to next task waiting for event flag(s)         */
S        if (p_pend_data != DEF_NULL) {
S            p_tcb = p_pend_data->TCBPtr;
S        } else {
S            p_tcb = DEF_NULL;
S        }
S    }
S    OS_CRITICAL_EXIT_NO_SCHED();
S
S    if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
S        OSSched();
S    }
S
S    CPU_CRITICAL_ENTER();
S    flags_cur = p_grp->Flags;
S    CPU_CRITICAL_EXIT();
S   *p_err     = OS_ERR_NONE;
S    return (flags_cur);
S}
S
S
S/*
S************************************************************************************************************************
S*                                        MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
S*
S* Description: This function is internal to uC/OS-III and is used to make a task ready-to-run because the desired event
S*              flag bits have been set.
S*
S* Arguments  : p_tcb         is a pointer to the OS_TCB of the task to remove
S*              -----
S*
S*              flags_rdy     contains the bit pattern of the event flags that cause the task to become ready-to-run.
S*
S*              ts            is a timestamp associated with the post
S*
S* Returns    : none
S*
S* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
S************************************************************************************************************************
S*/
S
Svoid   OS_FlagTaskRdy (OS_TCB    *p_tcb,
S                       OS_FLAGS   flags_rdy,
S                       CPU_TS     ts)
S{
S#if (OS_CFG_TS_EN == DEF_DISABLED)
S    (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
S#endif
S
S    p_tcb->FlagsRdy   = flags_rdy;
S    p_tcb->PendStatus = OS_STATUS_PEND_OK;                      /* Clear pend status                                    */
S    p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;                /* Indicate no longer pending                           */
S#if (OS_CFG_TS_EN == DEF_ENABLED)
S    p_tcb->TS         = ts;
S#endif
S    switch (p_tcb->TaskState) {
S        case OS_TASK_STATE_PEND:
S        case OS_TASK_STATE_PEND_TIMEOUT:
S#if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
S             if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
S                 OS_TickListRemove(p_tcb);                      /* Remove from tick list                                */
S             }
S#endif
S             OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
S             p_tcb->TaskState = OS_TASK_STATE_RDY;
S             break;
S
S        case OS_TASK_STATE_PEND_SUSPENDED:
S        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
S             p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
S             break;
S
S        case OS_TASK_STATE_RDY:
S        case OS_TASK_STATE_DLY:
S        case OS_TASK_STATE_DLY_SUSPENDED:
S        case OS_TASK_STATE_SUSPENDED:
S        default:
S             break;
S    }
S    OS_PendListRemove(p_tcb);
S}
N#endif
