; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\os_core.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\os_core.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\os_core.crf ..\..\uCOS-III\uCOS-III\Source\os_core.c]
                          THUMB

                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=2

                  OSInit PROC
;;;56     
;;;57     void  OSInit (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;58     {
000002  4604              MOV      r4,r0
;;;59     #if (OS_CFG_ISR_STK_SIZE > 0u)
;;;60         CPU_STK      *p_stk;
;;;61         CPU_STK_SIZE  size;
;;;62     #endif
;;;63     
;;;64     
;;;65     
;;;66     #ifdef OS_SAFETY_CRITICAL
;;;67         if (p_err == DEF_NULL) {
;;;68             OS_SAFETY_CRITICAL_EXCEPTION();
;;;69             return;
;;;70         }
;;;71     #endif
;;;72     
;;;73         OSInitHook();                                               /* Call port specific initialization code               */
000004  f7fffffe          BL       OSInitHook
;;;74     
;;;75         OSIntNestingCtr       = 0u;                                 /* Clear the interrupt nesting counter                  */
000008  2000              MOVS     r0,#0
00000a  4931              LDR      r1,|L1.208|
00000c  7008              STRB     r0,[r1,#0]
;;;76     
;;;77         OSRunning             = OS_STATE_OS_STOPPED;                /* Indicate that multitasking not started               */
00000e  4931              LDR      r1,|L1.212|
000010  7008              STRB     r0,[r1,#0]
;;;78     
;;;79         OSSchedLockNestingCtr = 0u;                                 /* Clear the scheduling lock counter                    */
000012  4931              LDR      r1,|L1.216|
000014  7008              STRB     r0,[r1,#0]
;;;80     
;;;81         OSTCBCurPtr           = DEF_NULL;                           /* Initialize OS_TCB pointers to a known state          */
000016  4931              LDR      r1,|L1.220|
000018  6008              STR      r0,[r1,#0]  ; OSTCBCurPtr
;;;82         OSTCBHighRdyPtr       = DEF_NULL;
00001a  4931              LDR      r1,|L1.224|
00001c  6008              STR      r0,[r1,#0]  ; OSTCBHighRdyPtr
;;;83     
;;;84         OSPrioCur             = 0u;                                 /* Initialize priority variables to a known state       */
00001e  4931              LDR      r1,|L1.228|
000020  7008              STRB     r0,[r1,#0]
;;;85         OSPrioHighRdy         = 0u;
000022  4931              LDR      r1,|L1.232|
000024  7008              STRB     r0,[r1,#0]
;;;86     #if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
;;;87         OSPrioSaved           = 0u;
;;;88     #endif
;;;89     
;;;90     #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
;;;91         OSSchedLockTimeBegin  = 0u;
;;;92         OSSchedLockTimeMax    = 0u;
;;;93         OSSchedLockTimeMaxCur = 0u;
;;;94     #endif
;;;95     
;;;96     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;97         OSSafetyCriticalStartFlag       =  DEF_FALSE;
;;;98     #endif
;;;99     
;;;100    #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
;;;101        OSSchedRoundRobinEn             = DEF_FALSE;
;;;102        OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
;;;103    #endif
;;;104    
;;;105    #if (OS_CFG_ISR_STK_SIZE > 0u)
;;;106        p_stk = OSCfg_ISRStkBasePtr;                                /* Clear exception stack for stack checking.            */
000026  4831              LDR      r0,|L1.236|
000028  6805              LDR      r5,[r0,#0]  ; OSCfg_ISRStkBasePtr
;;;107        if (p_stk != DEF_NULL) {
00002a  b145              CBZ      r5,|L1.62|
;;;108            size  = OSCfg_ISRStkSize;
00002c  4830              LDR      r0,|L1.240|
00002e  6806              LDR      r6,[r0,#0]  ; OSCfg_ISRStkSize
;;;109            while (size > 0u) {
000030  e003              B        |L1.58|
                  |L1.50|
;;;110                size--;
000032  1e76              SUBS     r6,r6,#1
;;;111               *p_stk = 0u;
000034  2000              MOVS     r0,#0
000036  6028              STR      r0,[r5,#0]
;;;112                p_stk++;
000038  1d2d              ADDS     r5,r5,#4
                  |L1.58|
00003a  2e00              CMP      r6,#0                 ;109
00003c  d1f9              BNE      |L1.50|
                  |L1.62|
;;;113            }
;;;114        }
;;;115    #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)                 /* Initialize Redzoned ISR stack                        */
;;;116        OS_TaskStkRedzoneInit(OSCfg_ISRStkBasePtr, OSCfg_ISRStkSize);
;;;117    #endif
;;;118    #endif
;;;119    
;;;120    #if (OS_CFG_APP_HOOKS_EN == DEF_ENABLED)                        /* Clear application hook pointers                      */
;;;121    #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
;;;122        OS_AppRedzoneHitHookPtr = DEF_NULL;
;;;123    #endif
;;;124        OS_AppTaskCreateHookPtr = DEF_NULL;
00003e  2000              MOVS     r0,#0
000040  492c              LDR      r1,|L1.244|
000042  6008              STR      r0,[r1,#0]  ; OS_AppTaskCreateHookPtr
;;;125        OS_AppTaskDelHookPtr    = DEF_NULL;
000044  492c              LDR      r1,|L1.248|
000046  6008              STR      r0,[r1,#0]  ; OS_AppTaskDelHookPtr
;;;126        OS_AppTaskReturnHookPtr = DEF_NULL;
000048  492c              LDR      r1,|L1.252|
00004a  6008              STR      r0,[r1,#0]  ; OS_AppTaskReturnHookPtr
;;;127    
;;;128        OS_AppIdleTaskHookPtr   = DEF_NULL;
00004c  492c              LDR      r1,|L1.256|
00004e  6008              STR      r0,[r1,#0]  ; OS_AppIdleTaskHookPtr
;;;129        OS_AppStatTaskHookPtr   = DEF_NULL;
000050  492c              LDR      r1,|L1.260|
000052  6008              STR      r0,[r1,#0]  ; OS_AppStatTaskHookPtr
;;;130        OS_AppTaskSwHookPtr     = DEF_NULL;
000054  492c              LDR      r1,|L1.264|
000056  6008              STR      r0,[r1,#0]  ; OS_AppTaskSwHookPtr
;;;131        OS_AppTimeTickHookPtr   = DEF_NULL;
000058  492c              LDR      r1,|L1.268|
00005a  6008              STR      r0,[r1,#0]  ; OS_AppTimeTickHookPtr
;;;132    #endif
;;;133    
;;;134    #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
;;;135        OSTaskRegNextAvailID    = 0u;
00005c  492c              LDR      r1,|L1.272|
00005e  7008              STRB     r0,[r1,#0]
;;;136    #endif
;;;137    
;;;138        OS_PrioInit();                                              /* Initialize the priority bitmap table                 */
000060  f7fffffe          BL       OS_PrioInit
;;;139    
;;;140        OS_RdyListInit();                                           /* Initialize the Ready List                            */
000064  f7fffffe          BL       OS_RdyListInit
;;;141    
;;;142    
;;;143    #if (OS_CFG_FLAG_EN == DEF_ENABLED)                             /* Initialize the Event Flag module                     */
;;;144    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;145        OSFlagDbgListPtr = DEF_NULL;
;;;146        OSFlagQty        = 0u;
;;;147    #endif
;;;148    #endif
;;;149    
;;;150    #if (OS_CFG_MEM_EN == DEF_ENABLED)                              /* Initialize the Memory Manager module                 */
;;;151        OS_MemInit(p_err);
;;;152        if (*p_err != OS_ERR_NONE) {
;;;153            return;
;;;154        }
;;;155    #endif
;;;156    
;;;157    
;;;158    #if (OS_MSG_EN == DEF_ENABLED)                                  /* Initialize the free list of OS_MSGs                  */
;;;159        OS_MsgPoolInit(p_err);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       OS_MsgPoolInit
;;;160        if (*p_err != OS_ERR_NONE) {
00006e  8820              LDRH     r0,[r4,#0]
000070  b100              CBZ      r0,|L1.116|
                  |L1.114|
;;;161            return;
;;;162        }
;;;163    #endif
;;;164    
;;;165    
;;;166    #if (OS_CFG_MUTEX_EN == DEF_ENABLED)                            /* Initialize the Mutex Manager module                  */
;;;167    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;168        OSMutexDbgListPtr = DEF_NULL;
;;;169        OSMutexQty        = 0u;
;;;170    #endif
;;;171    #endif
;;;172    
;;;173    
;;;174    #if (OS_CFG_Q_EN == DEF_ENABLED)                                /* Initialize the Message Queue Manager module          */
;;;175    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;176        OSQDbgListPtr = DEF_NULL;
;;;177        OSQQty        = 0u;
;;;178    #endif
;;;179    #endif
;;;180    
;;;181    
;;;182    #if (OS_CFG_SEM_EN == DEF_ENABLED)                              /* Initialize the Semaphore Manager module              */
;;;183    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;184        OSSemDbgListPtr = DEF_NULL;
;;;185        OSSemQty        = 0u;
;;;186    #endif
;;;187    #endif
;;;188    
;;;189    
;;;190    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;191        OS_TLS_Init(p_err);                                         /* Initialize Task Local Storage, before creating tasks */
;;;192        if (*p_err != OS_ERR_NONE) {
;;;193            return;
;;;194        }
;;;195    #endif
;;;196    
;;;197    
;;;198        OS_TaskInit(p_err);                                         /* Initialize the task manager                          */
;;;199        if (*p_err != OS_ERR_NONE) {
;;;200            return;
;;;201        }
;;;202    
;;;203    
;;;204    #if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
;;;205        OS_IntQTaskInit(p_err);                                     /* Initialize the Interrupt Queue Handler Task          */
;;;206        if (*p_err != OS_ERR_NONE) {
;;;207            return;
;;;208        }
;;;209    #endif
;;;210    
;;;211    
;;;212    #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
;;;213        OS_IdleTaskInit(p_err);                                     /* Initialize the Idle Task                             */
;;;214        if (*p_err != OS_ERR_NONE) {
;;;215            return;
;;;216        }
;;;217    #endif
;;;218    
;;;219    
;;;220    #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;221        OS_TickTaskInit(p_err);                                     /* Initialize the Tick Task                             */
;;;222        if (*p_err != OS_ERR_NONE) {
;;;223            return;
;;;224        }
;;;225    #endif
;;;226    
;;;227    
;;;228    #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)                        /* Initialize the Statistic Task                        */
;;;229        OS_StatTaskInit(p_err);
;;;230        if (*p_err != OS_ERR_NONE) {
;;;231            return;
;;;232        }
;;;233    #endif
;;;234    
;;;235    
;;;236    #if (OS_CFG_TMR_EN == DEF_ENABLED)                              /* Initialize the Timer Manager module                  */
;;;237        OS_TmrInit(p_err);
;;;238        if (*p_err != OS_ERR_NONE) {
;;;239            return;
;;;240        }
;;;241    #endif
;;;242    
;;;243    
;;;244    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;245        OS_Dbg_Init();
;;;246    #endif
;;;247    
;;;248    
;;;249        OSCfg_Init();
;;;250    
;;;251        OSInitialized = DEF_TRUE;                                   /* Kernel is initialized                                */
;;;252    }
000072  bd70              POP      {r4-r6,pc}
                  |L1.116|
000074  2000              MOVS     r0,#0                 ;168
000076  4927              LDR      r1,|L1.276|
000078  6008              STR      r0,[r1,#0]            ;168  ; OSMutexDbgListPtr
00007a  4927              LDR      r1,|L1.280|
00007c  8008              STRH     r0,[r1,#0]            ;169
00007e  4927              LDR      r1,|L1.284|
000080  6008              STR      r0,[r1,#0]            ;176  ; OSQDbgListPtr
000082  4927              LDR      r1,|L1.288|
000084  8008              STRH     r0,[r1,#0]            ;177
000086  4927              LDR      r1,|L1.292|
000088  6008              STR      r0,[r1,#0]            ;184  ; OSSemDbgListPtr
00008a  4927              LDR      r1,|L1.296|
00008c  8008              STRH     r0,[r1,#0]            ;185
00008e  4620              MOV      r0,r4                 ;198
000090  f7fffffe          BL       OS_TaskInit
000094  8820              LDRH     r0,[r4,#0]            ;199
000096  b100              CBZ      r0,|L1.154|
000098  e7eb              B        |L1.114|
                  |L1.154|
00009a  4620              MOV      r0,r4                 ;213
00009c  f7fffffe          BL       OS_IdleTaskInit
0000a0  8820              LDRH     r0,[r4,#0]            ;214
0000a2  b100              CBZ      r0,|L1.166|
0000a4  e7e5              B        |L1.114|
                  |L1.166|
0000a6  4620              MOV      r0,r4                 ;221
0000a8  f7fffffe          BL       OS_TickTaskInit
0000ac  8820              LDRH     r0,[r4,#0]            ;222
0000ae  b100              CBZ      r0,|L1.178|
0000b0  e7df              B        |L1.114|
                  |L1.178|
0000b2  4620              MOV      r0,r4                 ;237
0000b4  f7fffffe          BL       OS_TmrInit
0000b8  8820              LDRH     r0,[r4,#0]            ;238
0000ba  b100              CBZ      r0,|L1.190|
0000bc  e7d9              B        |L1.114|
                  |L1.190|
0000be  f7fffffe          BL       OS_Dbg_Init
0000c2  f7fffffe          BL       OSCfg_Init
0000c6  2001              MOVS     r0,#1                 ;251
0000c8  4918              LDR      r1,|L1.300|
0000ca  7008              STRB     r0,[r1,#0]            ;251
0000cc  bf00              NOP      
0000ce  e7d0              B        |L1.114|
;;;253    
                          ENDP

                  |L1.208|
                          DCD      OSIntNestingCtr
                  |L1.212|
                          DCD      OSRunning
                  |L1.216|
                          DCD      OSSchedLockNestingCtr
                  |L1.220|
                          DCD      OSTCBCurPtr
                  |L1.224|
                          DCD      OSTCBHighRdyPtr
                  |L1.228|
                          DCD      OSPrioCur
                  |L1.232|
                          DCD      OSPrioHighRdy
                  |L1.236|
                          DCD      OSCfg_ISRStkBasePtr
                  |L1.240|
                          DCD      OSCfg_ISRStkSize
                  |L1.244|
                          DCD      OS_AppTaskCreateHookPtr
                  |L1.248|
                          DCD      OS_AppTaskDelHookPtr
                  |L1.252|
                          DCD      OS_AppTaskReturnHookPtr
                  |L1.256|
                          DCD      OS_AppIdleTaskHookPtr
                  |L1.260|
                          DCD      OS_AppStatTaskHookPtr
                  |L1.264|
                          DCD      OS_AppTaskSwHookPtr
                  |L1.268|
                          DCD      OS_AppTimeTickHookPtr
                  |L1.272|
                          DCD      OSTaskRegNextAvailID
                  |L1.276|
                          DCD      OSMutexDbgListPtr
                  |L1.280|
                          DCD      OSMutexQty
                  |L1.284|
                          DCD      OSQDbgListPtr
                  |L1.288|
                          DCD      OSQQty
                  |L1.292|
                          DCD      OSSemDbgListPtr
                  |L1.296|
                          DCD      OSSemQty
                  |L1.300|
                          DCD      OSInitialized

                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;282    
;;;283    void  OSIntEnter (void)
000000  4808              LDR      r0,|L2.36|
;;;284    {
;;;285        if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is OS running?                                       */
000002  7800              LDRB     r0,[r0,#0]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d000              BEQ      |L2.10|
                  |L2.8|
;;;286            return;                                                 /* No                                                   */
;;;287        }
;;;288    
;;;289        if (OSIntNestingCtr >= 250u) {                              /* Have we nested past 250 levels?                      */
;;;290            return;                                                 /* Yes                                                  */
;;;291        }
;;;292    
;;;293        OSIntNestingCtr++;                                          /* Increment ISR nesting level                          */
;;;294    }
000008  4770              BX       lr
                  |L2.10|
00000a  4807              LDR      r0,|L2.40|
00000c  7800              LDRB     r0,[r0,#0]            ;289  ; OSIntNestingCtr
00000e  28fa              CMP      r0,#0xfa              ;289
000010  d300              BCC      |L2.20|
000012  e7f9              B        |L2.8|
                  |L2.20|
000014  4804              LDR      r0,|L2.40|
000016  7800              LDRB     r0,[r0,#0]            ;293  ; OSIntNestingCtr
000018  1c40              ADDS     r0,r0,#1              ;293
00001a  4903              LDR      r1,|L2.40|
00001c  7008              STRB     r0,[r1,#0]            ;293
00001e  bf00              NOP      
000020  e7f2              B        |L2.8|
;;;295    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      OSRunning
                  |L2.40|
                          DCD      OSIntNestingCtr

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;316    
;;;317    void  OSIntExit (void)
000000  b510              PUSH     {r4,lr}
;;;318    {
;;;319    #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
;;;320        CPU_BOOLEAN  stk_status;
;;;321    #endif
;;;322        CPU_SR_ALLOC();
000002  2400              MOVS     r4,#0
;;;323    
;;;324    
;;;325    
;;;326        if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Has the OS started?                                  */
000004  482d              LDR      r0,|L3.188|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d000              BEQ      |L3.14|
                  |L3.12|
;;;327            return;                                                 /* No                                                   */
;;;328        }
;;;329    
;;;330        CPU_INT_DIS();
;;;331        if (OSIntNestingCtr == 0u) {                                /* Prevent OSIntNestingCtr from wrapping                */
;;;332            CPU_INT_EN();
;;;333            return;
;;;334        }
;;;335        OSIntNestingCtr--;
;;;336        if (OSIntNestingCtr > 0u) {                                 /* ISRs still nested?                                   */
;;;337            CPU_INT_EN();                                           /* Yes                                                  */
;;;338            return;
;;;339        }
;;;340    
;;;341        if (OSSchedLockNestingCtr > 0u) {                           /* Scheduler still locked?                              */
;;;342            CPU_INT_EN();                                           /* Yes                                                  */
;;;343            return;
;;;344        }
;;;345    
;;;346                                                                    /* Verify ISR Stack                                     */
;;;347    #if (OS_CFG_ISR_STK_SIZE > 0u)
;;;348    #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
;;;349        stk_status = OS_TaskStkRedzoneChk(OSCfg_ISRStkBasePtr, OSCfg_ISRStkSize);
;;;350        if (stk_status != DEF_OK) {
;;;351            OSRedzoneHitHook(DEF_NULL);
;;;352        }
;;;353    #endif
;;;354    #endif
;;;355    
;;;356        OSPrioHighRdy   = OS_PrioGetHighest();                      /* Find highest priority                                */
;;;357    #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
;;;358        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;         /* Get highest priority task ready-to-run               */
;;;359        if (OSTCBHighRdyPtr == OSTCBCurPtr) {                       /* Current task still the highest priority?             */
;;;360    #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
;;;361            stk_status = OSTaskStkRedzoneChk(DEF_NULL);
;;;362            if (stk_status != DEF_OK) {
;;;363                OSRedzoneHitHook(OSTCBCurPtr);
;;;364            }
;;;365    #endif
;;;366            CPU_INT_EN();                                           /* Yes                                                  */
;;;367            return;
;;;368        }
;;;369    #else
;;;370        if (OSPrioHighRdy != (OS_CFG_PRIO_MAX - 1u)) {              /* Are we returning to idle?                              */
;;;371            OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* No ... get highest priority task ready-to-run          */
;;;372            if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
;;;373                CPU_INT_EN();                                       /* Yes                                                    */
;;;374                return;
;;;375            }
;;;376        }
;;;377    #endif
;;;378    
;;;379    #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
;;;380        OSTCBHighRdyPtr->CtxSwCtr++;                                /* Inc. # of context switches for this new task         */
;;;381    #endif
;;;382    #if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) || (OS_CFG_DBG_EN == DEF_ENABLED))
;;;383        OSTaskCtxSwCtr++;                                           /* Keep track of the total number of ctx switches       */
;;;384    #endif
;;;385    
;;;386    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;387        OS_TLS_TaskSw();
;;;388    #endif
;;;389    
;;;390        OSIntCtxSw();                                               /* Perform interrupt level ctx switch                   */
;;;391    
;;;392        CPU_INT_EN();
;;;393    }
00000c  bd10              POP      {r4,pc}
                  |L3.14|
00000e  bf00              NOP                            ;330
000010  f7fffffe          BL       CPU_SR_Save
000014  4604              MOV      r4,r0                 ;330
000016  bf00              NOP                            ;330
000018  4829              LDR      r0,|L3.192|
00001a  7800              LDRB     r0,[r0,#0]            ;331  ; OSIntNestingCtr
00001c  b928              CBNZ     r0,|L3.42|
00001e  bf00              NOP                            ;332
000020  4620              MOV      r0,r4                 ;332
000022  f7fffffe          BL       CPU_SR_Restore
000026  bf00              NOP                            ;332
000028  e7f0              B        |L3.12|
                  |L3.42|
00002a  4825              LDR      r0,|L3.192|
00002c  7800              LDRB     r0,[r0,#0]            ;335  ; OSIntNestingCtr
00002e  1e40              SUBS     r0,r0,#1              ;335
000030  4923              LDR      r1,|L3.192|
000032  7008              STRB     r0,[r1,#0]            ;335
000034  4608              MOV      r0,r1                 ;336
000036  7800              LDRB     r0,[r0,#0]            ;336  ; OSIntNestingCtr
000038  b128              CBZ      r0,|L3.70|
00003a  bf00              NOP                            ;337
00003c  4620              MOV      r0,r4                 ;337
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP                            ;337
000044  e7e2              B        |L3.12|
                  |L3.70|
000046  481f              LDR      r0,|L3.196|
000048  7800              LDRB     r0,[r0,#0]            ;341  ; OSSchedLockNestingCtr
00004a  b128              CBZ      r0,|L3.88|
00004c  bf00              NOP                            ;342
00004e  4620              MOV      r0,r4                 ;342
000050  f7fffffe          BL       CPU_SR_Restore
000054  bf00              NOP                            ;342
000056  e7d9              B        |L3.12|
                  |L3.88|
000058  f7fffffe          BL       OS_PrioGetHighest
00005c  491a              LDR      r1,|L3.200|
00005e  7008              STRB     r0,[r1,#0]            ;356
000060  4608              MOV      r0,r1                 ;358
000062  7800              LDRB     r0,[r0,#0]            ;358  ; OSPrioHighRdy
000064  eb000040          ADD      r0,r0,r0,LSL #1       ;358
000068  4918              LDR      r1,|L3.204|
00006a  f8510020          LDR      r0,[r1,r0,LSL #2]     ;358
00006e  4918              LDR      r1,|L3.208|
000070  6008              STR      r0,[r1,#0]            ;358  ; OSTCBHighRdyPtr
000072  4608              MOV      r0,r1                 ;359
000074  6800              LDR      r0,[r0,#0]            ;359  ; OSTCBHighRdyPtr
000076  4917              LDR      r1,|L3.212|
000078  6809              LDR      r1,[r1,#0]            ;359  ; OSTCBCurPtr
00007a  4288              CMP      r0,r1                 ;359
00007c  d105              BNE      |L3.138|
00007e  bf00              NOP                            ;366
000080  4620              MOV      r0,r4                 ;366
000082  f7fffffe          BL       CPU_SR_Restore
000086  bf00              NOP                            ;366
000088  e7c0              B        |L3.12|
                  |L3.138|
00008a  4811              LDR      r0,|L3.208|
00008c  6800              LDR      r0,[r0,#0]            ;380  ; OSTCBHighRdyPtr
00008e  f8d00084          LDR      r0,[r0,#0x84]         ;380
000092  1c40              ADDS     r0,r0,#1              ;380
000094  490e              LDR      r1,|L3.208|
000096  6809              LDR      r1,[r1,#0]            ;380  ; OSTCBHighRdyPtr
000098  f8c10084          STR      r0,[r1,#0x84]         ;380
00009c  480e              LDR      r0,|L3.216|
00009e  6800              LDR      r0,[r0,#0]            ;383  ; OSTaskCtxSwCtr
0000a0  1c40              ADDS     r0,r0,#1              ;383
0000a2  490d              LDR      r1,|L3.216|
0000a4  6008              STR      r0,[r1,#0]            ;383  ; OSTaskCtxSwCtr
0000a6  f04f5080          MOV      r0,#0x10000000        ;390
0000aa  490c              LDR      r1,|L3.220|
0000ac  6008              STR      r0,[r1,#0]            ;390
0000ae  bf00              NOP                            ;392
0000b0  4620              MOV      r0,r4                 ;392
0000b2  f7fffffe          BL       CPU_SR_Restore
0000b6  bf00              NOP                            ;392
0000b8  bf00              NOP      
0000ba  e7a7              B        |L3.12|
;;;394    
                          ENDP

                  |L3.188|
                          DCD      OSRunning
                  |L3.192|
                          DCD      OSIntNestingCtr
                  |L3.196|
                          DCD      OSSchedLockNestingCtr
                  |L3.200|
                          DCD      OSPrioHighRdy
                  |L3.204|
                          DCD      OSRdyList
                  |L3.208|
                          DCD      OSTCBHighRdyPtr
                  |L3.212|
                          DCD      OSTCBCurPtr
                  |L3.216|
                          DCD      OSTaskCtxSwCtr
                  |L3.220|
                          DCD      0xe000ed04

                          AREA ||i.OSSched||, CODE, READONLY, ALIGN=2

                  OSSched PROC
;;;411    
;;;412    void  OSSched (void)
000000  b510              PUSH     {r4,lr}
;;;413    {
;;;414        CPU_SR_ALLOC();
000002  2400              MOVS     r4,#0
;;;415    
;;;416    
;;;417    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Can't schedule when the kernel is stopped.           */
;;;418        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;419            return;
;;;420        }
;;;421    #endif
;;;422    
;;;423        if (OSIntNestingCtr > 0u) {                                 /* ISRs still nested?                                   */
000004  4820              LDR      r0,|L4.136|
000006  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000008  b100              CBZ      r0,|L4.12|
                  |L4.10|
;;;424            return;                                                 /* Yes ... only schedule when no nested ISRs            */
;;;425        }
;;;426    
;;;427        if (OSSchedLockNestingCtr > 0u) {                           /* Scheduler locked?                                    */
;;;428            return;                                                 /* Yes                                                  */
;;;429        }
;;;430    
;;;431        CPU_INT_DIS();
;;;432        OSPrioHighRdy   = OS_PrioGetHighest();                      /* Find the highest priority ready                      */
;;;433    #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
;;;434        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;         /* Get highest priority task ready-to-run               */
;;;435        if (OSTCBHighRdyPtr == OSTCBCurPtr) {                       /* Current task still the highest priority?             */
;;;436            CPU_INT_EN();                                           /* Yes                                                  */
;;;437            return;
;;;438        }
;;;439    #else
;;;440        if (OSPrioHighRdy != (OS_CFG_PRIO_MAX - 1u)) {              /* Are we returning to idle?                              */
;;;441            OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* No ... get highest priority task ready-to-run          */
;;;442            if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
;;;443                CPU_INT_EN();                                       /* Yes                                                    */
;;;444                return;
;;;445            }
;;;446        }
;;;447    #endif
;;;448    
;;;449    
;;;450    #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
;;;451        OSTCBHighRdyPtr->CtxSwCtr++;                                /* Inc. # of context switches to this task              */
;;;452    #endif
;;;453    
;;;454    #if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) || (OS_CFG_DBG_EN == DEF_ENABLED))
;;;455        OSTaskCtxSwCtr++;                                           /* Increment context switch counter                     */
;;;456    #endif
;;;457    
;;;458    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;459        OS_TLS_TaskSw();
;;;460    #endif
;;;461    
;;;462    #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
;;;463        OS_TASK_SW();                                               /* Perform a task level context switch                  */
;;;464        CPU_INT_EN();
;;;465    #else
;;;466        if ((OSPrioHighRdy != (OS_CFG_PRIO_MAX - 1u))) {
;;;467            OS_TASK_SW();                                           /* Perform a task level context switch                  */
;;;468            CPU_INT_EN();
;;;469        } else {
;;;470            OSTCBHighRdyPtr = OSTCBCurPtr;
;;;471            CPU_INT_EN();
;;;472            while (DEF_ON) {
;;;473    #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_EN == DEF_ENABLED))
;;;474                CPU_CRITICAL_ENTER();
;;;475    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;476                OSIdleTaskCtr++;
;;;477    #endif
;;;478    #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
;;;479                OSStatTaskCtr++;
;;;480    #endif
;;;481                CPU_CRITICAL_EXIT();
;;;482    #endif
;;;483    
;;;484    #if (OS_CFG_APP_HOOKS_EN == DEF_ENABLED)
;;;485                OSIdleTaskHook();                                   /* Call user definable HOOK                             */
;;;486    #endif
;;;487                if ((*((volatile OS_PRIO *)&OSPrioHighRdy) != (OS_CFG_PRIO_MAX - 1u))) {
;;;488                    break;
;;;489                }
;;;490            }
;;;491        }
;;;492    #endif
;;;493    
;;;494    #ifdef OS_TASK_SW_SYNC
;;;495         OS_TASK_SW_SYNC();
;;;496    #endif
;;;497    }
00000a  bd10              POP      {r4,pc}
                  |L4.12|
00000c  481f              LDR      r0,|L4.140|
00000e  7800              LDRB     r0,[r0,#0]            ;427  ; OSSchedLockNestingCtr
000010  b100              CBZ      r0,|L4.20|
000012  e7fa              B        |L4.10|
                  |L4.20|
000014  bf00              NOP                            ;431
000016  f7fffffe          BL       CPU_SR_Save
00001a  4604              MOV      r4,r0                 ;431
00001c  bf00              NOP                            ;431
00001e  f7fffffe          BL       OS_PrioGetHighest
000022  491b              LDR      r1,|L4.144|
000024  7008              STRB     r0,[r1,#0]            ;432
000026  4608              MOV      r0,r1                 ;434
000028  7800              LDRB     r0,[r0,#0]            ;434  ; OSPrioHighRdy
00002a  eb000040          ADD      r0,r0,r0,LSL #1       ;434
00002e  4919              LDR      r1,|L4.148|
000030  f8510020          LDR      r0,[r1,r0,LSL #2]     ;434
000034  4918              LDR      r1,|L4.152|
000036  6008              STR      r0,[r1,#0]            ;434  ; OSTCBHighRdyPtr
000038  4608              MOV      r0,r1                 ;435
00003a  6800              LDR      r0,[r0,#0]            ;435  ; OSTCBHighRdyPtr
00003c  4917              LDR      r1,|L4.156|
00003e  6809              LDR      r1,[r1,#0]            ;435  ; OSTCBCurPtr
000040  4288              CMP      r0,r1                 ;435
000042  d105              BNE      |L4.80|
000044  bf00              NOP                            ;436
000046  4620              MOV      r0,r4                 ;436
000048  f7fffffe          BL       CPU_SR_Restore
00004c  bf00              NOP                            ;436
00004e  e7dc              B        |L4.10|
                  |L4.80|
000050  4811              LDR      r0,|L4.152|
000052  6800              LDR      r0,[r0,#0]            ;451  ; OSTCBHighRdyPtr
000054  f8d00084          LDR      r0,[r0,#0x84]         ;451
000058  1c40              ADDS     r0,r0,#1              ;451
00005a  490f              LDR      r1,|L4.152|
00005c  6809              LDR      r1,[r1,#0]            ;451  ; OSTCBHighRdyPtr
00005e  f8c10084          STR      r0,[r1,#0x84]         ;451
000062  480f              LDR      r0,|L4.160|
000064  6800              LDR      r0,[r0,#0]            ;455  ; OSTaskCtxSwCtr
000066  1c40              ADDS     r0,r0,#1              ;455
000068  490d              LDR      r1,|L4.160|
00006a  6008              STR      r0,[r1,#0]            ;455  ; OSTaskCtxSwCtr
00006c  f04f5080          MOV      r0,#0x10000000        ;463
000070  490c              LDR      r1,|L4.164|
000072  6008              STR      r0,[r1,#0]            ;463
000074  bf00              NOP                            ;464
000076  4620              MOV      r0,r4                 ;464
000078  f7fffffe          BL       CPU_SR_Restore
00007c  bf00              NOP                            ;464
00007e  f3bf8f6f          ISB                            ;495
000082  bf00              NOP      
000084  e7c1              B        |L4.10|
;;;498    
                          ENDP

000086  0000              DCW      0x0000
                  |L4.136|
                          DCD      OSIntNestingCtr
                  |L4.140|
                          DCD      OSSchedLockNestingCtr
                  |L4.144|
                          DCD      OSPrioHighRdy
                  |L4.148|
                          DCD      OSRdyList
                  |L4.152|
                          DCD      OSTCBHighRdyPtr
                  |L4.156|
                          DCD      OSTCBCurPtr
                  |L4.160|
                          DCD      OSTaskCtxSwCtr
                  |L4.164|
                          DCD      0xe000ed04

                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;520    
;;;521    void  OSSchedLock (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;522    {
000002  4604              MOV      r4,r0
;;;523        CPU_SR_ALLOC();
000004  2500              MOVS     r5,#0
;;;524    
;;;525    
;;;526    
;;;527    #ifdef OS_SAFETY_CRITICAL
;;;528        if (p_err == DEF_NULL) {
;;;529            OS_SAFETY_CRITICAL_EXCEPTION();
;;;530            return;
;;;531        }
;;;532    #endif
;;;533    
;;;534    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;535        if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
000006  4819              LDR      r0,|L5.108|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b118              CBZ      r0,|L5.20|
;;;536           *p_err = OS_ERR_SCHED_LOCK_ISR;
00000c  f6465062          MOV      r0,#0x6d62
000010  8020              STRH     r0,[r4,#0]
                  |L5.18|
;;;537            return;
;;;538        }
;;;539    #endif
;;;540    
;;;541        if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Make sure multitasking is running                    */
;;;542           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;543            return;
;;;544        }
;;;545    
;;;546        if (OSSchedLockNestingCtr >= 250u) {                        /* Prevent OSSchedLockNestingCtr overflowing            */
;;;547           *p_err = OS_ERR_LOCK_NESTING_OVF;
;;;548            return;
;;;549        }
;;;550    
;;;551        CPU_CRITICAL_ENTER();
;;;552        OSSchedLockNestingCtr++;                                    /* Increment lock nesting level                         */
;;;553    #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
;;;554        OS_SchedLockTimeMeasStart();
;;;555    #endif
;;;556        CPU_CRITICAL_EXIT();
;;;557       *p_err = OS_ERR_NONE;
;;;558    }
000012  bd70              POP      {r4-r6,pc}
                  |L5.20|
000014  4816              LDR      r0,|L5.112|
000016  7800              LDRB     r0,[r0,#0]            ;541  ; OSRunning
000018  2801              CMP      r0,#1                 ;541
00001a  d003              BEQ      |L5.36|
00001c  f6456089          MOV      r0,#0x5e89            ;542
000020  8020              STRH     r0,[r4,#0]            ;542
000022  e7f6              B        |L5.18|
                  |L5.36|
000024  4813              LDR      r0,|L5.116|
000026  7800              LDRB     r0,[r0,#0]            ;546  ; OSSchedLockNestingCtr
000028  28fa              CMP      r0,#0xfa              ;546
00002a  d303              BCC      |L5.52|
00002c  f2452009          MOV      r0,#0x5209            ;547
000030  8020              STRH     r0,[r4,#0]            ;547
000032  e7ee              B        |L5.18|
                  |L5.52|
000034  bf00              NOP                            ;551
000036  bf00              NOP                            ;551
000038  f7fffffe          BL       CPU_SR_Save
00003c  4605              MOV      r5,r0                 ;551
00003e  bf00              NOP                            ;551
000040  f7fffffe          BL       CPU_IntDisMeasStart
000044  bf00              NOP                            ;551
000046  480b              LDR      r0,|L5.116|
000048  7800              LDRB     r0,[r0,#0]            ;552  ; OSSchedLockNestingCtr
00004a  1c40              ADDS     r0,r0,#1              ;552
00004c  4909              LDR      r1,|L5.116|
00004e  7008              STRB     r0,[r1,#0]            ;552
000050  bf00              NOP                            ;556
000052  f7fffffe          BL       CPU_IntDisMeasStop
000056  bf00              NOP                            ;556
000058  4628              MOV      r0,r5                 ;556
00005a  f7fffffe          BL       CPU_SR_Restore
00005e  bf00              NOP                            ;556
000060  bf00              NOP                            ;556
000062  2000              MOVS     r0,#0                 ;557
000064  8020              STRH     r0,[r4,#0]            ;557
000066  bf00              NOP      
000068  e7d3              B        |L5.18|
;;;559    
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      OSIntNestingCtr
                  |L5.112|
                          DCD      OSRunning
                  |L5.116|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;581    
;;;582    void  OSSchedUnlock (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;583    {
000002  4604              MOV      r4,r0
;;;584        CPU_SR_ALLOC();
000004  2500              MOVS     r5,#0
;;;585    
;;;586    
;;;587    
;;;588    #ifdef OS_SAFETY_CRITICAL
;;;589        if (p_err == DEF_NULL) {
;;;590            OS_SAFETY_CRITICAL_EXCEPTION();
;;;591            return;
;;;592        }
;;;593    #endif
;;;594    
;;;595    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;596        if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
000006  4821              LDR      r0,|L6.140|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b118              CBZ      r0,|L6.20|
;;;597           *p_err = OS_ERR_SCHED_UNLOCK_ISR;
00000c  f6465065          MOV      r0,#0x6d65
000010  8020              STRH     r0,[r4,#0]
                  |L6.18|
;;;598            return;
;;;599        }
;;;600    #endif
;;;601    
;;;602        if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Make sure multitasking is running                    */
;;;603           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;604            return;
;;;605        }
;;;606    
;;;607        if (OSSchedLockNestingCtr == 0u) {                          /* See if the scheduler is locked                       */
;;;608           *p_err = OS_ERR_SCHED_NOT_LOCKED;
;;;609            return;
;;;610        }
;;;611    
;;;612        CPU_CRITICAL_ENTER();
;;;613        OSSchedLockNestingCtr--;                                    /* Decrement lock nesting level                         */
;;;614        if (OSSchedLockNestingCtr > 0u) {
;;;615            CPU_CRITICAL_EXIT();                                    /* Scheduler is still locked                            */
;;;616           *p_err = OS_ERR_SCHED_LOCKED;
;;;617            return;
;;;618        }
;;;619    
;;;620    #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
;;;621        OS_SchedLockTimeMeasStop();
;;;622    #endif
;;;623    
;;;624        CPU_CRITICAL_EXIT();                                        /* Scheduler should be re-enabled                       */
;;;625        OSSched();                                                  /* Run the scheduler                                    */
;;;626       *p_err = OS_ERR_NONE;
;;;627    }
000012  bd70              POP      {r4-r6,pc}
                  |L6.20|
000014  481e              LDR      r0,|L6.144|
000016  7800              LDRB     r0,[r0,#0]            ;602  ; OSRunning
000018  2801              CMP      r0,#1                 ;602
00001a  d003              BEQ      |L6.36|
00001c  f6456089          MOV      r0,#0x5e89            ;603
000020  8020              STRH     r0,[r4,#0]            ;603
000022  e7f6              B        |L6.18|
                  |L6.36|
000024  481b              LDR      r0,|L6.148|
000026  7800              LDRB     r0,[r0,#0]            ;607  ; OSSchedLockNestingCtr
000028  b918              CBNZ     r0,|L6.50|
00002a  f6465064          MOV      r0,#0x6d64            ;608
00002e  8020              STRH     r0,[r4,#0]            ;608
000030  e7ef              B        |L6.18|
                  |L6.50|
000032  bf00              NOP                            ;612
000034  bf00              NOP                            ;612
000036  f7fffffe          BL       CPU_SR_Save
00003a  4605              MOV      r5,r0                 ;612
00003c  bf00              NOP                            ;612
00003e  f7fffffe          BL       CPU_IntDisMeasStart
000042  bf00              NOP                            ;612
000044  4813              LDR      r0,|L6.148|
000046  7800              LDRB     r0,[r0,#0]            ;613  ; OSSchedLockNestingCtr
000048  1e40              SUBS     r0,r0,#1              ;613
00004a  4912              LDR      r1,|L6.148|
00004c  7008              STRB     r0,[r1,#0]            ;613
00004e  4608              MOV      r0,r1                 ;614
000050  7800              LDRB     r0,[r0,#0]            ;614  ; OSSchedLockNestingCtr
000052  b160              CBZ      r0,|L6.110|
000054  bf00              NOP                            ;615
000056  f7fffffe          BL       CPU_IntDisMeasStop
00005a  bf00              NOP                            ;615
00005c  4628              MOV      r0,r5                 ;615
00005e  f7fffffe          BL       CPU_SR_Restore
000062  bf00              NOP                            ;615
000064  bf00              NOP                            ;615
000066  f6465063          MOV      r0,#0x6d63            ;616
00006a  8020              STRH     r0,[r4,#0]            ;616
00006c  e7d1              B        |L6.18|
                  |L6.110|
00006e  bf00              NOP                            ;624
000070  f7fffffe          BL       CPU_IntDisMeasStop
000074  bf00              NOP                            ;624
000076  4628              MOV      r0,r5                 ;624
000078  f7fffffe          BL       CPU_SR_Restore
00007c  bf00              NOP                            ;624
00007e  bf00              NOP                            ;624
000080  f7fffffe          BL       OSSched
000084  2000              MOVS     r0,#0                 ;626
000086  8020              STRH     r0,[r4,#0]            ;626
000088  bf00              NOP      
00008a  e7c2              B        |L6.18|
;;;628    
                          ENDP

                  |L6.140|
                          DCD      OSIntNestingCtr
                  |L6.144|
                          DCD      OSRunning
                  |L6.148|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;786    
;;;787    void  OSStart (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;788    {
000002  4604              MOV      r4,r0
;;;789        OS_OBJ_QTY  kernel_task_cnt;
;;;790    
;;;791    
;;;792    #ifdef OS_SAFETY_CRITICAL
;;;793        if (p_err == DEF_NULL) {
;;;794            OS_SAFETY_CRITICAL_EXCEPTION();
;;;795            return;
;;;796        }
;;;797    #endif
;;;798    
;;;799        if (OSInitialized != DEF_TRUE) {
000004  481c              LDR      r0,|L7.120|
000006  7800              LDRB     r0,[r0,#0]  ; OSInitialized
000008  2801              CMP      r0,#1
00000a  d003              BEQ      |L7.20|
;;;800           *p_err = OS_ERR_OS_NOT_INIT;
00000c  f645608b          MOV      r0,#0x5e8b
000010  8020              STRH     r0,[r4,#0]
                  |L7.18|
;;;801            return;
;;;802        }
;;;803    
;;;804        kernel_task_cnt = 0u;                                       /* Calculate the number of kernel tasks                 */
;;;805    #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
;;;806        kernel_task_cnt++;
;;;807    #endif
;;;808    #if (OS_CFG_TASK_TICK_EN  == DEF_ENABLED)
;;;809        kernel_task_cnt++;
;;;810    #endif
;;;811    #if (OS_CFG_TMR_EN == DEF_ENABLED)
;;;812        kernel_task_cnt++;
;;;813    #endif
;;;814    #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
;;;815        kernel_task_cnt++;
;;;816    #endif
;;;817    
;;;818        if (OSTaskQty <= kernel_task_cnt) {                         /* No application task created                          */
;;;819            *p_err = OS_ERR_OS_NO_APP_TASK;
;;;820             return;
;;;821        }
;;;822    
;;;823        if (OSRunning == OS_STATE_OS_STOPPED) {
;;;824            OSPrioHighRdy             = OS_PrioGetHighest();        /* Find the highest priority                            */
;;;825            OSPrioCur                 = OSPrioHighRdy;
;;;826            OSTCBHighRdyPtr           = OSRdyList[OSPrioHighRdy].HeadPtr;
;;;827            OSTCBCurPtr               = OSTCBHighRdyPtr;
;;;828    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;829            OSSafetyCriticalStartFlag = DEF_TRUE;                   /* Prevent creation of additional kernel objects        */
;;;830    #endif
;;;831            OSRunning                 = OS_STATE_OS_RUNNING;
;;;832            OSStartHighRdy();                                       /* Execute target specific code to start task           */
;;;833           *p_err                     = OS_ERR_FATAL_RETURN;        /* OSStart() is not supposed to return                  */
;;;834        } else {
;;;835           *p_err                     = OS_ERR_OS_RUNNING;          /* OS is already running                                */
;;;836        }
;;;837    }
000012  bd70              POP      {r4-r6,pc}
                  |L7.20|
000014  2500              MOVS     r5,#0                 ;804
000016  1c6d              ADDS     r5,r5,#1              ;809
000018  1c6d              ADDS     r5,r5,#1              ;812
00001a  1c6d              ADDS     r5,r5,#1              ;815
00001c  4817              LDR      r0,|L7.124|
00001e  8800              LDRH     r0,[r0,#0]            ;818  ; OSTaskQty
000020  42a8              CMP      r0,r5                 ;818
000022  dc03              BGT      |L7.44|
000024  f645608c          MOV      r0,#0x5e8c            ;819
000028  8020              STRH     r0,[r4,#0]            ;819
00002a  e7f2              B        |L7.18|
                  |L7.44|
00002c  4814              LDR      r0,|L7.128|
00002e  7800              LDRB     r0,[r0,#0]            ;823  ; OSRunning
000030  b9e8              CBNZ     r0,|L7.110|
000032  f7fffffe          BL       OS_PrioGetHighest
000036  4913              LDR      r1,|L7.132|
000038  7008              STRB     r0,[r1,#0]            ;824
00003a  4608              MOV      r0,r1                 ;825
00003c  7800              LDRB     r0,[r0,#0]            ;825  ; OSPrioHighRdy
00003e  4912              LDR      r1,|L7.136|
000040  7008              STRB     r0,[r1,#0]            ;825
000042  4810              LDR      r0,|L7.132|
000044  7800              LDRB     r0,[r0,#0]            ;826  ; OSPrioHighRdy
000046  eb000040          ADD      r0,r0,r0,LSL #1       ;826
00004a  4910              LDR      r1,|L7.140|
00004c  f8510020          LDR      r0,[r1,r0,LSL #2]     ;826
000050  490f              LDR      r1,|L7.144|
000052  6008              STR      r0,[r1,#0]            ;826  ; OSTCBHighRdyPtr
000054  4608              MOV      r0,r1                 ;827
000056  6800              LDR      r0,[r0,#0]            ;827  ; OSTCBHighRdyPtr
000058  490e              LDR      r1,|L7.148|
00005a  6008              STR      r0,[r1,#0]            ;827  ; OSTCBCurPtr
00005c  2001              MOVS     r0,#1                 ;831
00005e  4908              LDR      r1,|L7.128|
000060  7008              STRB     r0,[r1,#0]            ;831
000062  f7fffffe          BL       OSStartHighRdy
000066  f6432099          MOV      r0,#0x3a99            ;833
00006a  8020              STRH     r0,[r4,#0]            ;833
00006c  e002              B        |L7.116|
                  |L7.110|
00006e  f645608a          MOV      r0,#0x5e8a            ;835
000072  8020              STRH     r0,[r4,#0]            ;835
                  |L7.116|
000074  bf00              NOP      
000076  e7cc              B        |L7.18|
;;;838    
                          ENDP

                  |L7.120|
                          DCD      OSInitialized
                  |L7.124|
                          DCD      OSTaskQty
                  |L7.128|
                          DCD      OSRunning
                  |L7.132|
                          DCD      OSPrioHighRdy
                  |L7.136|
                          DCD      OSPrioCur
                  |L7.140|
                          DCD      OSRdyList
                  |L7.144|
                          DCD      OSTCBHighRdyPtr
                  |L7.148|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;857    
;;;858    CPU_INT16U  OSVersion (OS_ERR  *p_err)
000000  4601              MOV      r1,r0
;;;859    {
;;;860    #ifdef OS_SAFETY_CRITICAL
;;;861        if (p_err == DEF_NULL) {
;;;862            OS_SAFETY_CRITICAL_EXCEPTION();
;;;863            return (0u);
;;;864        }
;;;865    #endif
;;;866    
;;;867       *p_err = OS_ERR_NONE;
000002  2000              MOVS     r0,#0
000004  8008              STRH     r0,[r1,#0]
;;;868        return (OS_VERSION);
000006  f2477024          MOV      r0,#0x7724
;;;869    }
00000a  4770              BX       lr
;;;870    
                          ENDP


                          AREA ||i.OS_IdleTask||, CODE, READONLY, ALIGN=2

                  OS_IdleTask PROC
;;;893    #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
;;;894    void  OS_IdleTask (void  *p_arg)
000000  2400              MOVS     r4,#0
;;;895    {
;;;896    #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_EN == DEF_ENABLED))
;;;897        CPU_SR_ALLOC();
;;;898    #endif
;;;899    
;;;900    
;;;901        (void)p_arg;                                                /* Prevent compiler warning for not using 'p_arg'       */
;;;902    
;;;903        while (DEF_ON) {
000002  e018              B        |L9.54|
                  |L9.4|
;;;904    #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_EN == DEF_ENABLED))
;;;905            CPU_CRITICAL_ENTER();
000004  bf00              NOP      
000006  bf00              NOP      
000008  f7fffffe          BL       CPU_SR_Save
00000c  4604              MOV      r4,r0
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_IntDisMeasStart
000014  bf00              NOP      
;;;906    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;907            OSIdleTaskCtr++;
000016  4808              LDR      r0,|L9.56|
000018  6800              LDR      r0,[r0,#0]  ; OSIdleTaskCtr
00001a  1c40              ADDS     r0,r0,#1
00001c  4906              LDR      r1,|L9.56|
00001e  6008              STR      r0,[r1,#0]  ; OSIdleTaskCtr
;;;908    #endif
;;;909    #if (OS_CFG_STAT_TASK_EN == DEF_ENABLED)
;;;910            OSStatTaskCtr++;
;;;911    #endif
;;;912            CPU_CRITICAL_EXIT();
000020  bf00              NOP      
000022  f7fffffe          BL       CPU_IntDisMeasStop
000026  bf00              NOP      
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       CPU_SR_Restore
00002e  bf00              NOP      
000030  bf00              NOP      
;;;913    #endif
;;;914    
;;;915    #if (OS_CFG_APP_HOOKS_EN == DEF_ENABLED)
;;;916            OSIdleTaskHook();                                       /* Call user definable HOOK                             */
000032  f7fffffe          BL       OSIdleTaskHook
                  |L9.54|
000036  e7e5              B        |L9.4|
;;;917    #endif
;;;918        }
;;;919    }
;;;920    #endif
                          ENDP

                  |L9.56|
                          DCD      OSIdleTaskCtr

                          AREA ||i.OS_IdleTaskInit||, CODE, READONLY, ALIGN=2

                  OS_IdleTaskInit PROC
;;;935    #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
;;;936    void  OS_IdleTaskInit (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;937    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;938    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;939        OSIdleTaskCtr = 0u;
000006  2000              MOVS     r0,#0
000008  490e              LDR      r1,|L10.68|
00000a  6008              STR      r0,[r1,#0]  ; OSIdleTaskCtr
;;;940    #endif
;;;941                                                                    /* --------------- CREATE THE IDLE TASK --------------- */
;;;942        OSTaskCreate(&OSIdleTaskTCB,
00000c  200b              MOVS     r0,#0xb
00000e  2100              MOVS     r1,#0
000010  9105              STR      r1,[sp,#0x14]
000012  e9cd0407          STRD     r0,r4,[sp,#0x1c]
000016  9106              STR      r1,[sp,#0x18]
000018  4608              MOV      r0,r1
00001a  490b              LDR      r1,|L10.72|
00001c  6809              LDR      r1,[r1,#0]  ; OSCfg_IdleTaskStkSize
00001e  4a0b              LDR      r2,|L10.76|
000020  6812              LDR      r2,[r2,#0]  ; OSCfg_IdleTaskStkLimit
000022  4b0b              LDR      r3,|L10.80|
000024  681b              LDR      r3,[r3,#0]  ; OSCfg_IdleTaskStkBasePtr
000026  e9cd3201          STRD     r3,r2,[sp,#4]
00002a  e9cd1003          STRD     r1,r0,[sp,#0xc]
00002e  201f              MOVS     r0,#0x1f
000030  2300              MOVS     r3,#0
000032  4a08              LDR      r2,|L10.84|
000034  a108              ADR      r1,|L10.88|
000036  9000              STR      r0,[sp,#0]
000038  480c              LDR      r0,|L10.108|
00003a  f7fffffe          BL       OSTaskCreate
;;;943                     (CPU_CHAR   *)((void *)"uC/OS-III Idle Task"),
;;;944                      OS_IdleTask,
;;;945                      DEF_NULL,
;;;946                     (OS_CFG_PRIO_MAX - 1u),
;;;947                      OSCfg_IdleTaskStkBasePtr,
;;;948                      OSCfg_IdleTaskStkLimit,
;;;949                      OSCfg_IdleTaskStkSize,
;;;950                      0u,
;;;951                      0u,
;;;952                      DEF_NULL,
;;;953                     (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
;;;954                      p_err);
;;;955    }
00003e  b00a              ADD      sp,sp,#0x28
000040  bd10              POP      {r4,pc}
;;;956    #endif
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      OSIdleTaskCtr
                  |L10.72|
                          DCD      OSCfg_IdleTaskStkSize
                  |L10.76|
                          DCD      OSCfg_IdleTaskStkLimit
                  |L10.80|
                          DCD      OSCfg_IdleTaskStkBasePtr
                  |L10.84|
                          DCD      OS_IdleTask
                  |L10.88|
000058  75432f4f          DCB      "uC/OS-III Idle Task",0
00005c  532d4949
000060  49204964
000064  6c652054
000068  61736b00
                  |L10.108|
                          DCD      OSIdleTaskTCB

                          AREA ||i.OS_Pend||, CODE, READONLY, ALIGN=2

                  OS_Pend PROC
;;;987    
;;;988    void  OS_Pend (OS_PEND_DATA  *p_pend_data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;989                   OS_PEND_OBJ   *p_obj,
;;;990                   OS_STATE       pending_on,
;;;991                   OS_TICK        timeout)
;;;992    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;993        OS_PEND_LIST  *p_pend_list;
;;;994    
;;;995    
;;;996    
;;;997        OSTCBCurPtr->PendOn     = pending_on;                       /* Resource not available, wait until it is             */
00000c  4813              LDR      r0,|L11.92|
00000e  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000010  f8806034          STRB     r6,[r0,#0x34]
;;;998        OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
000014  2000              MOVS     r0,#0
000016  4911              LDR      r1,|L11.92|
000018  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00001a  f8810035          STRB     r0,[r1,#0x35]
;;;999    
;;;1000       OS_TaskBlock(OSTCBCurPtr,                                   /* Block the task and add it to the tick list if needed */
00001e  4639              MOV      r1,r7
000020  480e              LDR      r0,|L11.92|
000022  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000024  f7fffffe          BL       OS_TaskBlock
;;;1001                    timeout);
;;;1002   
;;;1003       if (p_obj != DEF_NULL) {                                    /* Add the current task to the pend list ...            */
000028  b16c              CBZ      r4,|L11.70|
;;;1004           p_pend_list             = &p_obj->PendList;             /* ... if there is an object to pend on                 */
00002a  f1040808          ADD      r8,r4,#8
;;;1005           p_pend_data->PendObjPtr = p_obj;                        /* Save the pointer to the object pending on            */
00002e  60ec              STR      r4,[r5,#0xc]
;;;1006           OS_PendDataInit(OSTCBCurPtr,                            /* Initialize the remaining field                       */
000030  2201              MOVS     r2,#1
000032  4629              MOV      r1,r5
000034  4809              LDR      r0,|L11.92|
000036  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000038  f7fffffe          BL       OS_PendDataInit
;;;1007                           p_pend_data,
;;;1008                           1u);
;;;1009           OS_PendListInsertPrio(p_pend_list,                      /* Insert in the pend list in priority order            */
00003c  4629              MOV      r1,r5
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       OS_PendListInsertPrio
000044  e003              B        |L11.78|
                  |L11.70|
;;;1010                                 p_pend_data);
;;;1011       } else {
;;;1012   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;1013           OSTCBCurPtr->PendDataTblEntries = 0u;                   /* If no object being pended on the clear these fields  */
;;;1014   #endif
;;;1015           OSTCBCurPtr->PendDataTblPtr     = DEF_NULL;             /* ... in the TCB                                       */
000046  2000              MOVS     r0,#0
000048  4904              LDR      r1,|L11.92|
00004a  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00004c  6308              STR      r0,[r1,#0x30]
                  |L11.78|
;;;1016       }
;;;1017   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1018       OS_PendDbgNameAdd(p_obj,
00004e  4803              LDR      r0,|L11.92|
000050  6801              LDR      r1,[r0,#0]  ; OSTCBCurPtr
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       OS_PendDbgNameAdd
;;;1019                         OSTCBCurPtr);
;;;1020   #endif
;;;1021   }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;1022   
                          ENDP

                  |L11.92|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_PendAbort||, CODE, READONLY, ALIGN=1

                  OS_PendAbort PROC
;;;1043   
;;;1044   void  OS_PendAbort (OS_PEND_OBJ  *p_obj,
000000  b570              PUSH     {r4-r6,lr}
;;;1045                       OS_TCB       *p_tcb,
;;;1046                       CPU_TS        ts)
;;;1047   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;1048   #if (OS_CFG_TS_EN == DEF_DISABLED)
;;;1049       (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
;;;1050   #endif
;;;1051   
;;;1052       switch (p_tcb->TaskState) {
000008  f8940036          LDRB     r0,[r4,#0x36]
00000c  2808              CMP      r0,#8
00000e  d242              BCS      |L12.150|
000010  e8dff000          TBB      [pc,r0]
000014  42430405          DCB      0x42,0x43,0x04,0x05
000018  44452425          DCB      0x44,0x45,0x24,0x25
;;;1053           case OS_TASK_STATE_PEND:
;;;1054           case OS_TASK_STATE_PEND_TIMEOUT:
00001c  bf00              NOP      
;;;1055   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;1056                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
;;;1057                    OS_PendAbort1(p_obj,                           /* Indicate which object was pend aborted               */
;;;1058                                  p_tcb,
;;;1059                                  ts);
;;;1060                }
;;;1061   #endif
;;;1062   #if (OS_MSG_EN == DEF_ENABLED)
;;;1063                p_tcb->MsgPtr     = DEF_NULL;
00001e  2000              MOVS     r0,#0
000020  65a0              STR      r0,[r4,#0x58]
;;;1064                p_tcb->MsgSize    = 0u;
000022  f8a4005c          STRH     r0,[r4,#0x5c]
;;;1065   #endif
;;;1066   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1067                p_tcb->TS         = ts;
000026  64a6              STR      r6,[r4,#0x48]
;;;1068   #endif
;;;1069                if (p_obj != DEF_NULL) {
000028  b115              CBZ      r5,|L12.48|
;;;1070                    OS_PendListRemove(p_tcb);                      /* Remove task from all pend lists                      */
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       OS_PendListRemove
                  |L12.48|
;;;1071                }
;;;1072   #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;1073                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
000030  f8940036          LDRB     r0,[r4,#0x36]
000034  2803              CMP      r0,#3
000036  d102              BNE      |L12.62|
;;;1074                    OS_TickListRemove(p_tcb);                      /* Remove from tick list                                */
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       OS_TickListRemove
                  |L12.62|
;;;1075                }
;;;1076   #endif
;;;1077                OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       OS_RdyListInsert
;;;1078                p_tcb->TaskState  = OS_TASK_STATE_RDY;             /* Task will be ready                                   */
000044  2000              MOVS     r0,#0
000046  f1040434          ADD      r4,r4,#0x34
00004a  70a0              STRB     r0,[r4,#2]
;;;1079                p_tcb->PendStatus = OS_STATUS_PEND_ABORT;          /* Indicate pend was aborted                            */
00004c  f04f0001          MOV      r0,#1
000050  7060              STRB     r0,[r4,#1]
;;;1080                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
000052  f04f0000          MOV      r0,#0
000056  f8040934          STRB     r0,[r4],#-0x34
;;;1081                break;
00005a  e021              B        |L12.160|
;;;1082   
;;;1083           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1084           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00005c  bf00              NOP      
;;;1085   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;1086                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
;;;1087                    OS_PendAbort1(p_obj,                           /* Indicate which object was pend aborted               */
;;;1088                                  p_tcb,
;;;1089                                  ts);
;;;1090                }
;;;1091   #endif
;;;1092   #if (OS_MSG_EN == DEF_ENABLED)
;;;1093                p_tcb->MsgPtr     = DEF_NULL;
00005e  2000              MOVS     r0,#0
000060  65a0              STR      r0,[r4,#0x58]
;;;1094                p_tcb->MsgSize    = 0u;
000062  f8a4005c          STRH     r0,[r4,#0x5c]
;;;1095   #endif
;;;1096   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1097                p_tcb->TS         = ts;
000066  64a6              STR      r6,[r4,#0x48]
;;;1098   #endif
;;;1099                if (p_obj != DEF_NULL) {
000068  b115              CBZ      r5,|L12.112|
;;;1100                    OS_PendListRemove(p_tcb);                      /* Remove task from all pend lists                      */
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       OS_PendListRemove
                  |L12.112|
;;;1101                }
;;;1102   #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;1103                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
000070  f8940036          LDRB     r0,[r4,#0x36]
000074  2807              CMP      r0,#7
000076  d102              BNE      |L12.126|
;;;1104                    OS_TickListRemove(p_tcb);                      /* Cancel the timeout                                   */
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       OS_TickListRemove
                  |L12.126|
;;;1105                }
;;;1106   #endif
;;;1107                p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;       /* Pend Aborted task is still suspended                 */
00007e  2004              MOVS     r0,#4
000080  f1040434          ADD      r4,r4,#0x34
000084  70a0              STRB     r0,[r4,#2]
;;;1108                p_tcb->PendStatus = OS_STATUS_PEND_ABORT;          /* Indicate pend was aborted                            */
000086  f04f0001          MOV      r0,#1
00008a  7060              STRB     r0,[r4,#1]
;;;1109                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
00008c  f04f0000          MOV      r0,#0
000090  f8040934          STRB     r0,[r4],#-0x34
;;;1110                break;
000094  e004              B        |L12.160|
                  |L12.150|
;;;1111   
;;;1112           case OS_TASK_STATE_RDY:                                 /* Cannot Pend Abort a task that is ready               */
000096  bf00              NOP      
;;;1113           case OS_TASK_STATE_DLY:                                 /* Cannot Pend Abort a task that is delayed             */
000098  bf00              NOP      
;;;1114           case OS_TASK_STATE_SUSPENDED:                           /* Cannot Pend Abort a suspended task                   */
00009a  bf00              NOP      
;;;1115           case OS_TASK_STATE_DLY_SUSPENDED:                       /* Cannot Pend Abort a suspended task also dly'd        */
00009c  bf00              NOP      
;;;1116           default:
;;;1117                break;
00009e  bf00              NOP      
                  |L12.160|
0000a0  bf00              NOP                            ;1081
;;;1118       }
;;;1119   }
0000a2  bd70              POP      {r4-r6,pc}
;;;1120   
                          ENDP


                          AREA ||i.OS_PendDataInit||, CODE, READONLY, ALIGN=1

                  OS_PendDataInit PROC
;;;1240   
;;;1241   void  OS_PendDataInit (OS_TCB        *p_tcb,
000000  6301              STR      r1,[r0,#0x30]
;;;1242                          OS_PEND_DATA  *p_pend_data_tbl,
;;;1243                          OS_OBJ_QTY     tbl_size)
;;;1244   {
;;;1245   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;1246       OS_OBJ_QTY  i;
;;;1247   #endif
;;;1248   
;;;1249   
;;;1250   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;1251       p_tcb->PendDataTblEntries = tbl_size;                       /* Link the TCB to the beginning of the table           */
;;;1252       p_tcb->PendDataTblPtr     = p_pend_data_tbl;
;;;1253   
;;;1254       for (i = 0u; i < tbl_size; i++) {
;;;1255           p_pend_data_tbl->NextPtr    = DEF_NULL;                 /* Initialize all the fields                            */
;;;1256           p_pend_data_tbl->PrevPtr    = DEF_NULL;
;;;1257           p_pend_data_tbl->RdyObjPtr  = DEF_NULL;
;;;1258           p_pend_data_tbl->RdyMsgPtr  = DEF_NULL;
;;;1259           p_pend_data_tbl->RdyMsgSize = 0u;
;;;1260   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1261           p_pend_data_tbl->RdyTS      = 0u;
;;;1262   #endif
;;;1263           p_pend_data_tbl->TCBPtr     = p_tcb;                    /* Every entry points back to the TCB of the task       */
;;;1264           p_pend_data_tbl++;
;;;1265       }
;;;1266   #else
;;;1267       (void)tbl_size;
;;;1268   
;;;1269       p_tcb->PendDataTblPtr       = p_pend_data_tbl;
;;;1270   
;;;1271       p_pend_data_tbl->NextPtr    = DEF_NULL;        /* Initialize all the fields                              */
000002  2300              MOVS     r3,#0
000004  604b              STR      r3,[r1,#4]
;;;1272       p_pend_data_tbl->PrevPtr    = DEF_NULL;
000006  600b              STR      r3,[r1,#0]
;;;1273       p_pend_data_tbl->RdyObjPtr  = DEF_NULL;
000008  610b              STR      r3,[r1,#0x10]
;;;1274       p_pend_data_tbl->RdyMsgPtr  = DEF_NULL;
00000a  614b              STR      r3,[r1,#0x14]
;;;1275       p_pend_data_tbl->RdyMsgSize = 0u;
00000c  830b              STRH     r3,[r1,#0x18]
;;;1276   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1277       p_pend_data_tbl->RdyTS      = 0u;
00000e  61cb              STR      r3,[r1,#0x1c]
;;;1278   #endif
;;;1279       p_pend_data_tbl->TCBPtr     = p_tcb;                    /* Every entry points back to the TCB of the task         */
000010  6088              STR      r0,[r1,#8]
;;;1280   #endif
;;;1281   }
000012  4770              BX       lr
;;;1282   
                          ENDP


                          AREA ||i.OS_PendDbgNameAdd||, CODE, READONLY, ALIGN=2

                  OS_PendDbgNameAdd PROC
;;;1302   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1303   void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
000000  b530              PUSH     {r4,r5,lr}
;;;1304                            OS_TCB       *p_tcb)
;;;1305   {
;;;1306       OS_PEND_LIST  *p_pend_list;
;;;1307       OS_PEND_DATA  *p_pend_data;
;;;1308       OS_TCB        *p_tcb1;
;;;1309   
;;;1310   
;;;1311       if (p_obj != DEF_NULL) {
000002  b148              CBZ      r0,|L14.24|
;;;1312           p_tcb->DbgNamePtr =  p_obj->NamePtr;                    /* Task pending on this object ... save name in TCB     */
000004  6845              LDR      r5,[r0,#4]
000006  f8c150b4          STR      r5,[r1,#0xb4]
;;;1313           p_pend_list       = &p_obj->PendList;                   /* Find name of HP task pending on this object ...      */
00000a  f1000408          ADD      r4,r0,#8
;;;1314           p_pend_data       =  p_pend_list->HeadPtr;
00000e  6822              LDR      r2,[r4,#0]
;;;1315           p_tcb1            =  p_pend_data->TCBPtr;
000010  6893              LDR      r3,[r2,#8]
;;;1316           p_obj->DbgNamePtr = p_tcb1->NamePtr;                    /* ... Save in object                                   */
000012  689d              LDR      r5,[r3,#8]
000014  61c5              STR      r5,[r0,#0x1c]
000016  e013              B        |L14.64|
                  |L14.24|
;;;1317       } else {
;;;1318           switch (p_tcb->PendOn) {
000018  f8915034          LDRB     r5,[r1,#0x34]
00001c  2d02              CMP      r5,#2
00001e  d002              BEQ      |L14.38|
000020  2d07              CMP      r5,#7
000022  d108              BNE      |L14.54|
000024  e003              B        |L14.46|
                  |L14.38|
;;;1319               case OS_TASK_PEND_ON_TASK_Q:
;;;1320                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
000026  a507              ADR      r5,|L14.68|
000028  f8c150b4          STR      r5,[r1,#0xb4]
;;;1321                    break;
00002c  e007              B        |L14.62|
                  |L14.46|
;;;1322   
;;;1323               case OS_TASK_PEND_ON_TASK_SEM:
;;;1324                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
00002e  a507              ADR      r5,|L14.76|
000030  f8c150b4          STR      r5,[r1,#0xb4]
;;;1325                    break;
000034  e003              B        |L14.62|
                  |L14.54|
;;;1326   
;;;1327               default:
;;;1328                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
000036  a508              ADR      r5,|L14.88|
000038  f8c150b4          STR      r5,[r1,#0xb4]
;;;1329                    break;
00003c  bf00              NOP      
                  |L14.62|
00003e  bf00              NOP                            ;1321
                  |L14.64|
;;;1330           }
;;;1331       }
;;;1332   }
000040  bd30              POP      {r4,r5,pc}
;;;1333   
                          ENDP

000042  0000              DCW      0x0000
                  |L14.68|
000044  5461736b          DCB      "Task Q",0
000048  205100  
00004b  00                DCB      0
                  |L14.76|
00004c  5461736b          DCB      "Task Sem",0
000050  2053656d
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L14.88|
000058  2000              DCB      " ",0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.OS_PendDbgNameRemove||, CODE, READONLY, ALIGN=2

                  OS_PendDbgNameRemove PROC
;;;1335   
;;;1336   void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
000000  b530              PUSH     {r4,r5,lr}
;;;1337                               OS_TCB       *p_tcb)
;;;1338   {
;;;1339       OS_PEND_LIST  *p_pend_list;
;;;1340       OS_PEND_DATA  *p_pend_data;
;;;1341       OS_TCB        *p_tcb1;
;;;1342   
;;;1343   
;;;1344       p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");              /* Remove name of object pended on for readied task     */
000002  a507              ADR      r5,|L15.32|
000004  f8c150b4          STR      r5,[r1,#0xb4]
;;;1345       p_pend_list       = &p_obj->PendList;
000008  f1000408          ADD      r4,r0,#8
;;;1346       p_pend_data       =  p_pend_list->HeadPtr;
00000c  6822              LDR      r2,[r4,#0]
;;;1347       if (p_pend_data != DEF_NULL) {
00000e  b11a              CBZ      r2,|L15.24|
;;;1348           p_tcb1            = p_pend_data->TCBPtr;
000010  6893              LDR      r3,[r2,#8]
;;;1349           p_obj->DbgNamePtr = p_tcb1->NamePtr;
000012  689d              LDR      r5,[r3,#8]
000014  61c5              STR      r5,[r0,#0x1c]
000016  e001              B        |L15.28|
                  |L15.24|
;;;1350       } else {
;;;1351           p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* No other task pending on object                      */
000018  a501              ADR      r5,|L15.32|
00001a  61c5              STR      r5,[r0,#0x1c]
                  |L15.28|
;;;1352       }
;;;1353   }
00001c  bd30              POP      {r4,r5,pc}
;;;1354   #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L15.32|
000020  2000              DCB      " ",0
000022  00                DCB      0
000023  00                DCB      0

                          AREA ||i.OS_PendListChangePrio||, CODE, READONLY, ALIGN=1

                  OS_PendListChangePrio PROC
;;;1435   
;;;1436   void  OS_PendListChangePrio (OS_TCB   *p_tcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1437   {
000004  4606              MOV      r6,r0
;;;1438       OS_OBJ_QTY      n_pend_list;                                /* Number of pend lists                                 */
;;;1439       OS_PEND_DATA   *p_pend_data;
;;;1440       OS_PEND_LIST   *p_pend_list;
;;;1441       OS_PEND_OBJ    *p_obj;
;;;1442   
;;;1443   
;;;1444       p_pend_data = p_tcb->PendDataTblPtr;                        /* Point to first wait list entry                       */
000006  6b34              LDR      r4,[r6,#0x30]
;;;1445   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;1446       n_pend_list = p_tcb->PendDataTblEntries;                    /* Get the number of pend list task is in               */
;;;1447   #else
;;;1448       n_pend_list = 1u;
000008  2701              MOVS     r7,#1
;;;1449   #endif
;;;1450   
;;;1451       while (n_pend_list > 0u) {
00000a  e011              B        |L16.48|
                  |L16.12|
;;;1452           p_obj       =  p_pend_data->PendObjPtr;                 /* Get pointer to pend list                             */
00000c  f8d4800c          LDR      r8,[r4,#0xc]
;;;1453           p_pend_list = &p_obj->PendList;
000010  f1080508          ADD      r5,r8,#8
;;;1454           if (p_pend_list->HeadPtr->NextPtr != DEF_NULL) {        /* Only move if multiple entries in the list            */
000014  6828              LDR      r0,[r5,#0]
000016  6840              LDR      r0,[r0,#4]
000018  b138              CBZ      r0,|L16.42|
;;;1455               OS_PendListRemove1(p_pend_list,                     /* Remove entry from current position                   */
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       OS_PendListRemove1
;;;1456                                  p_pend_data);
;;;1457               OS_PendListInsertPrio(p_pend_list,                  /* INSERT it back in the list                           */
000022  4621              MOV      r1,r4
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       OS_PendListInsertPrio
                  |L16.42|
;;;1458                                     p_pend_data);
;;;1459           }
;;;1460           p_pend_data++;                                          /* Point to next wait list                              */
00002a  3420              ADDS     r4,r4,#0x20
;;;1461           n_pend_list--;
00002c  1e78              SUBS     r0,r7,#1
00002e  b287              UXTH     r7,r0
                  |L16.48|
000030  2f00              CMP      r7,#0                 ;1451
000032  d1eb              BNE      |L16.12|
;;;1462       }
;;;1463   }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;1464   
                          ENDP


                          AREA ||i.OS_PendListInit||, CODE, READONLY, ALIGN=1

                  OS_PendListInit PROC
;;;1480   
;;;1481   void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
000000  2100              MOVS     r1,#0
;;;1482   {
;;;1483       p_pend_list->HeadPtr    = DEF_NULL;
000002  6001              STR      r1,[r0,#0]
;;;1484       p_pend_list->TailPtr    = DEF_NULL;
000004  6041              STR      r1,[r0,#4]
;;;1485   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1486       p_pend_list->NbrEntries = 0u;
000006  8101              STRH     r1,[r0,#8]
;;;1487   #endif
;;;1488   }
000008  4770              BX       lr
;;;1489   
                          ENDP


                          AREA ||i.OS_PendListInsertPrio||, CODE, READONLY, ALIGN=1

                  OS_PendListInsertPrio PROC
;;;1557   
;;;1558   void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1559                                OS_PEND_DATA  *p_pend_data)
;;;1560   {
;;;1561       OS_PRIO        prio;
;;;1562       OS_TCB        *p_tcb;
;;;1563       OS_TCB        *p_tcb_next;
;;;1564       OS_PEND_DATA  *p_pend_data_prev;
;;;1565       OS_PEND_DATA  *p_pend_data_next;
;;;1566   
;;;1567   
;;;1568   
;;;1569       p_tcb = p_pend_data->TCBPtr;                                /* Obtain the priority of the task to insert            */
000002  688e              LDR      r6,[r1,#8]
;;;1570       prio  = p_tcb->Prio;
000004  f8965037          LDRB     r5,[r6,#0x37]
;;;1571       if (p_pend_list->HeadPtr == DEF_NULL) {                     /* CASE 0: Insert when there are no entries             */
000008  6807              LDR      r7,[r0,#0]
00000a  b93f              CBNZ     r7,|L18.28|
;;;1572   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1573           p_pend_list->NbrEntries = 1u;                           /* This is the first entry                              */
00000c  2701              MOVS     r7,#1
00000e  8107              STRH     r7,[r0,#8]
;;;1574   #endif
;;;1575           p_pend_data->NextPtr    = DEF_NULL;                     /* No other OS_PEND_DATAs in the list                   */
000010  2700              MOVS     r7,#0
000012  604f              STR      r7,[r1,#4]
;;;1576           p_pend_data->PrevPtr    = DEF_NULL;
000014  600f              STR      r7,[r1,#0]
;;;1577           p_pend_list->HeadPtr    = p_pend_data;
000016  6001              STR      r1,[r0,#0]
;;;1578           p_pend_list->TailPtr    = p_pend_data;
000018  6041              STR      r1,[r0,#4]
00001a  e023              B        |L18.100|
                  |L18.28|
;;;1579       } else {
;;;1580   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1581           p_pend_list->NbrEntries++;                              /* CASE 1: One more OS_PEND_DATA in the list            */
00001c  8907              LDRH     r7,[r0,#8]
00001e  1c7f              ADDS     r7,r7,#1
000020  8107              STRH     r7,[r0,#8]
;;;1582   #endif
;;;1583           p_pend_data_next = p_pend_list->HeadPtr;
000022  6802              LDR      r2,[r0,#0]
;;;1584           while (p_pend_data_next != DEF_NULL) {                  /* Find the position where to insert                    */
000024  e006              B        |L18.52|
                  |L18.38|
;;;1585               p_tcb_next   = p_pend_data_next->TCBPtr;
000026  6894              LDR      r4,[r2,#8]
;;;1586               if (prio < p_tcb_next->Prio) {
000028  f8947037          LDRB     r7,[r4,#0x37]
00002c  42af              CMP      r7,r5
00002e  dd00              BLE      |L18.50|
;;;1587                   break;                                          /* Found! ... insert BEFORE current                     */
000030  e002              B        |L18.56|
                  |L18.50|
;;;1588               } else {
;;;1589                   p_pend_data_next = p_pend_data_next->NextPtr;   /* Not Found, follow the list                           */
000032  6852              LDR      r2,[r2,#4]
                  |L18.52|
000034  2a00              CMP      r2,#0                 ;1584
000036  d1f6              BNE      |L18.38|
                  |L18.56|
000038  bf00              NOP                            ;1587
;;;1590               }
;;;1591           }
;;;1592           if (p_pend_data_next == DEF_NULL) {                     /* TCB to insert is lower in prio                       */
00003a  b932              CBNZ     r2,|L18.74|
;;;1593               p_pend_data->NextPtr      = DEF_NULL;               /* ... insert at the tail.                              */
00003c  2700              MOVS     r7,#0
00003e  604f              STR      r7,[r1,#4]
;;;1594               p_pend_data_prev          = p_pend_list->TailPtr;
000040  6843              LDR      r3,[r0,#4]
;;;1595               p_pend_data->PrevPtr      = p_pend_data_prev;
000042  600b              STR      r3,[r1,#0]
;;;1596               p_pend_data_prev->NextPtr = p_pend_data;
000044  6059              STR      r1,[r3,#4]
;;;1597               p_pend_list->TailPtr      = p_pend_data;
000046  6041              STR      r1,[r0,#4]
000048  e00c              B        |L18.100|
                  |L18.74|
;;;1598           } else {
;;;1599               if (p_pend_data_next->PrevPtr == DEF_NULL) {        /* Is new TCB highest priority?                         */
00004a  6817              LDR      r7,[r2,#0]
00004c  b92f              CBNZ     r7,|L18.90|
;;;1600                   p_pend_data_next->PrevPtr = p_pend_data;        /* Yes, insert as new Head of list                      */
00004e  6011              STR      r1,[r2,#0]
;;;1601                   p_pend_data->PrevPtr      = DEF_NULL;
000050  2700              MOVS     r7,#0
000052  600f              STR      r7,[r1,#0]
;;;1602                   p_pend_data->NextPtr      = p_pend_data_next;
000054  604a              STR      r2,[r1,#4]
;;;1603                   p_pend_list->HeadPtr      = p_pend_data;
000056  6001              STR      r1,[r0,#0]
000058  e004              B        |L18.100|
                  |L18.90|
;;;1604               } else {
;;;1605                   p_pend_data_prev          = p_pend_data_next->PrevPtr;  /* No,  insert in between two entries           */
00005a  6813              LDR      r3,[r2,#0]
;;;1606                   p_pend_data->PrevPtr      = p_pend_data_prev;
00005c  600b              STR      r3,[r1,#0]
;;;1607                   p_pend_data->NextPtr      = p_pend_data_next;
00005e  604a              STR      r2,[r1,#4]
;;;1608                   p_pend_data_prev->NextPtr = p_pend_data;
000060  6059              STR      r1,[r3,#4]
;;;1609                   p_pend_data_next->PrevPtr = p_pend_data;
000062  6011              STR      r1,[r2,#0]
                  |L18.100|
;;;1610               }
;;;1611           }
;;;1612       }
;;;1613   }
000064  bdf0              POP      {r4-r7,pc}
;;;1614   
                          ENDP


                          AREA ||i.OS_PendListRemove||, CODE, READONLY, ALIGN=1

                  OS_PendListRemove PROC
;;;1664   
;;;1665   void  OS_PendListRemove (OS_TCB  *p_tcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1666   {
000004  4604              MOV      r4,r0
;;;1667       OS_OBJ_QTY      n_pend_list;                                /* Number of pend lists                                 */
;;;1668       OS_PEND_DATA   *p_pend_data;
;;;1669       OS_PEND_LIST   *p_pend_list;
;;;1670       OS_PEND_OBJ    *p_obj;
;;;1671   
;;;1672   
;;;1673       if (p_tcb->PendDataTblPtr != DEF_NULL) {                    /* Only remove if object has a pend list.               */
000006  6b20              LDR      r0,[r4,#0x30]
000008  b188              CBZ      r0,|L19.46|
;;;1674           p_pend_data = p_tcb->PendDataTblPtr;                    /* Point to the first OS_PEND_DATA to remove            */
00000a  6b25              LDR      r5,[r4,#0x30]
;;;1675   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;1676           n_pend_list = p_tcb->PendDataTblEntries;                /* Get number of entries in the table                   */
;;;1677   #else
;;;1678           n_pend_list = 1u;
00000c  2601              MOVS     r6,#1
;;;1679   #endif
;;;1680   
;;;1681   
;;;1682           while (n_pend_list > 0u) {
00000e  e00a              B        |L19.38|
                  |L19.16|
;;;1683           p_obj       =  p_pend_data->PendObjPtr;                 /* Get pointer to pend list                             */
000010  f8d5800c          LDR      r8,[r5,#0xc]
;;;1684               p_pend_list = &p_obj->PendList;
000014  f1080708          ADD      r7,r8,#8
;;;1685               OS_PendListRemove1(p_pend_list,
000018  4629              MOV      r1,r5
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       OS_PendListRemove1
;;;1686                                  p_pend_data);
;;;1687               p_pend_data++;
000020  3520              ADDS     r5,r5,#0x20
;;;1688               n_pend_list--;
000022  1e70              SUBS     r0,r6,#1
000024  b286              UXTH     r6,r0
                  |L19.38|
000026  2e00              CMP      r6,#0                 ;1682
000028  d1f2              BNE      |L19.16|
;;;1689           }
;;;1690       #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;1691           p_tcb->PendDataTblEntries = 0u;
;;;1692       #endif
;;;1693           p_tcb->PendDataTblPtr     = DEF_NULL;
00002a  2000              MOVS     r0,#0
00002c  6320              STR      r0,[r4,#0x30]
                  |L19.46|
;;;1694       }
;;;1695   }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;1696   
                          ENDP


                          AREA ||i.OS_PendListRemove1||, CODE, READONLY, ALIGN=1

                  OS_PendListRemove1 PROC
;;;1747   
;;;1748   void  OS_PendListRemove1 (OS_PEND_LIST  *p_pend_list,
000000  b510              PUSH     {r4,lr}
;;;1749                             OS_PEND_DATA  *p_pend_data)
;;;1750   {
;;;1751       OS_PEND_DATA  *p_prev;
;;;1752       OS_PEND_DATA  *p_next;
;;;1753   
;;;1754   
;;;1755   
;;;1756       if (p_pend_list->HeadPtr->NextPtr == DEF_NULL) {
000002  6804              LDR      r4,[r0,#0]
000004  6864              LDR      r4,[r4,#4]
000006  b91c              CBNZ     r4,|L20.16|
;;;1757           p_pend_list->HeadPtr = DEF_NULL;                        /* Only one entry in the pend list                      */
000008  2400              MOVS     r4,#0
00000a  6004              STR      r4,[r0,#0]
;;;1758           p_pend_list->TailPtr = DEF_NULL;
00000c  6044              STR      r4,[r0,#4]
00000e  e011              B        |L20.52|
                  |L20.16|
;;;1759   
;;;1760       } else if (p_pend_data->PrevPtr == DEF_NULL) {              /* See if entry is at the head of the list              */
000010  680c              LDR      r4,[r1,#0]
000012  b924              CBNZ     r4,|L20.30|
;;;1761           p_next               = p_pend_data->NextPtr;            /* Yes                                                  */
000014  684b              LDR      r3,[r1,#4]
;;;1762           p_next->PrevPtr      = DEF_NULL;
000016  2400              MOVS     r4,#0
000018  601c              STR      r4,[r3,#0]
;;;1763           p_pend_list->HeadPtr = p_next;
00001a  6003              STR      r3,[r0,#0]
00001c  e00a              B        |L20.52|
                  |L20.30|
;;;1764   
;;;1765       } else if (p_pend_data->NextPtr == DEF_NULL) {              /* See if entry is at the tail of the list              */
00001e  684c              LDR      r4,[r1,#4]
000020  b924              CBNZ     r4,|L20.44|
;;;1766           p_prev               = p_pend_data->PrevPtr;            /* Yes                                                  */
000022  680a              LDR      r2,[r1,#0]
;;;1767           p_prev->NextPtr      = DEF_NULL;
000024  2400              MOVS     r4,#0
000026  6054              STR      r4,[r2,#4]
;;;1768           p_pend_list->TailPtr = p_prev;
000028  6042              STR      r2,[r0,#4]
00002a  e003              B        |L20.52|
                  |L20.44|
;;;1769   
;;;1770       } else {
;;;1771           p_prev               = p_pend_data->PrevPtr;            /* Remove from inside the list                          */
00002c  680a              LDR      r2,[r1,#0]
;;;1772           p_next               = p_pend_data->NextPtr;
00002e  684b              LDR      r3,[r1,#4]
;;;1773           p_prev->NextPtr      = p_next;
000030  6053              STR      r3,[r2,#4]
;;;1774           p_next->PrevPtr      = p_prev;
000032  601a              STR      r2,[r3,#0]
                  |L20.52|
;;;1775       }
;;;1776   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1777       p_pend_list->NbrEntries--;                                  /* One less entry in the list                           */
000034  8904              LDRH     r4,[r0,#8]
000036  1e64              SUBS     r4,r4,#1
000038  8104              STRH     r4,[r0,#8]
;;;1778   #endif
;;;1779       p_pend_data->NextPtr = DEF_NULL;
00003a  2400              MOVS     r4,#0
00003c  604c              STR      r4,[r1,#4]
;;;1780       p_pend_data->PrevPtr = DEF_NULL;
00003e  600c              STR      r4,[r1,#0]
;;;1781   }
000040  bd10              POP      {r4,pc}
;;;1782   
                          ENDP


                          AREA ||i.OS_PendObjDel||, CODE, READONLY, ALIGN=1

                  OS_PendObjDel PROC
;;;1803   
;;;1804   void  OS_PendObjDel (OS_PEND_OBJ  *p_obj,
000000  b570              PUSH     {r4-r6,lr}
;;;1805                        OS_TCB       *p_tcb,
;;;1806                        CPU_TS        ts)
;;;1807   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1808   #if (OS_CFG_TS_EN == DEF_DISABLED)
;;;1809       (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
;;;1810   #endif
;;;1811   #if (OS_CFG_PEND_MULTI_EN == DEF_DISABLED)
;;;1812       (void)p_obj;
;;;1813   #endif
;;;1814   
;;;1815       switch (p_tcb->TaskState) {
000008  f8940036          LDRB     r0,[r4,#0x36]
00000c  2808              CMP      r0,#8
00000e  d244              BCS      |L21.154|
000010  e8dff000          TBB      [pc,r0]
000014  04050809          DCB      0x04,0x05,0x08,0x09
000018  06072728          DCB      0x06,0x07,0x27,0x28
;;;1816           case OS_TASK_STATE_RDY:                                 /* These states should never occur                      */
;;;1817           case OS_TASK_STATE_DLY:
00001c  bf00              NOP      
;;;1818           case OS_TASK_STATE_SUSPENDED:
00001e  bf00              NOP      
;;;1819           case OS_TASK_STATE_DLY_SUSPENDED:
000020  bf00              NOP      
;;;1820                break;
000022  e03b              B        |L21.156|
;;;1821   
;;;1822           case OS_TASK_STATE_PEND:
;;;1823           case OS_TASK_STATE_PEND_TIMEOUT:
000024  bf00              NOP      
;;;1824   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;1825                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
;;;1826                    OS_PendObjDel1(p_obj,                          /* Indicate which object was pend aborted               */
;;;1827                                   p_tcb,
;;;1828                                   ts);
;;;1829                }
;;;1830   #endif
;;;1831   #if (OS_MSG_EN == DEF_ENABLED)
;;;1832                p_tcb->MsgPtr     = DEF_NULL;
000026  2000              MOVS     r0,#0
000028  65a0              STR      r0,[r4,#0x58]
;;;1833                p_tcb->MsgSize    = 0u;
00002a  f8a4005c          STRH     r0,[r4,#0x5c]
;;;1834   #endif
;;;1835   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1836                p_tcb->TS         = ts;
00002e  64a5              STR      r5,[r4,#0x48]
;;;1837   #endif
;;;1838                OS_PendListRemove(p_tcb);                          /* Remove task from all wait lists                      */
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       OS_PendListRemove
;;;1839   #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;1840                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
000036  f8940036          LDRB     r0,[r4,#0x36]
00003a  2803              CMP      r0,#3
00003c  d102              BNE      |L21.68|
;;;1841                    OS_TickListRemove(p_tcb);                      /* Remove from tick list                                */
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       OS_TickListRemove
                  |L21.68|
;;;1842                }
;;;1843   #endif
;;;1844                OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       OS_RdyListInsert
;;;1845                p_tcb->TaskState  = OS_TASK_STATE_RDY;             /* Task is readied because object is deleted            */
00004a  2000              MOVS     r0,#0
00004c  f1040434          ADD      r4,r4,#0x34
000050  70a0              STRB     r0,[r4,#2]
;;;1846                p_tcb->PendStatus = OS_STATUS_PEND_DEL;
000052  f04f0002          MOV      r0,#2
000056  7060              STRB     r0,[r4,#1]
;;;1847                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
000058  f04f0000          MOV      r0,#0
00005c  f8040934          STRB     r0,[r4],#-0x34
;;;1848                break;
000060  e01c              B        |L21.156|
;;;1849   
;;;1850           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1851           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
000062  bf00              NOP      
;;;1852   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;1853                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
;;;1854                    OS_PendObjDel1(p_obj,                          /* Indicate which object was pend aborted               */
;;;1855                                   p_tcb,
;;;1856                                   ts);
;;;1857                }
;;;1858   #endif
;;;1859   #if (OS_MSG_EN == DEF_ENABLED)
;;;1860                p_tcb->MsgPtr     = DEF_NULL;
000064  2000              MOVS     r0,#0
000066  65a0              STR      r0,[r4,#0x58]
;;;1861                p_tcb->MsgSize    = 0u;
000068  f8a4005c          STRH     r0,[r4,#0x5c]
;;;1862   #endif
;;;1863   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1864                p_tcb->TS         = ts;
00006c  64a5              STR      r5,[r4,#0x48]
;;;1865   #endif
;;;1866                OS_PendListRemove(p_tcb);                          /* Remove task from all wait lists                      */
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       OS_PendListRemove
;;;1867   #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;1868                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
000074  f8940036          LDRB     r0,[r4,#0x36]
000078  2807              CMP      r0,#7
00007a  d102              BNE      |L21.130|
;;;1869                    OS_TickListRemove(p_tcb);                      /* Cancel the timeout                                   */
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       OS_TickListRemove
                  |L21.130|
;;;1870                }
;;;1871   #endif
;;;1872                p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;       /* Task needs to remain suspended                       */
000082  2004              MOVS     r0,#4
000084  f1040434          ADD      r4,r4,#0x34
000088  70a0              STRB     r0,[r4,#2]
;;;1873                p_tcb->PendStatus = OS_STATUS_PEND_DEL;
00008a  f04f0002          MOV      r0,#2
00008e  7060              STRB     r0,[r4,#1]
;;;1874                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
000090  f04f0000          MOV      r0,#0
000094  f8040934          STRB     r0,[r4],#-0x34
;;;1875                break;
000098  e000              B        |L21.156|
                  |L21.154|
;;;1876   
;;;1877           default:
;;;1878                break;
00009a  bf00              NOP      
                  |L21.156|
00009c  bf00              NOP                            ;1820
;;;1879       }
;;;1880   }
00009e  bd70              POP      {r4-r6,pc}
;;;1881   
                          ENDP


                          AREA ||i.OS_Post||, CODE, READONLY, ALIGN=1

                  OS_Post PROC
;;;1983   
;;;1984   void  OS_Post (OS_PEND_OBJ  *p_obj,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1985                  OS_TCB       *p_tcb,
;;;1986                  void         *p_void,
;;;1987                  OS_MSG_SIZE   msg_size,
;;;1988                  CPU_TS        ts)
;;;1989   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1990   #if (OS_CFG_TS_EN == DEF_DISABLED)
;;;1991       (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
;;;1992   #endif
;;;1993   
;;;1994       switch (p_tcb->TaskState) {
000010  f8940036          LDRB     r0,[r4,#0x36]
000014  2808              CMP      r0,#8
000016  d248              BCS      |L22.170|
000018  e8dff000          TBB      [pc,r0]
00001c  04050809          DCB      0x04,0x05,0x08,0x09
000020  06072829          DCB      0x06,0x07,0x28,0x29
;;;1995           case OS_TASK_STATE_RDY:                                 /* Cannot Pend Abort a task that is ready               */
;;;1996           case OS_TASK_STATE_DLY:                                 /* Cannot Pend Abort a task that is delayed             */
000024  bf00              NOP      
;;;1997           case OS_TASK_STATE_SUSPENDED:                           /* Cannot Post a suspended task                         */
000026  bf00              NOP      
;;;1998           case OS_TASK_STATE_DLY_SUSPENDED:                       /* Cannot Post a suspended task that was also dly'd     */
000028  bf00              NOP      
;;;1999                break;
00002a  e03f              B        |L22.172|
;;;2000   
;;;2001           case OS_TASK_STATE_PEND:
;;;2002           case OS_TASK_STATE_PEND_TIMEOUT:
00002c  bf00              NOP      
;;;2003   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;2004                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
;;;2005                    OS_Post1(p_obj,                                /* Indicate which object was posted to                  */
;;;2006                             p_tcb,
;;;2007                             p_void,
;;;2008                             msg_size,
;;;2009                             ts);
;;;2010                } else {
;;;2011   #endif
;;;2012   #if (OS_MSG_EN == DEF_ENABLED)
;;;2013                    p_tcb->MsgPtr  = p_void;                       /* Deposit message in OS_TCB of task waiting            */
00002e  65a6              STR      r6,[r4,#0x58]
;;;2014                    p_tcb->MsgSize = msg_size;                     /* ... assuming posting a message                       */
000030  f8a4705c          STRH     r7,[r4,#0x5c]
;;;2015   #endif
;;;2016   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;2017                    p_tcb->TS      = ts;
000034  f8c48048          STR      r8,[r4,#0x48]
;;;2018   #endif
;;;2019   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;2020                }
;;;2021   #endif
;;;2022                if (p_obj != DEF_NULL) {
000038  b135              CBZ      r5,|L22.72|
;;;2023                    OS_PendListRemove(p_tcb);                      /* Remove task from wait list(s)                        */
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       OS_PendListRemove
;;;2024   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2025                    OS_PendDbgNameRemove(p_obj,
000040  4621              MOV      r1,r4
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       OS_PendDbgNameRemove
                  |L22.72|
;;;2026                                         p_tcb);
;;;2027   #endif
;;;2028                }
;;;2029   #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;2030                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
000048  f8940036          LDRB     r0,[r4,#0x36]
00004c  2803              CMP      r0,#3
00004e  d102              BNE      |L22.86|
;;;2031                    OS_TickListRemove(p_tcb);                      /* Remove from tick list                                */
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       OS_TickListRemove
                  |L22.86|
;;;2032                }
;;;2033   #endif
;;;2034                OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       OS_RdyListInsert
;;;2035                p_tcb->TaskState  = OS_TASK_STATE_RDY;
00005c  2000              MOVS     r0,#0
00005e  f1040434          ADD      r4,r4,#0x34
000062  70a0              STRB     r0,[r4,#2]
;;;2036                p_tcb->PendStatus = OS_STATUS_PEND_OK;             /* Clear pend status                                    */
000064  7060              STRB     r0,[r4,#1]
;;;2037                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
000066  f8040934          STRB     r0,[r4],#-0x34
;;;2038                break;
00006a  e01f              B        |L22.172|
;;;2039   
;;;2040           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2041           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00006c  bf00              NOP      
;;;2042   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;2043                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
;;;2044                    OS_Post1(p_obj,                                /* Indicate which object was posted to                  */
;;;2045                             p_tcb,
;;;2046                             p_void,
;;;2047                             msg_size,
;;;2048                             ts);
;;;2049                } else {
;;;2050   #endif
;;;2051   #if (OS_MSG_EN == DEF_ENABLED)
;;;2052                    p_tcb->MsgPtr  = p_void;                       /* Deposit message in OS_TCB of task waiting            */
00006e  65a6              STR      r6,[r4,#0x58]
;;;2053                    p_tcb->MsgSize = msg_size;                     /* ... assuming posting a message                       */
000070  f8a4705c          STRH     r7,[r4,#0x5c]
;;;2054   #endif
;;;2055   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;2056                    p_tcb->TS      = ts;
000074  f8c48048          STR      r8,[r4,#0x48]
;;;2057   #endif
;;;2058   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;2059                }
;;;2060   #endif
;;;2061                if (p_obj != DEF_NULL) {
000078  b135              CBZ      r5,|L22.136|
;;;2062                    OS_PendListRemove(p_tcb);                      /* Remove task from wait list(s)                        */
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       OS_PendListRemove
;;;2063   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2064                    OS_PendDbgNameRemove(p_obj,
000080  4621              MOV      r1,r4
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       OS_PendDbgNameRemove
                  |L22.136|
;;;2065                                         p_tcb);
;;;2066   #endif
;;;2067                }
;;;2068   #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;2069                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
000088  f8940036          LDRB     r0,[r4,#0x36]
00008c  2807              CMP      r0,#7
00008e  d102              BNE      |L22.150|
;;;2070                    OS_TickListRemove(p_tcb);                      /* Cancel any timeout                                   */
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       OS_TickListRemove
                  |L22.150|
;;;2071                }
;;;2072   #endif
;;;2073                p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
000096  2004              MOVS     r0,#4
000098  f1040434          ADD      r4,r4,#0x34
00009c  70a0              STRB     r0,[r4,#2]
;;;2074                p_tcb->PendStatus = OS_STATUS_PEND_OK;             /* Clear pend status                                    */
00009e  f04f0000          MOV      r0,#0
0000a2  7060              STRB     r0,[r4,#1]
;;;2075                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
0000a4  f8040934          STRB     r0,[r4],#-0x34
;;;2076                break;
0000a8  e000              B        |L22.172|
                  |L22.170|
;;;2077   
;;;2078           default:
;;;2079                break;
0000aa  bf00              NOP      
                  |L22.172|
0000ac  bf00              NOP                            ;1999
;;;2080       }
;;;2081   }
0000ae  e8bd81f0          POP      {r4-r8,pc}
;;;2082   
                          ENDP


                          AREA ||i.OS_RdyListInit||, CODE, READONLY, ALIGN=2

                  OS_RdyListInit PROC
;;;2209   
;;;2210   void  OS_RdyListInit (void)
000000  2100              MOVS     r1,#0
;;;2211   {
;;;2212       CPU_INT32U    i;
;;;2213       OS_RDY_LIST  *p_rdy_list;
;;;2214   
;;;2215   
;;;2216   
;;;2217       for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                    /* Initialize the array of OS_RDY_LIST at each priority */
000002  e009              B        |L23.24|
                  |L23.4|
;;;2218           p_rdy_list = &OSRdyList[i];
000004  eb010241          ADD      r2,r1,r1,LSL #1
000008  4b05              LDR      r3,|L23.32|
00000a  eb030082          ADD      r0,r3,r2,LSL #2
;;;2219   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2220           p_rdy_list->NbrEntries = 0u;
00000e  2200              MOVS     r2,#0
000010  8102              STRH     r2,[r0,#8]
;;;2221   #endif
;;;2222           p_rdy_list->HeadPtr    = DEF_NULL;
000012  6002              STR      r2,[r0,#0]
;;;2223           p_rdy_list->TailPtr    = DEF_NULL;
000014  6042              STR      r2,[r0,#4]
000016  1c49              ADDS     r1,r1,#1              ;2217
                  |L23.24|
000018  2920              CMP      r1,#0x20              ;2217
00001a  d3f3              BCC      |L23.4|
;;;2224       }
;;;2225   }
00001c  4770              BX       lr
;;;2226   
                          ENDP

00001e  0000              DCW      0x0000
                  |L23.32|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListInsert||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsert PROC
;;;2245   
;;;2246   void  OS_RdyListInsert (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2247   {
000002  4604              MOV      r4,r0
;;;2248       OS_PrioInsert(p_tcb->Prio);
000004  f8940037          LDRB     r0,[r4,#0x37]
000008  f7fffffe          BL       OS_PrioInsert
;;;2249       if (p_tcb->Prio == OSPrioCur) {                             /* Are we readying a task at the same prio?             */
00000c  f8940037          LDRB     r0,[r4,#0x37]
000010  4905              LDR      r1,|L24.40|
000012  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000014  4288              CMP      r0,r1
000016  d103              BNE      |L24.32|
;;;2250           OS_RdyListInsertTail(p_tcb);                            /* Yes, insert readied task at the end of the list      */
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       OS_RdyListInsertTail
00001e  e002              B        |L24.38|
                  |L24.32|
;;;2251       } else {
;;;2252           OS_RdyListInsertHead(p_tcb);                            /* No,  insert readied task at the beginning of the list*/
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       OS_RdyListInsertHead
                  |L24.38|
;;;2253       }
;;;2254   
;;;2255   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;2256           TRACE_OS_TASK_READY(p_tcb);                             /* Record the event.                                    */
;;;2257   #endif
;;;2258   }
000026  bd10              POP      {r4,pc}
;;;2259   
                          ENDP

                  |L24.40|
                          DCD      OSPrioCur

                          AREA ||i.OS_RdyListInsertHead||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsertHead PROC
;;;2316   
;;;2317   void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2318   {
;;;2319       OS_RDY_LIST  *p_rdy_list;
;;;2320       OS_TCB       *p_tcb2;
;;;2321   
;;;2322   
;;;2323   
;;;2324       p_rdy_list = &OSRdyList[p_tcb->Prio];
000002  f8903037          LDRB     r3,[r0,#0x37]
000006  eb030343          ADD      r3,r3,r3,LSL #1
00000a  4c0c              LDR      r4,|L25.60|
00000c  eb040183          ADD      r1,r4,r3,LSL #2
;;;2325       if (p_rdy_list->HeadPtr == DEF_NULL) {                      /* CASE 0: Insert when there are no entries             */
000010  680b              LDR      r3,[r1,#0]
000012  b93b              CBNZ     r3,|L25.36|
;;;2326   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2327           p_rdy_list->NbrEntries =  1u;                           /* This is the first entry                              */
000014  2301              MOVS     r3,#1
000016  810b              STRH     r3,[r1,#8]
;;;2328   #endif
;;;2329           p_tcb->NextPtr         =  DEF_NULL;                     /* No other OS_TCBs in the list                         */
000018  2300              MOVS     r3,#0
00001a  6103              STR      r3,[r0,#0x10]
;;;2330           p_tcb->PrevPtr         =  DEF_NULL;
00001c  6143              STR      r3,[r0,#0x14]
;;;2331           p_rdy_list->HeadPtr    =  p_tcb;                        /* Both list pointers point to this OS_TCB              */
00001e  6008              STR      r0,[r1,#0]
;;;2332           p_rdy_list->TailPtr    =  p_tcb;
000020  6048              STR      r0,[r1,#4]
000022  e009              B        |L25.56|
                  |L25.36|
;;;2333       } else {                                                    /* CASE 1: Insert BEFORE the current head of list       */
;;;2334   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2335           p_rdy_list->NbrEntries++;                               /* One more OS_TCB in the list                          */
000024  890b              LDRH     r3,[r1,#8]
000026  1c5b              ADDS     r3,r3,#1
000028  810b              STRH     r3,[r1,#8]
;;;2336   #endif
;;;2337           p_tcb->NextPtr         = p_rdy_list->HeadPtr;           /* Adjust new OS_TCBs links                             */
00002a  680b              LDR      r3,[r1,#0]
00002c  6103              STR      r3,[r0,#0x10]
;;;2338           p_tcb->PrevPtr         = DEF_NULL;
00002e  2300              MOVS     r3,#0
000030  6143              STR      r3,[r0,#0x14]
;;;2339           p_tcb2                 = p_rdy_list->HeadPtr;           /* Adjust old head of list's links                      */
000032  680a              LDR      r2,[r1,#0]
;;;2340           p_tcb2->PrevPtr        = p_tcb;
000034  6150              STR      r0,[r2,#0x14]
;;;2341           p_rdy_list->HeadPtr    = p_tcb;
000036  6008              STR      r0,[r1,#0]
                  |L25.56|
;;;2342       }
;;;2343   }
000038  bd10              POP      {r4,pc}
;;;2344   
                          ENDP

00003a  0000              DCW      0x0000
                  |L25.60|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListInsertTail||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsertTail PROC
;;;2401   
;;;2402   void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2403   {
;;;2404       OS_RDY_LIST  *p_rdy_list;
;;;2405       OS_TCB       *p_tcb2;
;;;2406   
;;;2407   
;;;2408   
;;;2409       p_rdy_list = &OSRdyList[p_tcb->Prio];
000002  f8903037          LDRB     r3,[r0,#0x37]
000006  eb030343          ADD      r3,r3,r3,LSL #1
00000a  4c0b              LDR      r4,|L26.56|
00000c  eb040183          ADD      r1,r4,r3,LSL #2
;;;2410       if (p_rdy_list->HeadPtr == DEF_NULL) {                      /* CASE 0: Insert when there are no entries             */
000010  680b              LDR      r3,[r1,#0]
000012  b93b              CBNZ     r3,|L26.36|
;;;2411   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2412           p_rdy_list->NbrEntries  = 1u;                           /* This is the first entry                              */
000014  2301              MOVS     r3,#1
000016  810b              STRH     r3,[r1,#8]
;;;2413   #endif
;;;2414           p_tcb->NextPtr          = DEF_NULL;                     /* No other OS_TCBs in the list                         */
000018  2300              MOVS     r3,#0
00001a  6103              STR      r3,[r0,#0x10]
;;;2415           p_tcb->PrevPtr          = DEF_NULL;
00001c  6143              STR      r3,[r0,#0x14]
;;;2416           p_rdy_list->HeadPtr     = p_tcb;                        /* Both list pointers point to this OS_TCB              */
00001e  6008              STR      r0,[r1,#0]
;;;2417           p_rdy_list->TailPtr     = p_tcb;
000020  6048              STR      r0,[r1,#4]
000022  e008              B        |L26.54|
                  |L26.36|
;;;2418       } else {                                                    /* CASE 1: Insert AFTER the current tail of list        */
;;;2419   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2420           p_rdy_list->NbrEntries++;                               /* One more OS_TCB in the list                          */
000024  890b              LDRH     r3,[r1,#8]
000026  1c5b              ADDS     r3,r3,#1
000028  810b              STRH     r3,[r1,#8]
;;;2421   #endif
;;;2422           p_tcb->NextPtr          = DEF_NULL;                     /* Adjust new OS_TCBs links                             */
00002a  2300              MOVS     r3,#0
00002c  6103              STR      r3,[r0,#0x10]
;;;2423           p_tcb2                  = p_rdy_list->TailPtr;
00002e  684a              LDR      r2,[r1,#4]
;;;2424           p_tcb->PrevPtr          = p_tcb2;
000030  6142              STR      r2,[r0,#0x14]
;;;2425           p_tcb2->NextPtr         = p_tcb;                        /* Adjust old tail of list's links                      */
000032  6110              STR      r0,[r2,#0x10]
;;;2426           p_rdy_list->TailPtr     = p_tcb;
000034  6048              STR      r0,[r1,#4]
                  |L26.54|
;;;2427       }
;;;2428   }
000036  bd10              POP      {r4,pc}
;;;2429   
                          ENDP

                  |L26.56|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListMoveHeadToTail||, CODE, READONLY, ALIGN=1

                  OS_RdyListMoveHeadToTail PROC
;;;2482   
;;;2483   void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
000000  b530              PUSH     {r4,r5,lr}
;;;2484   {
;;;2485       OS_TCB  *p_tcb1;
;;;2486       OS_TCB  *p_tcb2;
;;;2487       OS_TCB  *p_tcb3;
;;;2488   
;;;2489   
;;;2490        if (p_rdy_list->HeadPtr != p_rdy_list->TailPtr) {
000002  e9d04500          LDRD     r4,r5,[r0,#0]
000006  42ac              CMP      r4,r5
000008  d018              BEQ      |L27.60|
;;;2491            if (p_rdy_list->HeadPtr->NextPtr == p_rdy_list->TailPtr) { /* SWAP the TCBs                                    */
00000a  6804              LDR      r4,[r0,#0]
00000c  6924              LDR      r4,[r4,#0x10]
00000e  6845              LDR      r5,[r0,#4]
000010  42ac              CMP      r4,r5
000012  d109              BNE      |L27.40|
;;;2492                p_tcb1              = p_rdy_list->HeadPtr;         /* Point to current head                                */
000014  6801              LDR      r1,[r0,#0]
;;;2493                p_tcb2              = p_rdy_list->TailPtr;         /* Point to current tail                                */
000016  6842              LDR      r2,[r0,#4]
;;;2494                p_tcb1->PrevPtr     = p_tcb2;
000018  614a              STR      r2,[r1,#0x14]
;;;2495                p_tcb1->NextPtr     = DEF_NULL;
00001a  2400              MOVS     r4,#0
00001c  610c              STR      r4,[r1,#0x10]
;;;2496                p_tcb2->PrevPtr     = DEF_NULL;
00001e  6154              STR      r4,[r2,#0x14]
;;;2497                p_tcb2->NextPtr     = p_tcb1;
000020  6111              STR      r1,[r2,#0x10]
;;;2498                p_rdy_list->HeadPtr = p_tcb2;
000022  6002              STR      r2,[r0,#0]
;;;2499                p_rdy_list->TailPtr = p_tcb1;
000024  6041              STR      r1,[r0,#4]
000026  e009              B        |L27.60|
                  |L27.40|
;;;2500            } else {
;;;2501                p_tcb1              = p_rdy_list->HeadPtr;         /* Point to current head                                */
000028  6801              LDR      r1,[r0,#0]
;;;2502                p_tcb2              = p_rdy_list->TailPtr;         /* Point to current tail                                */
00002a  6842              LDR      r2,[r0,#4]
;;;2503                p_tcb3              = p_tcb1->NextPtr;             /* Point to new list head                               */
00002c  690b              LDR      r3,[r1,#0x10]
;;;2504                p_tcb3->PrevPtr     = DEF_NULL;                    /* Adjust back    link of new list head                 */
00002e  2400              MOVS     r4,#0
000030  615c              STR      r4,[r3,#0x14]
;;;2505                p_tcb1->NextPtr     = DEF_NULL;                    /* Adjust forward link of new list tail                 */
000032  610c              STR      r4,[r1,#0x10]
;;;2506                p_tcb1->PrevPtr     = p_tcb2;                      /* Adjust back    link of new list tail                 */
000034  614a              STR      r2,[r1,#0x14]
;;;2507                p_tcb2->NextPtr     = p_tcb1;                      /* Adjust forward link of old list tail                 */
000036  6111              STR      r1,[r2,#0x10]
;;;2508                p_rdy_list->HeadPtr = p_tcb3;                      /* Adjust new list head and tail pointers               */
000038  6003              STR      r3,[r0,#0]
;;;2509                p_rdy_list->TailPtr = p_tcb1;
00003a  6041              STR      r1,[r0,#4]
                  |L27.60|
;;;2510            }
;;;2511        }
;;;2512   }
00003c  bd30              POP      {r4,r5,pc}
;;;2513   
                          ENDP


                          AREA ||i.OS_RdyListRemove||, CODE, READONLY, ALIGN=2

                  OS_RdyListRemove PROC
;;;2562   
;;;2563   void  OS_RdyListRemove (OS_TCB  *p_tcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2564   {
000004  4605              MOV      r5,r0
;;;2565       OS_RDY_LIST  *p_rdy_list;
;;;2566       OS_TCB       *p_tcb1;
;;;2567       OS_TCB       *p_tcb2;
;;;2568   
;;;2569   
;;;2570   
;;;2571       p_rdy_list = &OSRdyList[p_tcb->Prio];
000006  f8950037          LDRB     r0,[r5,#0x37]
00000a  eb000040          ADD      r0,r0,r0,LSL #1
00000e  4912              LDR      r1,|L28.88|
000010  eb010480          ADD      r4,r1,r0,LSL #2
;;;2572       p_tcb1     = p_tcb->PrevPtr;                                /* Point to next and previous OS_TCB in the list        */
000014  696f              LDR      r7,[r5,#0x14]
;;;2573       p_tcb2     = p_tcb->NextPtr;
000016  692e              LDR      r6,[r5,#0x10]
;;;2574       if (p_tcb1 == DEF_NULL) {                                   /* Was the OS_TCB to remove at the head?                */
000018  b987              CBNZ     r7,|L28.60|
;;;2575           if (p_tcb2 == DEF_NULL) {                               /* Yes, was it the only OS_TCB?                         */
00001a  b946              CBNZ     r6,|L28.46|
;;;2576   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2577               p_rdy_list->NbrEntries = 0u;                        /* Yes, no more entries                                 */
00001c  2000              MOVS     r0,#0
00001e  8120              STRH     r0,[r4,#8]
;;;2578   #endif
;;;2579               p_rdy_list->HeadPtr    = DEF_NULL;
000020  6020              STR      r0,[r4,#0]
;;;2580               p_rdy_list->TailPtr    = DEF_NULL;
000022  6060              STR      r0,[r4,#4]
;;;2581               OS_PrioRemove(p_tcb->Prio);
000024  f8950037          LDRB     r0,[r5,#0x37]
000028  f7fffffe          BL       OS_PrioRemove
00002c  e00e              B        |L28.76|
                  |L28.46|
;;;2582           } else {
;;;2583   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2584               p_rdy_list->NbrEntries--;                           /* No,  one less entry                                  */
00002e  8920              LDRH     r0,[r4,#8]
000030  1e40              SUBS     r0,r0,#1
000032  8120              STRH     r0,[r4,#8]
;;;2585   #endif
;;;2586               p_tcb2->PrevPtr     = DEF_NULL;                     /* adjust back link of new list head                    */
000034  2000              MOVS     r0,#0
000036  6170              STR      r0,[r6,#0x14]
;;;2587               p_rdy_list->HeadPtr = p_tcb2;                       /* adjust OS_RDY_LIST's new head                        */
000038  6026              STR      r6,[r4,#0]
00003a  e007              B        |L28.76|
                  |L28.60|
;;;2588           }
;;;2589       } else {
;;;2590   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2591           p_rdy_list->NbrEntries--;                               /* No,  one less entry                                  */
00003c  8920              LDRH     r0,[r4,#8]
00003e  1e40              SUBS     r0,r0,#1
000040  8120              STRH     r0,[r4,#8]
;;;2592   #endif
;;;2593           p_tcb1->NextPtr = p_tcb2;
000042  613e              STR      r6,[r7,#0x10]
;;;2594           if (p_tcb2 == DEF_NULL) {
000044  b90e              CBNZ     r6,|L28.74|
;;;2595               p_rdy_list->TailPtr = p_tcb1;                       /* Removing the TCB at the tail, adj the tail ptr       */
000046  6067              STR      r7,[r4,#4]
000048  e000              B        |L28.76|
                  |L28.74|
;;;2596           } else {
;;;2597               p_tcb2->PrevPtr     = p_tcb1;
00004a  6177              STR      r7,[r6,#0x14]
                  |L28.76|
;;;2598           }
;;;2599       }
;;;2600       p_tcb->PrevPtr = DEF_NULL;
00004c  2000              MOVS     r0,#0
00004e  6168              STR      r0,[r5,#0x14]
;;;2601       p_tcb->NextPtr = DEF_NULL;
000050  6128              STR      r0,[r5,#0x10]
;;;2602   
;;;2603   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;2604       TRACE_OS_TASK_SUSPEND(p_tcb);                               /* Record the event.                                    */
;;;2605   #endif
;;;2606   }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;2607   
                          ENDP

000056  0000              DCW      0x0000
                  |L28.88|
                          DCD      OSRdyList

                          AREA ||i.OS_TaskBlock||, CODE, READONLY, ALIGN=2

                  OS_TaskBlock PROC
;;;2789   
;;;2790   void  OS_TaskBlock (OS_TCB   *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2791                       OS_TICK   timeout)
;;;2792   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2793   #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;2794   #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
;;;2795           OS_TICK tick_ctr;
;;;2796   #endif
;;;2797   
;;;2798   
;;;2799       if (timeout > 0u) {                                         /* Add task to tick list if timeout non zero            */
000006  b145              CBZ      r5,|L29.26|
;;;2800   #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
;;;2801           tick_ctr = BSP_OS_TickGet();
;;;2802           OS_TickListInsert(&OSTickListTimeout, p_tcb, timeout + (tick_ctr - OSTickCtr));
;;;2803   #else
;;;2804           OS_TickListInsert(&OSTickListTimeout, p_tcb, timeout);
000008  462a              MOV      r2,r5
00000a  4621              MOV      r1,r4
00000c  4806              LDR      r0,|L29.40|
00000e  f7fffffe          BL       OS_TickListInsert
;;;2805   #endif
;;;2806           p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
000012  2003              MOVS     r0,#3
000014  f8840036          STRB     r0,[r4,#0x36]
000018  e002              B        |L29.32|
                  |L29.26|
;;;2807       } else {
;;;2808           p_tcb->TaskState = OS_TASK_STATE_PEND;
00001a  2002              MOVS     r0,#2
00001c  f8840036          STRB     r0,[r4,#0x36]
                  |L29.32|
;;;2809       }
;;;2810   #else
;;;2811       p_tcb->TaskState = OS_TASK_STATE_PEND;
;;;2812   #endif
;;;2813       OS_RdyListRemove(p_tcb);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       OS_RdyListRemove
;;;2814   }
000026  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L29.40|
                          DCD      OSTickListTimeout
