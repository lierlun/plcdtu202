; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\stm32f10x_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\stm32f10x_flash.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1443     */
;;;1444   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;1445   {
;;;1446   #ifdef STM32F10X_XL
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1449   
;;;1450     if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1451     {
;;;1452       /* Clear the flags */
;;;1453       FLASH->SR2 = FLASH_FLAG;
;;;1454     }
;;;1455     else
;;;1456     {
;;;1457       /* Clear the flags */
;;;1458       FLASH->SR = FLASH_FLAG;
;;;1459     }  
;;;1460   
;;;1461   #else
;;;1462     /* Check the parameters */
;;;1463     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1464     
;;;1465     /* Clear the flags */
;;;1466     FLASH->SR = FLASH_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;1467   #endif /* STM32F10X_XL */
;;;1468   }
000004  4770              BX       lr
;;;1469   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;975      */
;;;976    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;977    {
000004  4604              MOV      r4,r0
;;;978      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
00000a  4637              MOV      r7,r6
00000c  46b0              MOV      r8,r6
00000e  46b1              MOV      r9,r6
;;;979      
;;;980      FLASH_Status status = FLASH_COMPLETE;
000010  2504              MOVS     r5,#4
;;;981      
;;;982      /* Check the parameters */
;;;983      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;984      
;;;985      FLASH_Pages = (uint32_t)(~FLASH_Pages);
000012  43e4              MVNS     r4,r4
;;;986      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000014  b2e6              UXTB     r6,r4
;;;987      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000016  f3c42707          UBFX     r7,r4,#8,#8
;;;988      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
00001a  f3c44807          UBFX     r8,r4,#16,#8
;;;989      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
00001e  ea4f6914          LSR      r9,r4,#24
;;;990      
;;;991      /* Wait for last operation to be completed */
;;;992      status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  02e8              LSLS     r0,r5,#11
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4605              MOV      r5,r0
;;;993      
;;;994      if(status == FLASH_COMPLETE)
00002a  2d04              CMP      r5,#4
00002c  d13f              BNE      |L2.174|
;;;995      {
;;;996        /* Authorizes the small information block programming */
;;;997        FLASH->OPTKEYR = FLASH_KEY1;
00002e  4821              LDR      r0,|L2.180|
000030  4921              LDR      r1,|L2.184|
000032  6088              STR      r0,[r1,#8]
;;;998        FLASH->OPTKEYR = FLASH_KEY2;
000034  4821              LDR      r0,|L2.188|
000036  6088              STR      r0,[r1,#8]
;;;999        FLASH->CR |= CR_OPTPG_Set;
000038  4608              MOV      r0,r1
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6108              STR      r0,[r1,#0x10]
;;;1000       if(WRP0_Data != 0xFF)
000042  2eff              CMP      r6,#0xff
000044  d005              BEQ      |L2.82|
;;;1001       {
;;;1002         OB->WRP0 = WRP0_Data;
000046  481e              LDR      r0,|L2.192|
000048  8006              STRH     r6,[r0,#0]
;;;1003         
;;;1004         /* Wait for last operation to be completed */
;;;1005         status = FLASH_WaitForLastOperation(ProgramTimeout);
00004a  02e8              LSLS     r0,r5,#11
00004c  f7fffffe          BL       FLASH_WaitForLastOperation
000050  4605              MOV      r5,r0
                  |L2.82|
;;;1006       }
;;;1007       if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000052  2d04              CMP      r5,#4
000054  d108              BNE      |L2.104|
000056  2fff              CMP      r7,#0xff
000058  d006              BEQ      |L2.104|
;;;1008       {
;;;1009         OB->WRP1 = WRP1_Data;
00005a  4819              LDR      r0,|L2.192|
00005c  1c80              ADDS     r0,r0,#2
00005e  8007              STRH     r7,[r0,#0]
;;;1010         
;;;1011         /* Wait for last operation to be completed */
;;;1012         status = FLASH_WaitForLastOperation(ProgramTimeout);
000060  02e8              LSLS     r0,r5,#11
000062  f7fffffe          BL       FLASH_WaitForLastOperation
000066  4605              MOV      r5,r0
                  |L2.104|
;;;1013       }
;;;1014       if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000068  2d04              CMP      r5,#4
00006a  d10a              BNE      |L2.130|
00006c  f1b80fff          CMP      r8,#0xff
000070  d007              BEQ      |L2.130|
;;;1015       {
;;;1016         OB->WRP2 = WRP2_Data;
000072  4813              LDR      r0,|L2.192|
000074  1d00              ADDS     r0,r0,#4
000076  f8a08000          STRH     r8,[r0,#0]
;;;1017         
;;;1018         /* Wait for last operation to be completed */
;;;1019         status = FLASH_WaitForLastOperation(ProgramTimeout);
00007a  02e8              LSLS     r0,r5,#11
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
000080  4605              MOV      r5,r0
                  |L2.130|
;;;1020       }
;;;1021       
;;;1022       if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000082  2d04              CMP      r5,#4
000084  d10a              BNE      |L2.156|
000086  f1b90fff          CMP      r9,#0xff
00008a  d007              BEQ      |L2.156|
;;;1023       {
;;;1024         OB->WRP3 = WRP3_Data;
00008c  480c              LDR      r0,|L2.192|
00008e  1d80              ADDS     r0,r0,#6
000090  f8a09000          STRH     r9,[r0,#0]
;;;1025        
;;;1026         /* Wait for last operation to be completed */
;;;1027         status = FLASH_WaitForLastOperation(ProgramTimeout);
000094  02e8              LSLS     r0,r5,#11
000096  f7fffffe          BL       FLASH_WaitForLastOperation
00009a  4605              MOV      r5,r0
                  |L2.156|
;;;1028       }
;;;1029             
;;;1030       if(status != FLASH_TIMEOUT)
00009c  2d05              CMP      r5,#5
00009e  d006              BEQ      |L2.174|
;;;1031       {
;;;1032         /* if the program operation is completed, disable the OPTPG Bit */
;;;1033         FLASH->CR &= CR_OPTPG_Reset;
0000a0  4805              LDR      r0,|L2.184|
0000a2  6900              LDR      r0,[r0,#0x10]
0000a4  f64171ef          MOV      r1,#0x1fef
0000a8  4008              ANDS     r0,r0,r1
0000aa  4903              LDR      r1,|L2.184|
0000ac  6108              STR      r0,[r1,#0x10]
                  |L2.174|
;;;1034       }
;;;1035     } 
;;;1036     /* Return the write protection operation Status */
;;;1037     return status;       
0000ae  4628              MOV      r0,r5
;;;1038   }
0000b0  e8bd83f0          POP      {r4-r9,pc}
;;;1039   
                          ENDP

                  |L2.180|
                          DCD      0x45670123
                  |L2.184|
                          DCD      0x40022000
                  |L2.188|
                          DCD      0xcdef89ab
                  |L2.192|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_EraseAllBank1Pages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Pages PROC
;;;555      */
;;;556    FLASH_Status FLASH_EraseAllBank1Pages(void)
000000  b510              PUSH     {r4,lr}
;;;557    {
;;;558      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;559      /* Wait for last operation to be completed */
;;;560      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastBank1Operation
00000c  4604              MOV      r4,r0
;;;561      
;;;562      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d116              BNE      |L3.64|
;;;563      {
;;;564        /* if the previous operation is completed, proceed to erase all pages */
;;;565         FLASH->CR |= CR_MER_Set;
000012  480c              LDR      r0,|L3.68|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490a              LDR      r1,|L3.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;566         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;567        
;;;568        /* Wait for last operation to be completed */
;;;569        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastBank1Operation
000030  4604              MOV      r4,r0
;;;570        
;;;571        /* Disable the MER Bit */
;;;572        FLASH->CR &= CR_MER_Reset;
000032  4804              LDR      r0,|L3.68|
000034  6900              LDR      r0,[r0,#0x10]
000036  f64171fb          MOV      r1,#0x1ffb
00003a  4008              ANDS     r0,r0,r1
00003c  4901              LDR      r1,|L3.68|
00003e  6108              STR      r0,[r1,#0x10]
                  |L3.64|
;;;573      }    
;;;574      /* Return the Erase Status */
;;;575      return status;
000040  4620              MOV      r0,r4
;;;576    }
000042  bd10              POP      {r4,pc}
;;;577    
                          ENDP

                  |L3.68|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;492      */
;;;493    FLASH_Status FLASH_EraseAllPages(void)
000000  b510              PUSH     {r4,lr}
;;;494    {
;;;495      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;496    
;;;497    #ifdef STM32F10X_XL
;;;498      /* Wait for last operation to be completed */
;;;499      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;500      
;;;501      if(status == FLASH_COMPLETE)
;;;502      {
;;;503        /* if the previous operation is completed, proceed to erase all pages */
;;;504         FLASH->CR |= CR_MER_Set;
;;;505         FLASH->CR |= CR_STRT_Set;
;;;506        
;;;507        /* Wait for last operation to be completed */
;;;508        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;509        
;;;510        /* Disable the MER Bit */
;;;511        FLASH->CR &= CR_MER_Reset;
;;;512      }    
;;;513      if(status == FLASH_COMPLETE)
;;;514      {
;;;515        /* if the previous operation is completed, proceed to erase all pages */
;;;516         FLASH->CR2 |= CR_MER_Set;
;;;517         FLASH->CR2 |= CR_STRT_Set;
;;;518        
;;;519        /* Wait for last operation to be completed */
;;;520        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;521        
;;;522        /* Disable the MER Bit */
;;;523        FLASH->CR2 &= CR_MER_Reset;
;;;524      }
;;;525    #else
;;;526      /* Wait for last operation to be completed */
;;;527      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f44f2030          MOV      r0,#0xb0000
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;528      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d116              BNE      |L4.64|
;;;529      {
;;;530        /* if the previous operation is completed, proceed to erase all pages */
;;;531         FLASH->CR |= CR_MER_Set;
000012  480c              LDR      r0,|L4.68|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490a              LDR      r1,|L4.68|
00001c  6108              STR      r0,[r1,#0x10]
;;;532         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;533        
;;;534        /* Wait for last operation to be completed */
;;;535        status = FLASH_WaitForLastOperation(EraseTimeout);
000028  f44f2030          MOV      r0,#0xb0000
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;536    
;;;537        /* Disable the MER Bit */
;;;538        FLASH->CR &= CR_MER_Reset;
000032  4804              LDR      r0,|L4.68|
000034  6900              LDR      r0,[r0,#0x10]
000036  f64171fb          MOV      r1,#0x1ffb
00003a  4008              ANDS     r0,r0,r1
00003c  4901              LDR      r1,|L4.68|
00003e  6108              STR      r0,[r1,#0x10]
                  |L4.64|
;;;539      }
;;;540    #endif /* STM32F10X_XL */
;;;541    
;;;542      /* Return the Erase Status */
;;;543      return status;
000040  4620              MOV      r0,r4
;;;544    }
000042  bd10              POP      {r4,pc}
;;;545    
                          ENDP

                  |L4.68|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;616      */
;;;617    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b530              PUSH     {r4,r5,lr}
;;;618    {
;;;619      uint16_t rdptmp = RDP_Key;
000002  25a5              MOVS     r5,#0xa5
;;;620    
;;;621      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;622    
;;;623      /* Get the actual read protection Option Byte value */ 
;;;624      if(FLASH_GetReadOutProtectionStatus() != RESET)
000006  f7fffffe          BL       FLASH_GetReadOutProtectionStatus
00000a  b100              CBZ      r0,|L5.14|
;;;625      {
;;;626        rdptmp = 0x00;  
00000c  2500              MOVS     r5,#0
                  |L5.14|
;;;627      }
;;;628    
;;;629      /* Wait for last operation to be completed */
;;;630      status = FLASH_WaitForLastOperation(EraseTimeout);
00000e  f44f2030          MOV      r0,#0xb0000
000012  f7fffffe          BL       FLASH_WaitForLastOperation
000016  4604              MOV      r4,r0
;;;631      if(status == FLASH_COMPLETE)
000018  2c04              CMP      r4,#4
00001a  d13a              BNE      |L5.146|
;;;632      {
;;;633        /* Authorize the small information block programming */
;;;634        FLASH->OPTKEYR = FLASH_KEY1;
00001c  481e              LDR      r0,|L5.152|
00001e  491f              LDR      r1,|L5.156|
000020  6088              STR      r0,[r1,#8]
;;;635        FLASH->OPTKEYR = FLASH_KEY2;
000022  481f              LDR      r0,|L5.160|
000024  6088              STR      r0,[r1,#8]
;;;636        
;;;637        /* if the previous operation is completed, proceed to erase the option bytes */
;;;638        FLASH->CR |= CR_OPTER_Set;
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400020          ORR      r0,r0,#0x20
00002e  6108              STR      r0,[r1,#0x10]
;;;639        FLASH->CR |= CR_STRT_Set;
000030  4608              MOV      r0,r1
000032  6900              LDR      r0,[r0,#0x10]
000034  f0400040          ORR      r0,r0,#0x40
000038  6108              STR      r0,[r1,#0x10]
;;;640        /* Wait for last operation to be completed */
;;;641        status = FLASH_WaitForLastOperation(EraseTimeout);
00003a  f44f2030          MOV      r0,#0xb0000
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4604              MOV      r4,r0
;;;642        
;;;643        if(status == FLASH_COMPLETE)
000044  2c04              CMP      r4,#4
000046  d11b              BNE      |L5.128|
;;;644        {
;;;645          /* if the erase operation is completed, disable the OPTER Bit */
;;;646          FLASH->CR &= CR_OPTER_Reset;
000048  4814              LDR      r0,|L5.156|
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f64171df          MOV      r1,#0x1fdf
000050  4008              ANDS     r0,r0,r1
000052  4912              LDR      r1,|L5.156|
000054  6108              STR      r0,[r1,#0x10]
;;;647           
;;;648          /* Enable the Option Bytes Programming operation */
;;;649          FLASH->CR |= CR_OPTPG_Set;
000056  4608              MOV      r0,r1
000058  6900              LDR      r0,[r0,#0x10]
00005a  f0400010          ORR      r0,r0,#0x10
00005e  6108              STR      r0,[r1,#0x10]
;;;650          /* Restore the last read protection Option Byte value */
;;;651          OB->RDP = (uint16_t)rdptmp; 
000060  4810              LDR      r0,|L5.164|
000062  8005              STRH     r5,[r0,#0]
;;;652          /* Wait for last operation to be completed */
;;;653          status = FLASH_WaitForLastOperation(ProgramTimeout);
000064  02e0              LSLS     r0,r4,#11
000066  f7fffffe          BL       FLASH_WaitForLastOperation
00006a  4604              MOV      r4,r0
;;;654     
;;;655          if(status != FLASH_TIMEOUT)
00006c  2c05              CMP      r4,#5
00006e  d010              BEQ      |L5.146|
;;;656          {
;;;657            /* if the program operation is completed, disable the OPTPG Bit */
;;;658            FLASH->CR &= CR_OPTPG_Reset;
000070  480a              LDR      r0,|L5.156|
000072  6900              LDR      r0,[r0,#0x10]
000074  f64171ef          MOV      r1,#0x1fef
000078  4008              ANDS     r0,r0,r1
00007a  4908              LDR      r1,|L5.156|
00007c  6108              STR      r0,[r1,#0x10]
00007e  e008              B        |L5.146|
                  |L5.128|
;;;659          }
;;;660        }
;;;661        else
;;;662        {
;;;663          if (status != FLASH_TIMEOUT)
000080  2c05              CMP      r4,#5
000082  d006              BEQ      |L5.146|
;;;664          {
;;;665            /* Disable the OPTPG Bit */
;;;666            FLASH->CR &= CR_OPTPG_Reset;
000084  4805              LDR      r0,|L5.156|
000086  6900              LDR      r0,[r0,#0x10]
000088  f64171ef          MOV      r1,#0x1fef
00008c  4008              ANDS     r0,r0,r1
00008e  4903              LDR      r1,|L5.156|
000090  6108              STR      r0,[r1,#0x10]
                  |L5.146|
;;;667          }
;;;668        }  
;;;669      }
;;;670      /* Return the erase status */
;;;671      return status;
000092  4620              MOV      r0,r4
;;;672    }
000094  bd30              POP      {r4,r5,pc}
;;;673    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      0x45670123
                  |L5.156|
                          DCD      0x40022000
                  |L5.160|
                          DCD      0xcdef89ab
                  |L5.164|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;419      */
;;;420    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b530              PUSH     {r4,r5,lr}
;;;421    {
000002  4604              MOV      r4,r0
;;;422      FLASH_Status status = FLASH_COMPLETE;
000004  2504              MOVS     r5,#4
;;;423      /* Check the parameters */
;;;424      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;425    
;;;426    #ifdef STM32F10X_XL
;;;427      if(Page_Address < FLASH_BANK1_END_ADDRESS)  
;;;428      {
;;;429        /* Wait for last operation to be completed */
;;;430        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;431        if(status == FLASH_COMPLETE)
;;;432        { 
;;;433          /* if the previous operation is completed, proceed to erase the page */
;;;434          FLASH->CR|= CR_PER_Set;
;;;435          FLASH->AR = Page_Address; 
;;;436          FLASH->CR|= CR_STRT_Set;
;;;437        
;;;438          /* Wait for last operation to be completed */
;;;439          status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;440    
;;;441          /* Disable the PER Bit */
;;;442          FLASH->CR &= CR_PER_Reset;
;;;443        }
;;;444      }
;;;445      else
;;;446      {
;;;447        /* Wait for last operation to be completed */
;;;448        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;449        if(status == FLASH_COMPLETE)
;;;450        { 
;;;451          /* if the previous operation is completed, proceed to erase the page */
;;;452          FLASH->CR2|= CR_PER_Set;
;;;453          FLASH->AR2 = Page_Address; 
;;;454          FLASH->CR2|= CR_STRT_Set;
;;;455        
;;;456          /* Wait for last operation to be completed */
;;;457          status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;458          
;;;459          /* Disable the PER Bit */
;;;460          FLASH->CR2 &= CR_PER_Reset;
;;;461        }
;;;462      }
;;;463    #else
;;;464      /* Wait for last operation to be completed */
;;;465      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f44f2030          MOV      r0,#0xb0000
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4605              MOV      r5,r0
;;;466      
;;;467      if(status == FLASH_COMPLETE)
000010  2d04              CMP      r5,#4
000012  d117              BNE      |L6.68|
;;;468      { 
;;;469        /* if the previous operation is completed, proceed to erase the page */
;;;470        FLASH->CR|= CR_PER_Set;
000014  480c              LDR      r0,|L6.72|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400002          ORR      r0,r0,#2
00001c  490a              LDR      r1,|L6.72|
00001e  6108              STR      r0,[r1,#0x10]
;;;471        FLASH->AR = Page_Address; 
000020  4608              MOV      r0,r1
000022  6144              STR      r4,[r0,#0x14]
;;;472        FLASH->CR|= CR_STRT_Set;
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6108              STR      r0,[r1,#0x10]
;;;473        
;;;474        /* Wait for last operation to be completed */
;;;475        status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  f44f2030          MOV      r0,#0xb0000
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  4605              MOV      r5,r0
;;;476        
;;;477        /* Disable the PER Bit */
;;;478        FLASH->CR &= CR_PER_Reset;
000036  4804              LDR      r0,|L6.72|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171fd          MOV      r1,#0x1ffd
00003e  4008              ANDS     r0,r0,r1
000040  4901              LDR      r1,|L6.72|
000042  6108              STR      r0,[r1,#0x10]
                  |L6.68|
;;;479      }
;;;480    #endif /* STM32F10X_XL */
;;;481    
;;;482      /* Return the Erase Status */
;;;483      return status;
000044  4628              MOV      r0,r5
;;;484    }
000046  bd30              POP      {r4,r5,pc}
;;;485    
                          ENDP

                  |L6.72|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetBank1Status||, CODE, READONLY, ALIGN=2

                  FLASH_GetBank1Status PROC
;;;1515     */
;;;1516   FLASH_Status FLASH_GetBank1Status(void)
000000  2004              MOVS     r0,#4
;;;1517   {
;;;1518     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1519     
;;;1520     if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L7.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0110f01          TST      r1,#1
00000a  d001              BEQ      |L7.16|
;;;1521     {
;;;1522       flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L7.46|
                  |L7.16|
;;;1523     }
;;;1524     else 
;;;1525     {  
;;;1526       if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
000010  4907              LDR      r1,|L7.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0110f04          TST      r1,#4
000018  d001              BEQ      |L7.30|
;;;1527       { 
;;;1528         flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L7.46|
                  |L7.30|
;;;1529       }
;;;1530       else 
;;;1531       {
;;;1532         if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L7.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0110f10          TST      r1,#0x10
000026  d001              BEQ      |L7.44|
;;;1533         {
;;;1534           flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L7.46|
                  |L7.44|
;;;1535         }
;;;1536         else
;;;1537         {
;;;1538           flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L7.46|
;;;1539         }
;;;1540       }
;;;1541     }
;;;1542     /* Return the Flash Status */
;;;1543     return flashstatus;
;;;1544   }
00002e  4770              BX       lr
;;;1545   
                          ENDP

                  |L7.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1357     */
;;;1358   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;1359   {
;;;1360     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1361   
;;;1362   #ifdef STM32F10X_XL
;;;1363     /* Check the parameters */
;;;1364     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1365     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;1366     {
;;;1367       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
;;;1368       {
;;;1369         bitstatus = SET;
;;;1370       }
;;;1371       else
;;;1372       {
;;;1373         bitstatus = RESET;
;;;1374       }
;;;1375     }
;;;1376     else
;;;1377     {
;;;1378       if((FLASH_FLAG & 0x80000000) != 0x0)
;;;1379       {
;;;1380         if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
;;;1381         {
;;;1382           bitstatus = SET;
;;;1383         }
;;;1384         else
;;;1385         {
;;;1386           bitstatus = RESET;
;;;1387         }
;;;1388       }
;;;1389       else
;;;1390       {
;;;1391         if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
;;;1392         {
;;;1393           bitstatus = SET;
;;;1394         }
;;;1395         else
;;;1396         {
;;;1397           bitstatus = RESET;
;;;1398         }
;;;1399       }
;;;1400     }
;;;1401   #else
;;;1402     /* Check the parameters */
;;;1403     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1404     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
000004  2901              CMP      r1,#1
000006  d108              BNE      |L8.26|
;;;1405     {
;;;1406       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
000008  4a08              LDR      r2,|L8.44|
00000a  69d2              LDR      r2,[r2,#0x1c]
00000c  f0120f01          TST      r2,#1
000010  d001              BEQ      |L8.22|
;;;1407       {
;;;1408         bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e008              B        |L8.40|
                  |L8.22|
;;;1409       }
;;;1410       else
;;;1411       {
;;;1412         bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e006              B        |L8.40|
                  |L8.26|
;;;1413       }
;;;1414     }
;;;1415     else
;;;1416     {
;;;1417      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00001a  4a04              LDR      r2,|L8.44|
00001c  68d2              LDR      r2,[r2,#0xc]
00001e  420a              TST      r2,r1
000020  d001              BEQ      |L8.38|
;;;1418       {
;;;1419         bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L8.40|
                  |L8.38|
;;;1420       }
;;;1421       else
;;;1422       {
;;;1423         bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L8.40|
;;;1424       }
;;;1425     }
;;;1426   #endif /* STM32F10X_XL */
;;;1427   
;;;1428     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1429     return bitstatus;
;;;1430   }
000028  4770              BX       lr
;;;1431   
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;1260     */
;;;1261   FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  2000              MOVS     r0,#0
;;;1262   {
;;;1263     FlagStatus bitstatus = RESET;
;;;1264     
;;;1265     if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L9.20|
000004  6809              LDR      r1,[r1,#0]
000006  f0110f20          TST      r1,#0x20
00000a  d001              BEQ      |L9.16|
;;;1266     {
;;;1267       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
;;;1268     }
;;;1269     else
;;;1270     {
;;;1271       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;1272     }
;;;1273     /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;1274     return bitstatus; 
;;;1275   }
000012  4770              BX       lr
;;;1276   
                          ENDP

                  |L9.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;1240     */
;;;1241   FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  2000              MOVS     r0,#0
;;;1242   {
;;;1243     FlagStatus readoutstatus = RESET;
;;;1244     if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L10.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0110f02          TST      r1,#2
00000a  d001              BEQ      |L10.16|
;;;1245     {
;;;1246       readoutstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L10.18|
                  |L10.16|
;;;1247     }
;;;1248     else
;;;1249     {
;;;1250       readoutstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;1251     }
;;;1252     return readoutstatus;
;;;1253   }
000012  4770              BX       lr
;;;1254   
                          ENDP

                  |L10.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1477     */
;;;1478   FLASH_Status FLASH_GetStatus(void)
000000  2004              MOVS     r0,#4
;;;1479   {
;;;1480     FLASH_Status flashstatus = FLASH_COMPLETE;
;;;1481     
;;;1482     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L11.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0110f01          TST      r1,#1
00000a  d001              BEQ      |L11.16|
;;;1483     {
;;;1484       flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L11.46|
                  |L11.16|
;;;1485     }
;;;1486     else 
;;;1487     {  
;;;1488       if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
000010  4907              LDR      r1,|L11.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0110f04          TST      r1,#4
000018  d001              BEQ      |L11.30|
;;;1489       { 
;;;1490         flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L11.46|
                  |L11.30|
;;;1491       }
;;;1492       else 
;;;1493       {
;;;1494         if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
00001e  4904              LDR      r1,|L11.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0110f10          TST      r1,#0x10
000026  d001              BEQ      |L11.44|
;;;1495         {
;;;1496           flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L11.46|
                  |L11.44|
;;;1497         }
;;;1498         else
;;;1499         {
;;;1500           flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L11.46|
;;;1501         }
;;;1502       }
;;;1503     }
;;;1504     /* Return the Flash Status */
;;;1505     return flashstatus;
;;;1506   }
00002e  4770              BX       lr
;;;1507   
                          ENDP

                  |L11.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;1216     */
;;;1217   uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L12.8|
;;;1218   {
;;;1219     /* Return the User Option Byte */
;;;1220     return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;1221   }
000006  4770              BX       lr
;;;1222   
                          ENDP

                  |L12.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;1228     */
;;;1229   uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L13.8|
;;;1230   {
;;;1231     /* Return the Flash write protection Register value */
;;;1232     return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;1233   }
000004  4770              BX       lr
;;;1234   
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;281      */
;;;282    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  4905              LDR      r1,|L14.24|
;;;283    {
;;;284      /* Check the parameters */
;;;285      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;286      
;;;287      /* Enable or disable the Half cycle access */
;;;288      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210108          BIC      r1,r1,#8
000008  4a03              LDR      r2,|L14.24|
00000a  6011              STR      r1,[r2,#0]
;;;289      FLASH->ACR |= FLASH_HalfCycleAccess;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;290    }
000014  4770              BX       lr
;;;291    
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1290     */
;;;1291   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L15.14|
;;;1292   {
;;;1293   #ifdef STM32F10X_XL
;;;1294     /* Check the parameters */
;;;1295     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1296     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1297   
;;;1298     if((FLASH_IT & 0x80000000) != 0x0)
;;;1299     {
;;;1300       if(NewState != DISABLE)
;;;1301       {
;;;1302         /* Enable the interrupt sources */
;;;1303         FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
;;;1304       }
;;;1305       else
;;;1306       {
;;;1307         /* Disable the interrupt sources */
;;;1308         FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
;;;1309       }
;;;1310     }
;;;1311     else
;;;1312     {
;;;1313       if(NewState != DISABLE)
;;;1314       {
;;;1315         /* Enable the interrupt sources */
;;;1316         FLASH->CR |= FLASH_IT;
;;;1317       }
;;;1318       else
;;;1319       {
;;;1320         /* Disable the interrupt sources */
;;;1321         FLASH->CR &= ~(uint32_t)FLASH_IT;
;;;1322       }
;;;1323     }
;;;1324   #else
;;;1325     /* Check the parameters */
;;;1326     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1327     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1328   
;;;1329     if(NewState != DISABLE)
;;;1330     {
;;;1331       /* Enable the interrupt sources */
;;;1332       FLASH->CR |= FLASH_IT;
000002  4a06              LDR      r2,|L15.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L15.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L15.24|
                  |L15.14|
;;;1333     }
;;;1334     else
;;;1335     {
;;;1336       /* Disable the interrupt sources */
;;;1337       FLASH->CR &= ~(uint32_t)FLASH_IT;
00000e  4a03              LDR      r2,|L15.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L15.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L15.24|
;;;1338     }
;;;1339   #endif /* STM32F10X_XL */
;;;1340   }
000018  4770              BX       lr
;;;1341   
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;372      */
;;;373    void FLASH_Lock(void)
000000  4803              LDR      r0,|L16.16|
;;;374    {
;;;375      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;376      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L16.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;377    
;;;378    #ifdef STM32F10X_XL
;;;379      /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
;;;380      FLASH->CR2 |= CR_LOCK_Set;
;;;381    #endif /* STM32F10X_XL */
;;;382    }
00000c  4770              BX       lr
;;;383    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_LockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_LockBank1 PROC
;;;392      */
;;;393    void FLASH_LockBank1(void)
000000  4803              LDR      r0,|L17.16|
;;;394    {
;;;395      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;396      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L17.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;397    }
00000c  4770              BX       lr
;;;398    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;300      */
;;;301    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  4905              LDR      r1,|L18.24|
;;;302    {
;;;303      /* Check the parameters */
;;;304      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;305      
;;;306      /* Enable or disable the Prefetch Buffer */
;;;307      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210110          BIC      r1,r1,#0x10
000008  4a03              LDR      r2,|L18.24|
00000a  6011              STR      r1,[r2,#0]
;;;308      FLASH->ACR |= FLASH_PrefetchBuffer;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;309    }
000014  4770              BX       lr
;;;310    
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;858      */
;;;859    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;860    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;861      FLASH_Status status = FLASH_COMPLETE;
000006  2604              MOVS     r6,#4
;;;862      /* Check the parameters */
;;;863      assert_param(IS_FLASH_ADDRESS(Address));
;;;864    
;;;865    #ifdef STM32F10X_XL
;;;866      /* Wait for last operation to be completed */
;;;867      status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;868      
;;;869      if(Address < FLASH_BANK1_END_ADDRESS)
;;;870      {
;;;871        if(status == FLASH_COMPLETE)
;;;872        {
;;;873          /* if the previous operation is completed, proceed to program the new data */
;;;874          FLASH->CR |= CR_PG_Set;
;;;875      
;;;876          *(__IO uint16_t*)Address = Data;
;;;877          /* Wait for last operation to be completed */
;;;878          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;879    
;;;880          /* Disable the PG Bit */
;;;881          FLASH->CR &= CR_PG_Reset;
;;;882        }
;;;883      }
;;;884      else
;;;885      {
;;;886        if(status == FLASH_COMPLETE)
;;;887        {
;;;888          /* if the previous operation is completed, proceed to program the new data */
;;;889          FLASH->CR2 |= CR_PG_Set;
;;;890      
;;;891          *(__IO uint16_t*)Address = Data;
;;;892          /* Wait for last operation to be completed */
;;;893          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;894    
;;;895          /* Disable the PG Bit */
;;;896          FLASH->CR2 &= CR_PG_Reset;
;;;897        }
;;;898      }
;;;899    #else
;;;900      /* Wait for last operation to be completed */
;;;901      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  02f0              LSLS     r0,r6,#11
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4606              MOV      r6,r0
;;;902      
;;;903      if(status == FLASH_COMPLETE)
000010  2e04              CMP      r6,#4
000012  d111              BNE      |L19.56|
;;;904      {
;;;905        /* if the previous operation is completed, proceed to program the new data */
;;;906        FLASH->CR |= CR_PG_Set;
000014  4809              LDR      r0,|L19.60|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4907              LDR      r1,|L19.60|
00001e  6108              STR      r0,[r1,#0x10]
;;;907      
;;;908        *(__IO uint16_t*)Address = Data;
000020  8025              STRH     r5,[r4,#0]
;;;909        /* Wait for last operation to be completed */
;;;910        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  02f0              LSLS     r0,r6,#11
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4606              MOV      r6,r0
;;;911        
;;;912        /* Disable the PG Bit */
;;;913        FLASH->CR &= CR_PG_Reset;
00002a  4804              LDR      r0,|L19.60|
00002c  6900              LDR      r0,[r0,#0x10]
00002e  f64171fe          MOV      r1,#0x1ffe
000032  4008              ANDS     r0,r0,r1
000034  4901              LDR      r1,|L19.60|
000036  6108              STR      r0,[r1,#0x10]
                  |L19.56|
;;;914      } 
;;;915    #endif  /* STM32F10X_XL */
;;;916      
;;;917      /* Return the Program Status */
;;;918      return status;
000038  4630              MOV      r0,r6
;;;919    }
00003a  bd70              POP      {r4-r6,pc}
;;;920    
                          ENDP

                  |L19.60|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;929      */
;;;930    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;931    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;932      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;933      /* Check the parameters */
;;;934      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;935      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  02e0              LSLS     r0,r4,#11
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;936    
;;;937      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d117              BNE      |L20.68|
;;;938      {
;;;939        /* Authorize the small information block programming */
;;;940        FLASH->OPTKEYR = FLASH_KEY1;
000014  480c              LDR      r0,|L20.72|
000016  490d              LDR      r1,|L20.76|
000018  6088              STR      r0,[r1,#8]
;;;941        FLASH->OPTKEYR = FLASH_KEY2;
00001a  480d              LDR      r0,|L20.80|
00001c  6088              STR      r0,[r1,#8]
;;;942        /* Enables the Option Bytes Programming operation */
;;;943        FLASH->CR |= CR_OPTPG_Set; 
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400010          ORR      r0,r0,#0x10
000026  6108              STR      r0,[r1,#0x10]
;;;944        *(__IO uint16_t*)Address = Data;
000028  802e              STRH     r6,[r5,#0]
;;;945        
;;;946        /* Wait for last operation to be completed */
;;;947        status = FLASH_WaitForLastOperation(ProgramTimeout);
00002a  02e0              LSLS     r0,r4,#11
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;948        if(status != FLASH_TIMEOUT)
000032  2c05              CMP      r4,#5
000034  d006              BEQ      |L20.68|
;;;949        {
;;;950          /* if the program operation is completed, disable the OPTPG Bit */
;;;951          FLASH->CR &= CR_OPTPG_Reset;
000036  4805              LDR      r0,|L20.76|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171ef          MOV      r1,#0x1fef
00003e  4008              ANDS     r0,r0,r1
000040  4902              LDR      r1,|L20.76|
000042  6108              STR      r0,[r1,#0x10]
                  |L20.68|
;;;952        }
;;;953      }
;;;954      /* Return the Option Byte Data Program Status */
;;;955      return status;
000044  4620              MOV      r0,r4
;;;956    }
000046  bd70              POP      {r4-r6,pc}
;;;957    
                          ENDP

                  |L20.72|
                          DCD      0x45670123
                  |L20.76|
                          DCD      0x40022000
                  |L20.80|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;681      */
;;;682    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b578              PUSH     {r3-r6,lr}
;;;683    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;684      FLASH_Status status = FLASH_COMPLETE;
000006  2504              MOVS     r5,#4
;;;685      __IO uint32_t tmp = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;686    
;;;687      /* Check the parameters */
;;;688      assert_param(IS_FLASH_ADDRESS(Address));
;;;689    
;;;690    #ifdef STM32F10X_XL
;;;691      if(Address < FLASH_BANK1_END_ADDRESS - 2)
;;;692      { 
;;;693        /* Wait for last operation to be completed */
;;;694        status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
;;;695        if(status == FLASH_COMPLETE)
;;;696        {
;;;697          /* if the previous operation is completed, proceed to program the new first 
;;;698            half word */
;;;699          FLASH->CR |= CR_PG_Set;
;;;700      
;;;701          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;702          /* Wait for last operation to be completed */
;;;703          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;704     
;;;705          if(status == FLASH_COMPLETE)
;;;706          {
;;;707            /* if the previous operation is completed, proceed to program the new second 
;;;708            half word */
;;;709            tmp = Address + 2;
;;;710    
;;;711            *(__IO uint16_t*) tmp = Data >> 16;
;;;712        
;;;713            /* Wait for last operation to be completed */
;;;714            status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;715            
;;;716            /* Disable the PG Bit */
;;;717            FLASH->CR &= CR_PG_Reset;
;;;718          }
;;;719          else
;;;720          {
;;;721            /* Disable the PG Bit */
;;;722            FLASH->CR &= CR_PG_Reset;
;;;723           }
;;;724        }
;;;725      }
;;;726      else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
;;;727      {
;;;728        /* Wait for last operation to be completed */
;;;729        status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;730    
;;;731        if(status == FLASH_COMPLETE)
;;;732        {
;;;733          /* if the previous operation is completed, proceed to program the new first 
;;;734            half word */
;;;735          FLASH->CR |= CR_PG_Set;
;;;736      
;;;737          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;738    
;;;739          /* Wait for last operation to be completed */
;;;740          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;741          
;;;742    	  /* Disable the PG Bit */
;;;743          FLASH->CR &= CR_PG_Reset;
;;;744        }
;;;745        else
;;;746        {
;;;747          /* Disable the PG Bit */
;;;748          FLASH->CR &= CR_PG_Reset;
;;;749        }
;;;750    
;;;751        /* Wait for last operation to be completed */
;;;752        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;753    
;;;754        if(status == FLASH_COMPLETE)
;;;755        {
;;;756          /* if the previous operation is completed, proceed to program the new second 
;;;757          half word */
;;;758          FLASH->CR2 |= CR_PG_Set;
;;;759          tmp = Address + 2;
;;;760    
;;;761          *(__IO uint16_t*) tmp = Data >> 16;
;;;762        
;;;763          /* Wait for last operation to be completed */
;;;764          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;765            
;;;766          /* Disable the PG Bit */
;;;767          FLASH->CR2 &= CR_PG_Reset;
;;;768        }
;;;769        else
;;;770        {
;;;771          /* Disable the PG Bit */
;;;772          FLASH->CR2 &= CR_PG_Reset;
;;;773        }
;;;774      }
;;;775      else
;;;776      {
;;;777        /* Wait for last operation to be completed */
;;;778        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;779    
;;;780        if(status == FLASH_COMPLETE)
;;;781        {
;;;782          /* if the previous operation is completed, proceed to program the new first 
;;;783            half word */
;;;784          FLASH->CR2 |= CR_PG_Set;
;;;785      
;;;786          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;787          /* Wait for last operation to be completed */
;;;788          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;789     
;;;790          if(status == FLASH_COMPLETE)
;;;791          {
;;;792            /* if the previous operation is completed, proceed to program the new second 
;;;793            half word */
;;;794            tmp = Address + 2;
;;;795    
;;;796            *(__IO uint16_t*) tmp = Data >> 16;
;;;797        
;;;798            /* Wait for last operation to be completed */
;;;799            status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;800            
;;;801            /* Disable the PG Bit */
;;;802            FLASH->CR2 &= CR_PG_Reset;
;;;803          }
;;;804          else
;;;805          {
;;;806            /* Disable the PG Bit */
;;;807            FLASH->CR2 &= CR_PG_Reset;
;;;808          }
;;;809        }
;;;810      }
;;;811    #else
;;;812      /* Wait for last operation to be completed */
;;;813      status = FLASH_WaitForLastOperation(ProgramTimeout);
00000c  02e8              LSLS     r0,r5,#11
00000e  f7fffffe          BL       FLASH_WaitForLastOperation
000012  4605              MOV      r5,r0
;;;814      
;;;815      if(status == FLASH_COMPLETE)
000014  2d04              CMP      r5,#4
000016  d124              BNE      |L21.98|
;;;816      {
;;;817        /* if the previous operation is completed, proceed to program the new first 
;;;818        half word */
;;;819        FLASH->CR |= CR_PG_Set;
000018  4813              LDR      r0,|L21.104|
00001a  6900              LDR      r0,[r0,#0x10]
00001c  f0400001          ORR      r0,r0,#1
000020  4911              LDR      r1,|L21.104|
000022  6108              STR      r0,[r1,#0x10]
;;;820      
;;;821        *(__IO uint16_t*)Address = (uint16_t)Data;
000024  8034              STRH     r4,[r6,#0]
;;;822        /* Wait for last operation to be completed */
;;;823        status = FLASH_WaitForLastOperation(ProgramTimeout);
000026  02e8              LSLS     r0,r5,#11
000028  f7fffffe          BL       FLASH_WaitForLastOperation
00002c  4605              MOV      r5,r0
;;;824     
;;;825        if(status == FLASH_COMPLETE)
00002e  2d04              CMP      r5,#4
000030  d110              BNE      |L21.84|
;;;826        {
;;;827          /* if the previous operation is completed, proceed to program the new second 
;;;828          half word */
;;;829          tmp = Address + 2;
000032  1cb0              ADDS     r0,r6,#2
000034  9000              STR      r0,[sp,#0]
;;;830    
;;;831          *(__IO uint16_t*) tmp = Data >> 16;
000036  0c20              LSRS     r0,r4,#16
000038  9900              LDR      r1,[sp,#0]
00003a  8008              STRH     r0,[r1,#0]
;;;832        
;;;833          /* Wait for last operation to be completed */
;;;834          status = FLASH_WaitForLastOperation(ProgramTimeout);
00003c  02e8              LSLS     r0,r5,#11
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4605              MOV      r5,r0
;;;835            
;;;836          /* Disable the PG Bit */
;;;837          FLASH->CR &= CR_PG_Reset;
000044  4808              LDR      r0,|L21.104|
000046  6900              LDR      r0,[r0,#0x10]
000048  f64171fe          MOV      r1,#0x1ffe
00004c  4008              ANDS     r0,r0,r1
00004e  4906              LDR      r1,|L21.104|
000050  6108              STR      r0,[r1,#0x10]
000052  e006              B        |L21.98|
                  |L21.84|
;;;838        }
;;;839        else
;;;840        {
;;;841          /* Disable the PG Bit */
;;;842          FLASH->CR &= CR_PG_Reset;
000054  4804              LDR      r0,|L21.104|
000056  6900              LDR      r0,[r0,#0x10]
000058  f64171fe          MOV      r1,#0x1ffe
00005c  4008              ANDS     r0,r0,r1
00005e  4902              LDR      r1,|L21.104|
000060  6108              STR      r0,[r1,#0x10]
                  |L21.98|
;;;843        }
;;;844      }         
;;;845    #endif /* STM32F10X_XL */
;;;846       
;;;847      /* Return the Program Status */
;;;848      return status;
000062  4628              MOV      r0,r5
;;;849    }
000064  bd78              POP      {r3-r6,pc}
;;;850    
                          ENDP

000066  0000              DCW      0x0000
                  |L21.104|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;1049     */
;;;1050   FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1051   {
000002  4605              MOV      r5,r0
;;;1052     FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;1053     /* Check the parameters */
;;;1054     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1055     status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f44f2030          MOV      r0,#0xb0000
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;1056     if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d141              BNE      |L22.152|
;;;1057     {
;;;1058       /* Authorizes the small information block programming */
;;;1059       FLASH->OPTKEYR = FLASH_KEY1;
000014  4821              LDR      r0,|L22.156|
000016  4922              LDR      r1,|L22.160|
000018  6088              STR      r0,[r1,#8]
;;;1060       FLASH->OPTKEYR = FLASH_KEY2;
00001a  4822              LDR      r0,|L22.164|
00001c  6088              STR      r0,[r1,#8]
;;;1061       FLASH->CR |= CR_OPTER_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400020          ORR      r0,r0,#0x20
000026  6108              STR      r0,[r1,#0x10]
;;;1062       FLASH->CR |= CR_STRT_Set;
000028  4608              MOV      r0,r1
00002a  6900              LDR      r0,[r0,#0x10]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6108              STR      r0,[r1,#0x10]
;;;1063       /* Wait for last operation to be completed */
;;;1064       status = FLASH_WaitForLastOperation(EraseTimeout);
000032  f44f2030          MOV      r0,#0xb0000
000036  f7fffffe          BL       FLASH_WaitForLastOperation
00003a  4604              MOV      r4,r0
;;;1065       if(status == FLASH_COMPLETE)
00003c  2c04              CMP      r4,#4
00003e  d122              BNE      |L22.134|
;;;1066       {
;;;1067         /* if the erase operation is completed, disable the OPTER Bit */
;;;1068         FLASH->CR &= CR_OPTER_Reset;
000040  4817              LDR      r0,|L22.160|
000042  6900              LDR      r0,[r0,#0x10]
000044  f64171df          MOV      r1,#0x1fdf
000048  4008              ANDS     r0,r0,r1
00004a  4915              LDR      r1,|L22.160|
00004c  6108              STR      r0,[r1,#0x10]
;;;1069         /* Enable the Option Bytes Programming operation */
;;;1070         FLASH->CR |= CR_OPTPG_Set; 
00004e  4608              MOV      r0,r1
000050  6900              LDR      r0,[r0,#0x10]
000052  f0400010          ORR      r0,r0,#0x10
000056  6108              STR      r0,[r1,#0x10]
;;;1071         if(NewState != DISABLE)
000058  b11d              CBZ      r5,|L22.98|
;;;1072         {
;;;1073           OB->RDP = 0x00;
00005a  2000              MOVS     r0,#0
00005c  4912              LDR      r1,|L22.168|
00005e  8008              STRH     r0,[r1,#0]
000060  e002              B        |L22.104|
                  |L22.98|
;;;1074         }
;;;1075         else
;;;1076         {
;;;1077           OB->RDP = RDP_Key;  
000062  20a5              MOVS     r0,#0xa5
000064  4910              LDR      r1,|L22.168|
000066  8008              STRH     r0,[r1,#0]
                  |L22.104|
;;;1078         }
;;;1079         /* Wait for last operation to be completed */
;;;1080         status = FLASH_WaitForLastOperation(EraseTimeout); 
000068  f44f2030          MOV      r0,#0xb0000
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4604              MOV      r4,r0
;;;1081       
;;;1082         if(status != FLASH_TIMEOUT)
000072  2c05              CMP      r4,#5
000074  d010              BEQ      |L22.152|
;;;1083         {
;;;1084           /* if the program operation is completed, disable the OPTPG Bit */
;;;1085           FLASH->CR &= CR_OPTPG_Reset;
000076  480a              LDR      r0,|L22.160|
000078  6900              LDR      r0,[r0,#0x10]
00007a  f64171ef          MOV      r1,#0x1fef
00007e  4008              ANDS     r0,r0,r1
000080  4907              LDR      r1,|L22.160|
000082  6108              STR      r0,[r1,#0x10]
000084  e008              B        |L22.152|
                  |L22.134|
;;;1086         }
;;;1087       }
;;;1088       else 
;;;1089       {
;;;1090         if(status != FLASH_TIMEOUT)
000086  2c05              CMP      r4,#5
000088  d006              BEQ      |L22.152|
;;;1091         {
;;;1092           /* Disable the OPTER Bit */
;;;1093           FLASH->CR &= CR_OPTER_Reset;
00008a  4805              LDR      r0,|L22.160|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f64171df          MOV      r1,#0x1fdf
000092  4008              ANDS     r0,r0,r1
000094  4902              LDR      r1,|L22.160|
000096  6108              STR      r0,[r1,#0x10]
                  |L22.152|
;;;1094         }
;;;1095       }
;;;1096     }
;;;1097     /* Return the protection operation Status */
;;;1098     return status;       
000098  4620              MOV      r0,r4
;;;1099   }
00009a  bd30              POP      {r4,r5,pc}
;;;1100   
                          ENDP

                  |L22.156|
                          DCD      0x45670123
                  |L22.160|
                          DCD      0x40022000
                  |L22.164|
                          DCD      0xcdef89ab
                  |L22.168|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;254      */
;;;255    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4601              MOV      r1,r0
;;;256    {
;;;257      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;258      
;;;259      /* Check the parameters */
;;;260      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;261      
;;;262      /* Read the ACR register */
;;;263      tmpreg = FLASH->ACR;  
000004  4a03              LDR      r2,|L23.20|
000006  6810              LDR      r0,[r2,#0]
;;;264      
;;;265      /* Sets the Latency value */
;;;266      tmpreg &= ACR_LATENCY_Mask;
000008  f0000038          AND      r0,r0,#0x38
;;;267      tmpreg |= FLASH_Latency;
00000c  4308              ORRS     r0,r0,r1
;;;268      
;;;269      /* Write the ACR register */
;;;270      FLASH->ACR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;271    }
000010  4770              BX       lr
;;;272    
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;319      */
;;;320    void FLASH_Unlock(void)
000000  4802              LDR      r0,|L24.12|
;;;321    {
;;;322      /* Authorize the FPEC of Bank1 Access */
;;;323      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L24.16|
000004  6048              STR      r0,[r1,#4]
;;;324      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L24.20|
000008  6048              STR      r0,[r1,#4]
;;;325    
;;;326    #ifdef STM32F10X_XL
;;;327      /* Authorize the FPEC of Bank2 Access */
;;;328      FLASH->KEYR2 = FLASH_KEY1;
;;;329      FLASH->KEYR2 = FLASH_KEY2;
;;;330    #endif /* STM32F10X_XL */
;;;331    }
00000a  4770              BX       lr
;;;332    /**
                          ENDP

                  |L24.12|
                          DCD      0x45670123
                  |L24.16|
                          DCD      0x40022000
                  |L24.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UnlockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_UnlockBank1 PROC
;;;340      */
;;;341    void FLASH_UnlockBank1(void)
000000  4802              LDR      r0,|L25.12|
;;;342    {
;;;343      /* Authorize the FPEC of Bank1 Access */
;;;344      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L25.16|
000004  6048              STR      r0,[r1,#4]
;;;345      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L25.20|
000008  6048              STR      r0,[r1,#4]
;;;346    }
00000a  4770              BX       lr
;;;347    
                          ENDP

                  |L25.12|
                          DCD      0x45670123
                  |L25.16|
                          DCD      0x40022000
                  |L25.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;1118     */
;;;1119   FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1120   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1121     FLASH_Status status = FLASH_COMPLETE; 
000008  2404              MOVS     r4,#4
;;;1122   
;;;1123     /* Check the parameters */
;;;1124     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;1125     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;1126     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;1127   
;;;1128     /* Authorize the small information block programming */
;;;1129     FLASH->OPTKEYR = FLASH_KEY1;
00000a  4813              LDR      r0,|L26.88|
00000c  4913              LDR      r1,|L26.92|
00000e  6088              STR      r0,[r1,#8]
;;;1130     FLASH->OPTKEYR = FLASH_KEY2;
000010  4813              LDR      r0,|L26.96|
000012  6088              STR      r0,[r1,#8]
;;;1131     
;;;1132     /* Wait for last operation to be completed */
;;;1133     status = FLASH_WaitForLastOperation(ProgramTimeout);
000014  02e0              LSLS     r0,r4,#11
000016  f7fffffe          BL       FLASH_WaitForLastOperation
00001a  4604              MOV      r4,r0
;;;1134     
;;;1135     if(status == FLASH_COMPLETE)
00001c  2c04              CMP      r4,#4
00001e  d118              BNE      |L26.82|
;;;1136     {  
;;;1137       /* Enable the Option Bytes Programming operation */
;;;1138       FLASH->CR |= CR_OPTPG_Set; 
000020  480e              LDR      r0,|L26.92|
000022  6900              LDR      r0,[r0,#0x10]
000024  f0400010          ORR      r0,r0,#0x10
000028  490c              LDR      r1,|L26.92|
00002a  6108              STR      r0,[r1,#0x10]
;;;1139              
;;;1140       OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
00002c  f04700f8          ORR      r0,r7,#0xf8
000030  4330              ORRS     r0,r0,r6
000032  4328              ORRS     r0,r0,r5
000034  490b              LDR      r1,|L26.100|
000036  8008              STRH     r0,[r1,#0]
;;;1141     
;;;1142       /* Wait for last operation to be completed */
;;;1143       status = FLASH_WaitForLastOperation(ProgramTimeout);
000038  02e0              LSLS     r0,r4,#11
00003a  f7fffffe          BL       FLASH_WaitForLastOperation
00003e  4604              MOV      r4,r0
;;;1144       if(status != FLASH_TIMEOUT)
000040  2c05              CMP      r4,#5
000042  d006              BEQ      |L26.82|
;;;1145       {
;;;1146         /* if the program operation is completed, disable the OPTPG Bit */
;;;1147         FLASH->CR &= CR_OPTPG_Reset;
000044  4805              LDR      r0,|L26.92|
000046  6900              LDR      r0,[r0,#0x10]
000048  f64171ef          MOV      r1,#0x1fef
00004c  4008              ANDS     r0,r0,r1
00004e  4903              LDR      r1,|L26.92|
000050  6108              STR      r0,[r1,#0x10]
                  |L26.82|
;;;1148       }
;;;1149     }    
;;;1150     /* Return the Option Byte program Status */
;;;1151     return status;
000052  4620              MOV      r0,r4
;;;1152   }
000054  bdf0              POP      {r4-r7,pc}
;;;1153   
                          ENDP

000056  0000              DCW      0x0000
                  |L26.88|
                          DCD      0x45670123
                  |L26.92|
                          DCD      0x40022000
                  |L26.96|
                          DCD      0xcdef89ab
                  |L26.100|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastBank1Operation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastBank1Operation PROC
;;;1623     */
;;;1624   FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1625   { 
000002  4602              MOV      r2,r0
;;;1626     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1627      
;;;1628     /* Check for the Flash Status */
;;;1629     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1630     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1631     while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
00000c  e003              B        |L27.22|
                  |L27.14|
;;;1632     {
;;;1633       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1634       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L27.22|
000016  2b01              CMP      r3,#1                 ;1631
000018  d101              BNE      |L27.30|
00001a  2a00              CMP      r2,#0                 ;1631
00001c  d1f7              BNE      |L27.14|
                  |L27.30|
;;;1635     }
;;;1636     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L27.34|
;;;1637     {
;;;1638       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L27.34|
;;;1639     }
;;;1640     /* Return the operation status */
;;;1641     return status;
000022  4618              MOV      r0,r3
;;;1642   }
000024  bd00              POP      {pc}
;;;1643   
                          ENDP


                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1595     */
;;;1596   FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1597   { 
000002  4602              MOV      r2,r0
;;;1598     FLASH_Status status = FLASH_COMPLETE;
000004  2304              MOVS     r3,#4
;;;1599      
;;;1600     /* Check for the Flash Status */
;;;1601     status = FLASH_GetBank1Status();
000006  f7fffffe          BL       FLASH_GetBank1Status
00000a  4603              MOV      r3,r0
;;;1602     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1603     while((status == FLASH_BUSY) && (Timeout != 0x00))
00000c  e003              B        |L28.22|
                  |L28.14|
;;;1604     {
;;;1605       status = FLASH_GetBank1Status();
00000e  f7fffffe          BL       FLASH_GetBank1Status
000012  4603              MOV      r3,r0
;;;1606       Timeout--;
000014  1e52              SUBS     r2,r2,#1
                  |L28.22|
000016  2b01              CMP      r3,#1                 ;1603
000018  d101              BNE      |L28.30|
00001a  2a00              CMP      r2,#0                 ;1603
00001c  d1f7              BNE      |L28.14|
                  |L28.30|
;;;1607     }
;;;1608     if(Timeout == 0x00 )
00001e  b902              CBNZ     r2,|L28.34|
;;;1609     {
;;;1610       status = FLASH_TIMEOUT;
000020  2305              MOVS     r3,#5
                  |L28.34|
;;;1611     }
;;;1612     /* Return the operation status */
;;;1613     return status;
000022  4618              MOV      r0,r3
;;;1614   }
000024  bd00              POP      {pc}
;;;1615   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_flash.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f10x_flash_c_a2a150d6____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f10x_flash_c_a2a150d6____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f10x_flash_c_a2a150d6____REVSH|
#line 128
|__asm___17_stm32f10x_flash_c_a2a150d6____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
