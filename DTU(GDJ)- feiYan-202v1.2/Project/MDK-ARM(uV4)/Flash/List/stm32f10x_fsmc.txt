; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\stm32f10x_fsmc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\stm32f10x_fsmc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\stm32f10x_fsmc.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_fsmc.c]
                          THUMB

                          AREA ||i.FSMC_ClearFlag||, CODE, READONLY, ALIGN=2

                  FSMC_ClearFlag PROC
;;;752      */
;;;753    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  2810              CMP      r0,#0x10
;;;754    {
;;;755     /* Check the parameters */
;;;756      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;757      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;758        
;;;759      if(FSMC_Bank == FSMC_Bank2_NAND)
000002  d107              BNE      |L1.20|
;;;760      {
;;;761        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
000004  f04f4220          MOV      r2,#0xa0000000
000008  6e52              LDR      r2,[r2,#0x64]
00000a  438a              BICS     r2,r2,r1
00000c  f04f4320          MOV      r3,#0xa0000000
000010  665a              STR      r2,[r3,#0x64]
000012  e013              B        |L1.60|
                  |L1.20|
;;;762      }  
;;;763      else if(FSMC_Bank == FSMC_Bank3_NAND)
000014  f5b07f80          CMP      r0,#0x100
000018  d108              BNE      |L1.44|
;;;764      {
;;;765        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
00001a  4a09              LDR      r2,|L1.64|
00001c  6812              LDR      r2,[r2,#0]
00001e  ea220201          BIC      r2,r2,r1
000022  f04f4320          MOV      r3,#0xa0000000
000026  f8c32084          STR      r2,[r3,#0x84]
00002a  e007              B        |L1.60|
                  |L1.44|
;;;766      }
;;;767      /* FSMC_Bank4_PCCARD*/
;;;768      else
;;;769      {
;;;770        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
00002c  4a05              LDR      r2,|L1.68|
00002e  6812              LDR      r2,[r2,#0]
000030  ea220201          BIC      r2,r2,r1
000034  f04f4320          MOV      r3,#0xa0000000
000038  f8c320a4          STR      r2,[r3,#0xa4]
                  |L1.60|
;;;771      }
;;;772    }
00003c  4770              BX       lr
;;;773    
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      0xa0000084
                  |L1.68|
                          DCD      0xa00000a4

                          AREA ||i.FSMC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  FSMC_ClearITPendingBit PROC
;;;838      */
;;;839    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  2810              CMP      r0,#0x10
;;;840    {
;;;841      /* Check the parameters */
;;;842      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;843      assert_param(IS_FSMC_IT(FSMC_IT));
;;;844        
;;;845      if(FSMC_Bank == FSMC_Bank2_NAND)
000002  d108              BNE      |L2.22|
;;;846      {
;;;847        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
000004  f04f4220          MOV      r2,#0xa0000000
000008  6e52              LDR      r2,[r2,#0x64]
00000a  ea2202d1          BIC      r2,r2,r1,LSR #3
00000e  f04f4320          MOV      r3,#0xa0000000
000012  665a              STR      r2,[r3,#0x64]
000014  e013              B        |L2.62|
                  |L2.22|
;;;848      }  
;;;849      else if(FSMC_Bank == FSMC_Bank3_NAND)
000016  f5b07f80          CMP      r0,#0x100
00001a  d108              BNE      |L2.46|
;;;850      {
;;;851        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
00001c  4a08              LDR      r2,|L2.64|
00001e  6812              LDR      r2,[r2,#0]
000020  ea2202d1          BIC      r2,r2,r1,LSR #3
000024  f04f4320          MOV      r3,#0xa0000000
000028  f8c32084          STR      r2,[r3,#0x84]
00002c  e007              B        |L2.62|
                  |L2.46|
;;;852      }
;;;853      /* FSMC_Bank4_PCCARD*/
;;;854      else
;;;855      {
;;;856        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
00002e  4a05              LDR      r2,|L2.68|
000030  6812              LDR      r2,[r2,#0]
000032  ea2202d1          BIC      r2,r2,r1,LSR #3
000036  f04f4320          MOV      r3,#0xa0000000
00003a  f8c320a4          STR      r2,[r3,#0xa4]
                  |L2.62|
;;;857      }
;;;858    }
00003e  4770              BX       lr
;;;859    
                          ENDP

                  |L2.64|
                          DCD      0xa0000084
                  |L2.68|
                          DCD      0xa00000a4

                          AREA ||i.FSMC_GetECC||, CODE, READONLY, ALIGN=2

                  FSMC_GetECC PROC
;;;608      */
;;;609    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000000  4601              MOV      r1,r0
;;;610    {
;;;611      uint32_t eccval = 0x00000000;
000002  2000              MOVS     r0,#0
;;;612      
;;;613      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2910              CMP      r1,#0x10
000006  d103              BNE      |L3.16|
;;;614      {
;;;615        /* Get the ECCR2 register value */
;;;616        eccval = FSMC_Bank2->ECCR2;
000008  f04f4220          MOV      r2,#0xa0000000
00000c  6f50              LDR      r0,[r2,#0x74]
00000e  e001              B        |L3.20|
                  |L3.16|
;;;617      }
;;;618      else
;;;619      {
;;;620        /* Get the ECCR3 register value */
;;;621        eccval = FSMC_Bank3->ECCR3;
000010  4a01              LDR      r2,|L3.24|
000012  6810              LDR      r0,[r2,#0]
                  |L3.20|
;;;622      }
;;;623      /* Return the error correction code value */
;;;624      return(eccval);
;;;625    }
000014  4770              BX       lr
;;;626    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      0xa0000094

                          AREA ||i.FSMC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FSMC_GetFlagStatus PROC
;;;702      */
;;;703    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;704    {
000002  4602              MOV      r2,r0
;;;705      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;706      uint32_t tmpsr = 0x00000000;
000006  2300              MOVS     r3,#0
;;;707      
;;;708      /* Check the parameters */
;;;709      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;710      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;711      
;;;712      if(FSMC_Bank == FSMC_Bank2_NAND)
000008  2a10              CMP      r2,#0x10
00000a  d103              BNE      |L4.20|
;;;713      {
;;;714        tmpsr = FSMC_Bank2->SR2;
00000c  f04f4420          MOV      r4,#0xa0000000
000010  6e63              LDR      r3,[r4,#0x64]
000012  e007              B        |L4.36|
                  |L4.20|
;;;715      }  
;;;716      else if(FSMC_Bank == FSMC_Bank3_NAND)
000014  f5b27f80          CMP      r2,#0x100
000018  d102              BNE      |L4.32|
;;;717      {
;;;718        tmpsr = FSMC_Bank3->SR3;
00001a  4c05              LDR      r4,|L4.48|
00001c  6823              LDR      r3,[r4,#0]
00001e  e001              B        |L4.36|
                  |L4.32|
;;;719      }
;;;720      /* FSMC_Bank4_PCCARD*/
;;;721      else
;;;722      {
;;;723        tmpsr = FSMC_Bank4->SR4;
000020  4c04              LDR      r4,|L4.52|
000022  6823              LDR      r3,[r4,#0]
                  |L4.36|
;;;724      } 
;;;725      
;;;726      /* Get the flag status */
;;;727      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
000024  420b              TST      r3,r1
000026  d001              BEQ      |L4.44|
;;;728      {
;;;729        bitstatus = SET;
000028  2001              MOVS     r0,#1
00002a  e000              B        |L4.46|
                  |L4.44|
;;;730      }
;;;731      else
;;;732      {
;;;733        bitstatus = RESET;
00002c  2000              MOVS     r0,#0
                  |L4.46|
;;;734      }
;;;735      /* Return the flag status */
;;;736      return bitstatus;
;;;737    }
00002e  bd10              POP      {r4,pc}
;;;738    
                          ENDP

                  |L4.48|
                          DCD      0xa0000084
                  |L4.52|
                          DCD      0xa00000a4

                          AREA ||i.FSMC_GetITStatus||, CODE, READONLY, ALIGN=2

                  FSMC_GetITStatus PROC
;;;787      */
;;;788    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;789    {
000002  4602              MOV      r2,r0
;;;790      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;791      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
00000a  2500              MOVS     r5,#0
;;;792      
;;;793      /* Check the parameters */
;;;794      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;795      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;796      
;;;797      if(FSMC_Bank == FSMC_Bank2_NAND)
00000c  2a10              CMP      r2,#0x10
00000e  d103              BNE      |L5.24|
;;;798      {
;;;799        tmpsr = FSMC_Bank2->SR2;
000010  f04f4620          MOV      r6,#0xa0000000
000014  6e73              LDR      r3,[r6,#0x64]
000016  e007              B        |L5.40|
                  |L5.24|
;;;800      }  
;;;801      else if(FSMC_Bank == FSMC_Bank3_NAND)
000018  f5b27f80          CMP      r2,#0x100
00001c  d102              BNE      |L5.36|
;;;802      {
;;;803        tmpsr = FSMC_Bank3->SR3;
00001e  4e07              LDR      r6,|L5.60|
000020  6833              LDR      r3,[r6,#0]
000022  e001              B        |L5.40|
                  |L5.36|
;;;804      }
;;;805      /* FSMC_Bank4_PCCARD*/
;;;806      else
;;;807      {
;;;808        tmpsr = FSMC_Bank4->SR4;
000024  4e06              LDR      r6,|L5.64|
000026  6833              LDR      r3,[r6,#0]
                  |L5.40|
;;;809      } 
;;;810      
;;;811      itstatus = tmpsr & FSMC_IT;
000028  ea030401          AND      r4,r3,r1
;;;812      
;;;813      itenable = tmpsr & (FSMC_IT >> 3);
00002c  ea0305d1          AND      r5,r3,r1,LSR #3
;;;814      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
000030  b114              CBZ      r4,|L5.56|
000032  b10d              CBZ      r5,|L5.56|
;;;815      {
;;;816        bitstatus = SET;
000034  2001              MOVS     r0,#1
000036  e000              B        |L5.58|
                  |L5.56|
;;;817      }
;;;818      else
;;;819      {
;;;820        bitstatus = RESET;
000038  2000              MOVS     r0,#0
                  |L5.58|
;;;821      }
;;;822      return bitstatus; 
;;;823    }
00003a  bd70              POP      {r4-r6,pc}
;;;824    
                          ENDP

                  |L5.60|
                          DCD      0xa0000084
                  |L5.64|
                          DCD      0xa00000a4

                          AREA ||i.FSMC_ITConfig||, CODE, READONLY, ALIGN=2

                  FSMC_ITConfig PROC
;;;642      */
;;;643    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;644    {
;;;645      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;646      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;647      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;648      
;;;649      if (NewState != DISABLE)
000002  b1f2              CBZ      r2,|L6.66|
;;;650      {
;;;651        /* Enable the selected FSMC_Bank2 interrupts */
;;;652        if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d107              BNE      |L6.24|
;;;653        {
;;;654          FSMC_Bank2->SR2 |= FSMC_IT;
000008  f04f4320          MOV      r3,#0xa0000000
00000c  6e5b              LDR      r3,[r3,#0x64]
00000e  430b              ORRS     r3,r3,r1
000010  f04f4420          MOV      r4,#0xa0000000
000014  6663              STR      r3,[r4,#0x64]
000016  e032              B        |L6.126|
                  |L6.24|
;;;655        }
;;;656        /* Enable the selected FSMC_Bank3 interrupts */
;;;657        else if (FSMC_Bank == FSMC_Bank3_NAND)
000018  f5b07f80          CMP      r0,#0x100
00001c  d108              BNE      |L6.48|
;;;658        {
;;;659          FSMC_Bank3->SR3 |= FSMC_IT;
00001e  4b18              LDR      r3,|L6.128|
000020  681b              LDR      r3,[r3,#0]
000022  ea430301          ORR      r3,r3,r1
000026  f04f4420          MOV      r4,#0xa0000000
00002a  f8c43084          STR      r3,[r4,#0x84]
00002e  e026              B        |L6.126|
                  |L6.48|
;;;660        }
;;;661        /* Enable the selected FSMC_Bank4 interrupts */
;;;662        else
;;;663        {
;;;664          FSMC_Bank4->SR4 |= FSMC_IT;    
000030  4b14              LDR      r3,|L6.132|
000032  681b              LDR      r3,[r3,#0]
000034  ea430301          ORR      r3,r3,r1
000038  f04f4420          MOV      r4,#0xa0000000
00003c  f8c430a4          STR      r3,[r4,#0xa4]
000040  e01d              B        |L6.126|
                  |L6.66|
;;;665        }
;;;666      }
;;;667      else
;;;668      {
;;;669        /* Disable the selected FSMC_Bank2 interrupts */
;;;670        if(FSMC_Bank == FSMC_Bank2_NAND)
000042  2810              CMP      r0,#0x10
000044  d107              BNE      |L6.86|
;;;671        {
;;;672          
;;;673          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
000046  f04f4320          MOV      r3,#0xa0000000
00004a  6e5b              LDR      r3,[r3,#0x64]
00004c  438b              BICS     r3,r3,r1
00004e  f04f4420          MOV      r4,#0xa0000000
000052  6663              STR      r3,[r4,#0x64]
000054  e013              B        |L6.126|
                  |L6.86|
;;;674        }
;;;675        /* Disable the selected FSMC_Bank3 interrupts */
;;;676        else if (FSMC_Bank == FSMC_Bank3_NAND)
000056  f5b07f80          CMP      r0,#0x100
00005a  d108              BNE      |L6.110|
;;;677        {
;;;678          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
00005c  4b08              LDR      r3,|L6.128|
00005e  681b              LDR      r3,[r3,#0]
000060  ea230301          BIC      r3,r3,r1
000064  f04f4420          MOV      r4,#0xa0000000
000068  f8c43084          STR      r3,[r4,#0x84]
00006c  e007              B        |L6.126|
                  |L6.110|
;;;679        }
;;;680        /* Disable the selected FSMC_Bank4 interrupts */
;;;681        else
;;;682        {
;;;683          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
00006e  4b05              LDR      r3,|L6.132|
000070  681b              LDR      r3,[r3,#0]
000072  ea230301          BIC      r3,r3,r1
000076  f04f4420          MOV      r4,#0xa0000000
00007a  f8c430a4          STR      r3,[r4,#0xa4]
                  |L6.126|
;;;684        }
;;;685      }
;;;686    }
00007e  bd10              POP      {r4,pc}
;;;687    
                          ENDP

                  |L6.128|
                          DCD      0xa0000084
                  |L6.132|
                          DCD      0xa00000a4

                          AREA ||i.FSMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDCmd PROC
;;;506      */
;;;507    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  b199              CBZ      r1,|L7.42|
;;;508    {
;;;509      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;510      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;511      
;;;512      if (NewState != DISABLE)
;;;513      {
;;;514        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;515        if(FSMC_Bank == FSMC_Bank2_NAND)
000002  2810              CMP      r0,#0x10
000004  d108              BNE      |L7.24|
;;;516        {
;;;517          FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
000006  f04f4220          MOV      r2,#0xa0000000
00000a  6e12              LDR      r2,[r2,#0x60]
00000c  f0420204          ORR      r2,r2,#4
000010  f04f4320          MOV      r3,#0xa0000000
000014  661a              STR      r2,[r3,#0x60]
000016  e01c              B        |L7.82|
                  |L7.24|
;;;518        }
;;;519        else
;;;520        {
;;;521          FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
000018  4a0e              LDR      r2,|L7.84|
00001a  6812              LDR      r2,[r2,#0]
00001c  f0420204          ORR      r2,r2,#4
000020  f04f4320          MOV      r3,#0xa0000000
000024  f8c32080          STR      r2,[r3,#0x80]
000028  e013              B        |L7.82|
                  |L7.42|
;;;522        }
;;;523      }
;;;524      else
;;;525      {
;;;526        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;527        if(FSMC_Bank == FSMC_Bank2_NAND)
00002a  2810              CMP      r0,#0x10
00002c  d108              BNE      |L7.64|
;;;528        {
;;;529          FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
00002e  f04f4220          MOV      r2,#0xa0000000
000032  6e12              LDR      r2,[r2,#0x60]
000034  4b08              LDR      r3,|L7.88|
000036  401a              ANDS     r2,r2,r3
000038  f04f4320          MOV      r3,#0xa0000000
00003c  661a              STR      r2,[r3,#0x60]
00003e  e008              B        |L7.82|
                  |L7.64|
;;;530        }
;;;531        else
;;;532        {
;;;533          FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
000040  4a04              LDR      r2,|L7.84|
000042  6812              LDR      r2,[r2,#0]
000044  4b04              LDR      r3,|L7.88|
000046  ea020203          AND      r2,r2,r3
00004a  f04f4320          MOV      r3,#0xa0000000
00004e  f8c32080          STR      r2,[r3,#0x80]
                  |L7.82|
;;;534        }
;;;535      }
;;;536    }
000052  4770              BX       lr
;;;537    
                          ENDP

                  |L7.84|
                          DCD      0xa0000080
                  |L7.88|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_NANDDeInit||, CODE, READONLY, ALIGN=2

                  FSMC_NANDDeInit PROC
;;;134      */
;;;135    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000000  2810              CMP      r0,#0x10
;;;136    {
;;;137      /* Check the parameter */
;;;138      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;139      
;;;140      if(FSMC_Bank == FSMC_Bank2_NAND)
000002  d10a              BNE      |L8.26|
;;;141      {
;;;142        /* Set the FSMC_Bank2 registers to their reset values */
;;;143        FSMC_Bank2->PCR2 = 0x00000018;
000004  2118              MOVS     r1,#0x18
000006  f04f4220          MOV      r2,#0xa0000000
00000a  6611              STR      r1,[r2,#0x60]
;;;144        FSMC_Bank2->SR2 = 0x00000040;
00000c  2140              MOVS     r1,#0x40
00000e  6651              STR      r1,[r2,#0x64]
;;;145        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
000010  f04f31fc          MOV      r1,#0xfcfcfcfc
000014  6691              STR      r1,[r2,#0x68]
;;;146        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
000016  66d1              STR      r1,[r2,#0x6c]
000018  e010              B        |L8.60|
                  |L8.26|
;;;147      }
;;;148      /* FSMC_Bank3_NAND */  
;;;149      else
;;;150      {
;;;151        /* Set the FSMC_Bank3 registers to their reset values */
;;;152        FSMC_Bank3->PCR3 = 0x00000018;
00001a  2118              MOVS     r1,#0x18
00001c  4a08              LDR      r2,|L8.64|
00001e  6011              STR      r1,[r2,#0]
;;;153        FSMC_Bank3->SR3 = 0x00000040;
000020  f04f0140          MOV      r1,#0x40
000024  f04f4220          MOV      r2,#0xa0000000
000028  f8c21084          STR      r1,[r2,#0x84]
;;;154        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
00002c  f04f31fc          MOV      r1,#0xfcfcfcfc
000030  4a04              LDR      r2,|L8.68|
000032  6011              STR      r1,[r2,#0]
;;;155        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
000034  f04f4220          MOV      r2,#0xa0000000
000038  f8c2108c          STR      r1,[r2,#0x8c]
                  |L8.60|
;;;156      }  
;;;157    }
00003c  4770              BX       lr
;;;158    
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
                          DCD      0xa0000080
                  |L8.68|
                          DCD      0xa0000088

                          AREA ||i.FSMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDECCCmd PROC
;;;569      */
;;;570    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  b199              CBZ      r1,|L9.42|
;;;571    {
;;;572      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;573      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;574      
;;;575      if (NewState != DISABLE)
;;;576      {
;;;577        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;578        if(FSMC_Bank == FSMC_Bank2_NAND)
000002  2810              CMP      r0,#0x10
000004  d108              BNE      |L9.24|
;;;579        {
;;;580          FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
000006  f04f4220          MOV      r2,#0xa0000000
00000a  6e12              LDR      r2,[r2,#0x60]
00000c  f0420240          ORR      r2,r2,#0x40
000010  f04f4320          MOV      r3,#0xa0000000
000014  661a              STR      r2,[r3,#0x60]
000016  e01c              B        |L9.82|
                  |L9.24|
;;;581        }
;;;582        else
;;;583        {
;;;584          FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
000018  4a0e              LDR      r2,|L9.84|
00001a  6812              LDR      r2,[r2,#0]
00001c  f0420240          ORR      r2,r2,#0x40
000020  f04f4320          MOV      r3,#0xa0000000
000024  f8c32080          STR      r2,[r3,#0x80]
000028  e013              B        |L9.82|
                  |L9.42|
;;;585        }
;;;586      }
;;;587      else
;;;588      {
;;;589        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;590        if(FSMC_Bank == FSMC_Bank2_NAND)
00002a  2810              CMP      r0,#0x10
00002c  d108              BNE      |L9.64|
;;;591        {
;;;592          FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
00002e  f04f4220          MOV      r2,#0xa0000000
000032  6e12              LDR      r2,[r2,#0x60]
000034  4b08              LDR      r3,|L9.88|
000036  401a              ANDS     r2,r2,r3
000038  f04f4320          MOV      r3,#0xa0000000
00003c  661a              STR      r2,[r3,#0x60]
00003e  e008              B        |L9.82|
                  |L9.64|
;;;593        }
;;;594        else
;;;595        {
;;;596          FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
000040  4a04              LDR      r2,|L9.84|
000042  6812              LDR      r2,[r2,#0]
000044  4b04              LDR      r3,|L9.88|
000046  ea020203          AND      r2,r2,r3
00004a  f04f4320          MOV      r3,#0xa0000000
00004e  f8c32080          STR      r2,[r3,#0x80]
                  |L9.82|
;;;597        }
;;;598      }
;;;599    }
000052  4770              BX       lr
;;;600    
                          ENDP

                  |L9.84|
                          DCD      0xa0000080
                  |L9.88|
                          DCD      0x000fffbf

                          AREA ||i.FSMC_NANDInit||, CODE, READONLY, ALIGN=2

                  FSMC_NANDInit PROC
;;;267      */
;;;268    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;269    {
;;;270      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;271        
;;;272      /* Check the parameters */
;;;273      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;274      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;275      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;276      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;277      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;278      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;279      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;280      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;281      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;282      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;283      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;284      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;285      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;286      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;287      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;288      
;;;289      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;290      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000008  6844              LDR      r4,[r0,#4]
00000a  f0440408          ORR      r4,r4,#8
00000e  6885              LDR      r5,[r0,#8]
000010  432c              ORRS     r4,r4,r5
000012  68c5              LDR      r5,[r0,#0xc]
000014  432c              ORRS     r4,r4,r5
000016  6905              LDR      r5,[r0,#0x10]
000018  432c              ORRS     r4,r4,r5
00001a  6945              LDR      r5,[r0,#0x14]
00001c  ea442445          ORR      r4,r4,r5,LSL #9
000020  6985              LDR      r5,[r0,#0x18]
000022  ea443145          ORR      r1,r4,r5,LSL #13
;;;291                PCR_MemoryType_NAND |
;;;292                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;293                FSMC_NANDInitStruct->FSMC_ECC |
;;;294                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;295                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;296                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;297                
;;;298      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;299      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000026  69c4              LDR      r4,[r0,#0x1c]
000028  6824              LDR      r4,[r4,#0]
00002a  69c5              LDR      r5,[r0,#0x1c]
00002c  686d              LDR      r5,[r5,#4]
00002e  ea442405          ORR      r4,r4,r5,LSL #8
000032  69c5              LDR      r5,[r0,#0x1c]
000034  892d              LDRH     r5,[r5,#8]
000036  ea444405          ORR      r4,r4,r5,LSL #16
00003a  69c5              LDR      r5,[r0,#0x1c]
00003c  7b2d              LDRB     r5,[r5,#0xc]
00003e  ea446205          ORR      r2,r4,r5,LSL #24
;;;300                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;301                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;302                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;303                
;;;304      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;305      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000042  6a04              LDR      r4,[r0,#0x20]
000044  6824              LDR      r4,[r4,#0]
000046  6a05              LDR      r5,[r0,#0x20]
000048  686d              LDR      r5,[r5,#4]
00004a  ea442405          ORR      r4,r4,r5,LSL #8
00004e  6a05              LDR      r5,[r0,#0x20]
000050  892d              LDRH     r5,[r5,#8]
000052  ea444405          ORR      r4,r4,r5,LSL #16
000056  6a05              LDR      r5,[r0,#0x20]
000058  7b2d              LDRB     r5,[r5,#0xc]
00005a  ea446305          ORR      r3,r4,r5,LSL #24
;;;306                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;307                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;308                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;309      
;;;310      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
00005e  6804              LDR      r4,[r0,#0]
000060  2c10              CMP      r4,#0x10
000062  d105              BNE      |L10.112|
;;;311      {
;;;312        /* FSMC_Bank2_NAND registers configuration */
;;;313        FSMC_Bank2->PCR2 = tmppcr;
000064  f04f4420          MOV      r4,#0xa0000000
000068  6621              STR      r1,[r4,#0x60]
;;;314        FSMC_Bank2->PMEM2 = tmppmem;
00006a  66a2              STR      r2,[r4,#0x68]
;;;315        FSMC_Bank2->PATT2 = tmppatt;
00006c  66e3              STR      r3,[r4,#0x6c]
00006e  e007              B        |L10.128|
                  |L10.112|
;;;316      }
;;;317      else
;;;318      {
;;;319        /* FSMC_Bank3_NAND registers configuration */
;;;320        FSMC_Bank3->PCR3 = tmppcr;
000070  4c04              LDR      r4,|L10.132|
000072  6021              STR      r1,[r4,#0]
;;;321        FSMC_Bank3->PMEM3 = tmppmem;
000074  f04f4420          MOV      r4,#0xa0000000
000078  f8c42088          STR      r2,[r4,#0x88]
;;;322        FSMC_Bank3->PATT3 = tmppatt;
00007c  4c02              LDR      r4,|L10.136|
00007e  6023              STR      r3,[r4,#0]
                  |L10.128|
;;;323      }
;;;324    }
000080  bd30              POP      {r4,r5,pc}
;;;325    
                          ENDP

000082  0000              DCW      0x0000
                  |L10.132|
                          DCD      0xa0000080
                  |L10.136|
                          DCD      0xa000008c

                          AREA ||i.FSMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDStructInit PROC
;;;423      */
;;;424    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  2110              MOVS     r1,#0x10
;;;425    { 
;;;426      /* Reset NAND Init structure parameters values */
;;;427      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
000002  6001              STR      r1,[r0,#0]
;;;428      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000004  2100              MOVS     r1,#0
000006  6041              STR      r1,[r0,#4]
;;;429      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000008  6081              STR      r1,[r0,#8]
;;;430      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
00000a  60c1              STR      r1,[r0,#0xc]
;;;431      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00000c  6101              STR      r1,[r0,#0x10]
;;;432      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00000e  6141              STR      r1,[r0,#0x14]
;;;433      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
000010  6181              STR      r1,[r0,#0x18]
;;;434      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000012  21fc              MOVS     r1,#0xfc
000014  69c2              LDR      r2,[r0,#0x1c]
000016  6011              STR      r1,[r2,#0]
;;;435      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000018  69c2              LDR      r2,[r0,#0x1c]
00001a  6051              STR      r1,[r2,#4]
;;;436      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00001c  69c2              LDR      r2,[r0,#0x1c]
00001e  6091              STR      r1,[r2,#8]
;;;437      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000020  69c2              LDR      r2,[r0,#0x1c]
000022  60d1              STR      r1,[r2,#0xc]
;;;438      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000024  6a02              LDR      r2,[r0,#0x20]
000026  6011              STR      r1,[r2,#0]
;;;439      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000028  6a02              LDR      r2,[r0,#0x20]
00002a  6051              STR      r1,[r2,#4]
;;;440      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00002c  6a02              LDR      r2,[r0,#0x20]
00002e  6091              STR      r1,[r2,#8]
;;;441      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
000030  6a02              LDR      r2,[r0,#0x20]
000032  60d1              STR      r1,[r2,#0xc]
;;;442    }
000034  4770              BX       lr
;;;443    
                          ENDP


                          AREA ||i.FSMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMCmd PROC
;;;480      */
;;;481    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  b151              CBZ      r1,|L12.24|
;;;482    {
;;;483      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;484      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;485      
;;;486      if (NewState != DISABLE)
;;;487      {
;;;488        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;489        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
000002  f04f4220          MOV      r2,#0xa0000000
000006  f8522020          LDR      r2,[r2,r0,LSL #2]
00000a  f0420201          ORR      r2,r2,#1
00000e  f04f4320          MOV      r3,#0xa0000000
000012  f8432020          STR      r2,[r3,r0,LSL #2]
000016  e009              B        |L12.44|
                  |L12.24|
;;;490      }
;;;491      else
;;;492      {
;;;493        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;494        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
000018  f04f4220          MOV      r2,#0xa0000000
00001c  f8522020          LDR      r2,[r2,r0,LSL #2]
000020  4b03              LDR      r3,|L12.48|
000022  401a              ANDS     r2,r2,r3
000024  f04f4320          MOV      r3,#0xa0000000
000028  f8432020          STR      r2,[r3,r0,LSL #2]
                  |L12.44|
;;;495      }
;;;496    }
00002c  4770              BX       lr
;;;497    
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x000ffffe

                          AREA ||i.FSMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMDeInit PROC
;;;107      */
;;;108    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  b930              CBNZ     r0,|L13.16|
;;;109    {
;;;110      /* Check the parameter */
;;;111      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;112      
;;;113      /* FSMC_Bank1_NORSRAM1 */
;;;114      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;115      {
;;;116        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
000002  f24301db          MOV      r1,#0x30db
000006  f04f4220          MOV      r2,#0xa0000000
00000a  f8421020          STR      r1,[r2,r0,LSL #2]
00000e  e005              B        |L13.28|
                  |L13.16|
;;;117      }
;;;118      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;119      else
;;;120      {   
;;;121        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000010  f24301d2          MOV      r1,#0x30d2
000014  f04f4220          MOV      r2,#0xa0000000
000018  f8421020          STR      r1,[r2,r0,LSL #2]
                  |L13.28|
;;;122      }
;;;123      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00001c  f06f4270          MVN      r2,#0xf0000000
000020  1c41              ADDS     r1,r0,#1
000022  f04f4320          MOV      r3,#0xa0000000
000026  f8432021          STR      r2,[r3,r1,LSL #2]
;;;124      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
00002a  4611              MOV      r1,r2
00002c  461a              MOV      r2,r3
00002e  eb020280          ADD      r2,r2,r0,LSL #2
000032  f8c21104          STR      r1,[r2,#0x104]
;;;125    }
000036  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.FSMC_NORSRAMInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMInit PROC
;;;181      */
;;;182    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  e9d01201          LDRD     r1,r2,[r0,#4]
;;;183    { 
;;;184      /* Check the parameters */
;;;185      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;186      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;187      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;188      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;189      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;190      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;191      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;192      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;193      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;194      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;195      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;196      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;197      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;198      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;199      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;200      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;201      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;202      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;203      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;204      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;205      
;;;206      /* Bank1 NOR/SRAM control register configuration */ 
;;;207      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000004  4311              ORRS     r1,r1,r2
000006  68c2              LDR      r2,[r0,#0xc]
000008  4311              ORRS     r1,r1,r2
00000a  6902              LDR      r2,[r0,#0x10]
00000c  4311              ORRS     r1,r1,r2
00000e  6942              LDR      r2,[r0,#0x14]
000010  4311              ORRS     r1,r1,r2
000012  6982              LDR      r2,[r0,#0x18]
000014  4311              ORRS     r1,r1,r2
000016  69c2              LDR      r2,[r0,#0x1c]
000018  4311              ORRS     r1,r1,r2
00001a  6a02              LDR      r2,[r0,#0x20]
00001c  4311              ORRS     r1,r1,r2
00001e  6a42              LDR      r2,[r0,#0x24]
000020  4311              ORRS     r1,r1,r2
000022  6a82              LDR      r2,[r0,#0x28]
000024  4311              ORRS     r1,r1,r2
000026  6ac2              LDR      r2,[r0,#0x2c]
000028  4311              ORRS     r1,r1,r2
00002a  6b02              LDR      r2,[r0,#0x30]
00002c  4311              ORRS     r1,r1,r2
00002e  f04f4320          MOV      r3,#0xa0000000
000032  6802              LDR      r2,[r0,#0]
000034  f8431022          STR      r1,[r3,r2,LSL #2]
;;;208                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;209                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;210                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;211                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;212                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;213                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;214                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;215                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;216                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;217                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;218                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;219                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;220    
;;;221      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
000038  6881              LDR      r1,[r0,#8]
00003a  2908              CMP      r1,#8
00003c  d108              BNE      |L14.80|
;;;222      {
;;;223        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
00003e  461a              MOV      r2,r3
000040  6801              LDR      r1,[r0,#0]
000042  f8521021          LDR      r1,[r2,r1,LSL #2]
000046  f0410140          ORR      r1,r1,#0x40
00004a  6802              LDR      r2,[r0,#0]
00004c  f8431022          STR      r1,[r3,r2,LSL #2]
                  |L14.80|
;;;224      }
;;;225      
;;;226      /* Bank1 NOR/SRAM timing register configuration */
;;;227      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
000050  6b41              LDR      r1,[r0,#0x34]
000052  6809              LDR      r1,[r1,#0]
000054  6b42              LDR      r2,[r0,#0x34]
000056  6852              LDR      r2,[r2,#4]
000058  ea411102          ORR      r1,r1,r2,LSL #4
00005c  6b42              LDR      r2,[r0,#0x34]
00005e  6892              LDR      r2,[r2,#8]
000060  ea412102          ORR      r1,r1,r2,LSL #8
000064  6b42              LDR      r2,[r0,#0x34]
000066  8992              LDRH     r2,[r2,#0xc]
000068  ea414102          ORR      r1,r1,r2,LSL #16
00006c  6b42              LDR      r2,[r0,#0x34]
00006e  8a12              LDRH     r2,[r2,#0x10]
000070  ea415102          ORR      r1,r1,r2,LSL #20
000074  6b42              LDR      r2,[r0,#0x34]
000076  7d12              LDRB     r2,[r2,#0x14]
000078  ea416102          ORR      r1,r1,r2,LSL #24
00007c  6b42              LDR      r2,[r0,#0x34]
00007e  6992              LDR      r2,[r2,#0x18]
000080  4311              ORRS     r1,r1,r2
000082  6802              LDR      r2,[r0,#0]
000084  1c52              ADDS     r2,r2,#1
000086  f04f4320          MOV      r3,#0xa0000000
00008a  f8431022          STR      r1,[r3,r2,LSL #2]
;;;228                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;229                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;230                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;231                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;232                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;233                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;234                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;235                
;;;236        
;;;237      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;238      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
00008e  6ac1              LDR      r1,[r0,#0x2c]
000090  f5b14f80          CMP      r1,#0x4000
000094  d11a              BNE      |L14.204|
;;;239      {
;;;240        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;241        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;242        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;243        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;244        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;245        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;246        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000096  6b81              LDR      r1,[r0,#0x38]
000098  6809              LDR      r1,[r1,#0]
00009a  6b82              LDR      r2,[r0,#0x38]
00009c  6852              LDR      r2,[r2,#4]
00009e  ea411102          ORR      r1,r1,r2,LSL #4
0000a2  6b82              LDR      r2,[r0,#0x38]
0000a4  6892              LDR      r2,[r2,#8]
0000a6  ea412102          ORR      r1,r1,r2,LSL #8
0000aa  6b82              LDR      r2,[r0,#0x38]
0000ac  8a12              LDRH     r2,[r2,#0x10]
0000ae  ea415102          ORR      r1,r1,r2,LSL #20
0000b2  6b82              LDR      r2,[r0,#0x38]
0000b4  7d12              LDRB     r2,[r2,#0x14]
0000b6  ea416102          ORR      r1,r1,r2,LSL #24
0000ba  6b82              LDR      r2,[r0,#0x38]
0000bc  6992              LDR      r2,[r2,#0x18]
0000be  4311              ORRS     r1,r1,r2
0000c0  6802              LDR      r2,[r0,#0]
0000c2  eb030282          ADD      r2,r3,r2,LSL #2
0000c6  f8c21104          STR      r1,[r2,#0x104]
0000ca  e008              B        |L14.222|
                  |L14.204|
;;;247                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;248                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;249                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;250                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;251                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;252                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;253      }
;;;254      else
;;;255      {
;;;256        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
0000cc  f06f4170          MVN      r1,#0xf0000000
0000d0  f04f4320          MOV      r3,#0xa0000000
0000d4  6802              LDR      r2,[r0,#0]
0000d6  eb030282          ADD      r2,r3,r2,LSL #2
0000da  f8c21104          STR      r1,[r2,#0x104]
                  |L14.222|
;;;257      }
;;;258    }
0000de  4770              BX       lr
;;;259    
                          ENDP


                          AREA ||i.FSMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMStructInit PROC
;;;385      */
;;;386    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  2100              MOVS     r1,#0
;;;387    {  
;;;388      /* Reset NOR/SRAM Init structure parameters values */
;;;389      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
000002  6001              STR      r1,[r0,#0]
;;;390      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000004  2102              MOVS     r1,#2
000006  6041              STR      r1,[r0,#4]
;;;391      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
000008  2100              MOVS     r1,#0
00000a  6081              STR      r1,[r0,#8]
;;;392      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
00000c  60c1              STR      r1,[r0,#0xc]
;;;393      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00000e  6101              STR      r1,[r0,#0x10]
;;;394      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
000010  6141              STR      r1,[r0,#0x14]
;;;395      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000012  6181              STR      r1,[r0,#0x18]
;;;396      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000014  61c1              STR      r1,[r0,#0x1c]
;;;397      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
000016  6201              STR      r1,[r0,#0x20]
;;;398      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000018  f44f5180          MOV      r1,#0x1000
00001c  6241              STR      r1,[r0,#0x24]
;;;399      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00001e  0049              LSLS     r1,r1,#1
000020  6281              STR      r1,[r0,#0x28]
;;;400      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000022  2100              MOVS     r1,#0
000024  62c1              STR      r1,[r0,#0x2c]
;;;401      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000026  6301              STR      r1,[r0,#0x30]
;;;402      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000028  210f              MOVS     r1,#0xf
00002a  6b42              LDR      r2,[r0,#0x34]
00002c  6011              STR      r1,[r2,#0]
;;;403      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
00002e  6b42              LDR      r2,[r0,#0x34]
000030  6051              STR      r1,[r2,#4]
;;;404      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
000032  21ff              MOVS     r1,#0xff
000034  6b42              LDR      r2,[r0,#0x34]
000036  6091              STR      r1,[r2,#8]
;;;405      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000038  210f              MOVS     r1,#0xf
00003a  6b42              LDR      r2,[r0,#0x34]
00003c  60d1              STR      r1,[r2,#0xc]
;;;406      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
00003e  6b42              LDR      r2,[r0,#0x34]
000040  6111              STR      r1,[r2,#0x10]
;;;407      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
000042  6b42              LDR      r2,[r0,#0x34]
000044  6151              STR      r1,[r2,#0x14]
;;;408      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
000046  2100              MOVS     r1,#0
000048  6b42              LDR      r2,[r0,#0x34]
00004a  6191              STR      r1,[r2,#0x18]
;;;409      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
00004c  210f              MOVS     r1,#0xf
00004e  6b82              LDR      r2,[r0,#0x38]
000050  6011              STR      r1,[r2,#0]
;;;410      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000052  6b82              LDR      r2,[r0,#0x38]
000054  6051              STR      r1,[r2,#4]
;;;411      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
000056  21ff              MOVS     r1,#0xff
000058  6b82              LDR      r2,[r0,#0x38]
00005a  6091              STR      r1,[r2,#8]
;;;412      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
00005c  210f              MOVS     r1,#0xf
00005e  6b82              LDR      r2,[r0,#0x38]
000060  60d1              STR      r1,[r2,#0xc]
;;;413      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
000062  6b82              LDR      r2,[r0,#0x38]
000064  6111              STR      r1,[r2,#0x10]
;;;414      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
000066  6b82              LDR      r2,[r0,#0x38]
000068  6151              STR      r1,[r2,#0x14]
;;;415      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
00006a  2100              MOVS     r1,#0
00006c  6b82              LDR      r2,[r0,#0x38]
00006e  6191              STR      r1,[r2,#0x18]
;;;416    }
000070  4770              BX       lr
;;;417    
                          ENDP


                          AREA ||i.FSMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDCmd PROC
;;;543      */
;;;544    void FSMC_PCCARDCmd(FunctionalState NewState)
000000  b140              CBZ      r0,|L16.20|
;;;545    {
;;;546      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;547      
;;;548      if (NewState != DISABLE)
;;;549      {
;;;550        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;551        FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
000002  4909              LDR      r1,|L16.40|
000004  6809              LDR      r1,[r1,#0]
000006  f0410104          ORR      r1,r1,#4
00000a  f04f4220          MOV      r2,#0xa0000000
00000e  f8c210a0          STR      r1,[r2,#0xa0]
000012  e008              B        |L16.38|
                  |L16.20|
;;;552      }
;;;553      else
;;;554      {
;;;555        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;556        FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
000014  4904              LDR      r1,|L16.40|
000016  6809              LDR      r1,[r1,#0]
000018  4a04              LDR      r2,|L16.44|
00001a  ea010102          AND      r1,r1,r2
00001e  f04f4220          MOV      r2,#0xa0000000
000022  f8c210a0          STR      r1,[r2,#0xa0]
                  |L16.38|
;;;557      }
;;;558    }
000026  4770              BX       lr
;;;559    
                          ENDP

                  |L16.40|
                          DCD      0xa00000a0
                  |L16.44|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_PCCARDDeInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDDeInit PROC
;;;163      */
;;;164    void FSMC_PCCARDDeInit(void)
000000  2018              MOVS     r0,#0x18
;;;165    {
;;;166      /* Set the FSMC_Bank4 registers to their reset values */
;;;167      FSMC_Bank4->PCR4 = 0x00000018; 
000002  4909              LDR      r1,|L17.40|
000004  6008              STR      r0,[r1,#0]
;;;168      FSMC_Bank4->SR4 = 0x00000000;	
000006  f04f0000          MOV      r0,#0
00000a  f04f4120          MOV      r1,#0xa0000000
00000e  f8c100a4          STR      r0,[r1,#0xa4]
;;;169      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
000012  f04f30fc          MOV      r0,#0xfcfcfcfc
000016  4905              LDR      r1,|L17.44|
000018  6008              STR      r0,[r1,#0]
;;;170      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
00001a  f1010104          ADD      r1,r1,#4
00001e  6008              STR      r0,[r1,#0]
;;;171      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000020  f1010104          ADD      r1,r1,#4
000024  6008              STR      r0,[r1,#0]
;;;172    }
000026  4770              BX       lr
;;;173    
                          ENDP

                  |L17.40|
                          DCD      0xa00000a0
                  |L17.44|
                          DCD      0xa00000a8

                          AREA ||i.FSMC_PCCARDInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDInit PROC
;;;333      */
;;;334    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  6801              LDR      r1,[r0,#0]
;;;335    {
;;;336      /* Check the parameters */
;;;337      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;338      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;339      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;340     
;;;341      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;342      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;343      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;344      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;345      
;;;346      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;347      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;348      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;349      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;350      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;351      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;352      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;353      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;354      
;;;355      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;356      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
000002  f0410110          ORR      r1,r1,#0x10
000006  6842              LDR      r2,[r0,#4]
000008  ea412142          ORR      r1,r1,r2,LSL #9
00000c  6882              LDR      r2,[r0,#8]
00000e  ea413142          ORR      r1,r1,r2,LSL #13
000012  4a1a              LDR      r2,|L18.124|
000014  6011              STR      r1,[r2,#0]
;;;357                         FSMC_MemoryDataWidth_16b |  
;;;358                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;359                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;360                
;;;361      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;362      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000016  68c1              LDR      r1,[r0,#0xc]
000018  6809              LDR      r1,[r1,#0]
00001a  68c2              LDR      r2,[r0,#0xc]
00001c  6852              LDR      r2,[r2,#4]
00001e  ea412102          ORR      r1,r1,r2,LSL #8
000022  68c2              LDR      r2,[r0,#0xc]
000024  8912              LDRH     r2,[r2,#8]
000026  ea414102          ORR      r1,r1,r2,LSL #16
00002a  68c2              LDR      r2,[r0,#0xc]
00002c  7b12              LDRB     r2,[r2,#0xc]
00002e  ea416102          ORR      r1,r1,r2,LSL #24
000032  4a13              LDR      r2,|L18.128|
000034  6011              STR      r1,[r2,#0]
;;;363                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;364                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;365                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;366                
;;;367      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;368      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000036  6901              LDR      r1,[r0,#0x10]
000038  6809              LDR      r1,[r1,#0]
00003a  6902              LDR      r2,[r0,#0x10]
00003c  6852              LDR      r2,[r2,#4]
00003e  ea412102          ORR      r1,r1,r2,LSL #8
000042  6902              LDR      r2,[r0,#0x10]
000044  8912              LDRH     r2,[r2,#8]
000046  ea414102          ORR      r1,r1,r2,LSL #16
00004a  6902              LDR      r2,[r0,#0x10]
00004c  7b12              LDRB     r2,[r2,#0xc]
00004e  ea416102          ORR      r1,r1,r2,LSL #24
000052  4a0c              LDR      r2,|L18.132|
000054  6011              STR      r1,[r2,#0]
;;;369                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;370                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;371                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;372                
;;;373      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;374      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
000056  6941              LDR      r1,[r0,#0x14]
000058  6809              LDR      r1,[r1,#0]
00005a  6942              LDR      r2,[r0,#0x14]
00005c  6852              LDR      r2,[r2,#4]
00005e  ea412102          ORR      r1,r1,r2,LSL #8
000062  6942              LDR      r2,[r0,#0x14]
000064  8912              LDRH     r2,[r2,#8]
000066  ea414102          ORR      r1,r1,r2,LSL #16
00006a  6942              LDR      r2,[r0,#0x14]
00006c  7b12              LDRB     r2,[r2,#0xc]
00006e  ea416102          ORR      r1,r1,r2,LSL #24
000072  f04f4220          MOV      r2,#0xa0000000
000076  f8c210b0          STR      r1,[r2,#0xb0]
;;;375                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;376                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;377                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;378    }
00007a  4770              BX       lr
;;;379    
                          ENDP

                  |L18.124|
                          DCD      0xa00000a0
                  |L18.128|
                          DCD      0xa00000a8
                  |L18.132|
                          DCD      0xa00000ac

                          AREA ||i.FSMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDStructInit PROC
;;;449      */
;;;450    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;451    {
;;;452      /* Reset PCCARD Init structure parameters values */
;;;453      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000002  6001              STR      r1,[r0,#0]
;;;454      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000004  6041              STR      r1,[r0,#4]
;;;455      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000006  6081              STR      r1,[r0,#8]
;;;456      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000008  21fc              MOVS     r1,#0xfc
00000a  68c2              LDR      r2,[r0,#0xc]
00000c  6011              STR      r1,[r2,#0]
;;;457      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  6051              STR      r1,[r2,#4]
;;;458      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000012  68c2              LDR      r2,[r0,#0xc]
000014  6091              STR      r1,[r2,#8]
;;;459      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000016  68c2              LDR      r2,[r0,#0xc]
000018  60d1              STR      r1,[r2,#0xc]
;;;460      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00001a  6902              LDR      r2,[r0,#0x10]
00001c  6011              STR      r1,[r2,#0]
;;;461      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00001e  6902              LDR      r2,[r0,#0x10]
000020  6051              STR      r1,[r2,#4]
;;;462      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000022  6902              LDR      r2,[r0,#0x10]
000024  6091              STR      r1,[r2,#8]
;;;463      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000026  6902              LDR      r2,[r0,#0x10]
000028  60d1              STR      r1,[r2,#0xc]
;;;464      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00002a  6942              LDR      r2,[r0,#0x14]
00002c  6011              STR      r1,[r2,#0]
;;;465      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00002e  6942              LDR      r2,[r0,#0x14]
000030  6051              STR      r1,[r2,#4]
;;;466      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000032  6942              LDR      r2,[r0,#0x14]
000034  6091              STR      r1,[r2,#8]
;;;467      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000036  6942              LDR      r2,[r0,#0x14]
000038  60d1              STR      r1,[r2,#0xc]
;;;468    }
00003a  4770              BX       lr
;;;469    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_fsmc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f10x_fsmc_c_2e710976____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f10x_fsmc_c_2e710976____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f10x_fsmc_c_2e710976____REVSH|
#line 128
|__asm___16_stm32f10x_fsmc_c_2e710976____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
