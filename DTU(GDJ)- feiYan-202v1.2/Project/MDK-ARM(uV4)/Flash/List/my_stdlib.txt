; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\my_stdlib.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\my_stdlib.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\my_stdlib.crf ..\..\User\my_stdlib.c]
                          THUMB

                          AREA ||i.Ascii2UINT8||, CODE, READONLY, ALIGN=1

                  Ascii2UINT8 PROC
;;;192    */
;;;193    char Ascii2UINT8(char value)
000000  4601              MOV      r1,r0
;;;194    {
;;;195    	//数字
;;;196    	if((value >= '0')&&(value <= '9'))
000002  2930              CMP      r1,#0x30
000004  db05              BLT      |L1.18|
000006  2939              CMP      r1,#0x39
000008  dc03              BGT      |L1.18|
;;;197    	{
;;;198    		return value - 0x30;
00000a  f1a10030          SUB      r0,r1,#0x30
00000e  b2c0              UXTB     r0,r0
                  |L1.16|
;;;199      }
;;;200    	else if((value == 'a')||(value == 'A'))
;;;201    	{
;;;202    		return 10;
;;;203      }
;;;204    	else if((value == 'b')||(value == 'B'))
;;;205    	{
;;;206    		return 11;
;;;207      }
;;;208    	else if((value == 'c')||(value == 'C'))
;;;209    	{
;;;210    		return 12;
;;;211      }
;;;212    	else if((value == 'd')||(value == 'D'))
;;;213    	{
;;;214    		return 13;
;;;215      }
;;;216    	else if((value == 'e')||(value == 'E'))
;;;217    	{
;;;218    		return 14;
;;;219      }
;;;220    	else if((value == 'f')||(value == 'F'))
;;;221    	{
;;;222    		return 15;
;;;223      }
;;;224    	else 
;;;225    	{	
;;;226    		return 16;
;;;227      }
;;;228    }
000010  4770              BX       lr
                  |L1.18|
000012  2961              CMP      r1,#0x61              ;200
000014  d001              BEQ      |L1.26|
000016  2941              CMP      r1,#0x41              ;200
000018  d101              BNE      |L1.30|
                  |L1.26|
00001a  200a              MOVS     r0,#0xa               ;202
00001c  e7f8              B        |L1.16|
                  |L1.30|
00001e  2962              CMP      r1,#0x62              ;204
000020  d001              BEQ      |L1.38|
000022  2942              CMP      r1,#0x42              ;204
000024  d101              BNE      |L1.42|
                  |L1.38|
000026  200b              MOVS     r0,#0xb               ;206
000028  e7f2              B        |L1.16|
                  |L1.42|
00002a  2963              CMP      r1,#0x63              ;208
00002c  d001              BEQ      |L1.50|
00002e  2943              CMP      r1,#0x43              ;208
000030  d101              BNE      |L1.54|
                  |L1.50|
000032  200c              MOVS     r0,#0xc               ;210
000034  e7ec              B        |L1.16|
                  |L1.54|
000036  2964              CMP      r1,#0x64              ;212
000038  d001              BEQ      |L1.62|
00003a  2944              CMP      r1,#0x44              ;212
00003c  d101              BNE      |L1.66|
                  |L1.62|
00003e  200d              MOVS     r0,#0xd               ;214
000040  e7e6              B        |L1.16|
                  |L1.66|
000042  2965              CMP      r1,#0x65              ;216
000044  d001              BEQ      |L1.74|
000046  2945              CMP      r1,#0x45              ;216
000048  d101              BNE      |L1.78|
                  |L1.74|
00004a  200e              MOVS     r0,#0xe               ;218
00004c  e7e0              B        |L1.16|
                  |L1.78|
00004e  2966              CMP      r1,#0x66              ;220
000050  d001              BEQ      |L1.86|
000052  2946              CMP      r1,#0x46              ;220
000054  d101              BNE      |L1.90|
                  |L1.86|
000056  200f              MOVS     r0,#0xf               ;222
000058  e7da              B        |L1.16|
                  |L1.90|
00005a  2010              MOVS     r0,#0x10              ;226
00005c  e7d8              B        |L1.16|
;;;229    
                          ENDP


                          AREA ||i.CharToHex||, CODE, READONLY, ALIGN=1

                  CharToHex PROC
;;;237    */
;;;238    unsigned char CharToHex(char bHex)  
000000  2830              CMP      r0,#0x30
;;;239    {  
;;;240        if((bHex>='0')&&(bHex<='9'))  
000002  db05              BLT      |L2.16|
000004  2839              CMP      r0,#0x39
000006  dc03              BGT      |L2.16|
;;;241        {  
;;;242            bHex -= 0x30;  
000008  f1a00130          SUB      r1,r0,#0x30
00000c  b2c8              UXTB     r0,r1
00000e  e00e              B        |L2.46|
                  |L2.16|
;;;243        }  
;;;244        else if((bHex>='A')&&(bHex<='F'))//Capital  
000010  2841              CMP      r0,#0x41
000012  db05              BLT      |L2.32|
000014  2846              CMP      r0,#0x46
000016  dc03              BGT      |L2.32|
;;;245        {  
;;;246            bHex -= 0x37;  
000018  f1a00137          SUB      r1,r0,#0x37
00001c  b2c8              UXTB     r0,r1
00001e  e006              B        |L2.46|
                  |L2.32|
;;;247        }  
;;;248        else if((bHex>='a')&&(bHex<='f'))//Capital   
000020  2861              CMP      r0,#0x61
000022  db04              BLT      |L2.46|
000024  2866              CMP      r0,#0x66
000026  dc02              BGT      |L2.46|
;;;249        {  
;;;250            bHex -= 0x57;  
000028  f1a00157          SUB      r1,r0,#0x57
00002c  b2c8              UXTB     r0,r1
                  |L2.46|
;;;251        }  
;;;252        return bHex;  
;;;253    }
00002e  4770              BX       lr
;;;254    
                          ENDP


                          AREA ||i.From_Hex||, CODE, READONLY, ALIGN=1

                  From_Hex PROC
;;;281    */
;;;282    void From_Hex(char *s, int l, char *d)
000000  b530              PUSH     {r4,r5,lr}
;;;283    {
;;;284        while(l--)
000002  e015              B        |L3.48|
                  |L3.4|
;;;285        {
;;;286            *(d++) = ( (*s>'9' ? *(s++)+9 : *(s++)) << 4 ) | ( (*s>'9' ? *(s++)+9 : *(s++)) & 0x0F );
000004  7803              LDRB     r3,[r0,#0]
000006  2b39              CMP      r3,#0x39
000008  dd03              BLE      |L3.18|
00000a  f8104b01          LDRB     r4,[r0],#1
00000e  3409              ADDS     r4,r4,#9
000010  e001              B        |L3.22|
                  |L3.18|
000012  f8104b01          LDRB     r4,[r0],#1
                  |L3.22|
000016  7803              LDRB     r3,[r0,#0]
000018  2b39              CMP      r3,#0x39
00001a  dd03              BLE      |L3.36|
00001c  f8103b01          LDRB     r3,[r0],#1
000020  3309              ADDS     r3,r3,#9
000022  e001              B        |L3.40|
                  |L3.36|
000024  f8103b01          LDRB     r3,[r0],#1
                  |L3.40|
000028  f364131f          BFI      r3,r4,#4,#28
00002c  f8023b01          STRB     r3,[r2],#1
                  |L3.48|
000030  000b              MOVS     r3,r1                 ;284
000032  f1a10101          SUB      r1,r1,#1              ;284
000036  d1e5              BNE      |L3.4|
;;;287        }
;;;288    }
000038  bd30              POP      {r4,r5,pc}
                          ENDP


                          AREA ||i.My_Printf||, CODE, READONLY, ALIGN=1

                  My_Printf PROC
;;;17     */
;;;18     void My_Printf(char *fmt,...)
000000  b40f              PUSH     {r0-r3}
;;;19     {
000002  b538              PUSH     {r3-r5,lr}
;;;20     	  __va_list v_list;
;;;21     	  char *p;
;;;22     	
;;;23     	  //等待发送为空
;;;24     	  while(comGetWaitSend(PRINTF_UART))
000004  e002              B        |L4.12|
                  |L4.6|
;;;25     		{
;;;26     #if uCOS_EN == 1 
;;;27     			BSP_OS_TimeDlyMs(1);
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       BSP_OS_TimeDlyMs
                  |L4.12|
00000c  2002              MOVS     r0,#2                 ;24
00000e  f7fffffe          BL       comGetWaitSend
000012  2800              CMP      r0,#0                 ;24
000014  d1f7              BNE      |L4.6|
;;;28     #else
;;;29     			bsp_DelayMS(1);
;;;30     #endif
;;;31     		}
;;;32     		
;;;33     		//分配一块内存
;;;34     		p = mymalloc(SRAMIN,256);
000016  f44f7180          MOV      r1,#0x100
00001a  f7fffffe          BL       mymalloc
00001e  4605              MOV      r5,r0
;;;35     		memset((char*)p,0,256);
000020  f44f7180          MOV      r1,#0x100
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       __aeabi_memclr
;;;36     		
;;;37     		//清空FIFO
;;;38     		comClearFifo(PRINTF_UART);	
00002a  2002              MOVS     r0,#2
00002c  f7fffffe          BL       comClearFifo
;;;39     		//不允许格式化的字符串大于256,缓冲区长度决定
;;;40     		if(strlen(fmt) > 256)
000030  9804              LDR      r0,[sp,#0x10]
000032  f7fffffe          BL       strlen
000036  f5b07f80          CMP      r0,#0x100
00003a  d906              BLS      |L4.74|
;;;41     		{
;;;42     			myfree(SRAMIN,p);	
00003c  4629              MOV      r1,r5
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       myfree
                  |L4.68|
;;;43     			return;
;;;44     		}
;;;45     		va_start(v_list, fmt);     
;;;46     		vsprintf((char*)p, fmt, v_list ); 
;;;47     		va_end(v_list);	
;;;48     		
;;;49     		//发送消息
;;;50     		comSendBuf(PRINTF_UART, (unsigned char*)p, strlen((char*)p));
;;;51     
;;;52     		//释放
;;;53     		myfree(SRAMIN,p);		
;;;54     }
000044  bc38              POP      {r3-r5}
000046  f85dfb14          LDR      pc,[sp],#0x14
                  |L4.74|
00004a  a805              ADD      r0,sp,#0x14           ;45
00004c  9000              STR      r0,[sp,#0]            ;45
00004e  4628              MOV      r0,r5                 ;46
000050  9a00              LDR      r2,[sp,#0]            ;46
000052  9904              LDR      r1,[sp,#0x10]         ;46
000054  f7fffffe          BL       __c89vsprintf
000058  2000              MOVS     r0,#0                 ;47
00005a  9000              STR      r0,[sp,#0]            ;47
00005c  4628              MOV      r0,r5                 ;50
00005e  f7fffffe          BL       strlen
000062  b284              UXTH     r4,r0                 ;50
000064  4622              MOV      r2,r4                 ;50
000066  4629              MOV      r1,r5                 ;50
000068  2002              MOVS     r0,#2                 ;50
00006a  f7fffffe          BL       comSendBuf
00006e  4629              MOV      r1,r5                 ;53
000070  2000              MOVS     r0,#0                 ;53
000072  f7fffffe          BL       myfree
000076  bf00              NOP      
000078  e7e4              B        |L4.68|
;;;55     
                          ENDP


                          AREA ||i.To_Hex||, CODE, READONLY, ALIGN=2

                  To_Hex PROC
;;;264    
;;;265    void To_Hex(char *s, int l, char *d)
000000  b510              PUSH     {r4,lr}
;;;266    {
;;;267        while(l--)
000002  e00e              B        |L5.34|
                  |L5.4|
;;;268        {
;;;269            *(d++) = hex_table[*s >> 4];
000004  7803              LDRB     r3,[r0,#0]
000006  4c09              LDR      r4,|L5.44|
000008  eb041323          ADD      r3,r4,r3,ASR #4
00000c  781b              LDRB     r3,[r3,#0]
00000e  f8023b01          STRB     r3,[r2],#1
;;;270            *(d++) = hex_table[*(s++) & 0x0f];
000012  f8104b01          LDRB     r4,[r0],#1
000016  f004030f          AND      r3,r4,#0xf
00001a  4c04              LDR      r4,|L5.44|
00001c  5ce3              LDRB     r3,[r4,r3]
00001e  f8023b01          STRB     r3,[r2],#1
                  |L5.34|
000022  000b              MOVS     r3,r1                 ;267
000024  f1a10101          SUB      r1,r1,#1              ;267
000028  d1ec              BNE      |L5.4|
;;;271        }
;;;272    }
00002a  bd10              POP      {r4,pc}
;;;273    
                          ENDP

                  |L5.44|
                          DCD      hex_table

                          AREA ||i.left||, CODE, READONLY, ALIGN=1

                  left PROC
;;;65     */
;;;66     char * left(char *dst,char *src, int n)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;67     {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;68         char *p = src;
00000a  46a8              MOV      r8,r5
;;;69         char *q = dst;
00000c  463c              MOV      r4,r7
;;;70         int len = strlen(src);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       strlen
000014  4681              MOV      r9,r0
;;;71         if(n>len) n = len;
000016  454e              CMP      r6,r9
000018  dd00              BLE      |L6.28|
00001a  464e              MOV      r6,r9
                  |L6.28|
;;;72         /*p += (len-n);*/   
;;;73         while(n--) *(q++) = *(p++);
00001c  e003              B        |L6.38|
                  |L6.30|
00001e  f8180b01          LDRB     r0,[r8],#1
000022  f8040b01          STRB     r0,[r4],#1
                  |L6.38|
000026  0030              MOVS     r0,r6
000028  f1a60601          SUB      r6,r6,#1
00002c  d1f7              BNE      |L6.30|
;;;74         *(q++)='\0'; 
00002e  f8040b01          STRB     r0,[r4],#1
;;;75         return dst;
000032  4638              MOV      r0,r7
;;;76     }
000034  e8bd87f0          POP      {r4-r10,pc}
;;;77     
                          ENDP


                          AREA ||i.mid||, CODE, READONLY, ALIGN=1

                  mid PROC
;;;88     */
;;;89     char * mid(char *dst,char *src, int n,int m) //n为个数，m为位置
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;90     {
000004  4682              MOV      r10,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;91         char *p = src;
00000c  46b1              MOV      r9,r6
;;;92         char *q = dst;
00000e  4655              MOV      r5,r10
;;;93         int len = strlen(src);
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       strlen
000016  4607              MOV      r7,r0
;;;94         if(n>len) n = len-m;  //从第m个到最后
000018  45b8              CMP      r8,r7
00001a  dd01              BLE      |L7.32|
00001c  eba70804          SUB      r8,r7,r4
                  |L7.32|
;;;95         if(m<0) m=0;  
000020  2c00              CMP      r4,#0
000022  da00              BGE      |L7.38|
000024  2400              MOVS     r4,#0
                  |L7.38|
;;;96         if(m>len) return NULL;
000026  42bc              CMP      r4,r7
000028  dd02              BLE      |L7.48|
00002a  2000              MOVS     r0,#0
                  |L7.44|
;;;97         p += m;
;;;98         while(n--) *(q++) = *(p++);
;;;99         *(q++)='\0'; 
;;;100        return dst;
;;;101    }
00002c  e8bd87f0          POP      {r4-r10,pc}
                  |L7.48|
000030  44a1              ADD      r9,r9,r4              ;97
000032  e003              B        |L7.60|
                  |L7.52|
000034  f8190b01          LDRB     r0,[r9],#1            ;98
000038  f8050b01          STRB     r0,[r5],#1            ;98
                  |L7.60|
00003c  ea5f0008          MOVS     r0,r8                 ;98
000040  f1a80801          SUB      r8,r8,#1              ;98
000044  d1f6              BNE      |L7.52|
000046  f8050b01          STRB     r0,[r5],#1            ;99
00004a  4650              MOV      r0,r10                ;100
00004c  e7ee              B        |L7.44|
;;;102    
                          ENDP


                          AREA ||i.right||, CODE, READONLY, ALIGN=1

                  right PROC
;;;112    */
;;;113    char * right(char *dst,char *src, int n)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;114    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;115        char *p = src;
00000a  4626              MOV      r6,r4
;;;116        char *q = dst;
00000c  46c1              MOV      r9,r8
;;;117        int len = strlen(src);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       strlen
000014  4607              MOV      r7,r0
;;;118        if(n>len) n = len;
000016  42bd              CMP      r5,r7
000018  dd00              BLE      |L8.28|
00001a  463d              MOV      r5,r7
                  |L8.28|
;;;119        p += (len-n);  //从右边第n个字符开始
00001c  1b78              SUBS     r0,r7,r5
00001e  4406              ADD      r6,r6,r0
;;;120        while(*(q++) == *(p++));
000020  bf00              NOP      
                  |L8.34|
000022  f8191b01          LDRB     r1,[r9],#1
000026  f8162b01          LDRB     r2,[r6],#1
00002a  4291              CMP      r1,r2
00002c  d0f9              BEQ      |L8.34|
;;;121        return dst;
00002e  4640              MOV      r0,r8
;;;122    }
000030  e8bd87f0          POP      {r4-r10,pc}
;;;123    
                          ENDP


                          AREA ||i.strrpl||, CODE, READONLY, ALIGN=1

                  strrpl PROC
;;;135    //************************************
;;;136    void strrpl(char* pDstOut, char* pSrcIn, const char* pSrcRpl, const char* pDstRpl)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;137    {
000004  4682              MOV      r10,r0
000006  468b              MOV      r11,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;138    	char* pi = pSrcIn;
00000c  465f              MOV      r7,r11
;;;139    	char* po = pDstOut;
00000e  46d0              MOV      r8,r10
;;;140    
;;;141    	int nSrcRplLen = strlen(pSrcRpl);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       strlen
000016  9001              STR      r0,[sp,#4]
;;;142    	int nDstRplLen = strlen(pDstRpl);
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       strlen
00001e  9000              STR      r0,[sp,#0]
;;;143    
;;;144    	char *p = NULL;
000020  2400              MOVS     r4,#0
;;;145    	int nLen = 0;
000022  46a1              MOV      r9,r4
;;;146    
;;;147    	do{
000024  bf00              NOP      
                  |L9.38|
;;;148    			// 找到下一个替换点
;;;149    			p = strstr(pi, pSrcRpl);
000026  4629              MOV      r1,r5
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       strstr
00002e  4604              MOV      r4,r0
;;;150    			if(p != NULL)
000030  b16c              CBZ      r4,|L9.78|
;;;151    			{
;;;152    				// 拷贝上一个替换点和下一个替换点中间的字符串
;;;153    				nLen = p - pi;
000032  eba40907          SUB      r9,r4,r7
;;;154    				memcpy(po, pi, nLen);
000036  464a              MOV      r2,r9
000038  4639              MOV      r1,r7
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       __aeabi_memcpy
;;;155    				// 拷贝需要替换的字符串
;;;156    				memcpy(po + nLen, pDstRpl, nDstRplLen);
000040  eb080009          ADD      r0,r8,r9
000044  4631              MOV      r1,r6
000046  9a00              LDR      r2,[sp,#0]
000048  f7fffffe          BL       __aeabi_memcpy
00004c  e004              B        |L9.88|
                  |L9.78|
;;;157    			}
;;;158    			else
;;;159    			{
;;;160    				strcpy(po, pi);
00004e  4639              MOV      r1,r7
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       strcpy
;;;161    				// 如果没有需要拷贝的字符串,说明循环应该结束
;;;162    				break;
000056  e008              B        |L9.106|
                  |L9.88|
;;;163    			}
;;;164    			pi = p + nSrcRplLen;
000058  9801              LDR      r0,[sp,#4]
00005a  1827              ADDS     r7,r4,r0
;;;165    			po = po + nLen + nDstRplLen;
00005c  eb080109          ADD      r1,r8,r9
000060  9800              LDR      r0,[sp,#0]
000062  eb010800          ADD      r8,r1,r0
;;;166    	} while (p != NULL);
000066  2c00              CMP      r4,#0
000068  d1dd              BNE      |L9.38|
                  |L9.106|
00006a  bf00              NOP                            ;162
;;;167    }
00006c  e8bd9ffc          POP      {r2-r12,pc}
;;;168    
                          ENDP


                          AREA ||i.swap_HbyteLbyte||, CODE, READONLY, ALIGN=1

                  swap_HbyteLbyte PROC
;;;176    */
;;;177    unsigned short swap_HbyteLbyte(unsigned short value)
000000  4601              MOV      r1,r0
;;;178    {
;;;179    	unsigned char Hbyte = (value>>8)&0xff;
000002  0a0b              LSRS     r3,r1,#8
;;;180    	unsigned char Lbyte = (value>>0)&0xff;
000004  b2ca              UXTB     r2,r1
;;;181    
;;;182    	return ((((unsigned short)Lbyte)<<8)|Hbyte);
000006  ea432002          ORR      r0,r3,r2,LSL #8
;;;183    }
00000a  4770              BX       lr
;;;184    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  hex_table
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\my_stdlib.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_my_stdlib_c_8bedc5f8____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_my_stdlib_c_8bedc5f8____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_my_stdlib_c_8bedc5f8____REVSH|
#line 128
|__asm___11_my_stdlib_c_8bedc5f8____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
