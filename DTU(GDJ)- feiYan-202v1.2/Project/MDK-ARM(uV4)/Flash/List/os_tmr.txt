; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\os_tmr.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\os_tmr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\os_tmr.crf ..\..\uCOS-III\uCOS-III\Source\os_tmr.c]
                          THUMB

                          AREA ||i.OSTmrCreate||, CODE, READONLY, ALIGN=2

                  OSTmrCreate PROC
;;;104    
;;;105    void  OSTmrCreate (OS_TMR               *p_tmr,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;106                       CPU_CHAR             *p_name,
;;;107                       OS_TICK               dly,
;;;108                       OS_TICK               period,
;;;109                       OS_OPT                opt,
;;;110                       OS_TMR_CALLBACK_PTR   p_callback,
;;;111                       void                 *p_callback_arg,
;;;112                       OS_ERR               *p_err)
;;;113    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000010  f8dd9028          LDR      r9,[sp,#0x28]
000014  f8dd8034          LDR      r8,[sp,#0x34]
;;;114    #ifdef OS_SAFETY_CRITICAL
;;;115        if (p_err == DEF_NULL) {
;;;116            OS_SAFETY_CRITICAL_EXCEPTION();
;;;117            return;
;;;118        }
;;;119    #endif
;;;120    
;;;121    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;122        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;123           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;124            return;
;;;125        }
;;;126    #endif
;;;127    
;;;128    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;129        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000018  4819              LDR      r0,|L1.128|
00001a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00001c  b128              CBZ      r0,|L1.42|
;;;130           *p_err = OS_ERR_TMR_ISR;
00001e  f2473043          MOV      r0,#0x7343
000022  f8a80000          STRH     r0,[r8,#0]
                  |L1.38|
;;;131            return;
;;;132        }
;;;133    #endif
;;;134    
;;;135    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;136        if (p_tmr == DEF_NULL) {                                    /* Validate 'p_tmr'                                     */
;;;137           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;138            return;
;;;139        }
;;;140    
;;;141        switch (opt) {
;;;142            case OS_OPT_TMR_PERIODIC:
;;;143                 if (period == 0u) {
;;;144                    *p_err = OS_ERR_TMR_INVALID_PERIOD;
;;;145                     return;
;;;146                 }
;;;147    
;;;148                 if (p_callback == DEF_NULL) {                      /* No point in a periodic timer without a callback      */
;;;149                    *p_err = OS_ERR_TMR_INVALID_CALLBACK;
;;;150                     return;
;;;151                 }
;;;152                 break;
;;;153    
;;;154            case OS_OPT_TMR_ONE_SHOT:
;;;155                 if (dly == 0u) {
;;;156                    *p_err = OS_ERR_TMR_INVALID_DLY;
;;;157                     return;
;;;158                 }
;;;159                 break;
;;;160    
;;;161            default:
;;;162                *p_err = OS_ERR_OPT_INVALID;
;;;163                 return;
;;;164        }
;;;165    #endif
;;;166    
;;;167        if (OSRunning == OS_STATE_OS_RUNNING) {                     /* Only lock when the kernel is running                 */
;;;168            OS_TmrLock();
;;;169        }
;;;170    
;;;171        p_tmr->State          = OS_TMR_STATE_STOPPED;               /* Initialize the timer fields                          */
;;;172    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;173        p_tmr->Type           = OS_OBJ_TYPE_TMR;
;;;174    #endif
;;;175    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;176        p_tmr->NamePtr        = p_name;
;;;177    #else
;;;178        (void)&p_name;
;;;179    #endif
;;;180        p_tmr->Dly            = dly;
;;;181        p_tmr->Remain         = 0u;
;;;182        p_tmr->Period         = period;
;;;183        p_tmr->Opt            = opt;
;;;184        p_tmr->CallbackPtr    = p_callback;
;;;185        p_tmr->CallbackPtrArg = p_callback_arg;
;;;186        p_tmr->NextPtr        = DEF_NULL;
;;;187        p_tmr->PrevPtr        = DEF_NULL;
;;;188    
;;;189    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;190        OS_TmrDbgListAdd(p_tmr);
;;;191    #endif
;;;192    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;193        OSTmrQty++;                                                 /* Keep track of the number of timers created           */
;;;194    #endif
;;;195    
;;;196        if (OSRunning == OS_STATE_OS_RUNNING) {
;;;197            OS_TmrUnlock();
;;;198        }
;;;199    
;;;200       *p_err = OS_ERR_NONE;
;;;201    }
000026  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.42|
00002a  4816              LDR      r0,|L1.132|
00002c  7800              LDRB     r0,[r0,#0]            ;167  ; OSRunning
00002e  2801              CMP      r0,#1                 ;167
000030  d101              BNE      |L1.54|
000032  f7fffffe          BL       OS_TmrLock
                  |L1.54|
000036  2001              MOVS     r0,#1                 ;171
000038  f8840026          STRB     r0,[r4,#0x26]         ;171
00003c  4812              LDR      r0,|L1.136|
00003e  6020              STR      r0,[r4,#0]            ;173
000040  6065              STR      r5,[r4,#4]            ;176
000042  61e6              STR      r6,[r4,#0x1c]         ;180
000044  2000              MOVS     r0,#0                 ;181
000046  61a0              STR      r0,[r4,#0x18]         ;181
000048  6227              STR      r7,[r4,#0x20]         ;182
00004a  f8a49024          STRH     r9,[r4,#0x24]         ;183
00004e  f8c4a008          STR      r10,[r4,#8]           ;184
000052  f8c4b00c          STR      r11,[r4,#0xc]         ;185
000056  6120              STR      r0,[r4,#0x10]         ;186
000058  6160              STR      r0,[r4,#0x14]         ;187
00005a  4620              MOV      r0,r4                 ;190
00005c  f7fffffe          BL       OS_TmrDbgListAdd
000060  480a              LDR      r0,|L1.140|
000062  8800              LDRH     r0,[r0,#0]            ;193  ; OSTmrQty
000064  1c40              ADDS     r0,r0,#1              ;193
000066  4909              LDR      r1,|L1.140|
000068  8008              STRH     r0,[r1,#0]            ;193
00006a  4806              LDR      r0,|L1.132|
00006c  7800              LDRB     r0,[r0,#0]            ;196  ; OSRunning
00006e  2801              CMP      r0,#1                 ;196
000070  d101              BNE      |L1.118|
000072  f7fffffe          BL       OS_TmrUnlock
                  |L1.118|
000076  2000              MOVS     r0,#0                 ;200
000078  f8a80000          STRH     r0,[r8,#0]            ;200
00007c  bf00              NOP      
00007e  e7d2              B        |L1.38|
;;;202    
                          ENDP

                  |L1.128|
                          DCD      OSIntNestingCtr
                  |L1.132|
                          DCD      OSRunning
                  |L1.136|
                          DCD      0x20524d54
                  |L1.140|
                          DCD      OSTmrQty

                          AREA ||i.OSTmrDel||, CODE, READONLY, ALIGN=2

                  OSTmrDel PROC
;;;231    #if (OS_CFG_TMR_DEL_EN == DEF_ENABLED)
;;;232    CPU_BOOLEAN  OSTmrDel (OS_TMR  *p_tmr,
000000  b570              PUSH     {r4-r6,lr}
;;;233                           OS_ERR  *p_err)
;;;234    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;235        CPU_BOOLEAN  success;
;;;236    
;;;237    
;;;238    
;;;239    #ifdef OS_SAFETY_CRITICAL
;;;240        if (p_err == DEF_NULL) {
;;;241            OS_SAFETY_CRITICAL_EXCEPTION();
;;;242            return (DEF_FALSE);
;;;243        }
;;;244    #endif
;;;245    
;;;246    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;247        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;248           *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
;;;249            return (DEF_FALSE);
;;;250        }
;;;251    #endif
;;;252    
;;;253    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;254        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000006  4825              LDR      r0,|L2.156|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b120              CBZ      r0,|L2.22|
;;;255           *p_err  = OS_ERR_TMR_ISR;
00000c  f2473043          MOV      r0,#0x7343
000010  8020              STRH     r0,[r4,#0]
;;;256            return (DEF_FALSE);
000012  2000              MOVS     r0,#0
                  |L2.20|
;;;257        }
;;;258    #endif
;;;259    
;;;260    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;261        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;262           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;263            return (DEF_FALSE);
;;;264        }
;;;265    #endif
;;;266    
;;;267    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;268        if (p_tmr == DEF_NULL) {
;;;269           *p_err = OS_ERR_TMR_INVALID;
;;;270            return (DEF_FALSE);
;;;271        }
;;;272    #endif
;;;273    
;;;274    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;275        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;276           *p_err = OS_ERR_OBJ_TYPE;
;;;277            return (DEF_FALSE);
;;;278        }
;;;279    #endif
;;;280    
;;;281        OS_TmrLock();
;;;282    
;;;283    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;284        OS_TmrDbgListRemove(p_tmr);
;;;285    #endif
;;;286    
;;;287        switch (p_tmr->State) {
;;;288            case OS_TMR_STATE_RUNNING:
;;;289                 OS_TmrUnlink(p_tmr);                               /* Remove from the list                                 */
;;;290                 OS_TmrClr(p_tmr);
;;;291    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;292                 OSTmrQty--;                                        /* One less timer                                       */
;;;293    #endif
;;;294                *p_err   = OS_ERR_NONE;
;;;295                 success = DEF_TRUE;
;;;296                 break;
;;;297    
;;;298            case OS_TMR_STATE_STOPPED:                              /* Timer has not started or ...                         */
;;;299            case OS_TMR_STATE_COMPLETED:                            /* ... timer has completed the ONE-SHOT time            */
;;;300                 OS_TmrClr(p_tmr);                                  /* Clear timer fields                                   */
;;;301    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;302                 OSTmrQty--;                                        /* One less timer                                       */
;;;303    #endif
;;;304                *p_err   = OS_ERR_NONE;
;;;305                 success = DEF_TRUE;
;;;306                 break;
;;;307                 
;;;308            case OS_TMR_STATE_UNUSED:                               /* Already deleted                                      */
;;;309                *p_err   = OS_ERR_TMR_INACTIVE;
;;;310                 success = DEF_FALSE;
;;;311                 break;
;;;312    
;;;313            default:
;;;314                *p_err   = OS_ERR_TMR_INVALID_STATE;
;;;315                 success = DEF_FALSE;
;;;316                 break;
;;;317        }
;;;318    
;;;319        OS_TmrUnlock();
;;;320    
;;;321        return (success);
;;;322    }
000014  bd70              POP      {r4-r6,pc}
                  |L2.22|
000016  4922              LDR      r1,|L2.160|
000018  6830              LDR      r0,[r6,#0]            ;275
00001a  4288              CMP      r0,r1                 ;275
00001c  d004              BEQ      |L2.40|
00001e  f64550c4          MOV      r0,#0x5dc4            ;276
000022  8020              STRH     r0,[r4,#0]            ;276
000024  2000              MOVS     r0,#0                 ;277
000026  e7f5              B        |L2.20|
                  |L2.40|
000028  f7fffffe          BL       OS_TmrLock
00002c  4630              MOV      r0,r6                 ;284
00002e  f7fffffe          BL       OS_TmrDbgListRemove
000032  f8960026          LDRB     r0,[r6,#0x26]         ;287
000036  b310              CBZ      r0,|L2.126|
000038  2801              CMP      r0,#1                 ;287
00003a  d013              BEQ      |L2.100|
00003c  2802              CMP      r0,#2                 ;287
00003e  d002              BEQ      |L2.70|
000040  2803              CMP      r0,#3                 ;287
000042  d121              BNE      |L2.136|
000044  e00f              B        |L2.102|
                  |L2.70|
000046  4630              MOV      r0,r6                 ;289
000048  f7fffffe          BL       OS_TmrUnlink
00004c  4630              MOV      r0,r6                 ;290
00004e  f7fffffe          BL       OS_TmrClr
000052  4814              LDR      r0,|L2.164|
000054  8800              LDRH     r0,[r0,#0]            ;292  ; OSTmrQty
000056  1e40              SUBS     r0,r0,#1              ;292
000058  4912              LDR      r1,|L2.164|
00005a  8008              STRH     r0,[r1,#0]            ;292
00005c  2000              MOVS     r0,#0                 ;294
00005e  8020              STRH     r0,[r4,#0]            ;294
000060  2501              MOVS     r5,#1                 ;295
000062  e016              B        |L2.146|
                  |L2.100|
000064  bf00              NOP                            ;299
                  |L2.102|
000066  4630              MOV      r0,r6                 ;300
000068  f7fffffe          BL       OS_TmrClr
00006c  480d              LDR      r0,|L2.164|
00006e  8800              LDRH     r0,[r0,#0]            ;302  ; OSTmrQty
000070  1e40              SUBS     r0,r0,#1              ;302
000072  490c              LDR      r1,|L2.164|
000074  8008              STRH     r0,[r1,#0]            ;302
000076  2000              MOVS     r0,#0                 ;304
000078  8020              STRH     r0,[r4,#0]            ;304
00007a  2501              MOVS     r5,#1                 ;305
00007c  e009              B        |L2.146|
                  |L2.126|
00007e  f247303d          MOV      r0,#0x733d            ;309
000082  8020              STRH     r0,[r4,#0]            ;309
000084  2500              MOVS     r5,#0                 ;310
000086  e004              B        |L2.146|
                  |L2.136|
000088  f2473041          MOV      r0,#0x7341            ;314
00008c  8020              STRH     r0,[r4,#0]            ;314
00008e  2500              MOVS     r5,#0                 ;315
000090  bf00              NOP                            ;316
                  |L2.146|
000092  bf00              NOP                            ;296
000094  f7fffffe          BL       OS_TmrUnlock
000098  4628              MOV      r0,r5                 ;321
00009a  e7bb              B        |L2.20|
;;;323    #endif
                          ENDP

                  |L2.156|
                          DCD      OSIntNestingCtr
                  |L2.160|
                          DCD      0x20524d54
                  |L2.164|
                          DCD      OSTmrQty

                          AREA ||i.OSTmrRemainGet||, CODE, READONLY, ALIGN=2

                  OSTmrRemainGet PROC
;;;351    
;;;352    OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
000000  b570              PUSH     {r4-r6,lr}
;;;353                             OS_ERR  *p_err)
;;;354    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;355        OS_TICK  remain;
;;;356    
;;;357    
;;;358    #ifdef OS_SAFETY_CRITICAL
;;;359        if (p_err == DEF_NULL) {
;;;360            OS_SAFETY_CRITICAL_EXCEPTION();
;;;361            return (0u);
;;;362        }
;;;363    #endif
;;;364    
;;;365    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;366        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000006  4820              LDR      r0,|L3.136|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b120              CBZ      r0,|L3.22|
;;;367           *p_err = OS_ERR_TMR_ISR;
00000c  f2473043          MOV      r0,#0x7343
000010  8030              STRH     r0,[r6,#0]
;;;368            return (0u);
000012  2000              MOVS     r0,#0
                  |L3.20|
;;;369        }
;;;370    #endif
;;;371    
;;;372    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;373        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;374           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;375            return (0u);
;;;376        }
;;;377    #endif
;;;378    
;;;379    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;380        if (p_tmr == DEF_NULL) {
;;;381           *p_err = OS_ERR_TMR_INVALID;
;;;382            return (0u);
;;;383        }
;;;384    #endif
;;;385    
;;;386    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;387        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;388           *p_err = OS_ERR_OBJ_TYPE;
;;;389            return (0u);
;;;390        }
;;;391    #endif
;;;392    
;;;393        OS_TmrLock();
;;;394    
;;;395        switch (p_tmr->State) {
;;;396            case OS_TMR_STATE_RUNNING:
;;;397                 remain = p_tmr->Remain;
;;;398                *p_err  = OS_ERR_NONE;
;;;399                 break;
;;;400    
;;;401            case OS_TMR_STATE_STOPPED:                              /* It's assumed that the timer has not started yet      */
;;;402                 if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
;;;403                     if (p_tmr->Dly == 0u) {
;;;404                         remain = p_tmr->Period;
;;;405                     } else {
;;;406                         remain = p_tmr->Dly;
;;;407                     }
;;;408                 } else {
;;;409                     remain = p_tmr->Dly;
;;;410                 }
;;;411                *p_err = OS_ERR_NONE;
;;;412                 break;
;;;413    
;;;414            case OS_TMR_STATE_COMPLETED:                            /* Only ONE-SHOT that timed out can be in this state    */
;;;415                *p_err  = OS_ERR_NONE;
;;;416                 remain = 0u;
;;;417                 break;
;;;418    
;;;419            case OS_TMR_STATE_UNUSED:
;;;420                *p_err  = OS_ERR_TMR_INACTIVE;
;;;421                 remain = 0u;
;;;422                 break;
;;;423    
;;;424            default:
;;;425                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;426                 remain = 0u;
;;;427                 break;
;;;428        }
;;;429    
;;;430        OS_TmrUnlock();
;;;431    
;;;432        return (remain);
;;;433    }
000014  bd70              POP      {r4-r6,pc}
                  |L3.22|
000016  491d              LDR      r1,|L3.140|
000018  6820              LDR      r0,[r4,#0]            ;387
00001a  4288              CMP      r0,r1                 ;387
00001c  d004              BEQ      |L3.40|
00001e  f64550c4          MOV      r0,#0x5dc4            ;388
000022  8030              STRH     r0,[r6,#0]            ;388
000024  2000              MOVS     r0,#0                 ;389
000026  e7f5              B        |L3.20|
                  |L3.40|
000028  f7fffffe          BL       OS_TmrLock
00002c  f8940026          LDRB     r0,[r4,#0x26]         ;395
000030  b1d8              CBZ      r0,|L3.106|
000032  2801              CMP      r0,#1                 ;395
000034  d008              BEQ      |L3.72|
000036  2802              CMP      r0,#2                 ;395
000038  d002              BEQ      |L3.64|
00003a  2803              CMP      r0,#3                 ;395
00003c  d11a              BNE      |L3.116|
00003e  e010              B        |L3.98|
                  |L3.64|
000040  69a5              LDR      r5,[r4,#0x18]         ;397
000042  2000              MOVS     r0,#0                 ;398
000044  8030              STRH     r0,[r6,#0]            ;398
000046  e01a              B        |L3.126|
                  |L3.72|
000048  8ca0              LDRH     r0,[r4,#0x24]         ;402
00004a  2802              CMP      r0,#2                 ;402
00004c  d105              BNE      |L3.90|
00004e  69e0              LDR      r0,[r4,#0x1c]         ;403
000050  b908              CBNZ     r0,|L3.86|
000052  6a25              LDR      r5,[r4,#0x20]         ;404
000054  e002              B        |L3.92|
                  |L3.86|
000056  69e5              LDR      r5,[r4,#0x1c]         ;406
000058  e000              B        |L3.92|
                  |L3.90|
00005a  69e5              LDR      r5,[r4,#0x1c]         ;409
                  |L3.92|
00005c  2000              MOVS     r0,#0                 ;411
00005e  8030              STRH     r0,[r6,#0]            ;411
000060  e00d              B        |L3.126|
                  |L3.98|
000062  2000              MOVS     r0,#0                 ;415
000064  8030              STRH     r0,[r6,#0]            ;415
000066  2500              MOVS     r5,#0                 ;416
000068  e009              B        |L3.126|
                  |L3.106|
00006a  f247303d          MOV      r0,#0x733d            ;420
00006e  8030              STRH     r0,[r6,#0]            ;420
000070  2500              MOVS     r5,#0                 ;421
000072  e004              B        |L3.126|
                  |L3.116|
000074  f2473041          MOV      r0,#0x7341            ;425
000078  8030              STRH     r0,[r6,#0]            ;425
00007a  2500              MOVS     r5,#0                 ;426
00007c  bf00              NOP                            ;427
                  |L3.126|
00007e  bf00              NOP                            ;399
000080  f7fffffe          BL       OS_TmrUnlock
000084  4628              MOV      r0,r5                 ;432
000086  e7c5              B        |L3.20|
;;;434    
                          ENDP

                  |L3.136|
                          DCD      OSIntNestingCtr
                  |L3.140|
                          DCD      0x20524d54

                          AREA ||i.OSTmrSet||, CODE, READONLY, ALIGN=2

                  OSTmrSet PROC
;;;478    
;;;479    void  OSTmrSet (OS_TMR               *p_tmr,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;480                    OS_TICK               dly,
;;;481                    OS_TICK               period,
;;;482                    OS_TMR_CALLBACK_PTR   p_callback,
;;;483                    void                 *p_callback_arg,
;;;484                    OS_ERR               *p_err)
;;;485    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9508          LDRD     r9,r5,[sp,#0x20]
;;;486    #ifdef OS_SAFETY_CRITICAL
;;;487        if (p_err == DEF_NULL) {
;;;488            OS_SAFETY_CRITICAL_EXCEPTION();
;;;489            return;
;;;490        }
;;;491    #endif
;;;492    
;;;493    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;494        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000010  480e              LDR      r0,|L4.76|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000014  b120              CBZ      r0,|L4.32|
;;;495           *p_err = OS_ERR_TMR_ISR;
000016  f2473043          MOV      r0,#0x7343
00001a  8028              STRH     r0,[r5,#0]
                  |L4.28|
;;;496            return;
;;;497        }
;;;498    #endif
;;;499    
;;;500    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;501        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;502           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;503            return;
;;;504        }
;;;505    #endif
;;;506    
;;;507    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;508        if (p_tmr == DEF_NULL) {                                    /* Validate 'p_tmr'                                     */
;;;509           *p_err = OS_ERR_TMR_INVALID;
;;;510            return;
;;;511        }
;;;512    #endif
;;;513    
;;;514    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;515        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;516           *p_err = OS_ERR_OBJ_TYPE;
;;;517            return;
;;;518        }
;;;519    #endif
;;;520    
;;;521    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;522        switch (p_tmr->Opt) {
;;;523            case OS_OPT_TMR_PERIODIC:
;;;524                 if (period == 0u) {
;;;525                    *p_err = OS_ERR_TMR_INVALID_PERIOD;
;;;526                     return;
;;;527                 }
;;;528    
;;;529                 if (p_callback == DEF_NULL) {                      /* No point in a periodic timer without a callback      */
;;;530                    *p_err = OS_ERR_TMR_INVALID_CALLBACK;
;;;531                     return;
;;;532                 }
;;;533                 break;
;;;534    
;;;535            case OS_OPT_TMR_ONE_SHOT:
;;;536                 if (dly == 0u) {
;;;537                    *p_err = OS_ERR_TMR_INVALID_DLY;
;;;538                     return;
;;;539                 }
;;;540                 break;
;;;541    
;;;542            default:
;;;543                *p_err = OS_ERR_TMR_INVALID;
;;;544                 return;
;;;545        }
;;;546    #endif
;;;547    
;;;548        OS_TmrLock();
;;;549    
;;;550        p_tmr->Dly            = dly;
;;;551        p_tmr->Period         = period;
;;;552        p_tmr->CallbackPtr    = p_callback;
;;;553        p_tmr->CallbackPtrArg = p_callback_arg;
;;;554    
;;;555       *p_err = OS_ERR_NONE;
;;;556    
;;;557        OS_TmrUnlock();
;;;558    
;;;559    }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L4.32|
000020  490b              LDR      r1,|L4.80|
000022  6820              LDR      r0,[r4,#0]            ;515
000024  4288              CMP      r0,r1                 ;515
000026  d003              BEQ      |L4.48|
000028  f64550c4          MOV      r0,#0x5dc4            ;516
00002c  8028              STRH     r0,[r5,#0]            ;516
00002e  e7f5              B        |L4.28|
                  |L4.48|
000030  f7fffffe          BL       OS_TmrLock
000034  61e6              STR      r6,[r4,#0x1c]         ;550
000036  6227              STR      r7,[r4,#0x20]         ;551
000038  f8c48008          STR      r8,[r4,#8]            ;552
00003c  f8c4900c          STR      r9,[r4,#0xc]          ;553
000040  2000              MOVS     r0,#0                 ;555
000042  8028              STRH     r0,[r5,#0]            ;555
000044  f7fffffe          BL       OS_TmrUnlock
000048  bf00              NOP      
00004a  e7e7              B        |L4.28|
;;;560    
                          ENDP

                  |L4.76|
                          DCD      OSIntNestingCtr
                  |L4.80|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStart||, CODE, READONLY, ALIGN=2

                  OSTmrStart PROC
;;;589    
;;;590    CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;591                             OS_ERR  *p_err)
;;;592    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;593        OS_TMR      *p_next;
;;;594        CPU_BOOLEAN  success;
;;;595    
;;;596        
;;;597    
;;;598    #ifdef OS_SAFETY_CRITICAL
;;;599        if (p_err == DEF_NULL) {
;;;600            OS_SAFETY_CRITICAL_EXCEPTION();
;;;601            return (DEF_FALSE);
;;;602        }
;;;603    #endif
;;;604    
;;;605    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;606        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000008  482e              LDR      r0,|L5.196|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000c  b128              CBZ      r0,|L5.26|
;;;607           *p_err = OS_ERR_TMR_ISR;
00000e  f2473043          MOV      r0,#0x7343
000012  8028              STRH     r0,[r5,#0]
;;;608            return (DEF_FALSE);
000014  2000              MOVS     r0,#0
                  |L5.22|
;;;609        }
;;;610    #endif
;;;611    
;;;612    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;613        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;614           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;615            return (DEF_FALSE);
;;;616        }
;;;617    #endif
;;;618    
;;;619    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;620        if (p_tmr == DEF_NULL) {
;;;621           *p_err = OS_ERR_TMR_INVALID;
;;;622            return (DEF_FALSE);
;;;623        }
;;;624    #endif
;;;625    
;;;626    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;627        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;628           *p_err = OS_ERR_OBJ_TYPE;
;;;629            return (DEF_FALSE);
;;;630        }
;;;631    #endif
;;;632    
;;;633        OS_TmrLock();
;;;634    
;;;635        switch (p_tmr->State) {
;;;636            case OS_TMR_STATE_RUNNING:                              /* Restart the timer                                    */
;;;637                 p_tmr->Remain = p_tmr->Dly;
;;;638                *p_err         = OS_ERR_NONE;
;;;639                 success       = DEF_TRUE;
;;;640                 break;
;;;641    
;;;642            case OS_TMR_STATE_STOPPED:                              /* Start the timer                                      */
;;;643            case OS_TMR_STATE_COMPLETED:
;;;644                 p_tmr->State  = OS_TMR_STATE_RUNNING;
;;;645                 if (p_tmr->Dly == 0u) {
;;;646                     p_tmr->Remain = p_tmr->Period;
;;;647                 } else {
;;;648                     p_tmr->Remain = p_tmr->Dly;
;;;649                 }
;;;650                 if (OSTmrListPtr ==  DEF_NULL) {                   /* Link into timer list                                 */
;;;651                     p_tmr->NextPtr   = DEF_NULL;                   /* This is the first timer in the list                  */
;;;652                     p_tmr->PrevPtr   = DEF_NULL;
;;;653                     OSTmrListPtr     = p_tmr;
;;;654    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;655                     OSTmrListEntries = 1u;
;;;656    #endif
;;;657                 } else {
;;;658                     p_next           = OSTmrListPtr;               /* Insert at the beginning of the list                  */
;;;659                     p_tmr->NextPtr   = OSTmrListPtr;
;;;660                     p_tmr->PrevPtr   = DEF_NULL;
;;;661                     p_next->PrevPtr  = p_tmr;
;;;662                     OSTmrListPtr     = p_tmr;
;;;663    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;664                     OSTmrListEntries++;
;;;665    #endif
;;;666                 }
;;;667                *p_err   = OS_ERR_NONE;
;;;668                 success = DEF_TRUE;
;;;669                 break;
;;;670    
;;;671            case OS_TMR_STATE_UNUSED:                               /* Timer not created                                    */
;;;672                *p_err   = OS_ERR_TMR_INACTIVE;
;;;673                 success = DEF_FALSE;
;;;674                 break;
;;;675    
;;;676            default:
;;;677                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;678                 success = DEF_FALSE;
;;;679                 break;
;;;680        }
;;;681    
;;;682        OS_TmrUnlock();
;;;683    
;;;684        return (success);
;;;685    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L5.26|
00001a  492b              LDR      r1,|L5.200|
00001c  6820              LDR      r0,[r4,#0]            ;627
00001e  4288              CMP      r0,r1                 ;627
000020  d004              BEQ      |L5.44|
000022  f64550c4          MOV      r0,#0x5dc4            ;628
000026  8028              STRH     r0,[r5,#0]            ;628
000028  2000              MOVS     r0,#0                 ;629
00002a  e7f4              B        |L5.22|
                  |L5.44|
00002c  f7fffffe          BL       OS_TmrLock
000030  f8940026          LDRB     r0,[r4,#0x26]         ;635
000034  2800              CMP      r0,#0                 ;635
000036  d035              BEQ      |L5.164|
000038  2801              CMP      r0,#1                 ;635
00003a  d00a              BEQ      |L5.82|
00003c  2802              CMP      r0,#2                 ;635
00003e  d002              BEQ      |L5.70|
000040  2803              CMP      r0,#3                 ;635
000042  d134              BNE      |L5.174|
000044  e006              B        |L5.84|
                  |L5.70|
000046  69e0              LDR      r0,[r4,#0x1c]         ;637
000048  61a0              STR      r0,[r4,#0x18]         ;637
00004a  2000              MOVS     r0,#0                 ;638
00004c  8028              STRH     r0,[r5,#0]            ;638
00004e  2601              MOVS     r6,#1                 ;639
000050  e032              B        |L5.184|
                  |L5.82|
000052  bf00              NOP                            ;643
                  |L5.84|
000054  2002              MOVS     r0,#2                 ;644
000056  f8840026          STRB     r0,[r4,#0x26]         ;644
00005a  69e0              LDR      r0,[r4,#0x1c]         ;645
00005c  b910              CBNZ     r0,|L5.100|
00005e  6a20              LDR      r0,[r4,#0x20]         ;646
000060  61a0              STR      r0,[r4,#0x18]         ;646
000062  e001              B        |L5.104|
                  |L5.100|
000064  69e0              LDR      r0,[r4,#0x1c]         ;648
000066  61a0              STR      r0,[r4,#0x18]         ;648
                  |L5.104|
000068  4818              LDR      r0,|L5.204|
00006a  6800              LDR      r0,[r0,#0]            ;650  ; OSTmrListPtr
00006c  b940              CBNZ     r0,|L5.128|
00006e  2000              MOVS     r0,#0                 ;651
000070  6120              STR      r0,[r4,#0x10]         ;651
000072  6160              STR      r0,[r4,#0x14]         ;652
000074  4815              LDR      r0,|L5.204|
000076  6004              STR      r4,[r0,#0]            ;653  ; OSTmrListPtr
000078  2001              MOVS     r0,#1                 ;655
00007a  4915              LDR      r1,|L5.208|
00007c  8008              STRH     r0,[r1,#0]            ;655
00007e  e00d              B        |L5.156|
                  |L5.128|
000080  4812              LDR      r0,|L5.204|
000082  6807              LDR      r7,[r0,#0]            ;658  ; OSTmrListPtr
000084  6800              LDR      r0,[r0,#0]            ;659  ; OSTmrListPtr
000086  6120              STR      r0,[r4,#0x10]         ;659
000088  2000              MOVS     r0,#0                 ;660
00008a  6160              STR      r0,[r4,#0x14]         ;660
00008c  617c              STR      r4,[r7,#0x14]         ;661
00008e  480f              LDR      r0,|L5.204|
000090  6004              STR      r4,[r0,#0]            ;662  ; OSTmrListPtr
000092  480f              LDR      r0,|L5.208|
000094  8800              LDRH     r0,[r0,#0]            ;664  ; OSTmrListEntries
000096  1c40              ADDS     r0,r0,#1              ;664
000098  490d              LDR      r1,|L5.208|
00009a  8008              STRH     r0,[r1,#0]            ;664
                  |L5.156|
00009c  2000              MOVS     r0,#0                 ;667
00009e  8028              STRH     r0,[r5,#0]            ;667
0000a0  2601              MOVS     r6,#1                 ;668
0000a2  e009              B        |L5.184|
                  |L5.164|
0000a4  f247303d          MOV      r0,#0x733d            ;672
0000a8  8028              STRH     r0,[r5,#0]            ;672
0000aa  2600              MOVS     r6,#0                 ;673
0000ac  e004              B        |L5.184|
                  |L5.174|
0000ae  f2473041          MOV      r0,#0x7341            ;677
0000b2  8028              STRH     r0,[r5,#0]            ;677
0000b4  2600              MOVS     r6,#0                 ;678
0000b6  bf00              NOP                            ;679
                  |L5.184|
0000b8  bf00              NOP                            ;640
0000ba  f7fffffe          BL       OS_TmrUnlock
0000be  4630              MOV      r0,r6                 ;684
0000c0  e7a9              B        |L5.22|
;;;686    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L5.196|
                          DCD      OSIntNestingCtr
                  |L5.200|
                          DCD      0x20524d54
                  |L5.204|
                          DCD      OSTmrListPtr
                  |L5.208|
                          DCD      OSTmrListEntries

                          AREA ||i.OSTmrStateGet||, CODE, READONLY, ALIGN=2

                  OSTmrStateGet PROC
;;;715    
;;;716    OS_STATE  OSTmrStateGet (OS_TMR  *p_tmr,
000000  b570              PUSH     {r4-r6,lr}
;;;717                             OS_ERR  *p_err)
;;;718    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;719        OS_STATE  state;
;;;720    
;;;721    
;;;722    
;;;723    #ifdef OS_SAFETY_CRITICAL
;;;724        if (p_err == DEF_NULL) {
;;;725            OS_SAFETY_CRITICAL_EXCEPTION();
;;;726            return (OS_TMR_STATE_UNUSED);
;;;727        }
;;;728    #endif
;;;729    
;;;730    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;731        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
000006  4816              LDR      r0,|L6.96|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b120              CBZ      r0,|L6.22|
;;;732           *p_err = OS_ERR_TMR_ISR;
00000c  f2473043          MOV      r0,#0x7343
000010  8020              STRH     r0,[r4,#0]
;;;733            return (OS_TMR_STATE_UNUSED);
000012  2000              MOVS     r0,#0
                  |L6.20|
;;;734        }
;;;735    #endif
;;;736    
;;;737    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;738        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;739           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;740            return (OS_TMR_STATE_UNUSED);
;;;741        }
;;;742    #endif
;;;743    
;;;744    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;745        if (p_tmr == DEF_NULL) {
;;;746           *p_err = OS_ERR_TMR_INVALID;
;;;747            return (OS_TMR_STATE_UNUSED);
;;;748        }
;;;749    #endif
;;;750    
;;;751    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;752        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;753           *p_err = OS_ERR_OBJ_TYPE;
;;;754            return (OS_TMR_STATE_UNUSED);
;;;755        }
;;;756    #endif
;;;757    
;;;758        OS_TmrLock();
;;;759    
;;;760        state = p_tmr->State;
;;;761        switch (state) {
;;;762            case OS_TMR_STATE_UNUSED:
;;;763            case OS_TMR_STATE_STOPPED:
;;;764            case OS_TMR_STATE_COMPLETED:
;;;765            case OS_TMR_STATE_RUNNING:
;;;766                *p_err = OS_ERR_NONE;
;;;767                 break;
;;;768    
;;;769            default:
;;;770                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;771                 break;
;;;772        }
;;;773    
;;;774        OS_TmrUnlock();
;;;775    
;;;776        return (state);
;;;777    }
000014  bd70              POP      {r4-r6,pc}
                  |L6.22|
000016  4913              LDR      r1,|L6.100|
000018  6828              LDR      r0,[r5,#0]            ;752
00001a  4288              CMP      r0,r1                 ;752
00001c  d004              BEQ      |L6.40|
00001e  f64550c4          MOV      r0,#0x5dc4            ;753
000022  8020              STRH     r0,[r4,#0]            ;753
000024  2000              MOVS     r0,#0                 ;754
000026  e7f5              B        |L6.20|
                  |L6.40|
000028  f7fffffe          BL       OS_TmrLock
00002c  f8956026          LDRB     r6,[r5,#0x26]         ;760
000030  b136              CBZ      r6,|L6.64|
000032  2e01              CMP      r6,#1                 ;761
000034  d005              BEQ      |L6.66|
000036  2e02              CMP      r6,#2                 ;761
000038  d005              BEQ      |L6.70|
00003a  2e03              CMP      r6,#3                 ;761
00003c  d106              BNE      |L6.76|
00003e  e001              B        |L6.68|
                  |L6.64|
000040  bf00              NOP                            ;763
                  |L6.66|
000042  bf00              NOP                            ;764
                  |L6.68|
000044  bf00              NOP                            ;765
                  |L6.70|
000046  2000              MOVS     r0,#0                 ;766
000048  8020              STRH     r0,[r4,#0]            ;766
00004a  e003              B        |L6.84|
                  |L6.76|
00004c  f2473041          MOV      r0,#0x7341            ;770
000050  8020              STRH     r0,[r4,#0]            ;770
000052  bf00              NOP                            ;771
                  |L6.84|
000054  bf00              NOP                            ;767
000056  f7fffffe          BL       OS_TmrUnlock
00005a  4630              MOV      r0,r6                 ;776
00005c  e7da              B        |L6.20|
;;;778    
                          ENDP

00005e  0000              DCW      0x0000
                  |L6.96|
                          DCD      OSIntNestingCtr
                  |L6.100|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStop||, CODE, READONLY, ALIGN=2

                  OSTmrStop PROC
;;;819    
;;;820    CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;821                            OS_OPT   opt,
;;;822                            void    *p_callback_arg,
;;;823                            OS_ERR  *p_err)
;;;824    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
;;;825        OS_TMR_CALLBACK_PTR  p_fnct;
;;;826        CPU_BOOLEAN          success;
;;;827    
;;;828    
;;;829    
;;;830    #ifdef OS_SAFETY_CRITICAL
;;;831        if (p_err == DEF_NULL) {
;;;832            OS_SAFETY_CRITICAL_EXCEPTION();
;;;833            return (DEF_FALSE);
;;;834        }
;;;835    #endif
;;;836    
;;;837    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;838        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
00000c  4833              LDR      r0,|L7.220|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000010  b128              CBZ      r0,|L7.30|
;;;839           *p_err = OS_ERR_TMR_ISR;
000012  f2473043          MOV      r0,#0x7343
000016  8020              STRH     r0,[r4,#0]
;;;840            return (DEF_FALSE);
000018  2000              MOVS     r0,#0
                  |L7.26|
;;;841        }
;;;842    #endif
;;;843    
;;;844    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;845        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;846           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;847            return (DEF_FALSE);
;;;848        }
;;;849    #endif
;;;850    
;;;851    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;852        if (p_tmr == DEF_NULL) {
;;;853           *p_err = OS_ERR_TMR_INVALID;
;;;854            return (DEF_FALSE);
;;;855        }
;;;856    #endif
;;;857    
;;;858    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;859        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
;;;860           *p_err = OS_ERR_OBJ_TYPE;
;;;861            return (DEF_FALSE);
;;;862        }
;;;863    #endif
;;;864    
;;;865        OS_TmrLock();
;;;866    
;;;867        switch (p_tmr->State) {
;;;868            case OS_TMR_STATE_RUNNING:
;;;869                *p_err = OS_ERR_NONE;
;;;870                 switch (opt) {
;;;871                     case OS_OPT_TMR_CALLBACK:
;;;872                          OS_TmrUnlink(p_tmr);                      /* Remove from timer list                               */
;;;873                          p_fnct = p_tmr->CallbackPtr;              /* Execute callback function ...                        */
;;;874                          if (p_fnct != DEF_NULL) {                 /* ... if available                                     */
;;;875                            (*p_fnct)((void *)p_tmr, p_tmr->CallbackPtrArg); /* Use callback arg when timer was created     */
;;;876                          } else {
;;;877                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;878                          }
;;;879                          break;
;;;880    
;;;881                     case OS_OPT_TMR_CALLBACK_ARG:
;;;882                          OS_TmrUnlink(p_tmr);                      /* Remove from timer list                               */
;;;883                          p_fnct = p_tmr->CallbackPtr;              /* Execute callback function if available ...           */
;;;884                          if (p_fnct != DEF_NULL) {
;;;885                            (*p_fnct)((void *)p_tmr, p_callback_arg); /* .. using the 'callback_arg' provided in call       */
;;;886                          } else {
;;;887                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;888                          }
;;;889                          break;
;;;890    
;;;891                     case OS_OPT_TMR_NONE:
;;;892                          OS_TmrUnlink(p_tmr);                      /* Remove from timer list                               */
;;;893                          break;
;;;894    
;;;895                     default:
;;;896                         OS_TmrUnlock();
;;;897                        *p_err = OS_ERR_OPT_INVALID;
;;;898                         return (DEF_FALSE);
;;;899                 }
;;;900                 success = DEF_TRUE;
;;;901                 break;
;;;902    
;;;903            case OS_TMR_STATE_COMPLETED:                            /* Timer has already completed the ONE-SHOT or          */
;;;904            case OS_TMR_STATE_STOPPED:                              /* ... timer has not started yet.                       */
;;;905                *p_err   = OS_ERR_TMR_STOPPED;
;;;906                 success = DEF_TRUE;
;;;907                 break;
;;;908    
;;;909            case OS_TMR_STATE_UNUSED:                               /* Timer was not created                                */
;;;910                *p_err   = OS_ERR_TMR_INACTIVE;
;;;911                 success = DEF_FALSE;
;;;912                 break;
;;;913    
;;;914            default:
;;;915                *p_err   = OS_ERR_TMR_INVALID_STATE;
;;;916                 success = DEF_FALSE;
;;;917                 break;
;;;918        }
;;;919    
;;;920        OS_TmrUnlock();
;;;921    
;;;922        return (success);
;;;923    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L7.30|
00001e  4930              LDR      r1,|L7.224|
000020  6828              LDR      r0,[r5,#0]            ;859
000022  4288              CMP      r0,r1                 ;859
000024  d004              BEQ      |L7.48|
000026  f64550c4          MOV      r0,#0x5dc4            ;860
00002a  8020              STRH     r0,[r4,#0]            ;860
00002c  2000              MOVS     r0,#0                 ;861
00002e  e7f4              B        |L7.26|
                  |L7.48|
000030  f7fffffe          BL       OS_TmrLock
000034  f8950026          LDRB     r0,[r5,#0x26]         ;867
000038  2800              CMP      r0,#0                 ;867
00003a  d040              BEQ      |L7.190|
00003c  2801              CMP      r0,#1                 ;867
00003e  d039              BEQ      |L7.180|
000040  2802              CMP      r0,#2                 ;867
000042  d002              BEQ      |L7.74|
000044  2803              CMP      r0,#3                 ;867
000046  d13f              BNE      |L7.200|
000048  e033              B        |L7.178|
                  |L7.74|
00004a  2000              MOVS     r0,#0                 ;869
00004c  8020              STRH     r0,[r4,#0]            ;869
00004e  f1b80f00          CMP      r8,#0                 ;870
000052  d020              BEQ      |L7.150|
000054  f1b80f03          CMP      r8,#3                 ;870
000058  d003              BEQ      |L7.98|
00005a  f1b80f04          CMP      r8,#4                 ;870
00005e  d11e              BNE      |L7.158|
000060  e00c              B        |L7.124|
                  |L7.98|
000062  4628              MOV      r0,r5                 ;872
000064  f7fffffe          BL       OS_TmrUnlink
000068  68ae              LDR      r6,[r5,#8]            ;873
00006a  b11e              CBZ      r6,|L7.116|
00006c  4628              MOV      r0,r5                 ;875
00006e  68e9              LDR      r1,[r5,#0xc]          ;875
000070  47b0              BLX      r6                    ;875
000072  e002              B        |L7.122|
                  |L7.116|
000074  f2473044          MOV      r0,#0x7344            ;877
000078  8020              STRH     r0,[r4,#0]            ;877
                  |L7.122|
00007a  e017              B        |L7.172|
                  |L7.124|
00007c  4628              MOV      r0,r5                 ;882
00007e  f7fffffe          BL       OS_TmrUnlink
000082  68ae              LDR      r6,[r5,#8]            ;883
000084  b11e              CBZ      r6,|L7.142|
000086  4649              MOV      r1,r9                 ;885
000088  4628              MOV      r0,r5                 ;885
00008a  47b0              BLX      r6                    ;885
00008c  e002              B        |L7.148|
                  |L7.142|
00008e  f2473044          MOV      r0,#0x7344            ;887
000092  8020              STRH     r0,[r4,#0]            ;887
                  |L7.148|
000094  e00a              B        |L7.172|
                  |L7.150|
000096  4628              MOV      r0,r5                 ;892
000098  f7fffffe          BL       OS_TmrUnlink
00009c  e006              B        |L7.172|
                  |L7.158|
00009e  f7fffffe          BL       OS_TmrUnlock
0000a2  f6456025          MOV      r0,#0x5e25            ;897
0000a6  8020              STRH     r0,[r4,#0]            ;897
0000a8  2000              MOVS     r0,#0                 ;898
0000aa  e7b6              B        |L7.26|
                  |L7.172|
0000ac  bf00              NOP                            ;879
0000ae  2701              MOVS     r7,#1                 ;900
0000b0  e00f              B        |L7.210|
                  |L7.178|
0000b2  bf00              NOP                            ;904
                  |L7.180|
0000b4  f2473049          MOV      r0,#0x7349            ;905
0000b8  8020              STRH     r0,[r4,#0]            ;905
0000ba  2701              MOVS     r7,#1                 ;906
0000bc  e009              B        |L7.210|
                  |L7.190|
0000be  f247303d          MOV      r0,#0x733d            ;910
0000c2  8020              STRH     r0,[r4,#0]            ;910
0000c4  2700              MOVS     r7,#0                 ;911
0000c6  e004              B        |L7.210|
                  |L7.200|
0000c8  f2473041          MOV      r0,#0x7341            ;915
0000cc  8020              STRH     r0,[r4,#0]            ;915
0000ce  2700              MOVS     r7,#0                 ;916
0000d0  bf00              NOP                            ;917
                  |L7.210|
0000d2  bf00              NOP                            ;901
0000d4  f7fffffe          BL       OS_TmrUnlock
0000d8  4638              MOV      r0,r7                 ;922
0000da  e79e              B        |L7.26|
;;;924    
                          ENDP

                  |L7.220|
                          DCD      OSIntNestingCtr
                  |L7.224|
                          DCD      0x20524d54

                          AREA ||i.OS_TmrClr||, CODE, READONLY, ALIGN=2

                  OS_TmrClr PROC
;;;940    
;;;941    void  OS_TmrClr (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;942    {
;;;943        p_tmr->State          = OS_TMR_STATE_UNUSED;                /* Clear timer fields                                   */
000002  f8801026          STRB     r1,[r0,#0x26]
;;;944    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;945        p_tmr->Type           = OS_OBJ_TYPE_NONE;
000006  4907              LDR      r1,|L8.36|
000008  6001              STR      r1,[r0,#0]
;;;946    #endif
;;;947    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;948        p_tmr->NamePtr        = (CPU_CHAR *)((void *)"?TMR");
00000a  a107              ADR      r1,|L8.40|
00000c  6041              STR      r1,[r0,#4]
;;;949    #endif
;;;950        p_tmr->Dly            = 0u;
00000e  2100              MOVS     r1,#0
000010  61c1              STR      r1,[r0,#0x1c]
;;;951        p_tmr->Remain         = 0u;
000012  6181              STR      r1,[r0,#0x18]
;;;952        p_tmr->Period         = 0u;
000014  6201              STR      r1,[r0,#0x20]
;;;953        p_tmr->Opt            = 0u;
000016  8481              STRH     r1,[r0,#0x24]
;;;954        p_tmr->CallbackPtr    = DEF_NULL;
000018  6081              STR      r1,[r0,#8]
;;;955        p_tmr->CallbackPtrArg = DEF_NULL;
00001a  60c1              STR      r1,[r0,#0xc]
;;;956        p_tmr->NextPtr        = DEF_NULL;
00001c  6101              STR      r1,[r0,#0x10]
;;;957        p_tmr->PrevPtr        = DEF_NULL;
00001e  6141              STR      r1,[r0,#0x14]
;;;958    }
000020  4770              BX       lr
;;;959    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x454e4f4e
                  |L8.40|
000028  3f544d52          DCB      "?TMR",0
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i.OS_TmrDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListAdd PROC
;;;976    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;977    void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;978    {
;;;979        p_tmr->DbgPrevPtr               = DEF_NULL;
000002  6281              STR      r1,[r0,#0x28]
;;;980        if (OSTmrDbgListPtr == DEF_NULL) {
000004  4907              LDR      r1,|L9.36|
000006  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
000008  b911              CBNZ     r1,|L9.16|
;;;981            p_tmr->DbgNextPtr           = DEF_NULL;
00000a  2100              MOVS     r1,#0
00000c  62c1              STR      r1,[r0,#0x2c]
00000e  e005              B        |L9.28|
                  |L9.16|
;;;982        } else {
;;;983            p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
000010  4904              LDR      r1,|L9.36|
000012  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
000014  62c1              STR      r1,[r0,#0x2c]
;;;984            OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
000016  4903              LDR      r1,|L9.36|
000018  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
00001a  6288              STR      r0,[r1,#0x28]
                  |L9.28|
;;;985        }
;;;986        OSTmrDbgListPtr                 =  p_tmr;
00001c  4901              LDR      r1,|L9.36|
00001e  6008              STR      r0,[r1,#0]  ; OSTmrDbgListPtr
;;;987    }
000020  4770              BX       lr
;;;988    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListRemove PROC
;;;990    
;;;991    void  OS_TmrDbgListRemove (OS_TMR  *p_tmr)
000000  6a82              LDR      r2,[r0,#0x28]
;;;992    {
;;;993        OS_TMR  *p_tmr_next;
;;;994        OS_TMR  *p_tmr_prev;
;;;995    
;;;996    
;;;997        p_tmr_prev = p_tmr->DbgPrevPtr;
;;;998        p_tmr_next = p_tmr->DbgNextPtr;
000002  6ac1              LDR      r1,[r0,#0x2c]
;;;999    
;;;1000       if (p_tmr_prev == DEF_NULL) {
000004  b93a              CBNZ     r2,|L10.22|
;;;1001           OSTmrDbgListPtr = p_tmr_next;
000006  4b09              LDR      r3,|L10.44|
000008  6019              STR      r1,[r3,#0]  ; OSTmrDbgListPtr
;;;1002           if (p_tmr_next != DEF_NULL) {
00000a  b109              CBZ      r1,|L10.16|
;;;1003               p_tmr_next->DbgPrevPtr = DEF_NULL;
00000c  2300              MOVS     r3,#0
00000e  628b              STR      r3,[r1,#0x28]
                  |L10.16|
;;;1004           }
;;;1005           p_tmr->DbgNextPtr = DEF_NULL;
000010  2300              MOVS     r3,#0
000012  62c3              STR      r3,[r0,#0x2c]
000014  e009              B        |L10.42|
                  |L10.22|
;;;1006   
;;;1007       } else if (p_tmr_next == DEF_NULL) {
000016  b919              CBNZ     r1,|L10.32|
;;;1008           p_tmr_prev->DbgNextPtr = DEF_NULL;
000018  2300              MOVS     r3,#0
00001a  62d3              STR      r3,[r2,#0x2c]
;;;1009           p_tmr->DbgPrevPtr      = DEF_NULL;
00001c  6283              STR      r3,[r0,#0x28]
00001e  e004              B        |L10.42|
                  |L10.32|
;;;1010   
;;;1011       } else {
;;;1012           p_tmr_prev->DbgNextPtr = p_tmr_next;
000020  62d1              STR      r1,[r2,#0x2c]
;;;1013           p_tmr_next->DbgPrevPtr = p_tmr_prev;
000022  628a              STR      r2,[r1,#0x28]
;;;1014           p_tmr->DbgNextPtr      = DEF_NULL;
000024  2300              MOVS     r3,#0
000026  62c3              STR      r3,[r0,#0x2c]
;;;1015           p_tmr->DbgPrevPtr      = DEF_NULL;
000028  6283              STR      r3,[r0,#0x28]
                  |L10.42|
;;;1016       }
;;;1017   }
00002a  4770              BX       lr
;;;1018   #endif
                          ENDP

                  |L10.44|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrInit||, CODE, READONLY, ALIGN=2

                  OS_TmrInit PROC
;;;1040   
;;;1041   void  OS_TmrInit (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;1042   {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;1043   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1044       OSTmrDbgListPtr = DEF_NULL;
000006  2000              MOVS     r0,#0
000008  492f              LDR      r1,|L11.200|
00000a  6008              STR      r0,[r1,#0]  ; OSTmrDbgListPtr
;;;1045   #endif
;;;1046   
;;;1047       OSTmrListPtr        = DEF_NULL;                             /* Create an empty timer list                           */
00000c  492f              LDR      r1,|L11.204|
00000e  6008              STR      r0,[r1,#0]  ; OSTmrListPtr
;;;1048   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1049       OSTmrListEntries    = 0u;
000010  492f              LDR      r1,|L11.208|
000012  8008              STRH     r0,[r1,#0]
;;;1050   #endif
;;;1051   
;;;1052       if (OSCfg_TmrTaskRate_Hz > 0u) {
000014  482f              LDR      r0,|L11.212|
000016  6800              LDR      r0,[r0,#0]  ; OSCfg_TmrTaskRate_Hz
000018  b140              CBZ      r0,|L11.44|
;;;1053           OSTmrUpdateCnt  = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
00001a  482f              LDR      r0,|L11.216|
00001c  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
00001e  492d              LDR      r1,|L11.212|
000020  6809              LDR      r1,[r1,#0]  ; OSCfg_TmrTaskRate_Hz
000022  fbb0f0f1          UDIV     r0,r0,r1
000026  492d              LDR      r1,|L11.220|
000028  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCnt
00002a  e006              B        |L11.58|
                  |L11.44|
;;;1054       } else {
;;;1055           OSTmrUpdateCnt  = OSCfg_TickRate_Hz / 10u;
00002c  482a              LDR      r0,|L11.216|
00002e  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000030  210a              MOVS     r1,#0xa
000032  fbb0f0f1          UDIV     r0,r0,r1
000036  4929              LDR      r1,|L11.220|
000038  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCnt
                  |L11.58|
;;;1056       }
;;;1057       OSTmrUpdateCtr      = OSTmrUpdateCnt;
00003a  4828              LDR      r0,|L11.220|
00003c  6800              LDR      r0,[r0,#0]  ; OSTmrUpdateCnt
00003e  4928              LDR      r1,|L11.224|
000040  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCtr
;;;1058   
;;;1059       OSTmrTickCtr        = 0u;
000042  2000              MOVS     r0,#0
000044  4927              LDR      r1,|L11.228|
000046  6008              STR      r0,[r1,#0]  ; OSTmrTickCtr
;;;1060   
;;;1061   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1062       OSTmrTaskTimeMax    = 0u;
000048  4927              LDR      r1,|L11.232|
00004a  6008              STR      r0,[r1,#0]  ; OSTmrTaskTimeMax
;;;1063   #endif
;;;1064   
;;;1065   #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;1066       OSMutexCreate(&OSTmrMutex,                                  /* Use a mutex to protect the timers                    */
00004c  4622              MOV      r2,r4
00004e  a127              ADR      r1,|L11.236|
000050  482a              LDR      r0,|L11.252|
000052  f7fffffe          BL       OSMutexCreate
;;;1067                     (CPU_CHAR *)"OS Tmr Mutex", 
;;;1068                     p_err);
;;;1069       if (*p_err != OS_ERR_NONE) {
000056  8820              LDRH     r0,[r4,#0]
000058  b108              CBZ      r0,|L11.94|
                  |L11.90|
;;;1070           return;
;;;1071       }
;;;1072   #endif
;;;1073   
;;;1074                                                                   /* -------------- CREATE THE TIMER TASK --------------- */
;;;1075       if (OSCfg_TmrTaskStkBasePtr == DEF_NULL) {
;;;1076          *p_err = OS_ERR_TMR_STK_INVALID;
;;;1077           return;
;;;1078       }
;;;1079   
;;;1080       if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
;;;1081          *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
;;;1082           return;
;;;1083       }
;;;1084   
;;;1085       if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
;;;1086          *p_err = OS_ERR_TMR_PRIO_INVALID;
;;;1087           return;
;;;1088       }
;;;1089   
;;;1090       OSTaskCreate(&OSTmrTaskTCB,
;;;1091                    (CPU_CHAR   *)((void *)"uC/OS-III Timer Task"),
;;;1092                    OS_TmrTask,
;;;1093                    DEF_NULL,
;;;1094                    OSCfg_TmrTaskPrio,
;;;1095                    OSCfg_TmrTaskStkBasePtr,
;;;1096                    OSCfg_TmrTaskStkLimit,
;;;1097                    OSCfg_TmrTaskStkSize,
;;;1098                    0u,
;;;1099                    0u,
;;;1100                    DEF_NULL,
;;;1101                    (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
;;;1102                    p_err);
;;;1103   }
00005a  b00a              ADD      sp,sp,#0x28
00005c  bd10              POP      {r4,pc}
                  |L11.94|
00005e  4828              LDR      r0,|L11.256|
000060  6800              LDR      r0,[r0,#0]            ;1075  ; OSCfg_TmrTaskStkBasePtr
000062  b918              CBNZ     r0,|L11.108|
000064  f2473047          MOV      r0,#0x7347            ;1076
000068  8020              STRH     r0,[r4,#0]            ;1076
00006a  e7f6              B        |L11.90|
                  |L11.108|
00006c  4825              LDR      r0,|L11.260|
00006e  6800              LDR      r0,[r0,#0]            ;1080  ; OSCfg_TmrTaskStkSize
000070  4925              LDR      r1,|L11.264|
000072  6809              LDR      r1,[r1,#0]            ;1080  ; OSCfg_StkSizeMin
000074  4288              CMP      r0,r1                 ;1080
000076  d203              BCS      |L11.128|
000078  f2473048          MOV      r0,#0x7348            ;1081
00007c  8020              STRH     r0,[r4,#0]            ;1081
00007e  e7ec              B        |L11.90|
                  |L11.128|
000080  4822              LDR      r0,|L11.268|
000082  7800              LDRB     r0,[r0,#0]            ;1085  ; OSCfg_TmrTaskPrio
000084  281f              CMP      r0,#0x1f              ;1085
000086  d303              BCC      |L11.144|
000088  f2473046          MOV      r0,#0x7346            ;1086
00008c  8020              STRH     r0,[r4,#0]            ;1086
00008e  e7e4              B        |L11.90|
                  |L11.144|
000090  200b              MOVS     r0,#0xb               ;1090
000092  2100              MOVS     r1,#0                 ;1090
000094  9105              STR      r1,[sp,#0x14]         ;1090
000096  460a              MOV      r2,r1                 ;1090
000098  e9cd0407          STRD     r0,r4,[sp,#0x1c]      ;1090
00009c  9106              STR      r1,[sp,#0x18]         ;1090
00009e  4819              LDR      r0,|L11.260|
0000a0  6800              LDR      r0,[r0,#0]            ;1090  ; OSCfg_TmrTaskStkSize
0000a2  491b              LDR      r1,|L11.272|
0000a4  6809              LDR      r1,[r1,#0]            ;1090  ; OSCfg_TmrTaskStkLimit
0000a6  4b16              LDR      r3,|L11.256|
0000a8  681b              LDR      r3,[r3,#0]            ;1090  ; OSCfg_TmrTaskStkBasePtr
0000aa  e9cd3101          STRD     r3,r1,[sp,#4]         ;1090
0000ae  e9cd0203          STRD     r0,r2,[sp,#0xc]       ;1090
0000b2  4816              LDR      r0,|L11.268|
0000b4  7800              LDRB     r0,[r0,#0]            ;1090  ; OSCfg_TmrTaskPrio
0000b6  2300              MOVS     r3,#0                 ;1090
0000b8  4a16              LDR      r2,|L11.276|
0000ba  a117              ADR      r1,|L11.280|
0000bc  9000              STR      r0,[sp,#0]            ;1090
0000be  481c              LDR      r0,|L11.304|
0000c0  f7fffffe          BL       OSTaskCreate
0000c4  bf00              NOP      
0000c6  e7c8              B        |L11.90|
;;;1104   
                          ENDP

                  |L11.200|
                          DCD      OSTmrDbgListPtr
                  |L11.204|
                          DCD      OSTmrListPtr
                  |L11.208|
                          DCD      OSTmrListEntries
                  |L11.212|
                          DCD      OSCfg_TmrTaskRate_Hz
                  |L11.216|
                          DCD      OSCfg_TickRate_Hz
                  |L11.220|
                          DCD      OSTmrUpdateCnt
                  |L11.224|
                          DCD      OSTmrUpdateCtr
                  |L11.228|
                          DCD      OSTmrTickCtr
                  |L11.232|
                          DCD      OSTmrTaskTimeMax
                  |L11.236|
0000ec  4f532054          DCB      "OS Tmr Mutex",0
0000f0  6d72204d
0000f4  75746578
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L11.252|
                          DCD      OSTmrMutex
                  |L11.256|
                          DCD      OSCfg_TmrTaskStkBasePtr
                  |L11.260|
                          DCD      OSCfg_TmrTaskStkSize
                  |L11.264|
                          DCD      OSCfg_StkSizeMin
                  |L11.268|
                          DCD      OSCfg_TmrTaskPrio
                  |L11.272|
                          DCD      OSCfg_TmrTaskStkLimit
                  |L11.276|
                          DCD      OS_TmrTask
                  |L11.280|
000118  75432f4f          DCB      "uC/OS-III Timer Task",0
00011c  532d4949
000120  49205469
000124  6d657220
000128  5461736b
00012c  00      
00012d  00                DCB      0
00012e  00                DCB      0
00012f  00                DCB      0
                  |L11.304|
                          DCD      OSTmrTaskTCB

                          AREA ||i.OS_TmrLock||, CODE, READONLY, ALIGN=2

                  OS_TmrLock PROC
;;;1248   
;;;1249   static  void  OS_TmrLock (void)
000000  b50e              PUSH     {r1-r3,lr}
;;;1250   {
;;;1251       OS_ERR  err;
;;;1252   #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;1253       CPU_TS  ts;
;;;1254   
;;;1255   
;;;1256       OSMutexPend(&OSTmrMutex,                                    /* Use a mutex to protect the timers                    */
000002  a802              ADD      r0,sp,#8
000004  ab01              ADD      r3,sp,#4
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  9000              STR      r0,[sp,#0]
00000c  4801              LDR      r0,|L12.20|
00000e  f7fffffe          BL       OSMutexPend
;;;1257                   0u,
;;;1258                   OS_OPT_PEND_BLOCKING,
;;;1259                   &ts,
;;;1260                   &err);
;;;1261   #else
;;;1262       OSSchedLock(&err);                                          /* Lock the scheduler to protect the timers             */
;;;1263   #endif
;;;1264       (void)&err;
;;;1265   }
000012  bd0e              POP      {r1-r3,pc}
;;;1266   
                          ENDP

                  |L12.20|
                          DCD      OSTmrMutex

                          AREA ||i.OS_TmrTask||, CODE, READONLY, ALIGN=2

                  OS_TmrTask PROC
;;;1163   
;;;1164   void  OS_TmrTask (void  *p_arg)
000000  b51c              PUSH     {r2-r4,lr}
;;;1165   {
;;;1166       OS_ERR               err;
;;;1167       OS_TMR_CALLBACK_PTR  p_fnct;
;;;1168       OS_TMR              *p_tmr;
;;;1169       OS_TMR              *p_tmr_next;
;;;1170       CPU_TS               ts;
;;;1171   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1172       CPU_TS               ts_start;
;;;1173       CPU_TS               ts_delta;
;;;1174   #endif
;;;1175   
;;;1176   
;;;1177   
;;;1178       (void)p_arg;                                                /* Not using 'p_arg', prevent compiler warning          */
;;;1179       while (DEF_ON) {
000002  e03f              B        |L13.132|
                  |L13.4|
;;;1180   #if (OS_CFG_DYN_TICK_EN != DEF_ENABLED)
;;;1181           (void)OSTaskSemPend( 0u,                                /* Wait for signal indicating time to update tmrs       */
000004  ab01              ADD      r3,sp,#4
000006  466a              MOV      r2,sp
000008  2100              MOVS     r1,#0
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       OSTaskSemPend
;;;1182                                OS_OPT_PEND_BLOCKING,
;;;1183                               &ts,
;;;1184                               &err);
;;;1185           (void)err;
;;;1186   #else
;;;1187           OSTimeDly(OSTmrUpdateCnt, OS_OPT_TIME_DLY, &err);
;;;1188           (void)err;
;;;1189   #endif
;;;1190   
;;;1191   
;;;1192           OS_TmrLock();
000010  f7fffffe          BL       OS_TmrLock
;;;1193   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1194           ts_start = OS_TS_GET();
000014  f7fffffe          BL       CPU_TS_TmrRd
000018  4606              MOV      r6,r0
;;;1195   #endif
;;;1196           OSTmrTickCtr++;                                         /* Increment the current time                           */
00001a  481b              LDR      r0,|L13.136|
00001c  6800              LDR      r0,[r0,#0]  ; OSTmrTickCtr
00001e  1c40              ADDS     r0,r0,#1
000020  4919              LDR      r1,|L13.136|
000022  6008              STR      r0,[r1,#0]  ; OSTmrTickCtr
;;;1197           p_tmr    = OSTmrListPtr;
000024  4819              LDR      r0,|L13.140|
000026  6804              LDR      r4,[r0,#0]  ; OSTmrListPtr
;;;1198           while (p_tmr != DEF_NULL) {                             /* Update all the timers in the list                    */
000028  e01f              B        |L13.106|
                  |L13.42|
;;;1199               OSSchedLock(&err);
00002a  a801              ADD      r0,sp,#4
00002c  f7fffffe          BL       OSSchedLock
;;;1200               (void)&err;
;;;1201               p_tmr_next = p_tmr->NextPtr;
000030  f8d48010          LDR      r8,[r4,#0x10]
;;;1202               p_tmr->Remain--;
000034  69a0              LDR      r0,[r4,#0x18]
000036  1e40              SUBS     r0,r0,#1
000038  61a0              STR      r0,[r4,#0x18]
;;;1203               if (p_tmr->Remain == 0u) {
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  b980              CBNZ     r0,|L13.96|
;;;1204                   if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
00003e  8ca0              LDRH     r0,[r4,#0x24]
000040  2802              CMP      r0,#2
000042  d102              BNE      |L13.74|
;;;1205                       p_tmr->Remain = p_tmr->Period;              /* Reload the time remaining                            */
000044  6a20              LDR      r0,[r4,#0x20]
000046  61a0              STR      r0,[r4,#0x18]
000048  e005              B        |L13.86|
                  |L13.74|
;;;1206                   } else {
;;;1207                       OS_TmrUnlink(p_tmr);                        /* Remove from list                                     */
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_TmrUnlink
;;;1208                       p_tmr->State = OS_TMR_STATE_COMPLETED;      /* Indicate that the timer has completed                */
000050  2003              MOVS     r0,#3
000052  f8840026          STRB     r0,[r4,#0x26]
                  |L13.86|
;;;1209                   }
;;;1210                   p_fnct = p_tmr->CallbackPtr;                    /* Execute callback function if available               */
000056  68a5              LDR      r5,[r4,#8]
;;;1211                   if (p_fnct != 0u) {
000058  b115              CBZ      r5,|L13.96|
;;;1212                       (*p_fnct)((void *)p_tmr,
00005a  4620              MOV      r0,r4
00005c  68e1              LDR      r1,[r4,#0xc]
00005e  47a8              BLX      r5
                  |L13.96|
;;;1213                                 p_tmr->CallbackPtrArg);
;;;1214                   }
;;;1215               }
;;;1216               p_tmr = p_tmr_next;
000060  4644              MOV      r4,r8
;;;1217               OSSchedUnlock(&err);
000062  a801              ADD      r0,sp,#4
000064  f7fffffe          BL       OSSchedUnlock
;;;1218               (void)&err;
000068  bf00              NOP      
                  |L13.106|
00006a  2c00              CMP      r4,#0                 ;1198
00006c  d1dd              BNE      |L13.42|
;;;1219           }
;;;1220   
;;;1221   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1222           ts_delta = OS_TS_GET() - ts_start;                      /* Measure execution time of timer task                 */
00006e  f7fffffe          BL       CPU_TS_TmrRd
000072  1b87              SUBS     r7,r0,r6
;;;1223           if (OSTmrTaskTimeMax < ts_delta) {
000074  4806              LDR      r0,|L13.144|
000076  6800              LDR      r0,[r0,#0]  ; OSTmrTaskTimeMax
000078  42b8              CMP      r0,r7
00007a  d201              BCS      |L13.128|
;;;1224               OSTmrTaskTimeMax = ts_delta;
00007c  4804              LDR      r0,|L13.144|
00007e  6007              STR      r7,[r0,#0]  ; OSTmrTaskTimeMax
                  |L13.128|
;;;1225           }
;;;1226   #endif
;;;1227   
;;;1228           OS_TmrUnlock();
000080  f7fffffe          BL       OS_TmrUnlock
                  |L13.132|
000084  e7be              B        |L13.4|
;;;1229       }
;;;1230   }
;;;1231   
                          ENDP

000086  0000              DCW      0x0000
                  |L13.136|
                          DCD      OSTmrTickCtr
                  |L13.140|
                          DCD      OSTmrListPtr
                  |L13.144|
                          DCD      OSTmrTaskTimeMax

                          AREA ||i.OS_TmrUnlink||, CODE, READONLY, ALIGN=2

                  OS_TmrUnlink PROC
;;;1120   
;;;1121   void  OS_TmrUnlink (OS_TMR  *p_tmr)
000000  b510              PUSH     {r4,lr}
;;;1122   {
;;;1123       OS_TMR  *p_tmr1;
;;;1124       OS_TMR  *p_tmr2;
;;;1125   
;;;1126   
;;;1127       if (OSTmrListPtr == p_tmr) {                                /* See if timer to remove is at the beginning of list   */
000002  4b0e              LDR      r3,|L14.60|
000004  681b              LDR      r3,[r3,#0]  ; OSTmrListPtr
000006  4283              CMP      r3,r0
000008  d106              BNE      |L14.24|
;;;1128           p_tmr1       = p_tmr->NextPtr;
00000a  6901              LDR      r1,[r0,#0x10]
;;;1129           OSTmrListPtr = p_tmr1;
00000c  4b0b              LDR      r3,|L14.60|
00000e  6019              STR      r1,[r3,#0]  ; OSTmrListPtr
;;;1130           if (p_tmr1 != DEF_NULL) {
000010  b139              CBZ      r1,|L14.34|
;;;1131               p_tmr1->PrevPtr = DEF_NULL;
000012  2300              MOVS     r3,#0
000014  614b              STR      r3,[r1,#0x14]
000016  e004              B        |L14.34|
                  |L14.24|
;;;1132           }
;;;1133       } else {
;;;1134           p_tmr1          = p_tmr->PrevPtr;                       /* Remove timer from somewhere in the list              */
000018  6941              LDR      r1,[r0,#0x14]
;;;1135           p_tmr2          = p_tmr->NextPtr;
00001a  6902              LDR      r2,[r0,#0x10]
;;;1136           p_tmr1->NextPtr = p_tmr2;
00001c  610a              STR      r2,[r1,#0x10]
;;;1137           if (p_tmr2 != DEF_NULL) {
00001e  b102              CBZ      r2,|L14.34|
;;;1138               p_tmr2->PrevPtr = p_tmr1;
000020  6151              STR      r1,[r2,#0x14]
                  |L14.34|
;;;1139           }
;;;1140       }
;;;1141       p_tmr->State   = OS_TMR_STATE_STOPPED;
000022  2301              MOVS     r3,#1
000024  f8803026          STRB     r3,[r0,#0x26]
;;;1142       p_tmr->NextPtr = DEF_NULL;
000028  2300              MOVS     r3,#0
00002a  6103              STR      r3,[r0,#0x10]
;;;1143       p_tmr->PrevPtr = DEF_NULL;
00002c  6143              STR      r3,[r0,#0x14]
;;;1144   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;1145       OSTmrListEntries--;
00002e  4b04              LDR      r3,|L14.64|
000030  881b              LDRH     r3,[r3,#0]  ; OSTmrListEntries
000032  1e5b              SUBS     r3,r3,#1
000034  4c02              LDR      r4,|L14.64|
000036  8023              STRH     r3,[r4,#0]
;;;1146   #endif
;;;1147   }
000038  bd10              POP      {r4,pc}
;;;1148   
                          ENDP

00003a  0000              DCW      0x0000
                  |L14.60|
                          DCD      OSTmrListPtr
                  |L14.64|
                          DCD      OSTmrListEntries

                          AREA ||i.OS_TmrUnlock||, CODE, READONLY, ALIGN=2

                  OS_TmrUnlock PROC
;;;1269   
;;;1270   static  void  OS_TmrUnlock (void)
000000  b508              PUSH     {r3,lr}
;;;1271   {
;;;1272       OS_ERR  err;
;;;1273   
;;;1274   
;;;1275   #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;1276       OSMutexPost(&OSTmrMutex,                                    /* Use a mutex to protect the timers                    */
000002  466a              MOV      r2,sp
000004  2100              MOVS     r1,#0
000006  4802              LDR      r0,|L15.16|
000008  f7fffffe          BL       OSMutexPost
;;;1277                   OS_OPT_POST_NONE,
;;;1278                   &err);
;;;1279   #else
;;;1280       OSSchedUnlock(&err);                                        /* Lock the scheduler to protect the timers             */
;;;1281   #endif
;;;1282       (void)&err;
;;;1283   }
00000c  bd08              POP      {r3,pc}
;;;1284   
                          ENDP

00000e  0000              DCW      0x0000
                  |L15.16|
                          DCD      OSTmrMutex
