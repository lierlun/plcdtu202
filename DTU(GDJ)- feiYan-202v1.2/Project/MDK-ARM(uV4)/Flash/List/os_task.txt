; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\os_task.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\os_task.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\os_task.crf ..\..\uCOS-III\uCOS-III\Source\os_task.c]
                          THUMB

                          AREA ||i.OSTaskCreate||, CODE, READONLY, ALIGN=2

                  OSTaskCreate PROC
;;;239    
;;;240    void  OSTaskCreate (OS_TCB        *p_tcb,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;241                        CPU_CHAR      *p_name,
;;;242                        OS_TASK_PTR    p_task,
;;;243                        void          *p_arg,
;;;244                        OS_PRIO        prio,
;;;245                        CPU_STK       *p_stk_base,
;;;246                        CPU_STK_SIZE   stk_limit,
;;;247                        CPU_STK_SIZE   stk_size,
;;;248                        OS_MSG_QTY     q_size,
;;;249                        OS_TICK        time_quanta,
;;;250                        void          *p_ext,
;;;251                        OS_OPT         opt,
;;;252                        OS_ERR        *p_err)
;;;253    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4692              MOV      r10,r2
00000a  e9ddb512          LDRD     r11,r5,[sp,#0x48]
00000e  e9dd6819          LDRD     r6,r8,[sp,#0x64]
;;;254        CPU_STK_SIZE   i;
;;;255    #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
;;;256        OS_REG_ID      reg_nbr;
;;;257    #endif
;;;258    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;259        OS_TLS_ID      id;
;;;260    #endif
;;;261    
;;;262        CPU_STK       *p_sp;
;;;263        CPU_STK       *p_stk_limit;
;;;264        CPU_SR_ALLOC();
000012  2000              MOVS     r0,#0
000014  9002              STR      r0,[sp,#8]
;;;265    
;;;266    
;;;267    
;;;268    #ifdef OS_SAFETY_CRITICAL
;;;269        if (p_err == DEF_NULL) {
;;;270            OS_SAFETY_CRITICAL_EXCEPTION();
;;;271            return;
;;;272        }
;;;273    #endif
;;;274    
;;;275    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;276        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;277           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;278            return;
;;;279        }
;;;280    #endif
;;;281    
;;;282    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;283        if (OSIntNestingCtr > 0u) {                                 /* --------- CANNOT CREATE A TASK FROM AN ISR --------- */
000016  4852              LDR      r0,|L1.352|
000018  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00001a  b130              CBZ      r0,|L1.42|
;;;284    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;285            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                     /* Record the event.                                    */
;;;286    #endif
;;;287           *p_err = OS_ERR_TASK_CREATE_ISR;
00001c  f247104a          MOV      r0,#0x714a
000020  f8a80000          STRH     r0,[r8,#0]
                  |L1.36|
;;;288            return;
;;;289        }
;;;290    #endif
;;;291    
;;;292    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* ---------------- VALIDATE ARGUMENTS ---------------- */
;;;293        if (p_tcb == DEF_NULL) {                                    /* User must supply a valid OS_TCB                      */
;;;294    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;295            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                     /* Record the event.                                    */
;;;296    #endif
;;;297           *p_err = OS_ERR_TCB_INVALID;
;;;298            return;
;;;299        }
;;;300        if (p_task == 0u) {                                         /* User must supply a valid task                        */
;;;301    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;302            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                     /* Record the event.                                    */
;;;303    #endif
;;;304           *p_err = OS_ERR_TASK_INVALID;
;;;305            return;
;;;306        }
;;;307        if (p_stk_base == DEF_NULL) {                               /* User must supply a valid stack base address          */
;;;308    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;309            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                     /* Record the event.                                    */
;;;310    #endif
;;;311           *p_err = OS_ERR_STK_INVALID;
;;;312            return;
;;;313        }
;;;314        if (stk_size < OSCfg_StkSizeMin) {                          /* User must supply a valid minimum stack size          */
;;;315    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;316            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                     /* Record the event.                                    */
;;;317    #endif
;;;318           *p_err = OS_ERR_STK_SIZE_INVALID;
;;;319            return;
;;;320        }
;;;321        if (stk_limit >= stk_size) {                                /* User must supply a valid stack limit                 */
;;;322    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;323            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                     /* Record the event.                                    */
;;;324    #endif
;;;325           *p_err = OS_ERR_STK_LIMIT_INVALID;
;;;326            return;
;;;327        }
;;;328        if (prio >= OS_CFG_PRIO_MAX) {                              /* Priority must be within 0 and OS_CFG_PRIO_MAX-1      */
;;;329    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;330            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                     /* Record the event.                                    */
;;;331    #endif
;;;332           *p_err = OS_ERR_PRIO_INVALID;
;;;333            return;
;;;334        }
;;;335    #endif
;;;336    
;;;337    #if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
;;;338        if (prio == 0u) {
;;;339            if (p_tcb != &OSIntQTaskTCB) {
;;;340    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;341                TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                    */
;;;342    #endif
;;;343               *p_err = OS_ERR_PRIO_INVALID;                        /* Not allowed to use priority 0                        */
;;;344                return;
;;;345            }
;;;346        }
;;;347    #endif
;;;348    
;;;349        if (prio == (OS_CFG_PRIO_MAX - 1u)) {
;;;350    #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
;;;351            if (p_tcb != &OSIdleTaskTCB) {
;;;352    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;353                TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                    */
;;;354    #endif
;;;355               *p_err = OS_ERR_PRIO_INVALID;                        /* Not allowed to use same priority as idle task        */
;;;356                return;
;;;357            }
;;;358    #else
;;;359    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;360            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                     /* Record the event.                                    */
;;;361    #endif
;;;362           *p_err = OS_ERR_PRIO_INVALID;                            /* Not allowed to use same priority as idle task        */
;;;363            return;
;;;364    #endif
;;;365        }
;;;366    
;;;367        OS_TaskInitTCB(p_tcb);                                      /* Initialize the TCB to default values                 */
;;;368    
;;;369       *p_err = OS_ERR_NONE;
;;;370                                                                    /* -------------- CLEAR THE TASK'S STACK -------------- */
;;;371        if (((opt & OS_OPT_TASK_STK_CHK) != 0u) ||                  /* See if stack checking has been enabled               */
;;;372            ((opt & OS_OPT_TASK_STK_CLR) != 0u)) {                  /* See if stack needs to be cleared                     */
;;;373            if ((opt & OS_OPT_TASK_STK_CLR) != 0u) {
;;;374                p_sp = p_stk_base;
;;;375                for (i = 0u; i < stk_size; i++) {                   /* Stack grows from HIGH to LOW memory                  */
;;;376                   *p_sp = 0u;                                      /* Clear from bottom of stack and up!                   */
;;;377                    p_sp++;
;;;378                }
;;;379            }
;;;380        }
;;;381                                                                    /* ------ INITIALIZE THE STACK FRAME OF THE TASK ------ */
;;;382    #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
;;;383        p_stk_limit = p_stk_base + stk_limit;
;;;384    #else
;;;385        p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
;;;386    #endif
;;;387    
;;;388        p_sp = OSTaskStkInit(p_task,
;;;389                             p_arg,
;;;390                             p_stk_base,
;;;391                             p_stk_limit,
;;;392                             stk_size,
;;;393                             opt);
;;;394    
;;;395    #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)             /* Check if we overflown the stack during init          */
;;;396        if (p_sp < p_stk_base) {
;;;397           *p_err = OS_ERR_STAT_STK_SIZE_INVALID;
;;;398            return;
;;;399        }
;;;400    #else
;;;401        if (p_sp > p_stk_base + stk_size) {
;;;402           *p_err = OS_ERR_STAT_STK_SIZE_INVALID;
;;;403            return;
;;;404        }
;;;405    #endif
;;;406    
;;;407    #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)                 /* Initialize Redzoned stack                            */
;;;408        OS_TaskStkRedzoneInit(p_stk_base, stk_size);
;;;409    #endif
;;;410    
;;;411                                                                    /* ------------ INITIALIZE THE TCB FIELDS ------------- */
;;;412    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;413        p_tcb->TaskEntryAddr = p_task;                              /* Save task entry point address                        */
;;;414        p_tcb->TaskEntryArg  = p_arg;                               /* Save task entry argument                             */
;;;415    #endif
;;;416    
;;;417    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;418        p_tcb->NamePtr       = p_name;                              /* Save task name                                       */
;;;419    #else
;;;420        (void)&p_name;
;;;421    #endif
;;;422    
;;;423        p_tcb->Prio          = prio;                                /* Save the task's priority                             */
;;;424    
;;;425    #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;426        p_tcb->BasePrio      = prio;                                /* Set the base priority                                */
;;;427    #endif
;;;428    
;;;429        p_tcb->StkPtr        = p_sp;                                /* Save the new top-of-stack pointer                    */
;;;430    #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
;;;431        p_tcb->StkLimitPtr   = p_stk_limit;                         /* Save the stack limit pointer                         */
;;;432    #endif
;;;433    
;;;434    #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
;;;435        p_tcb->TimeQuanta    = time_quanta;                         /* Save the #ticks for time slice (0 means not sliced)  */
;;;436        if (time_quanta == 0u) {
;;;437            p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
;;;438        } else {
;;;439            p_tcb->TimeQuantaCtr = time_quanta;
;;;440        }
;;;441    #else
;;;442        (void)&time_quanta;
;;;443    #endif
;;;444    
;;;445        p_tcb->ExtPtr        = p_ext;                               /* Save pointer to TCB extension                        */
;;;446    #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED) || (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED))
;;;447        p_tcb->StkBasePtr    = p_stk_base;                          /* Save pointer to the base address of the stack        */
;;;448        p_tcb->StkSize       = stk_size;                            /* Save the stack size (in number of CPU_STK elements)  */
;;;449    #endif
;;;450        p_tcb->Opt           = opt;                                 /* Save task options                                    */
;;;451    
;;;452    #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
;;;453        for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
;;;454            p_tcb->RegTbl[reg_nbr] = 0u;
;;;455        }
;;;456    #endif
;;;457    
;;;458    #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
;;;459        OS_MsgQInit(&p_tcb->MsgQ,                                   /* Initialize the task's message queue                  */
;;;460                    q_size);
;;;461    #else
;;;462        (void)&q_size;
;;;463    #endif
;;;464    
;;;465        OSTaskCreateHook(p_tcb);                                    /* Call user defined hook                               */
;;;466    
;;;467    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;468        TRACE_OS_TASK_CREATE(p_tcb);                                /* Record the event.                                    */
;;;469        TRACE_OS_TASK_SEM_CREATE(p_tcb, p_name);                    /* Record the event.                                    */
;;;470    #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
;;;471        TRACE_OS_TASK_MSG_Q_CREATE(&p_tcb->MsgQ, p_name);           /* Record the event.                                    */
;;;472    #endif
;;;473    #endif
;;;474    
;;;475    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;476        for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
;;;477            p_tcb->TLS_Tbl[id] = 0u;
;;;478        }
;;;479        OS_TLS_TaskCreate(p_tcb);                                   /* Call TLS hook                                        */
;;;480    #endif
;;;481                                                                    /* -------------- ADD TASK TO READY LIST -------------- */
;;;482        OS_CRITICAL_ENTER();
;;;483        OS_PrioInsert(p_tcb->Prio);
;;;484        OS_RdyListInsertTail(p_tcb);
;;;485    
;;;486    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;487        OS_TaskDbgListAdd(p_tcb);
;;;488    #endif
;;;489    
;;;490        OSTaskQty++;                                                /* Increment the #tasks counter                         */
;;;491    
;;;492        if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Return if multitasking has not started               */
;;;493            OS_CRITICAL_EXIT();
;;;494            return;
;;;495        }
;;;496    
;;;497        OS_CRITICAL_EXIT_NO_SCHED();
;;;498    
;;;499        OSSched();
;;;500    }
000024  b009              ADD      sp,sp,#0x24
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.42|
00002a  f1bb0f1f          CMP      r11,#0x1f             ;349
00002e  d107              BNE      |L1.64|
000030  484c              LDR      r0,|L1.356|
000032  4284              CMP      r4,r0                 ;351
000034  d004              BEQ      |L1.64|
000036  f2462073          MOV      r0,#0x6273            ;355
00003a  f8a80000          STRH     r0,[r8,#0]            ;355
00003e  e7f1              B        |L1.36|
                  |L1.64|
000040  4620              MOV      r0,r4                 ;367
000042  f7fffffe          BL       OS_TaskInitTCB
000046  2000              MOVS     r0,#0                 ;369
000048  f8a80000          STRH     r0,[r8,#0]            ;369
00004c  f0160f01          TST      r6,#1                 ;371
000050  d102              BNE      |L1.88|
000052  f0160f02          TST      r6,#2                 ;372
000056  d010              BEQ      |L1.122|
                  |L1.88|
000058  f0160f02          TST      r6,#2                 ;373
00005c  d00d              BEQ      |L1.122|
00005e  462f              MOV      r7,r5                 ;374
000060  2000              MOVS     r0,#0                 ;375
000062  9004              STR      r0,[sp,#0x10]         ;375
000064  e005              B        |L1.114|
                  |L1.102|
000066  2000              MOVS     r0,#0                 ;376
000068  6038              STR      r0,[r7,#0]            ;376
00006a  1d3f              ADDS     r7,r7,#4              ;377
00006c  9804              LDR      r0,[sp,#0x10]         ;375
00006e  1c40              ADDS     r0,r0,#1              ;375
000070  9004              STR      r0,[sp,#0x10]         ;375
                  |L1.114|
000072  9915              LDR      r1,[sp,#0x54]         ;375
000074  9804              LDR      r0,[sp,#0x10]         ;375
000076  4288              CMP      r0,r1                 ;375
000078  d3f5              BCC      |L1.102|
                  |L1.122|
00007a  9814              LDR      r0,[sp,#0x50]         ;383
00007c  eb050080          ADD      r0,r5,r0,LSL #2       ;383
000080  9003              STR      r0,[sp,#0xc]          ;383
000082  9815              LDR      r0,[sp,#0x54]         ;388
000084  e9cd0600          STRD     r0,r6,[sp,#0]         ;388
000088  462a              MOV      r2,r5                 ;388
00008a  4650              MOV      r0,r10                ;388
00008c  9b03              LDR      r3,[sp,#0xc]          ;388
00008e  9908              LDR      r1,[sp,#0x20]         ;388
000090  f7fffffe          BL       OSTaskStkInit
000094  4607              MOV      r7,r0                 ;388
000096  42af              CMP      r7,r5                 ;396
000098  d204              BCS      |L1.164|
00009a  f646602c          MOV      r0,#0x6e2c            ;397
00009e  f8a80000          STRH     r0,[r8,#0]            ;397
0000a2  e7bf              B        |L1.36|
                  |L1.164|
0000a4  f8c4a028          STR      r10,[r4,#0x28]        ;413
0000a8  9808              LDR      r0,[sp,#0x20]         ;414
0000aa  62e0              STR      r0,[r4,#0x2c]         ;414
0000ac  9806              LDR      r0,[sp,#0x18]         ;418
0000ae  60a0              STR      r0,[r4,#8]            ;418
0000b0  f884b037          STRB     r11,[r4,#0x37]        ;423
0000b4  f884b038          STRB     r11,[r4,#0x38]        ;426
0000b8  6027              STR      r7,[r4,#0]            ;429
0000ba  9803              LDR      r0,[sp,#0xc]          ;431
0000bc  60e0              STR      r0,[r4,#0xc]          ;431
0000be  9818              LDR      r0,[sp,#0x60]         ;445
0000c0  6060              STR      r0,[r4,#4]            ;445
0000c2  6265              STR      r5,[r4,#0x24]         ;447
0000c4  9815              LDR      r0,[sp,#0x54]         ;448
0000c6  6420              STR      r0,[r4,#0x40]         ;448
0000c8  f8a46044          STRH     r6,[r4,#0x44]         ;450
0000cc  f04f0900          MOV      r9,#0                 ;453
0000d0  e008              B        |L1.228|
                  |L1.210|
0000d2  2100              MOVS     r1,#0                 ;454
0000d4  f1040078          ADD      r0,r4,#0x78           ;454
0000d8  f8401029          STR      r1,[r0,r9,LSL #2]     ;454
0000dc  f1090001          ADD      r0,r9,#1              ;453
0000e0  f00009ff          AND      r9,r0,#0xff           ;453
                  |L1.228|
0000e4  f1b90f00          CMP      r9,#0                 ;453
0000e8  d0f3              BEQ      |L1.210|
0000ea  f1040060          ADD      r0,r4,#0x60           ;459
0000ee  9916              LDR      r1,[sp,#0x58]         ;459
0000f0  f7fffffe          BL       OS_MsgQInit
0000f4  4620              MOV      r0,r4                 ;465
0000f6  f7fffffe          BL       OSTaskCreateHook
0000fa  bf00              NOP                            ;482
0000fc  bf00              NOP                            ;482
0000fe  f7fffffe          BL       CPU_SR_Save
000102  9002              STR      r0,[sp,#8]            ;482
000104  bf00              NOP                            ;482
000106  f7fffffe          BL       CPU_IntDisMeasStart
00010a  bf00              NOP                            ;482
00010c  f8940037          LDRB     r0,[r4,#0x37]         ;483
000110  f7fffffe          BL       OS_PrioInsert
000114  4620              MOV      r0,r4                 ;484
000116  f7fffffe          BL       OS_RdyListInsertTail
00011a  4620              MOV      r0,r4                 ;487
00011c  f7fffffe          BL       OS_TaskDbgListAdd
000120  4811              LDR      r0,|L1.360|
000122  8800              LDRH     r0,[r0,#0]            ;490  ; OSTaskQty
000124  1c40              ADDS     r0,r0,#1              ;490
000126  4910              LDR      r1,|L1.360|
000128  8008              STRH     r0,[r1,#0]            ;490
00012a  4810              LDR      r0,|L1.364|
00012c  7800              LDRB     r0,[r0,#0]            ;492  ; OSRunning
00012e  2801              CMP      r0,#1                 ;492
000130  d009              BEQ      |L1.326|
000132  bf00              NOP                            ;493
000134  f7fffffe          BL       CPU_IntDisMeasStop
000138  bf00              NOP                            ;493
00013a  9802              LDR      r0,[sp,#8]            ;493
00013c  f7fffffe          BL       CPU_SR_Restore
000140  bf00              NOP                            ;493
000142  bf00              NOP                            ;493
000144  e76e              B        |L1.36|
                  |L1.326|
000146  bf00              NOP                            ;497
000148  f7fffffe          BL       CPU_IntDisMeasStop
00014c  bf00              NOP                            ;497
00014e  9802              LDR      r0,[sp,#8]            ;497
000150  f7fffffe          BL       CPU_SR_Restore
000154  bf00              NOP                            ;497
000156  bf00              NOP                            ;497
000158  f7fffffe          BL       OSSched
00015c  bf00              NOP      
00015e  e761              B        |L1.36|
;;;501    
                          ENDP

                  |L1.352|
                          DCD      OSIntNestingCtr
                  |L1.356|
                          DCD      OSIdleTaskTCB
                  |L1.360|
                          DCD      OSTaskQty
                  |L1.364|
                          DCD      OSRunning

                          AREA ||i.OSTaskQFlush||, CODE, READONLY, ALIGN=2

                  OSTaskQFlush PROC
;;;728    #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
;;;729    OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;730                              OS_ERR  *p_err)
;;;731    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;732        OS_MSG_QTY  entries;
;;;733        CPU_SR_ALLOC();
000008  2600              MOVS     r6,#0
;;;734    
;;;735    
;;;736    
;;;737    #ifdef OS_SAFETY_CRITICAL
;;;738        if (p_err == DEF_NULL) {
;;;739            OS_SAFETY_CRITICAL_EXCEPTION();
;;;740            return (0u);
;;;741        }
;;;742    #endif
;;;743    
;;;744    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;745        if (OSIntNestingCtr > 0u) {                                 /* Can't flush a message queue from an ISR              */
00000a  481c              LDR      r0,|L2.124|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b128              CBZ      r0,|L2.28|
;;;746           *p_err = OS_ERR_FLUSH_ISR;
000010  f44f506c          MOV      r0,#0x3b00
000014  8028              STRH     r0,[r5,#0]
;;;747            return (0u);
000016  2000              MOVS     r0,#0
                  |L2.24|
;;;748        }
;;;749    #endif
;;;750    
;;;751    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;752        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;753           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;754            return (0u);
;;;755        }
;;;756    #endif
;;;757    
;;;758        if (p_tcb == DEF_NULL) {                                    /* Flush message queue of calling task?                 */
;;;759            CPU_CRITICAL_ENTER();
;;;760            p_tcb = OSTCBCurPtr;
;;;761            CPU_CRITICAL_EXIT();
;;;762        }
;;;763    
;;;764        OS_CRITICAL_ENTER();
;;;765        entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Return all OS_MSGs to the OS_MSG pool                */
;;;766        OS_CRITICAL_EXIT();
;;;767       *p_err   = OS_ERR_NONE;
;;;768        return (entries);
;;;769    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L2.28|
00001c  b99c              CBNZ     r4,|L2.70|
00001e  bf00              NOP                            ;759
000020  bf00              NOP                            ;759
000022  f7fffffe          BL       CPU_SR_Save
000026  4606              MOV      r6,r0                 ;759
000028  bf00              NOP                            ;759
00002a  f7fffffe          BL       CPU_IntDisMeasStart
00002e  bf00              NOP                            ;759
000030  4813              LDR      r0,|L2.128|
000032  6804              LDR      r4,[r0,#0]            ;760  ; OSTCBCurPtr
000034  bf00              NOP                            ;761
000036  f7fffffe          BL       CPU_IntDisMeasStop
00003a  bf00              NOP                            ;761
00003c  4630              MOV      r0,r6                 ;761
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP                            ;761
000044  bf00              NOP                            ;761
                  |L2.70|
000046  bf00              NOP                            ;764
000048  bf00              NOP                            ;764
00004a  f7fffffe          BL       CPU_SR_Save
00004e  4606              MOV      r6,r0                 ;764
000050  bf00              NOP                            ;764
000052  f7fffffe          BL       CPU_IntDisMeasStart
000056  bf00              NOP                            ;764
000058  f1040060          ADD      r0,r4,#0x60           ;765
00005c  f7fffffe          BL       OS_MsgQFreeAll
000060  4607              MOV      r7,r0                 ;765
000062  bf00              NOP                            ;766
000064  f7fffffe          BL       CPU_IntDisMeasStop
000068  bf00              NOP                            ;766
00006a  4630              MOV      r0,r6                 ;766
00006c  f7fffffe          BL       CPU_SR_Restore
000070  bf00              NOP                            ;766
000072  bf00              NOP                            ;766
000074  2000              MOVS     r0,#0                 ;767
000076  8028              STRH     r0,[r5,#0]            ;767
000078  4638              MOV      r0,r7                 ;768
00007a  e7cd              B        |L2.24|
;;;770    #endif
                          ENDP

                  |L2.124|
                          DCD      OSIntNestingCtr
                  |L2.128|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskQPend||, CODE, READONLY, ALIGN=2

                  OSTaskQPend PROC
;;;815    #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
;;;816    void  *OSTaskQPend (OS_TICK       timeout,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;817                        OS_OPT        opt,
;;;818                        OS_MSG_SIZE  *p_msg_size,
;;;819                        CPU_TS       *p_ts,
;;;820                        OS_ERR       *p_err)
;;;821    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;822        OS_MSG_Q     *p_msg_q;
;;;823        void         *p_void;
;;;824        CPU_SR_ALLOC();
00000e  f04f0b00          MOV      r11,#0
;;;825    
;;;826    
;;;827    #ifdef OS_SAFETY_CRITICAL
;;;828        if (p_err == DEF_NULL) {
;;;829            OS_SAFETY_CRITICAL_EXCEPTION();
;;;830            return (DEF_NULL);
;;;831        }
;;;832    #endif
;;;833    
;;;834    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;835        if (OSIntNestingCtr > 0u) {                                 /* Can't Pend from an ISR                               */
000012  486a              LDR      r0,|L3.444|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000016  b128              CBZ      r0,|L3.36|
;;;836           *p_err = OS_ERR_PEND_ISR;
000018  f24610ae          MOV      r0,#0x61ae
00001c  8028              STRH     r0,[r5,#0]
;;;837            return (DEF_NULL);
00001e  2000              MOVS     r0,#0
                  |L3.32|
;;;838        }
;;;839    #endif
;;;840    
;;;841    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;842        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;843           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;844            return (DEF_NULL);
;;;845        }
;;;846    #endif
;;;847    
;;;848    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* ---------------- VALIDATE ARGUMENTS ---------------- */
;;;849        if (p_msg_size == DEF_NULL) {                               /* User must supply a valid destination for msg size    */
;;;850           *p_err = OS_ERR_PTR_INVALID;
;;;851            return (DEF_NULL);
;;;852        }
;;;853        switch (opt) {                                              /* User must supply a valid option                      */
;;;854            case OS_OPT_PEND_BLOCKING:
;;;855            case OS_OPT_PEND_NON_BLOCKING:
;;;856                 break;
;;;857    
;;;858            default:
;;;859                *p_err = OS_ERR_OPT_INVALID;
;;;860                 return (DEF_NULL);
;;;861        }
;;;862    #endif
;;;863    
;;;864        if (p_ts != DEF_NULL) {
;;;865           *p_ts = 0u;                                              /* Initialize the returned timestamp                    */
;;;866        }
;;;867    
;;;868        CPU_CRITICAL_ENTER();
;;;869        p_msg_q = &OSTCBCurPtr->MsgQ;                               /* Any message waiting in the message queue?            */
;;;870        p_void  = OS_MsgQGet(p_msg_q,
;;;871                             p_msg_size,
;;;872                             p_ts,
;;;873                             p_err);
;;;874        if (*p_err == OS_ERR_NONE) {
;;;875    #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
;;;876    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;877            if (p_ts != DEF_NULL) {
;;;878                OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
;;;879                if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
;;;880                    OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
;;;881                }
;;;882            }
;;;883    #endif
;;;884    #endif
;;;885            CPU_CRITICAL_EXIT();
;;;886    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;887            TRACE_OS_TASK_MSG_Q_PEND(p_msg_q);                      /* Record the event.                                    */
;;;888    #endif
;;;889            return (p_void);                                        /* Yes, Return oldest message received                  */
;;;890        }
;;;891    
;;;892        if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
;;;893           *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
;;;894            CPU_CRITICAL_EXIT();
;;;895    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;896            TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);               /* Record the event.                                    */
;;;897    #endif
;;;898            return (DEF_NULL);
;;;899        } else {                                                    /* Yes                                                  */
;;;900            if (OSSchedLockNestingCtr > 0u) {                       /* Can't block when the scheduler is locked             */
;;;901                CPU_CRITICAL_EXIT();
;;;902    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;903                TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);           /* Record the event.                                    */
;;;904    #endif
;;;905               *p_err = OS_ERR_SCHED_LOCKED;
;;;906                return (DEF_NULL);
;;;907            }
;;;908        }
;;;909                                                                    /* Lock the scheduler/re-enable interrupts              */
;;;910        OS_CRITICAL_ENTER_CPU_EXIT();
;;;911        OS_Pend(DEF_NULL,                                           /* Block task pending on Message                        */
;;;912                DEF_NULL,
;;;913                OS_TASK_PEND_ON_TASK_Q,
;;;914                timeout);
;;;915        OS_CRITICAL_EXIT_NO_SCHED();
;;;916    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;917        TRACE_OS_TASK_MSG_Q_PEND_BLOCK(p_msg_q);                    /* Record the event.                                    */
;;;918    #endif
;;;919        OSSched();                                                  /* Find the next highest priority task ready to run     */
;;;920    
;;;921        CPU_CRITICAL_ENTER();
;;;922        switch (OSTCBCurPtr->PendStatus) {
;;;923            case OS_STATUS_PEND_OK:                                 /* Extract message from TCB (Put there by Post)         */
;;;924                 p_void      = OSTCBCurPtr->MsgPtr;
;;;925                *p_msg_size  = OSTCBCurPtr->MsgSize;
;;;926    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;927                 if (p_ts != DEF_NULL) {
;;;928                    *p_ts = OSTCBCurPtr->TS;
;;;929    #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
;;;930                    OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;931                    if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
;;;932                        OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
;;;933                    }
;;;934    #endif
;;;935                 }
;;;936    #endif
;;;937    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;938                 TRACE_OS_TASK_MSG_Q_PEND(p_msg_q);                 /* Record the event.                                    */
;;;939    #endif
;;;940                *p_err = OS_ERR_NONE;
;;;941                 break;
;;;942    
;;;943            case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
;;;944                 p_void     = DEF_NULL;
;;;945                *p_msg_size = 0u;
;;;946                 if (p_ts != DEF_NULL) {
;;;947                    *p_ts = 0u;
;;;948                 }
;;;949    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;950                 TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);          /* Record the event.                                    */
;;;951    #endif
;;;952                *p_err      =  OS_ERR_PEND_ABORT;
;;;953                 break;
;;;954    
;;;955            case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get event within TO          */
;;;956            default:
;;;957                 p_void     = DEF_NULL;
;;;958                *p_msg_size = 0u;
;;;959    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;960                 if (p_ts  != DEF_NULL) {
;;;961                    *p_ts = OSTCBCurPtr->TS;
;;;962                 }
;;;963    #endif
;;;964    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;965                 TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);          /* Record the event.                                    */
;;;966    #endif
;;;967                *p_err      =  OS_ERR_TIMEOUT;
;;;968                 break;
;;;969        }
;;;970        CPU_CRITICAL_EXIT();
;;;971        return (p_void);                                            /* Return received message                              */
;;;972    }
000020  e8bd9ff0          POP      {r4-r12,pc}
                  |L3.36|
000024  b10c              CBZ      r4,|L3.42|
000026  2000              MOVS     r0,#0                 ;865
000028  6020              STR      r0,[r4,#0]            ;865
                  |L3.42|
00002a  bf00              NOP                            ;868
00002c  bf00              NOP                            ;868
00002e  f7fffffe          BL       CPU_SR_Save
000032  4683              MOV      r11,r0                ;868
000034  bf00              NOP                            ;868
000036  f7fffffe          BL       CPU_IntDisMeasStart
00003a  bf00              NOP                            ;868
00003c  4860              LDR      r0,|L3.448|
00003e  6800              LDR      r0,[r0,#0]            ;869  ; OSTCBCurPtr
000040  f1000960          ADD      r9,r0,#0x60           ;869
000044  462b              MOV      r3,r5                 ;870
000046  4622              MOV      r2,r4                 ;870
000048  4631              MOV      r1,r6                 ;870
00004a  4648              MOV      r0,r9                 ;870
00004c  f7fffffe          BL       OS_MsgQGet
000050  4682              MOV      r10,r0                ;870
000052  8828              LDRH     r0,[r5,#0]            ;874
000054  bb00              CBNZ     r0,|L3.152|
000056  b1a4              CBZ      r4,|L3.130|
000058  f7fffffe          BL       CPU_TS_TmrRd
00005c  6821              LDR      r1,[r4,#0]            ;878
00005e  1a40              SUBS     r0,r0,r1              ;878
000060  4957              LDR      r1,|L3.448|
000062  6809              LDR      r1,[r1,#0]            ;878  ; OSTCBCurPtr
000064  6708              STR      r0,[r1,#0x70]         ;878
000066  4856              LDR      r0,|L3.448|
000068  6800              LDR      r0,[r0,#0]            ;879  ; OSTCBCurPtr
00006a  6f40              LDR      r0,[r0,#0x74]         ;879
00006c  4954              LDR      r1,|L3.448|
00006e  6809              LDR      r1,[r1,#0]            ;879  ; OSTCBCurPtr
000070  6f09              LDR      r1,[r1,#0x70]         ;879
000072  4288              CMP      r0,r1                 ;879
000074  d205              BCS      |L3.130|
000076  4852              LDR      r0,|L3.448|
000078  6800              LDR      r0,[r0,#0]            ;880  ; OSTCBCurPtr
00007a  6f00              LDR      r0,[r0,#0x70]         ;880
00007c  4950              LDR      r1,|L3.448|
00007e  6809              LDR      r1,[r1,#0]            ;880  ; OSTCBCurPtr
000080  6748              STR      r0,[r1,#0x74]         ;880
                  |L3.130|
000082  bf00              NOP                            ;885
000084  f7fffffe          BL       CPU_IntDisMeasStop
000088  bf00              NOP                            ;885
00008a  4658              MOV      r0,r11                ;885
00008c  f7fffffe          BL       CPU_SR_Restore
000090  bf00              NOP                            ;885
000092  bf00              NOP                            ;885
000094  4650              MOV      r0,r10                ;889
000096  e7c3              B        |L3.32|
                  |L3.152|
000098  f4184f00          TST      r8,#0x8000            ;892
00009c  d00d              BEQ      |L3.186|
00009e  f24610b0          MOV      r0,#0x61b0            ;893
0000a2  8028              STRH     r0,[r5,#0]            ;893
0000a4  bf00              NOP                            ;894
0000a6  f7fffffe          BL       CPU_IntDisMeasStop
0000aa  bf00              NOP                            ;894
0000ac  4658              MOV      r0,r11                ;894
0000ae  f7fffffe          BL       CPU_SR_Restore
0000b2  bf00              NOP                            ;894
0000b4  bf00              NOP                            ;894
0000b6  2000              MOVS     r0,#0                 ;898
0000b8  e7b2              B        |L3.32|
                  |L3.186|
0000ba  4842              LDR      r0,|L3.452|
0000bc  7800              LDRB     r0,[r0,#0]            ;900  ; OSSchedLockNestingCtr
0000be  b168              CBZ      r0,|L3.220|
0000c0  bf00              NOP                            ;901
0000c2  f7fffffe          BL       CPU_IntDisMeasStop
0000c6  bf00              NOP                            ;901
0000c8  4658              MOV      r0,r11                ;901
0000ca  f7fffffe          BL       CPU_SR_Restore
0000ce  bf00              NOP                            ;901
0000d0  bf00              NOP                            ;901
0000d2  f6465063          MOV      r0,#0x6d63            ;905
0000d6  8028              STRH     r0,[r5,#0]            ;905
0000d8  2000              MOVS     r0,#0                 ;906
0000da  e7a1              B        |L3.32|
                  |L3.220|
0000dc  463b              MOV      r3,r7                 ;911
0000de  2202              MOVS     r2,#2                 ;911
0000e0  2100              MOVS     r1,#0                 ;911
0000e2  4608              MOV      r0,r1                 ;911
0000e4  f7fffffe          BL       OS_Pend
0000e8  bf00              NOP                            ;915
0000ea  f7fffffe          BL       CPU_IntDisMeasStop
0000ee  bf00              NOP                            ;915
0000f0  4658              MOV      r0,r11                ;915
0000f2  f7fffffe          BL       CPU_SR_Restore
0000f6  bf00              NOP                            ;915
0000f8  bf00              NOP                            ;915
0000fa  f7fffffe          BL       OSSched
0000fe  bf00              NOP                            ;921
000100  bf00              NOP                            ;921
000102  f7fffffe          BL       CPU_SR_Save
000106  4683              MOV      r11,r0                ;921
000108  bf00              NOP                            ;921
00010a  f7fffffe          BL       CPU_IntDisMeasStart
00010e  bf00              NOP                            ;921
000110  482b              LDR      r0,|L3.448|
000112  6800              LDR      r0,[r0,#0]            ;922  ; OSTCBCurPtr
000114  f8900035          LDRB     r0,[r0,#0x35]         ;922
000118  b120              CBZ      r0,|L3.292|
00011a  2801              CMP      r0,#1                 ;922
00011c  d02a              BEQ      |L3.372|
00011e  2803              CMP      r0,#3                 ;922
000120  d132              BNE      |L3.392|
000122  e032              B        |L3.394|
                  |L3.292|
000124  4826              LDR      r0,|L3.448|
000126  6800              LDR      r0,[r0,#0]            ;924  ; OSTCBCurPtr
000128  f8d0a058          LDR      r10,[r0,#0x58]        ;924
00012c  4824              LDR      r0,|L3.448|
00012e  6800              LDR      r0,[r0,#0]            ;925  ; OSTCBCurPtr
000130  f8b0005c          LDRH     r0,[r0,#0x5c]         ;925
000134  8030              STRH     r0,[r6,#0]            ;925
000136  b1d4              CBZ      r4,|L3.366|
000138  4821              LDR      r0,|L3.448|
00013a  6800              LDR      r0,[r0,#0]            ;928  ; OSTCBCurPtr
00013c  6c80              LDR      r0,[r0,#0x48]         ;928
00013e  6020              STR      r0,[r4,#0]            ;928
000140  f7fffffe          BL       CPU_TS_TmrRd
000144  491e              LDR      r1,|L3.448|
000146  6809              LDR      r1,[r1,#0]            ;930  ; OSTCBCurPtr
000148  6c89              LDR      r1,[r1,#0x48]         ;930
00014a  1a40              SUBS     r0,r0,r1              ;930
00014c  491c              LDR      r1,|L3.448|
00014e  6809              LDR      r1,[r1,#0]            ;930  ; OSTCBCurPtr
000150  6708              STR      r0,[r1,#0x70]         ;930
000152  481b              LDR      r0,|L3.448|
000154  6800              LDR      r0,[r0,#0]            ;931  ; OSTCBCurPtr
000156  6f40              LDR      r0,[r0,#0x74]         ;931
000158  4919              LDR      r1,|L3.448|
00015a  6809              LDR      r1,[r1,#0]            ;931  ; OSTCBCurPtr
00015c  6f09              LDR      r1,[r1,#0x70]         ;931
00015e  4288              CMP      r0,r1                 ;931
000160  d205              BCS      |L3.366|
000162  4817              LDR      r0,|L3.448|
000164  6800              LDR      r0,[r0,#0]            ;932  ; OSTCBCurPtr
000166  6f00              LDR      r0,[r0,#0x70]         ;932
000168  4915              LDR      r1,|L3.448|
00016a  6809              LDR      r1,[r1,#0]            ;932  ; OSTCBCurPtr
00016c  6748              STR      r0,[r1,#0x74]         ;932
                  |L3.366|
00016e  2000              MOVS     r0,#0                 ;940
000170  8028              STRH     r0,[r5,#0]            ;940
000172  e017              B        |L3.420|
                  |L3.372|
000174  f04f0a00          MOV      r10,#0                ;944
000178  2000              MOVS     r0,#0                 ;945
00017a  8030              STRH     r0,[r6,#0]            ;945
00017c  b104              CBZ      r4,|L3.384|
00017e  6020              STR      r0,[r4,#0]            ;947
                  |L3.384|
000180  f24610a9          MOV      r0,#0x61a9            ;952
000184  8028              STRH     r0,[r5,#0]            ;952
000186  e00d              B        |L3.420|
                  |L3.392|
000188  bf00              NOP                            ;955
                  |L3.394|
00018a  f04f0a00          MOV      r10,#0                ;957
00018e  2000              MOVS     r0,#0                 ;958
000190  8030              STRH     r0,[r6,#0]            ;958
000192  b11c              CBZ      r4,|L3.412|
000194  480a              LDR      r0,|L3.448|
000196  6800              LDR      r0,[r0,#0]            ;961  ; OSTCBCurPtr
000198  6c80              LDR      r0,[r0,#0x48]         ;961
00019a  6020              STR      r0,[r4,#0]            ;961
                  |L3.412|
00019c  f24720d9          MOV      r0,#0x72d9            ;967
0001a0  8028              STRH     r0,[r5,#0]            ;967
0001a2  bf00              NOP                            ;968
                  |L3.420|
0001a4  bf00              NOP                            ;941
0001a6  bf00              NOP                            ;970
0001a8  f7fffffe          BL       CPU_IntDisMeasStop
0001ac  bf00              NOP                            ;970
0001ae  4658              MOV      r0,r11                ;970
0001b0  f7fffffe          BL       CPU_SR_Restore
0001b4  bf00              NOP                            ;970
0001b6  bf00              NOP                            ;970
0001b8  4650              MOV      r0,r10                ;971
0001ba  e731              B        |L3.32|
;;;973    #endif
                          ENDP

                  |L3.444|
                          DCD      OSIntNestingCtr
                  |L3.448|
                          DCD      OSTCBCurPtr
                  |L3.452|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskQPost||, CODE, READONLY, ALIGN=1

                  OSTaskQPost PROC
;;;1127   #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
;;;1128   void  OSTaskQPost (OS_TCB       *p_tcb,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1129                      void         *p_void,
;;;1130                      OS_MSG_SIZE   msg_size,
;;;1131                      OS_OPT        opt,
;;;1132                      OS_ERR       *p_err)
;;;1133   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;1134       CPU_TS   ts;
;;;1135   
;;;1136   
;;;1137   
;;;1138   #ifdef OS_SAFETY_CRITICAL
;;;1139       if (p_err == DEF_NULL) {
;;;1140           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1141           return;
;;;1142       }
;;;1143   #endif
;;;1144   
;;;1145   #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;1146       if (OSRunning != OS_STATE_OS_RUNNING) {
;;;1147          *p_err = OS_ERR_OS_NOT_RUNNING;
;;;1148           return;
;;;1149       }
;;;1150   #endif
;;;1151   
;;;1152   #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* ---------------- VALIDATE ARGUMENTS ---------------- */
;;;1153       switch (opt) {                                              /* User must supply a valid option                      */
;;;1154           case OS_OPT_POST_FIFO:
;;;1155           case OS_OPT_POST_LIFO:
;;;1156           case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
;;;1157           case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
;;;1158                break;
;;;1159   
;;;1160           default:
;;;1161   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1162                TRACE_OS_TASK_MSG_Q_POST_FAILED(&p_tcb->MsgQ);     /* Record the event.                                    */
;;;1163   #endif
;;;1164               *p_err = OS_ERR_OPT_INVALID;
;;;1165                return;
;;;1166       }
;;;1167   #endif
;;;1168   
;;;1169   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1170       ts = OS_TS_GET();                                           /* Get timestamp                                        */
000010  f7fffffe          BL       CPU_TS_TmrRd
000014  4681              MOV      r9,r0
;;;1171   #else
;;;1172       ts = 0u;
;;;1173   #endif
;;;1174   
;;;1175   #if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
;;;1176       if (OSIntNestingCtr > 0u) {
;;;1177           OS_IntQPost(OS_OBJ_TYPE_TASK_MSG,                       /* Post to ISR queue                                    */
;;;1178                       p_tcb,
;;;1179                       p_void,
;;;1180                       msg_size,
;;;1181                       0u,
;;;1182                       opt,
;;;1183                       ts,
;;;1184                       p_err);
;;;1185           return;
;;;1186       }
;;;1187   #endif
;;;1188   
;;;1189   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1190       TRACE_OS_TASK_MSG_Q_POST(&p_tcb->MsgQ);                     /* Record the event.                                    */
;;;1191   #endif
;;;1192   
;;;1193       OS_TaskQPost(p_tcb,
000016  463b              MOV      r3,r7
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  e9cd9800          STRD     r9,r8,[sp,#0]
000022  f7fffffe          BL       OS_TaskQPost
;;;1194                    p_void,
;;;1195                    msg_size,
;;;1196                    opt,
;;;1197                    ts,
;;;1198                    p_err);
;;;1199   }
000026  e8bd87fc          POP      {r2-r10,pc}
;;;1200   #endif
                          ENDP


                          AREA ||i.OSTaskRegGet||, CODE, READONLY, ALIGN=2

                  OSTaskRegGet PROC
;;;1228   #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
;;;1229   OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1230                         OS_REG_ID   id,
;;;1231                         OS_ERR     *p_err)
;;;1232   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1233       OS_REG     value;
;;;1234       CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;1235   
;;;1236   
;;;1237   
;;;1238   #ifdef OS_SAFETY_CRITICAL
;;;1239       if (p_err == DEF_NULL) {
;;;1240           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1241           return (0u);
;;;1242       }
;;;1243   #endif
;;;1244   
;;;1245   #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;1246       if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
;;;1247          *p_err = OS_ERR_REG_ID_INVALID;
;;;1248           return (0u);
;;;1249       }
;;;1250   #endif
;;;1251   
;;;1252       CPU_CRITICAL_ENTER();
00000e  bf00              NOP      
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_SR_Save
000016  4680              MOV      r8,r0
000018  bf00              NOP      
00001a  f7fffffe          BL       CPU_IntDisMeasStart
00001e  bf00              NOP      
;;;1253       if (p_tcb == DEF_NULL) {
000020  b90c              CBNZ     r4,|L5.38|
;;;1254           p_tcb = OSTCBCurPtr;
000022  480a              LDR      r0,|L5.76|
000024  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L5.38|
;;;1255       }
;;;1256       value = p_tcb->RegTbl[id];
000026  f1040078          ADD      r0,r4,#0x78
00002a  f8507025          LDR      r7,[r0,r5,LSL #2]
;;;1257       CPU_CRITICAL_EXIT();
00002e  bf00              NOP      
000030  f7fffffe          BL       CPU_IntDisMeasStop
000034  bf00              NOP      
000036  4640              MOV      r0,r8
000038  f7fffffe          BL       CPU_SR_Restore
00003c  bf00              NOP      
00003e  bf00              NOP      
;;;1258      *p_err = OS_ERR_NONE;
000040  2000              MOVS     r0,#0
000042  8030              STRH     r0,[r6,#0]
;;;1259       return (value);
000044  4638              MOV      r0,r7
;;;1260   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1261   #endif
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskRegGetID||, CODE, READONLY, ALIGN=2

                  OSTaskRegGetID PROC
;;;1283   #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
;;;1284   OS_REG_ID  OSTaskRegGetID (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;1285   {
000002  4604              MOV      r4,r0
;;;1286       OS_REG_ID  id;
;;;1287       CPU_SR_ALLOC();
000004  2600              MOVS     r6,#0
;;;1288   
;;;1289   
;;;1290   
;;;1291   #ifdef OS_SAFETY_CRITICAL
;;;1292       if (p_err == DEF_NULL) {
;;;1293           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1294           return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
;;;1295       }
;;;1296   #endif
;;;1297   
;;;1298       CPU_CRITICAL_ENTER();
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f7fffffe          BL       CPU_SR_Save
00000e  4606              MOV      r6,r0
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_IntDisMeasStart
000016  bf00              NOP      
;;;1299       if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {     /* See if we exceeded the number of IDs available       */
000018  4811              LDR      r0,|L6.96|
00001a  7800              LDRB     r0,[r0,#0]  ; OSTaskRegNextAvailID
00001c  b168              CBZ      r0,|L6.58|
;;;1300          *p_err = OS_ERR_NO_MORE_ID_AVAIL;                        /* Yes, cannot allocate more task register IDs          */
00001e  f64510da          MOV      r0,#0x59da
000022  8020              STRH     r0,[r4,#0]
;;;1301           CPU_CRITICAL_EXIT();
000024  bf00              NOP      
000026  f7fffffe          BL       CPU_IntDisMeasStop
00002a  bf00              NOP      
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       CPU_SR_Restore
000032  bf00              NOP      
000034  bf00              NOP      
;;;1302           return (OS_CFG_TASK_REG_TBL_SIZE);
000036  2001              MOVS     r0,#1
                  |L6.56|
;;;1303       }
;;;1304   
;;;1305       id    = OSTaskRegNextAvailID;                               /* Assign the next available ID                         */
;;;1306       OSTaskRegNextAvailID++;                                     /* Increment available ID for next request              */
;;;1307       CPU_CRITICAL_EXIT();
;;;1308      *p_err = OS_ERR_NONE;
;;;1309       return (id);
;;;1310   }
000038  bd70              POP      {r4-r6,pc}
                  |L6.58|
00003a  4809              LDR      r0,|L6.96|
00003c  7805              LDRB     r5,[r0,#0]            ;1305  ; OSTaskRegNextAvailID
00003e  7800              LDRB     r0,[r0,#0]            ;1306  ; OSTaskRegNextAvailID
000040  1c40              ADDS     r0,r0,#1              ;1306
000042  4907              LDR      r1,|L6.96|
000044  7008              STRB     r0,[r1,#0]            ;1306
000046  bf00              NOP                            ;1307
000048  f7fffffe          BL       CPU_IntDisMeasStop
00004c  bf00              NOP                            ;1307
00004e  4630              MOV      r0,r6                 ;1307
000050  f7fffffe          BL       CPU_SR_Restore
000054  bf00              NOP                            ;1307
000056  bf00              NOP                            ;1307
000058  2000              MOVS     r0,#0                 ;1308
00005a  8020              STRH     r0,[r4,#0]            ;1308
00005c  4628              MOV      r0,r5                 ;1309
00005e  e7eb              B        |L6.56|
;;;1311   #endif
                          ENDP

                  |L6.96|
                          DCD      OSTaskRegNextAvailID

                          AREA ||i.OSTaskRegSet||, CODE, READONLY, ALIGN=2

                  OSTaskRegSet PROC
;;;1341   #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
;;;1342   void  OSTaskRegSet (OS_TCB     *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1343                       OS_REG_ID   id,
;;;1344                       OS_REG      value,
;;;1345                       OS_ERR     *p_err)
;;;1346   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
;;;1347       CPU_SR_ALLOC();
00000c  f04f0800          MOV      r8,#0
;;;1348   
;;;1349   
;;;1350   
;;;1351   #ifdef OS_SAFETY_CRITICAL
;;;1352       if (p_err == DEF_NULL) {
;;;1353           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1354           return;
;;;1355       }
;;;1356   #endif
;;;1357   
;;;1358   #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;1359       if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
;;;1360          *p_err = OS_ERR_REG_ID_INVALID;
;;;1361           return;
;;;1362       }
;;;1363   #endif
;;;1364   
;;;1365       CPU_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4680              MOV      r8,r0
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStart
000020  bf00              NOP      
;;;1366       if (p_tcb == DEF_NULL) {
000022  b90c              CBNZ     r4,|L7.40|
;;;1367           p_tcb = OSTCBCurPtr;
000024  4809              LDR      r0,|L7.76|
000026  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L7.40|
;;;1368       }
;;;1369       p_tcb->RegTbl[id] = value;
000028  f1040078          ADD      r0,r4,#0x78
00002c  f8407025          STR      r7,[r0,r5,LSL #2]
;;;1370       CPU_CRITICAL_EXIT();
000030  bf00              NOP      
000032  f7fffffe          BL       CPU_IntDisMeasStop
000036  bf00              NOP      
000038  4640              MOV      r0,r8
00003a  f7fffffe          BL       CPU_SR_Restore
00003e  bf00              NOP      
000040  bf00              NOP      
;;;1371      *p_err             = OS_ERR_NONE;
000042  2000              MOVS     r0,#0
000044  8030              STRH     r0,[r6,#0]
;;;1372   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1373   #endif
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskResume||, CODE, READONLY, ALIGN=2

                  OSTaskResume PROC
;;;1401   #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
;;;1402   void  OSTaskResume (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1403                       OS_ERR  *p_err)
;;;1404   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1405       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;1406   
;;;1407   
;;;1408   
;;;1409   #ifdef OS_SAFETY_CRITICAL
;;;1410       if (p_err == DEF_NULL) {
;;;1411           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1412           return;
;;;1413       }
;;;1414   #endif
;;;1415   
;;;1416   #if (OS_CFG_ISR_POST_DEFERRED_EN   == DEF_DISABLED) && \
;;;1417       (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;1418       if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
000008  480f              LDR      r0,|L8.72|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000c  b118              CBZ      r0,|L8.22|
;;;1419          *p_err = OS_ERR_TASK_RESUME_ISR;
00000e  f2471055          MOV      r0,#0x7155
000012  8020              STRH     r0,[r4,#0]
                  |L8.20|
;;;1420           return;
;;;1421       }
;;;1422   #endif
;;;1423   
;;;1424   #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;1425       if (OSRunning != OS_STATE_OS_RUNNING) {
;;;1426          *p_err = OS_ERR_OS_NOT_RUNNING;
;;;1427           return;
;;;1428       }
;;;1429   #endif
;;;1430   
;;;1431   
;;;1432       CPU_CRITICAL_ENTER();
;;;1433   #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;1434       if ((p_tcb == DEF_NULL) ||                                  /* We cannot resume 'self'                              */
;;;1435           (p_tcb == OSTCBCurPtr)) {
;;;1436           CPU_CRITICAL_EXIT();
;;;1437          *p_err  = OS_ERR_TASK_RESUME_SELF;
;;;1438           return;
;;;1439       }
;;;1440   #endif
;;;1441       CPU_CRITICAL_EXIT();
;;;1442   
;;;1443   #if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
;;;1444       if (OSIntNestingCtr > 0u) {                                 /* See if called from an ISR                            */
;;;1445           OS_IntQPost(OS_OBJ_TYPE_TASK_RESUME,                    /* Post to ISR queue                                    */
;;;1446                       (void *)p_tcb,
;;;1447                       DEF_NULL,
;;;1448                       0u,
;;;1449                       0u,
;;;1450                       0u,
;;;1451                       0u,
;;;1452                       p_err);
;;;1453           return;
;;;1454       }
;;;1455   #endif
;;;1456   
;;;1457       OS_TaskResume(p_tcb, p_err);
;;;1458   
;;;1459   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1460       TRACE_OS_TASK_RESUME(p_tcb);                                /* Record the event.                                    */
;;;1461   #endif
;;;1462   }
000014  bd70              POP      {r4-r6,pc}
                  |L8.22|
000016  bf00              NOP                            ;1432
000018  bf00              NOP                            ;1432
00001a  f7fffffe          BL       CPU_SR_Save
00001e  4606              MOV      r6,r0                 ;1432
000020  bf00              NOP                            ;1432
000022  f7fffffe          BL       CPU_IntDisMeasStart
000026  bf00              NOP                            ;1432
000028  bf00              NOP                            ;1441
00002a  f7fffffe          BL       CPU_IntDisMeasStop
00002e  bf00              NOP                            ;1441
000030  4630              MOV      r0,r6                 ;1441
000032  f7fffffe          BL       CPU_SR_Restore
000036  bf00              NOP                            ;1441
000038  bf00              NOP                            ;1441
00003a  4621              MOV      r1,r4                 ;1457
00003c  4628              MOV      r0,r5                 ;1457
00003e  f7fffffe          BL       OS_TaskResume
000042  bf00              NOP      
000044  e7e6              B        |L8.20|
;;;1463   #endif
                          ENDP

000046  0000              DCW      0x0000
                  |L8.72|
                          DCD      OSIntNestingCtr

                          AREA ||i.OSTaskSemPend||, CODE, READONLY, ALIGN=2

                  OSTaskSemPend PROC
;;;1501   
;;;1502   OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1503                              OS_OPT    opt,
;;;1504                              CPU_TS   *p_ts,
;;;1505                              OS_ERR   *p_err)
;;;1506   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;1507       OS_SEM_CTR    ctr;
;;;1508       CPU_SR_ALLOC();
00000c  f04f0900          MOV      r9,#0
;;;1509   
;;;1510   
;;;1511   #if (OS_CFG_TS_EN == DEF_DISABLED)
;;;1512       (void)&p_ts;                                                /* Prevent compiler warning for not using 'ts'          */
;;;1513   #endif
;;;1514   
;;;1515   #ifdef OS_SAFETY_CRITICAL
;;;1516       if (p_err == DEF_NULL) {
;;;1517           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1518           return (0u);
;;;1519       }
;;;1520   #endif
;;;1521   
;;;1522   #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;1523       if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
000010  4870              LDR      r0,|L9.468|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000014  b128              CBZ      r0,|L9.34|
;;;1524   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1525           TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);             /* Record the event.                                    */
;;;1526   #endif
;;;1527          *p_err = OS_ERR_PEND_ISR;
000016  f24610ae          MOV      r0,#0x61ae
00001a  8028              STRH     r0,[r5,#0]
;;;1528           return (0u);
00001c  2000              MOVS     r0,#0
                  |L9.30|
;;;1529       }
;;;1530   #endif
;;;1531   
;;;1532   #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;1533       if (OSRunning != OS_STATE_OS_RUNNING) {
;;;1534          *p_err = OS_ERR_OS_NOT_RUNNING;
;;;1535           return (0u);
;;;1536       }
;;;1537   #endif
;;;1538   
;;;1539   #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;1540       switch (opt) {                                              /* Validate 'opt'                                       */
;;;1541           case OS_OPT_PEND_BLOCKING:
;;;1542           case OS_OPT_PEND_NON_BLOCKING:
;;;1543                break;
;;;1544   
;;;1545           default:
;;;1546   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1547                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);        /* Record the event.                                    */
;;;1548   #endif
;;;1549               *p_err = OS_ERR_OPT_INVALID;
;;;1550                return (0u);
;;;1551       }
;;;1552   #endif
;;;1553   
;;;1554       CPU_CRITICAL_ENTER();
;;;1555       if (OSTCBCurPtr->SemCtr > 0u) {                             /* See if task already been signaled                    */
;;;1556           OSTCBCurPtr->SemCtr--;
;;;1557           ctr = OSTCBCurPtr->SemCtr;
;;;1558   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1559           if (p_ts != DEF_NULL) {
;;;1560              *p_ts  = OSTCBCurPtr->TS;
;;;1561           }
;;;1562   #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
;;;1563   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1564           OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;1565           if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
;;;1566               OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
;;;1567           }
;;;1568   #endif
;;;1569   #endif
;;;1570   #endif
;;;1571           CPU_CRITICAL_EXIT();
;;;1572   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1573           TRACE_OS_TASK_SEM_PEND(OSTCBCurPtr);                    /* Record the event.                                    */
;;;1574   #endif
;;;1575          *p_err = OS_ERR_NONE;
;;;1576           return (ctr);
;;;1577       }
;;;1578   
;;;1579       if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
;;;1580           CPU_CRITICAL_EXIT();
;;;1581   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1582           if (p_ts != DEF_NULL) {
;;;1583               *p_ts  = 0u;
;;;1584           }
;;;1585   #endif
;;;1586          *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
;;;1587   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1588           TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);             /* Record the event.                                    */
;;;1589   #endif
;;;1590           return (0u);
;;;1591       } else {                                                    /* Yes                                                  */
;;;1592           if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
;;;1593   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1594               if (p_ts != DEF_NULL) {
;;;1595                  *p_ts  = 0u;
;;;1596               }
;;;1597   #endif
;;;1598               CPU_CRITICAL_EXIT();
;;;1599   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1600               TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);         /* Record the event.                                    */
;;;1601   #endif
;;;1602              *p_err = OS_ERR_SCHED_LOCKED;
;;;1603               return (0u);
;;;1604           }
;;;1605       }
;;;1606                                                                   /* Lock the scheduler/re-enable interrupts              */
;;;1607       OS_CRITICAL_ENTER_CPU_EXIT();
;;;1608       OS_Pend(DEF_NULL,                                           /* Block task pending on Signal                         */
;;;1609               DEF_NULL,
;;;1610               OS_TASK_PEND_ON_TASK_SEM,
;;;1611               timeout);
;;;1612       OS_CRITICAL_EXIT_NO_SCHED();
;;;1613   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1614       TRACE_OS_TASK_SEM_PEND_BLOCK(OSTCBCurPtr);                  /* Record the event.                                    */
;;;1615   #endif
;;;1616       OSSched();                                                  /* Find next highest priority task ready to run         */
;;;1617   
;;;1618       CPU_CRITICAL_ENTER();
;;;1619       switch (OSTCBCurPtr->PendStatus) {                          /* See if we timed-out or aborted                       */
;;;1620           case OS_STATUS_PEND_OK:
;;;1621   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1622                if (p_ts != DEF_NULL) {
;;;1623                   *p_ts                    =  OSTCBCurPtr->TS;
;;;1624   #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
;;;1625   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1626                   OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;1627                   if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
;;;1628                       OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
;;;1629                   }
;;;1630   #endif
;;;1631   #endif
;;;1632                }
;;;1633   #endif
;;;1634   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1635                TRACE_OS_TASK_SEM_PEND(OSTCBCurPtr);               /* Record the event.                                    */
;;;1636   #endif
;;;1637               *p_err = OS_ERR_NONE;
;;;1638                break;
;;;1639   
;;;1640           case OS_STATUS_PEND_ABORT:
;;;1641   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1642                if (p_ts != DEF_NULL) {
;;;1643                   *p_ts = OSTCBCurPtr->TS;
;;;1644                }
;;;1645   #endif
;;;1646   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1647                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);        /* Record the event.                                    */
;;;1648   #endif
;;;1649               *p_err = OS_ERR_PEND_ABORT;                         /* Indicate that we aborted                             */
;;;1650                break;
;;;1651   
;;;1652           case OS_STATUS_PEND_TIMEOUT:
;;;1653   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1654                if (p_ts != DEF_NULL) {
;;;1655                   *p_ts = 0u;
;;;1656                }
;;;1657   #endif
;;;1658   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1659                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);        /* Record the event.                                    */
;;;1660   #endif
;;;1661               *p_err = OS_ERR_TIMEOUT;                            /* Indicate that we didn't get event within TO          */
;;;1662                break;
;;;1663   
;;;1664           default:
;;;1665   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1666                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);        /* Record the event.                                    */
;;;1667   #endif
;;;1668               *p_err = OS_ERR_STATUS_INVALID;
;;;1669                break;
;;;1670       }
;;;1671       ctr = OSTCBCurPtr->SemCtr;
;;;1672       CPU_CRITICAL_EXIT();
;;;1673       return (ctr);
;;;1674   }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L9.34|
000022  bf00              NOP                            ;1554
000024  bf00              NOP                            ;1554
000026  f7fffffe          BL       CPU_SR_Save
00002a  4681              MOV      r9,r0                 ;1554
00002c  bf00              NOP                            ;1554
00002e  f7fffffe          BL       CPU_IntDisMeasStart
000032  bf00              NOP                            ;1554
000034  4868              LDR      r0,|L9.472|
000036  6800              LDR      r0,[r0,#0]            ;1555  ; OSTCBCurPtr
000038  6cc0              LDR      r0,[r0,#0x4c]         ;1555
00003a  b3b8              CBZ      r0,|L9.172|
00003c  4866              LDR      r0,|L9.472|
00003e  6800              LDR      r0,[r0,#0]            ;1556  ; OSTCBCurPtr
000040  6cc0              LDR      r0,[r0,#0x4c]         ;1556
000042  1e40              SUBS     r0,r0,#1              ;1556
000044  4964              LDR      r1,|L9.472|
000046  6809              LDR      r1,[r1,#0]            ;1556  ; OSTCBCurPtr
000048  64c8              STR      r0,[r1,#0x4c]         ;1556
00004a  4863              LDR      r0,|L9.472|
00004c  6800              LDR      r0,[r0,#0]            ;1557  ; OSTCBCurPtr
00004e  6cc6              LDR      r6,[r0,#0x4c]         ;1557
000050  b11c              CBZ      r4,|L9.90|
000052  4861              LDR      r0,|L9.472|
000054  6800              LDR      r0,[r0,#0]            ;1560  ; OSTCBCurPtr
000056  6c80              LDR      r0,[r0,#0x48]         ;1560
000058  6020              STR      r0,[r4,#0]            ;1560
                  |L9.90|
00005a  f7fffffe          BL       CPU_TS_TmrRd
00005e  495e              LDR      r1,|L9.472|
000060  6809              LDR      r1,[r1,#0]            ;1564  ; OSTCBCurPtr
000062  6c89              LDR      r1,[r1,#0x48]         ;1564
000064  1a40              SUBS     r0,r0,r1              ;1564
000066  495c              LDR      r1,|L9.472|
000068  6809              LDR      r1,[r1,#0]            ;1564  ; OSTCBCurPtr
00006a  f8c10098          STR      r0,[r1,#0x98]         ;1564
00006e  485a              LDR      r0,|L9.472|
000070  6800              LDR      r0,[r0,#0]            ;1565  ; OSTCBCurPtr
000072  f8d0009c          LDR      r0,[r0,#0x9c]         ;1565
000076  4958              LDR      r1,|L9.472|
000078  6809              LDR      r1,[r1,#0]            ;1565  ; OSTCBCurPtr
00007a  f8d11098          LDR      r1,[r1,#0x98]         ;1565
00007e  4288              CMP      r0,r1                 ;1565
000080  d207              BCS      |L9.146|
000082  4855              LDR      r0,|L9.472|
000084  6800              LDR      r0,[r0,#0]            ;1566  ; OSTCBCurPtr
000086  f8d00098          LDR      r0,[r0,#0x98]         ;1566
00008a  4953              LDR      r1,|L9.472|
00008c  6809              LDR      r1,[r1,#0]            ;1566  ; OSTCBCurPtr
00008e  f8c1009c          STR      r0,[r1,#0x9c]         ;1566
                  |L9.146|
000092  bf00              NOP                            ;1571
000094  f7fffffe          BL       CPU_IntDisMeasStop
000098  bf00              NOP                            ;1571
00009a  4648              MOV      r0,r9                 ;1571
00009c  f7fffffe          BL       CPU_SR_Restore
0000a0  bf00              NOP                            ;1571
0000a2  bf00              NOP                            ;1571
0000a4  2000              MOVS     r0,#0                 ;1575
0000a6  8028              STRH     r0,[r5,#0]            ;1575
0000a8  4630              MOV      r0,r6                 ;1576
0000aa  e7b8              B        |L9.30|
                  |L9.172|
0000ac  e7ff              B        |L9.174|
                  |L9.174|
0000ae  f4184f00          TST      r8,#0x8000            ;1579
0000b2  d010              BEQ      |L9.214|
0000b4  bf00              NOP                            ;1580
0000b6  f7fffffe          BL       CPU_IntDisMeasStop
0000ba  bf00              NOP                            ;1580
0000bc  4648              MOV      r0,r9                 ;1580
0000be  f7fffffe          BL       CPU_SR_Restore
0000c2  bf00              NOP                            ;1580
0000c4  bf00              NOP                            ;1580
0000c6  b10c              CBZ      r4,|L9.204|
0000c8  2000              MOVS     r0,#0                 ;1583
0000ca  6020              STR      r0,[r4,#0]            ;1583
                  |L9.204|
0000cc  f24610b0          MOV      r0,#0x61b0            ;1586
0000d0  8028              STRH     r0,[r5,#0]            ;1586
0000d2  2000              MOVS     r0,#0                 ;1590
0000d4  e7a3              B        |L9.30|
                  |L9.214|
0000d6  4841              LDR      r0,|L9.476|
0000d8  7800              LDRB     r0,[r0,#0]            ;1592  ; OSSchedLockNestingCtr
0000da  b180              CBZ      r0,|L9.254|
0000dc  b10c              CBZ      r4,|L9.226|
0000de  2000              MOVS     r0,#0                 ;1595
0000e0  6020              STR      r0,[r4,#0]            ;1595
                  |L9.226|
0000e2  bf00              NOP                            ;1598
0000e4  f7fffffe          BL       CPU_IntDisMeasStop
0000e8  bf00              NOP                            ;1598
0000ea  4648              MOV      r0,r9                 ;1598
0000ec  f7fffffe          BL       CPU_SR_Restore
0000f0  bf00              NOP                            ;1598
0000f2  bf00              NOP                            ;1598
0000f4  f6465063          MOV      r0,#0x6d63            ;1602
0000f8  8028              STRH     r0,[r5,#0]            ;1602
0000fa  2000              MOVS     r0,#0                 ;1603
0000fc  e78f              B        |L9.30|
                  |L9.254|
0000fe  463b              MOV      r3,r7                 ;1608
000100  2207              MOVS     r2,#7                 ;1608
000102  2100              MOVS     r1,#0                 ;1608
000104  4608              MOV      r0,r1                 ;1608
000106  f7fffffe          BL       OS_Pend
00010a  bf00              NOP                            ;1612
00010c  f7fffffe          BL       CPU_IntDisMeasStop
000110  bf00              NOP                            ;1612
000112  4648              MOV      r0,r9                 ;1612
000114  f7fffffe          BL       CPU_SR_Restore
000118  bf00              NOP                            ;1612
00011a  bf00              NOP                            ;1612
00011c  f7fffffe          BL       OSSched
000120  bf00              NOP                            ;1618
000122  bf00              NOP                            ;1618
000124  f7fffffe          BL       CPU_SR_Save
000128  4681              MOV      r9,r0                 ;1618
00012a  bf00              NOP                            ;1618
00012c  f7fffffe          BL       CPU_IntDisMeasStart
000130  bf00              NOP                            ;1618
000132  4829              LDR      r0,|L9.472|
000134  6800              LDR      r0,[r0,#0]            ;1619  ; OSTCBCurPtr
000136  f8900035          LDRB     r0,[r0,#0x35]         ;1619
00013a  b120              CBZ      r0,|L9.326|
00013c  2801              CMP      r0,#1                 ;1619
00013e  d026              BEQ      |L9.398|
000140  2803              CMP      r0,#3                 ;1619
000142  d134              BNE      |L9.430|
000144  e02c              B        |L9.416|
                  |L9.326|
000146  b1fc              CBZ      r4,|L9.392|
000148  4823              LDR      r0,|L9.472|
00014a  6800              LDR      r0,[r0,#0]            ;1623  ; OSTCBCurPtr
00014c  6c80              LDR      r0,[r0,#0x48]         ;1623
00014e  6020              STR      r0,[r4,#0]            ;1623
000150  f7fffffe          BL       CPU_TS_TmrRd
000154  4920              LDR      r1,|L9.472|
000156  6809              LDR      r1,[r1,#0]            ;1626  ; OSTCBCurPtr
000158  6c89              LDR      r1,[r1,#0x48]         ;1626
00015a  1a40              SUBS     r0,r0,r1              ;1626
00015c  491e              LDR      r1,|L9.472|
00015e  6809              LDR      r1,[r1,#0]            ;1626  ; OSTCBCurPtr
000160  f8c10098          STR      r0,[r1,#0x98]         ;1626
000164  481c              LDR      r0,|L9.472|
000166  6800              LDR      r0,[r0,#0]            ;1627  ; OSTCBCurPtr
000168  f8d0009c          LDR      r0,[r0,#0x9c]         ;1627
00016c  491a              LDR      r1,|L9.472|
00016e  6809              LDR      r1,[r1,#0]            ;1627  ; OSTCBCurPtr
000170  f8d11098          LDR      r1,[r1,#0x98]         ;1627
000174  4288              CMP      r0,r1                 ;1627
000176  d207              BCS      |L9.392|
000178  4817              LDR      r0,|L9.472|
00017a  6800              LDR      r0,[r0,#0]            ;1628  ; OSTCBCurPtr
00017c  f8d00098          LDR      r0,[r0,#0x98]         ;1628
000180  4915              LDR      r1,|L9.472|
000182  6809              LDR      r1,[r1,#0]            ;1628  ; OSTCBCurPtr
000184  f8c1009c          STR      r0,[r1,#0x9c]         ;1628
                  |L9.392|
000188  2000              MOVS     r0,#0                 ;1637
00018a  8028              STRH     r0,[r5,#0]            ;1637
00018c  e013              B        |L9.438|
                  |L9.398|
00018e  b11c              CBZ      r4,|L9.408|
000190  4811              LDR      r0,|L9.472|
000192  6800              LDR      r0,[r0,#0]            ;1643  ; OSTCBCurPtr
000194  6c80              LDR      r0,[r0,#0x48]         ;1643
000196  6020              STR      r0,[r4,#0]            ;1643
                  |L9.408|
000198  f24610a9          MOV      r0,#0x61a9            ;1649
00019c  8028              STRH     r0,[r5,#0]            ;1649
00019e  e00a              B        |L9.438|
                  |L9.416|
0001a0  b10c              CBZ      r4,|L9.422|
0001a2  2000              MOVS     r0,#0                 ;1655
0001a4  6020              STR      r0,[r4,#0]            ;1655
                  |L9.422|
0001a6  f24720d9          MOV      r0,#0x72d9            ;1661
0001aa  8028              STRH     r0,[r5,#0]            ;1661
0001ac  e003              B        |L9.438|
                  |L9.430|
0001ae  f646602e          MOV      r0,#0x6e2e            ;1668
0001b2  8028              STRH     r0,[r5,#0]            ;1668
0001b4  bf00              NOP                            ;1669
                  |L9.438|
0001b6  bf00              NOP                            ;1638
0001b8  4807              LDR      r0,|L9.472|
0001ba  6800              LDR      r0,[r0,#0]            ;1671  ; OSTCBCurPtr
0001bc  6cc6              LDR      r6,[r0,#0x4c]         ;1671
0001be  bf00              NOP                            ;1672
0001c0  f7fffffe          BL       CPU_IntDisMeasStop
0001c4  bf00              NOP                            ;1672
0001c6  4648              MOV      r0,r9                 ;1672
0001c8  f7fffffe          BL       CPU_SR_Restore
0001cc  bf00              NOP                            ;1672
0001ce  bf00              NOP                            ;1672
0001d0  4630              MOV      r0,r6                 ;1673
0001d2  e724              B        |L9.30|
;;;1675   
                          ENDP

                  |L9.468|
                          DCD      OSIntNestingCtr
                  |L9.472|
                          DCD      OSTCBCurPtr
                  |L9.476|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskSemPendAbort||, CODE, READONLY, ALIGN=2

                  OSTaskSemPendAbort PROC
;;;1709   #if (OS_CFG_TASK_SEM_PEND_ABORT_EN == DEF_ENABLED)
;;;1710   CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1711                                    OS_OPT   opt,
;;;1712                                    OS_ERR  *p_err)
;;;1713   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1714       CPU_TS  ts;
;;;1715       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;1716   
;;;1717   
;;;1718   
;;;1719   #ifdef OS_SAFETY_CRITICAL
;;;1720       if (p_err == DEF_NULL) {
;;;1721           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1722           return (DEF_FALSE);
;;;1723       }
;;;1724   #endif
;;;1725   
;;;1726   #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;1727       if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
00000c  4831              LDR      r0,|L10.212|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000010  b128              CBZ      r0,|L10.30|
;;;1728          *p_err = OS_ERR_PEND_ABORT_ISR;                          /* ... can't Pend Abort from an ISR                     */
000012  f24610aa          MOV      r0,#0x61aa
000016  8028              STRH     r0,[r5,#0]
;;;1729           return (DEF_FALSE);
000018  2000              MOVS     r0,#0
                  |L10.26|
;;;1730       }
;;;1731   #endif
;;;1732   
;;;1733   #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;1734       if (OSRunning != OS_STATE_OS_RUNNING) {
;;;1735          *p_err = OS_ERR_OS_NOT_RUNNING;
;;;1736           return (DEF_FALSE);
;;;1737       }
;;;1738   #endif
;;;1739   
;;;1740   #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;1741       switch (opt) {                                              /* Validate 'opt'                                       */
;;;1742           case OS_OPT_POST_NONE:
;;;1743           case OS_OPT_POST_NO_SCHED:
;;;1744                break;
;;;1745   
;;;1746           default:
;;;1747               *p_err = OS_ERR_OPT_INVALID;
;;;1748                return (DEF_FALSE);
;;;1749       }
;;;1750   #endif
;;;1751   
;;;1752       CPU_CRITICAL_ENTER();
;;;1753       if ((p_tcb == DEF_NULL) ||                                  /* Pend abort self?                                     */
;;;1754           (p_tcb == OSTCBCurPtr)) {
;;;1755           CPU_CRITICAL_EXIT();                                    /* ... doesn't make sense!                              */
;;;1756          *p_err = OS_ERR_PEND_ABORT_SELF;
;;;1757           return (DEF_FALSE);
;;;1758       }
;;;1759   
;;;1760       if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {            /* Is task waiting for a signal?                        */
;;;1761           CPU_CRITICAL_EXIT();
;;;1762          *p_err = OS_ERR_PEND_ABORT_NONE;
;;;1763           return (DEF_FALSE);
;;;1764       }
;;;1765       CPU_CRITICAL_EXIT();
;;;1766   
;;;1767       OS_CRITICAL_ENTER();
;;;1768   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1769       ts = OS_TS_GET();
;;;1770   #else
;;;1771       ts = 0u;
;;;1772   #endif
;;;1773       OS_PendAbort(DEF_NULL,
;;;1774                    p_tcb,
;;;1775                    ts);
;;;1776       OS_CRITICAL_EXIT_NO_SCHED();
;;;1777       if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
;;;1778           OSSched();                                              /* Run the scheduler                                    */
;;;1779       }
;;;1780      *p_err = OS_ERR_NONE;
;;;1781       return (DEF_TRUE);
;;;1782   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L10.30|
00001e  bf00              NOP                            ;1752
000020  bf00              NOP                            ;1752
000022  f7fffffe          BL       CPU_SR_Save
000026  4607              MOV      r7,r0                 ;1752
000028  bf00              NOP                            ;1752
00002a  f7fffffe          BL       CPU_IntDisMeasStart
00002e  bf00              NOP                            ;1752
000030  b11c              CBZ      r4,|L10.58|
000032  4829              LDR      r0,|L10.216|
000034  6800              LDR      r0,[r0,#0]            ;1754  ; OSTCBCurPtr
000036  4284              CMP      r4,r0                 ;1754
000038  d10d              BNE      |L10.86|
                  |L10.58|
00003a  bf00              NOP                            ;1755
00003c  f7fffffe          BL       CPU_IntDisMeasStop
000040  bf00              NOP                            ;1755
000042  4638              MOV      r0,r7                 ;1755
000044  f7fffffe          BL       CPU_SR_Restore
000048  bf00              NOP                            ;1755
00004a  bf00              NOP                            ;1755
00004c  f24610ac          MOV      r0,#0x61ac            ;1756
000050  8028              STRH     r0,[r5,#0]            ;1756
000052  2000              MOVS     r0,#0                 ;1757
000054  e7e1              B        |L10.26|
                  |L10.86|
000056  f8940034          LDRB     r0,[r4,#0x34]         ;1760
00005a  2807              CMP      r0,#7                 ;1760
00005c  d00d              BEQ      |L10.122|
00005e  bf00              NOP                            ;1761
000060  f7fffffe          BL       CPU_IntDisMeasStop
000064  bf00              NOP                            ;1761
000066  4638              MOV      r0,r7                 ;1761
000068  f7fffffe          BL       CPU_SR_Restore
00006c  bf00              NOP                            ;1761
00006e  bf00              NOP                            ;1761
000070  f24610ab          MOV      r0,#0x61ab            ;1762
000074  8028              STRH     r0,[r5,#0]            ;1762
000076  2000              MOVS     r0,#0                 ;1763
000078  e7cf              B        |L10.26|
                  |L10.122|
00007a  bf00              NOP                            ;1765
00007c  f7fffffe          BL       CPU_IntDisMeasStop
000080  bf00              NOP                            ;1765
000082  4638              MOV      r0,r7                 ;1765
000084  f7fffffe          BL       CPU_SR_Restore
000088  bf00              NOP                            ;1765
00008a  bf00              NOP                            ;1765
00008c  bf00              NOP                            ;1767
00008e  bf00              NOP                            ;1767
000090  f7fffffe          BL       CPU_SR_Save
000094  4607              MOV      r7,r0                 ;1767
000096  bf00              NOP                            ;1767
000098  f7fffffe          BL       CPU_IntDisMeasStart
00009c  bf00              NOP                            ;1767
00009e  f7fffffe          BL       CPU_TS_TmrRd
0000a2  4680              MOV      r8,r0                 ;1769
0000a4  4642              MOV      r2,r8                 ;1773
0000a6  4621              MOV      r1,r4                 ;1773
0000a8  2000              MOVS     r0,#0                 ;1773
0000aa  f7fffffe          BL       OS_PendAbort
0000ae  bf00              NOP                            ;1776
0000b0  f7fffffe          BL       CPU_IntDisMeasStop
0000b4  bf00              NOP                            ;1776
0000b6  4638              MOV      r0,r7                 ;1776
0000b8  f7fffffe          BL       CPU_SR_Restore
0000bc  bf00              NOP                            ;1776
0000be  bf00              NOP                            ;1776
0000c0  f4164f00          TST      r6,#0x8000            ;1777
0000c4  d101              BNE      |L10.202|
0000c6  f7fffffe          BL       OSSched
                  |L10.202|
0000ca  2000              MOVS     r0,#0                 ;1780
0000cc  8028              STRH     r0,[r5,#0]            ;1780
0000ce  2001              MOVS     r0,#1                 ;1781
0000d0  e7a3              B        |L10.26|
;;;1783   #endif
                          ENDP

0000d2  0000              DCW      0x0000
                  |L10.212|
                          DCD      OSIntNestingCtr
                  |L10.216|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSemPost||, CODE, READONLY, ALIGN=1

                  OSTaskSemPost PROC
;;;1815   
;;;1816   OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1817                              OS_OPT   opt,
;;;1818                              OS_ERR  *p_err)
;;;1819   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;1820       OS_SEM_CTR  ctr;
;;;1821       CPU_TS      ts;
;;;1822   
;;;1823   
;;;1824   
;;;1825   #ifdef OS_SAFETY_CRITICAL
;;;1826       if (p_err == DEF_NULL) {
;;;1827           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1828           return (0u);
;;;1829       }
;;;1830   #endif
;;;1831   
;;;1832   #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;1833       if (OSRunning != OS_STATE_OS_RUNNING) {
;;;1834          *p_err = OS_ERR_OS_NOT_RUNNING;
;;;1835           return (0u);
;;;1836       }
;;;1837   #endif
;;;1838   
;;;1839   #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;1840       switch (opt) {                                              /* Validate 'opt'                                       */
;;;1841           case OS_OPT_POST_NONE:
;;;1842           case OS_OPT_POST_NO_SCHED:
;;;1843                break;
;;;1844   
;;;1845           default:
;;;1846   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1847                TRACE_OS_TASK_SEM_POST_FAILED(p_tcb);              /* Record the event.                                    */
;;;1848   #endif
;;;1849               *p_err =  OS_ERR_OPT_INVALID;
;;;1850                return (0u);
;;;1851       }
;;;1852   #endif
;;;1853   
;;;1854   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1855       ts = OS_TS_GET();                                           /* Get timestamp                                        */
00000a  f7fffffe          BL       CPU_TS_TmrRd
00000e  4680              MOV      r8,r0
;;;1856   #else
;;;1857       ts = 0u;
;;;1858   #endif
;;;1859   
;;;1860   #if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
;;;1861       if (OSIntNestingCtr > 0u) {                                 /* See if called from an ISR                            */
;;;1862           OS_IntQPost(OS_OBJ_TYPE_TASK_SIGNAL,                    /* Post to ISR queue                                    */
;;;1863                       (void      *)p_tcb,
;;;1864                       DEF_NULL,
;;;1865                       0u,
;;;1866                       0u,
;;;1867                       0u,
;;;1868                       ts,
;;;1869                       p_err);
;;;1870           return (0u);
;;;1871       }
;;;1872   #endif
;;;1873   
;;;1874   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;1875       TRACE_OS_TASK_SEM_POST(p_tcb);                              /* Record the event.                                    */
;;;1876   #endif
;;;1877   
;;;1878       ctr = OS_TaskSemPost(p_tcb,
000010  4623              MOV      r3,r4
000012  4642              MOV      r2,r8
000014  4631              MOV      r1,r6
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       OS_TaskSemPost
00001c  4607              MOV      r7,r0
;;;1879                            opt,
;;;1880                            ts,
;;;1881                            p_err);
;;;1882   
;;;1883       return (ctr);
00001e  4638              MOV      r0,r7
;;;1884   }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;1885   
                          ENDP


                          AREA ||i.OSTaskSemSet||, CODE, READONLY, ALIGN=2

                  OSTaskSemSet PROC
;;;1909   
;;;1910   OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1911                             OS_SEM_CTR   cnt,
;;;1912                             OS_ERR      *p_err)
;;;1913   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1914       OS_SEM_CTR  ctr;
;;;1915       CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;1916   
;;;1917   
;;;1918   
;;;1919   #ifdef OS_SAFETY_CRITICAL
;;;1920       if (p_err == DEF_NULL) {
;;;1921           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1922           return (0u);
;;;1923       }
;;;1924   #endif
;;;1925   
;;;1926   #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;1927       if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
00000e  481d              LDR      r0,|L12.132|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000012  b128              CBZ      r0,|L12.32|
;;;1928          *p_err = OS_ERR_SET_ISR;
000014  f64650c6          MOV      r0,#0x6dc6
000018  8028              STRH     r0,[r5,#0]
;;;1929           return (0u);
00001a  2000              MOVS     r0,#0
                  |L12.28|
;;;1930       }
;;;1931   #endif
;;;1932   
;;;1933       CPU_CRITICAL_ENTER();
;;;1934       if (p_tcb == DEF_NULL) {
;;;1935           p_tcb = OSTCBCurPtr;
;;;1936       }
;;;1937   
;;;1938       if (((p_tcb->TaskState   & OS_TASK_STATE_PEND) != 0u) &&    /* Not allowed when a task is waiting.                  */
;;;1939            (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM)) {
;;;1940           CPU_CRITICAL_EXIT();
;;;1941          *p_err = OS_ERR_TASK_WAITING;
;;;1942           return (0u);
;;;1943       }
;;;1944   
;;;1945       ctr           = p_tcb->SemCtr;
;;;1946       p_tcb->SemCtr = (OS_SEM_CTR)cnt;
;;;1947       CPU_CRITICAL_EXIT();
;;;1948      *p_err         =  OS_ERR_NONE;
;;;1949       return (ctr);
;;;1950   }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L12.32|
000020  bf00              NOP                            ;1933
000022  bf00              NOP                            ;1933
000024  f7fffffe          BL       CPU_SR_Save
000028  4680              MOV      r8,r0                 ;1933
00002a  bf00              NOP                            ;1933
00002c  f7fffffe          BL       CPU_IntDisMeasStart
000030  bf00              NOP                            ;1933
000032  b90c              CBNZ     r4,|L12.56|
000034  4814              LDR      r0,|L12.136|
000036  6804              LDR      r4,[r0,#0]            ;1935  ; OSTCBCurPtr
                  |L12.56|
000038  f8940036          LDRB     r0,[r4,#0x36]         ;1938
00003c  f0100f02          TST      r0,#2                 ;1938
000040  d011              BEQ      |L12.102|
000042  f8940034          LDRB     r0,[r4,#0x34]         ;1939
000046  2807              CMP      r0,#7                 ;1939
000048  d10d              BNE      |L12.102|
00004a  bf00              NOP                            ;1940
00004c  f7fffffe          BL       CPU_IntDisMeasStop
000050  bf00              NOP                            ;1940
000052  4640              MOV      r0,r8                 ;1940
000054  f7fffffe          BL       CPU_SR_Restore
000058  bf00              NOP                            ;1940
00005a  bf00              NOP                            ;1940
00005c  f247105f          MOV      r0,#0x715f            ;1941
000060  8028              STRH     r0,[r5,#0]            ;1941
000062  2000              MOVS     r0,#0                 ;1942
000064  e7da              B        |L12.28|
                  |L12.102|
000066  6ce6              LDR      r6,[r4,#0x4c]         ;1945
000068  64e7              STR      r7,[r4,#0x4c]         ;1946
00006a  bf00              NOP                            ;1947
00006c  f7fffffe          BL       CPU_IntDisMeasStop
000070  bf00              NOP                            ;1947
000072  4640              MOV      r0,r8                 ;1947
000074  f7fffffe          BL       CPU_SR_Restore
000078  bf00              NOP                            ;1947
00007a  bf00              NOP                            ;1947
00007c  2000              MOVS     r0,#0                 ;1948
00007e  8028              STRH     r0,[r5,#0]            ;1948
000080  4630              MOV      r0,r6                 ;1949
000082  e7cb              B        |L12.28|
;;;1951   
                          ENDP

                  |L12.132|
                          DCD      OSIntNestingCtr
                  |L12.136|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskStkChk||, CODE, READONLY, ALIGN=2

                  OSTaskStkChk PROC
;;;1981   #if (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED)
;;;1982   void  OSTaskStkChk (OS_TCB        *p_tcb,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1983                       CPU_STK_SIZE  *p_free,
;;;1984                       CPU_STK_SIZE  *p_used,
;;;1985                       OS_ERR        *p_err)
;;;1986   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;1987       CPU_STK_SIZE  free_stk;
;;;1988       CPU_STK      *p_stk;
;;;1989       CPU_SR_ALLOC();
00000c  f04f0a00          MOV      r10,#0
;;;1990   
;;;1991   
;;;1992   #ifdef OS_SAFETY_CRITICAL
;;;1993       if (p_err == DEF_NULL) {
;;;1994           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1995           return;
;;;1996       }
;;;1997   #endif
;;;1998   
;;;1999   #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;2000       if (OSIntNestingCtr > 0u) {                                 /* See if trying to check stack from ISR                */
000010  482d              LDR      r0,|L13.200|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000014  b120              CBZ      r0,|L13.32|
;;;2001          *p_err = OS_ERR_TASK_STK_CHK_ISR;
000016  f2471059          MOV      r0,#0x7159
00001a  8028              STRH     r0,[r5,#0]
                  |L13.28|
;;;2002           return;
;;;2003       }
;;;2004   #endif
;;;2005   
;;;2006   #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;2007       if (p_free == DEF_NULL) {                                   /* User must specify valid destinations for the sizes   */
;;;2008          *p_err = OS_ERR_PTR_INVALID;
;;;2009           return;
;;;2010       }
;;;2011   
;;;2012       if (p_used == DEF_NULL) {
;;;2013          *p_err = OS_ERR_PTR_INVALID;
;;;2014           return;
;;;2015       }
;;;2016   #endif
;;;2017   
;;;2018       CPU_CRITICAL_ENTER();
;;;2019       if (p_tcb == DEF_NULL) {                                    /* Check the stack of the current task?                 */
;;;2020           p_tcb = OSTCBCurPtr;                                    /* Yes                                                  */
;;;2021       }
;;;2022   
;;;2023       if (p_tcb->StkPtr == DEF_NULL) {                            /* Make sure task exist                                 */
;;;2024           CPU_CRITICAL_EXIT();
;;;2025          *p_free = 0u;
;;;2026          *p_used = 0u;
;;;2027          *p_err  = OS_ERR_TASK_NOT_EXIST;
;;;2028           return;
;;;2029       }
;;;2030   
;;;2031       if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == 0u) {             /* Make sure stack checking option is set               */
;;;2032           CPU_CRITICAL_EXIT();
;;;2033          *p_free = 0u;
;;;2034          *p_used = 0u;
;;;2035          *p_err  = OS_ERR_TASK_OPT;
;;;2036           return;
;;;2037       }
;;;2038       CPU_CRITICAL_EXIT();
;;;2039   
;;;2040       free_stk = 0u;
;;;2041   #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
;;;2042       p_stk = p_tcb->StkBasePtr;                                  /* Start at the lowest memory and go up                 */
;;;2043   #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
;;;2044       p_stk += OS_CFG_TASK_STK_REDZONE_DEPTH;
;;;2045   #endif
;;;2046       while (*p_stk == 0u) {                                      /* Compute the number of zero entries on the stk        */
;;;2047           p_stk++;
;;;2048           free_stk++;
;;;2049       }
;;;2050   #else
;;;2051       p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;            /* Start at the highest memory and go down              */
;;;2052   #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
;;;2053       p_stk -= OS_CFG_TASK_STK_REDZONE_DEPTH;
;;;2054   #endif
;;;2055       while (*p_stk == 0u) {
;;;2056           free_stk++;
;;;2057           p_stk--;
;;;2058       }
;;;2059   #endif
;;;2060   #if (OS_CFG_TASK_STK_REDZONE_EN == DEF_ENABLED)
;;;2061       free_stk -= OS_CFG_TASK_STK_REDZONE_DEPTH;                  /* Compensate for stack elements used by Redzone.       */
;;;2062   #endif
;;;2063      *p_free = free_stk;
;;;2064      *p_used = (p_tcb->StkSize - free_stk);                       /* Compute number of entries used on the stack          */
;;;2065      *p_err  = OS_ERR_NONE;
;;;2066   }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L13.32|
000020  bf00              NOP                            ;2018
000022  bf00              NOP                            ;2018
000024  f7fffffe          BL       CPU_SR_Save
000028  4682              MOV      r10,r0                ;2018
00002a  bf00              NOP                            ;2018
00002c  f7fffffe          BL       CPU_IntDisMeasStart
000030  bf00              NOP                            ;2018
000032  b90c              CBNZ     r4,|L13.56|
000034  4825              LDR      r0,|L13.204|
000036  6804              LDR      r4,[r0,#0]            ;2020  ; OSTCBCurPtr
                  |L13.56|
000038  6820              LDR      r0,[r4,#0]            ;2023
00003a  b978              CBNZ     r0,|L13.92|
00003c  bf00              NOP                            ;2024
00003e  f7fffffe          BL       CPU_IntDisMeasStop
000042  bf00              NOP                            ;2024
000044  4650              MOV      r0,r10                ;2024
000046  f7fffffe          BL       CPU_SR_Restore
00004a  bf00              NOP                            ;2024
00004c  bf00              NOP                            ;2024
00004e  2000              MOVS     r0,#0                 ;2025
000050  6030              STR      r0,[r6,#0]            ;2025
000052  6038              STR      r0,[r7,#0]            ;2026
000054  f2471052          MOV      r0,#0x7152            ;2027
000058  8028              STRH     r0,[r5,#0]            ;2027
00005a  e7df              B        |L13.28|
                  |L13.92|
00005c  f8940044          LDRB     r0,[r4,#0x44]         ;2031
000060  f0100f01          TST      r0,#1                 ;2031
000064  d10f              BNE      |L13.134|
000066  bf00              NOP                            ;2032
000068  f7fffffe          BL       CPU_IntDisMeasStop
00006c  bf00              NOP                            ;2032
00006e  4650              MOV      r0,r10                ;2032
000070  f7fffffe          BL       CPU_SR_Restore
000074  bf00              NOP                            ;2032
000076  bf00              NOP                            ;2032
000078  2000              MOVS     r0,#0                 ;2033
00007a  6030              STR      r0,[r6,#0]            ;2033
00007c  6038              STR      r0,[r7,#0]            ;2034
00007e  f2471054          MOV      r0,#0x7154            ;2035
000082  8028              STRH     r0,[r5,#0]            ;2035
000084  e7ca              B        |L13.28|
                  |L13.134|
000086  bf00              NOP                            ;2038
000088  f7fffffe          BL       CPU_IntDisMeasStop
00008c  bf00              NOP                            ;2038
00008e  4650              MOV      r0,r10                ;2038
000090  f7fffffe          BL       CPU_SR_Restore
000094  bf00              NOP                            ;2038
000096  bf00              NOP                            ;2038
000098  f04f0800          MOV      r8,#0                 ;2040
00009c  f8d49024          LDR      r9,[r4,#0x24]         ;2042
0000a0  e003              B        |L13.170|
                  |L13.162|
0000a2  f1090904          ADD      r9,r9,#4              ;2047
0000a6  f1080801          ADD      r8,r8,#1              ;2048
                  |L13.170|
0000aa  f8d90000          LDR      r0,[r9,#0]            ;2046
0000ae  2800              CMP      r0,#0                 ;2046
0000b0  d0f7              BEQ      |L13.162|
0000b2  f8c68000          STR      r8,[r6,#0]            ;2063
0000b6  6c20              LDR      r0,[r4,#0x40]         ;2064
0000b8  eba00008          SUB      r0,r0,r8              ;2064
0000bc  6038              STR      r0,[r7,#0]            ;2064
0000be  2000              MOVS     r0,#0                 ;2065
0000c0  8028              STRH     r0,[r5,#0]            ;2065
0000c2  bf00              NOP      
0000c4  e7aa              B        |L13.28|
;;;2067   #endif
                          ENDP

0000c6  0000              DCW      0x0000
                  |L13.200|
                          DCD      OSIntNestingCtr
                  |L13.204|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSuspend||, CODE, READONLY, ALIGN=2

                  OSTaskSuspend PROC
;;;2140   #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
;;;2141   void   OSTaskSuspend (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2142                         OS_ERR  *p_err)
;;;2143   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2144   #ifdef OS_SAFETY_CRITICAL
;;;2145       if (p_err == DEF_NULL) {
;;;2146           OS_SAFETY_CRITICAL_EXCEPTION();
;;;2147           return;
;;;2148       }
;;;2149   #endif
;;;2150   
;;;2151   #if (OS_CFG_ISR_POST_DEFERRED_EN   == DEF_DISABLED) && \
;;;2152       (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;2153       if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
000006  480a              LDR      r0,|L14.48|
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b118              CBZ      r0,|L14.20|
;;;2154          *p_err = OS_ERR_TASK_SUSPEND_ISR;
00000c  f247105d          MOV      r0,#0x715d
000010  8020              STRH     r0,[r4,#0]
                  |L14.18|
;;;2155           return;
;;;2156       }
;;;2157   #endif
;;;2158   
;;;2159   #if (OS_CFG_TASK_IDLE_EN == DEF_ENABLED)
;;;2160       if (p_tcb == &OSIdleTaskTCB) {                              /* Make sure not suspending the idle task               */
;;;2161          *p_err = OS_ERR_TASK_SUSPEND_IDLE;
;;;2162           return;
;;;2163       }
;;;2164   #endif
;;;2165   
;;;2166   #if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
;;;2167       if (p_tcb == &OSIntQTaskTCB) {                              /* Not allowed to suspend the ISR handler task          */
;;;2168          *p_err = OS_ERR_TASK_SUSPEND_INT_HANDLER;
;;;2169           return;
;;;2170       }
;;;2171   
;;;2172       if (OSIntNestingCtr > 0u) {                                 /* See if called from an ISR                            */
;;;2173           OS_IntQPost(OS_OBJ_TYPE_TASK_SUSPEND,                   /* Post to ISR queue                                    */
;;;2174                       (void *)p_tcb,
;;;2175                       DEF_NULL,
;;;2176                       0u,
;;;2177                       0u,
;;;2178                       0u,
;;;2179                       0u,
;;;2180                       p_err);
;;;2181           return;
;;;2182       }
;;;2183   #endif
;;;2184   
;;;2185       OS_TaskSuspend(p_tcb, p_err);
;;;2186   }
000012  bd70              POP      {r4-r6,pc}
                  |L14.20|
000014  4807              LDR      r0,|L14.52|
000016  4285              CMP      r5,r0                 ;2160
000018  d103              BNE      |L14.34|
00001a  f247105b          MOV      r0,#0x715b            ;2161
00001e  8020              STRH     r0,[r4,#0]            ;2161
000020  e7f7              B        |L14.18|
                  |L14.34|
000022  4621              MOV      r1,r4                 ;2185
000024  4628              MOV      r0,r5                 ;2185
000026  f7fffffe          BL       OS_TaskSuspend
00002a  bf00              NOP      
00002c  e7f1              B        |L14.18|
;;;2187   #endif
                          ENDP

00002e  0000              DCW      0x0000
                  |L14.48|
                          DCD      OSIntNestingCtr
                  |L14.52|
                          DCD      OSIdleTaskTCB

                          AREA ||i.OS_TaskChangePrio||, CODE, READONLY, ALIGN=2

                  OS_TaskChangePrio PROC
;;;3097   
;;;3098   void  OS_TaskChangePrio(OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3099                           OS_PRIO  prio_new)
;;;3100   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;3101       OS_TCB  *p_tcb_owner;
;;;3102   #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;3103       OS_PRIO  prio_cur;
;;;3104   #endif
;;;3105   
;;;3106   
;;;3107       do {
000008  bf00              NOP      
                  |L15.10|
;;;3108           p_tcb_owner = DEF_NULL;
00000a  2600              MOVS     r6,#0
;;;3109   #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;3110           prio_cur    = p_tcb->Prio;
00000c  f8947037          LDRB     r7,[r4,#0x37]
;;;3111   #endif
;;;3112           switch (p_tcb->TaskState) {
000010  f8940036          LDRB     r0,[r4,#0x36]
000014  2808              CMP      r0,#8
000016  d25e              BCS      |L15.214|
000018  e8dff000          TBB      [pc,r0]
00001c  04191e1f          DCB      0x04,0x19,0x1e,0x1f
000020  1a1b2021          DCB      0x1a,0x1b,0x20,0x21
;;;3113               case OS_TASK_STATE_RDY:
;;;3114                    OS_RdyListRemove(p_tcb);                       /* Remove from current priority                         */
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       OS_RdyListRemove
;;;3115                    p_tcb->Prio = prio_new;                        /* Set new task priority                                */
00002a  f8845037          STRB     r5,[r4,#0x37]
;;;3116                    OS_PrioInsert(p_tcb->Prio);
00002e  f8940037          LDRB     r0,[r4,#0x37]
000032  f7fffffe          BL       OS_PrioInsert
;;;3117                    if (p_tcb == OSTCBCurPtr) {
000036  482c              LDR      r0,|L15.232|
000038  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00003a  4284              CMP      r4,r0
00003c  d103              BNE      |L15.70|
;;;3118                        OS_RdyListInsertHead(p_tcb);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       OS_RdyListInsertHead
000044  e002              B        |L15.76|
                  |L15.70|
;;;3119                    } else {
;;;3120                        OS_RdyListInsertTail(p_tcb);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       OS_RdyListInsertTail
                  |L15.76|
;;;3121                    }
;;;3122                    break;
00004c  e045              B        |L15.218|
;;;3123   
;;;3124               case OS_TASK_STATE_DLY:                             /* Nothing to do except change the priority in the OS_TCB*/
;;;3125               case OS_TASK_STATE_SUSPENDED:
00004e  bf00              NOP      
;;;3126               case OS_TASK_STATE_DLY_SUSPENDED:
000050  bf00              NOP      
;;;3127                    p_tcb->Prio = prio_new;                        /* Set new task priority                                */
000052  f8845037          STRB     r5,[r4,#0x37]
;;;3128                    break;
000056  e040              B        |L15.218|
;;;3129   
;;;3130               case OS_TASK_STATE_PEND:
;;;3131               case OS_TASK_STATE_PEND_TIMEOUT:
000058  bf00              NOP      
;;;3132               case OS_TASK_STATE_PEND_SUSPENDED:
00005a  bf00              NOP      
;;;3133               case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00005c  bf00              NOP      
;;;3134                    p_tcb->Prio = prio_new;                        /* Set new task priority                                */
00005e  f8845037          STRB     r5,[r4,#0x37]
;;;3135                    switch (p_tcb->PendOn) {                       /* What to do depends on what we are pending on         */
000062  f8940034          LDRB     r0,[r4,#0x34]
000066  2808              CMP      r0,#8
000068  d230              BCS      |L15.204|
00006a  e8dff000          TBB      [pc,r0]
00006e  2f04              DCB      0x2f,0x04
000070  302f0a05          DCB      0x30,0x2f,0x0a,0x05
000074  0631              DCB      0x06,0x31
;;;3136                        case OS_TASK_PEND_ON_FLAG:
;;;3137   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;3138                        case OS_TASK_PEND_ON_MULTI:
;;;3139   #endif
;;;3140                        case OS_TASK_PEND_ON_Q:
000076  bf00              NOP      
;;;3141                        case OS_TASK_PEND_ON_SEM:
000078  bf00              NOP      
;;;3142                             OS_PendListChangePrio(p_tcb);
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       OS_PendListChangePrio
;;;3143                             break;
000080  e027              B        |L15.210|
;;;3144   
;;;3145                        case OS_TASK_PEND_ON_MUTEX:
;;;3146   #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;3147                             OS_PendListChangePrio(p_tcb);
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       OS_PendListChangePrio
;;;3148                             p_tcb_owner = ((OS_MUTEX *)p_tcb->PendDataTblPtr->PendObjPtr)->OwnerTCBPtr;
000088  6b20              LDR      r0,[r4,#0x30]
00008a  68c0              LDR      r0,[r0,#0xc]
00008c  6a46              LDR      r6,[r0,#0x24]
;;;3149                             if (prio_cur > prio_new) {            /* Are we increasing the priority?                      */
00008e  42af              CMP      r7,r5
000090  dd05              BLE      |L15.158|
;;;3150                                 if (p_tcb_owner->Prio <= prio_new) { /* Yes, do we need to give this prio to the owner?   */
000092  f8960037          LDRB     r0,[r6,#0x37]
000096  42a8              CMP      r0,r5
000098  dc17              BGT      |L15.202|
;;;3151                                     p_tcb_owner = DEF_NULL;
00009a  2600              MOVS     r6,#0
00009c  e015              B        |L15.202|
                  |L15.158|
;;;3152                                 } else {
;;;3153   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;3154                                    TRACE_OS_MUTEX_TASK_PRIO_INHERIT(p_tcb_owner, prio_new);
;;;3155   #endif
;;;3156                                 }
;;;3157                             } else {
;;;3158                                 if (p_tcb_owner->Prio == prio_cur) { /* No, is it required to check for a lower prio?     */
00009e  f8960037          LDRB     r0,[r6,#0x37]
0000a2  42b8              CMP      r0,r7
0000a4  d111              BNE      |L15.202|
;;;3159                                     prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
0000a6  4630              MOV      r0,r6
0000a8  f7fffffe          BL       OS_MutexGrpPrioFindHighest
0000ac  4605              MOV      r5,r0
;;;3160                                     prio_new = prio_new > p_tcb_owner->BasePrio ? p_tcb_owner->BasePrio : prio_new;
0000ae  f8960038          LDRB     r0,[r6,#0x38]
0000b2  42a8              CMP      r0,r5
0000b4  da02              BGE      |L15.188|
0000b6  f8960038          LDRB     r0,[r6,#0x38]
0000ba  e000              B        |L15.190|
                  |L15.188|
0000bc  4628              MOV      r0,r5
                  |L15.190|
0000be  4605              MOV      r5,r0
;;;3161                                     if (prio_new == p_tcb_owner->Prio) {
0000c0  f8960037          LDRB     r0,[r6,#0x37]
0000c4  42a8              CMP      r0,r5
0000c6  d100              BNE      |L15.202|
;;;3162                                         p_tcb_owner = DEF_NULL;
0000c8  2600              MOVS     r6,#0
                  |L15.202|
;;;3163                                     } else {
;;;3164   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;3165                                        TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, prio_new);
;;;3166   #endif
;;;3167                                     }
;;;3168                                 }
;;;3169                             }
;;;3170   #endif
;;;3171                            break;
0000ca  e002              B        |L15.210|
                  |L15.204|
;;;3172   
;;;3173                        case OS_TASK_PEND_ON_TASK_Q:
0000cc  bf00              NOP      
;;;3174                        case OS_TASK_PEND_ON_TASK_SEM:
0000ce  bf00              NOP      
;;;3175                        default:
;;;3176                             break;
0000d0  bf00              NOP      
                  |L15.210|
0000d2  bf00              NOP                            ;3143
;;;3177                    }
;;;3178                    break;
0000d4  e001              B        |L15.218|
                  |L15.214|
;;;3179   
;;;3180               default:
;;;3181                    return;
;;;3182           }
;;;3183           p_tcb = p_tcb_owner;
;;;3184       } while (p_tcb != DEF_NULL);
;;;3185   }
0000d6  e8bd81f0          POP      {r4-r8,pc}
                  |L15.218|
0000da  bf00              NOP                            ;3122
0000dc  4634              MOV      r4,r6                 ;3183
0000de  2c00              CMP      r4,#0                 ;3184
0000e0  d193              BNE      |L15.10|
0000e2  bf00              NOP      
0000e4  e7f7              B        |L15.214|
                          ENDP

0000e6  0000              DCW      0x0000
                  |L15.232|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TaskDbgListAdd PROC
;;;2268   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2269   void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
000000  2100              MOVS     r1,#0
;;;2270   {
;;;2271       p_tcb->DbgPrevPtr                = DEF_NULL;
000002  f8c010ac          STR      r1,[r0,#0xac]
;;;2272       if (OSTaskDbgListPtr == DEF_NULL) {
000006  4909              LDR      r1,|L16.44|
000008  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
00000a  b919              CBNZ     r1,|L16.20|
;;;2273           p_tcb->DbgNextPtr            = DEF_NULL;
00000c  2100              MOVS     r1,#0
00000e  f8c010b0          STR      r1,[r0,#0xb0]
000012  e007              B        |L16.36|
                  |L16.20|
;;;2274       } else {
;;;2275           p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
000014  4905              LDR      r1,|L16.44|
000016  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
000018  f8c010b0          STR      r1,[r0,#0xb0]
;;;2276           OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
00001c  4903              LDR      r1,|L16.44|
00001e  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
000020  f8c100ac          STR      r0,[r1,#0xac]
                  |L16.36|
;;;2277       }
;;;2278       OSTaskDbgListPtr                 =  p_tcb;
000024  4901              LDR      r1,|L16.44|
000026  6008              STR      r0,[r1,#0]  ; OSTaskDbgListPtr
;;;2279   }
000028  4770              BX       lr
;;;2280   
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      OSTaskDbgListPtr

                          AREA ||i.OS_TaskDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TaskDbgListRemove PROC
;;;2282   
;;;2283   void  OS_TaskDbgListRemove (OS_TCB  *p_tcb)
000000  f8d020ac          LDR      r2,[r0,#0xac]
;;;2284   {
;;;2285       OS_TCB  *p_tcb_next;
;;;2286       OS_TCB  *p_tcb_prev;
;;;2287   
;;;2288   
;;;2289       p_tcb_prev = p_tcb->DbgPrevPtr;
;;;2290       p_tcb_next = p_tcb->DbgNextPtr;
000004  f8d010b0          LDR      r1,[r0,#0xb0]
;;;2291   
;;;2292       if (p_tcb_prev == DEF_NULL) {
000008  b94a              CBNZ     r2,|L17.30|
;;;2293           OSTaskDbgListPtr = p_tcb_next;
00000a  4b0d              LDR      r3,|L17.64|
00000c  6019              STR      r1,[r3,#0]  ; OSTaskDbgListPtr
;;;2294           if (p_tcb_next != DEF_NULL) {
00000e  b111              CBZ      r1,|L17.22|
;;;2295               p_tcb_next->DbgPrevPtr = DEF_NULL;
000010  2300              MOVS     r3,#0
000012  f8c130ac          STR      r3,[r1,#0xac]
                  |L17.22|
;;;2296           }
;;;2297           p_tcb->DbgNextPtr = DEF_NULL;
000016  2300              MOVS     r3,#0
000018  f8c030b0          STR      r3,[r0,#0xb0]
00001c  e00f              B        |L17.62|
                  |L17.30|
;;;2298   
;;;2299       } else if (p_tcb_next == DEF_NULL) {
00001e  b929              CBNZ     r1,|L17.44|
;;;2300           p_tcb_prev->DbgNextPtr = DEF_NULL;
000020  2300              MOVS     r3,#0
000022  f8c230b0          STR      r3,[r2,#0xb0]
;;;2301           p_tcb->DbgPrevPtr      = DEF_NULL;
000026  f8c030ac          STR      r3,[r0,#0xac]
00002a  e008              B        |L17.62|
                  |L17.44|
;;;2302   
;;;2303       } else {
;;;2304           p_tcb_prev->DbgNextPtr =  p_tcb_next;
00002c  f8c210b0          STR      r1,[r2,#0xb0]
;;;2305           p_tcb_next->DbgPrevPtr =  p_tcb_prev;
000030  f8c120ac          STR      r2,[r1,#0xac]
;;;2306           p_tcb->DbgNextPtr      = DEF_NULL;
000034  2300              MOVS     r3,#0
000036  f8c030b0          STR      r3,[r0,#0xb0]
;;;2307           p_tcb->DbgPrevPtr      = DEF_NULL;
00003a  f8c030ac          STR      r3,[r0,#0xac]
                  |L17.62|
;;;2308       }
;;;2309   }
00003e  4770              BX       lr
;;;2310   #endif
                          ENDP

                  |L17.64|
                          DCD      OSTaskDbgListPtr

                          AREA ||i.OS_TaskInit||, CODE, READONLY, ALIGN=2

                  OS_TaskInit PROC
;;;2329   
;;;2330   void  OS_TaskInit (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;2331   {
;;;2332   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2333       OSTaskDbgListPtr = DEF_NULL;
000002  4a04              LDR      r2,|L18.20|
000004  6011              STR      r1,[r2,#0]  ; OSTaskDbgListPtr
;;;2334   #endif
;;;2335   
;;;2336       OSTaskQty        = 0u;                                      /* Clear the number of tasks                            */
000006  4a04              LDR      r2,|L18.24|
000008  8011              STRH     r1,[r2,#0]
;;;2337   
;;;2338   #if ((OS_CFG_TASK_PROFILE_EN == DEF_ENABLED) || (OS_CFG_DBG_EN == DEF_ENABLED))
;;;2339       OSTaskCtxSwCtr   = 0u;                                      /* Clear the context switch counter                     */
00000a  4a04              LDR      r2,|L18.28|
00000c  6011              STR      r1,[r2,#0]  ; OSTaskCtxSwCtr
;;;2340   #endif
;;;2341   
;;;2342      *p_err            = OS_ERR_NONE;
00000e  8001              STRH     r1,[r0,#0]
;;;2343   }
000010  4770              BX       lr
;;;2344   
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      OSTaskDbgListPtr
                  |L18.24|
                          DCD      OSTaskQty
                  |L18.28|
                          DCD      OSTaskCtxSwCtr

                          AREA ||i.OS_TaskInitTCB||, CODE, READONLY, ALIGN=2

                  OS_TaskInitTCB PROC
;;;2359   
;;;2360   void  OS_TaskInitTCB (OS_TCB  *p_tcb)
000000  b570              PUSH     {r4-r6,lr}
;;;2361   {
000002  4604              MOV      r4,r0
;;;2362   #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
;;;2363       OS_REG_ID   reg_id;
;;;2364   #endif
;;;2365   #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;2366       OS_TLS_ID   id;
;;;2367   #endif
;;;2368   
;;;2369   
;;;2370       p_tcb->StkPtr             = DEF_NULL;
000004  2000              MOVS     r0,#0
000006  6020              STR      r0,[r4,#0]
;;;2371   #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
;;;2372       p_tcb->StkLimitPtr        = DEF_NULL;
000008  60e0              STR      r0,[r4,#0xc]
;;;2373   #endif
;;;2374   
;;;2375       p_tcb->ExtPtr             = DEF_NULL;
00000a  6060              STR      r0,[r4,#4]
;;;2376   
;;;2377       p_tcb->NextPtr            = DEF_NULL;
00000c  6120              STR      r0,[r4,#0x10]
;;;2378       p_tcb->PrevPtr            = DEF_NULL;
00000e  6160              STR      r0,[r4,#0x14]
;;;2379   
;;;2380   #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;2381       p_tcb->TickNextPtr        = DEF_NULL;
000010  61a0              STR      r0,[r4,#0x18]
;;;2382       p_tcb->TickPrevPtr        = DEF_NULL;
000012  61e0              STR      r0,[r4,#0x1c]
;;;2383       p_tcb->TickListPtr        = DEF_NULL;
000014  6220              STR      r0,[r4,#0x20]
;;;2384   #endif
;;;2385   
;;;2386   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2387       p_tcb->NamePtr            = (CPU_CHAR *)((void *)"?Task");
000016  a023              ADR      r0,|L19.164|
000018  60a0              STR      r0,[r4,#8]
;;;2388   #endif
;;;2389   
;;;2390   #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
;;;2391       p_tcb->StkBasePtr         = DEF_NULL;
00001a  2000              MOVS     r0,#0
00001c  6260              STR      r0,[r4,#0x24]
;;;2392   #endif
;;;2393   
;;;2394   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2395       p_tcb->TaskEntryAddr      = 0u;
00001e  62a0              STR      r0,[r4,#0x28]
;;;2396       p_tcb->TaskEntryArg       = DEF_NULL;
000020  62e0              STR      r0,[r4,#0x2c]
;;;2397   #endif
;;;2398   
;;;2399   #if (OS_CFG_PEND_MULTI_EN == DEF_ENABLED)
;;;2400       p_tcb->PendDataTblPtr     = DEF_NULL;
;;;2401       p_tcb->PendDataTblEntries = 0u;
;;;2402   #endif
;;;2403   
;;;2404   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;2405       p_tcb->TS                 = 0u;
000022  64a0              STR      r0,[r4,#0x48]
;;;2406   #endif
;;;2407   
;;;2408   #if (OS_MSG_EN == DEF_ENABLED)
;;;2409       p_tcb->MsgPtr             = DEF_NULL;
000024  65a0              STR      r0,[r4,#0x58]
;;;2410       p_tcb->MsgSize            = 0u;
000026  f8a4005c          STRH     r0,[r4,#0x5c]
;;;2411   #endif
;;;2412   
;;;2413   #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
;;;2414       OS_MsgQInit(&p_tcb->MsgQ,
00002a  2100              MOVS     r1,#0
00002c  f1040060          ADD      r0,r4,#0x60
000030  f7fffffe          BL       OS_MsgQInit
;;;2415                    0u);
;;;2416   #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
;;;2417       p_tcb->MsgQPendTime       = 0u;
000034  2000              MOVS     r0,#0
000036  6720              STR      r0,[r4,#0x70]
;;;2418       p_tcb->MsgQPendTimeMax    = 0u;
000038  6760              STR      r0,[r4,#0x74]
;;;2419   #endif
;;;2420   #endif
;;;2421   
;;;2422   #if (OS_CFG_FLAG_EN == DEF_ENABLED)
;;;2423       p_tcb->FlagsPend          = 0u;
;;;2424       p_tcb->FlagsOpt           = 0u;
;;;2425       p_tcb->FlagsRdy           = 0u;
;;;2426   #endif
;;;2427   
;;;2428   #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
;;;2429       for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
00003a  2500              MOVS     r5,#0
00003c  e006              B        |L19.76|
                  |L19.62|
;;;2430           p_tcb->RegTbl[reg_id] = 0u;
00003e  2100              MOVS     r1,#0
000040  f1040078          ADD      r0,r4,#0x78
000044  f8401025          STR      r1,[r0,r5,LSL #2]
000048  1c68              ADDS     r0,r5,#1              ;2429
00004a  b2c5              UXTB     r5,r0                 ;2429
                  |L19.76|
00004c  2d00              CMP      r5,#0                 ;2429
00004e  d0f6              BEQ      |L19.62|
;;;2431       }
;;;2432   #endif
;;;2433   
;;;2434   #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;2435       for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
;;;2436           p_tcb->TLS_Tbl[id]    = 0u;
;;;2437       }
;;;2438   #endif
;;;2439   
;;;2440       p_tcb->SemCtr             = 0u;
000050  2000              MOVS     r0,#0
000052  f1040434          ADD      r4,r4,#0x34
000056  61a0              STR      r0,[r4,#0x18]
;;;2441   #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
;;;2442       p_tcb->SemPendTime        = 0u;
000058  6660              STR      r0,[r4,#0x64]
;;;2443       p_tcb->SemPendTimeMax     = 0u;
00005a  66a0              STR      r0,[r4,#0x68]
;;;2444   #endif
;;;2445   
;;;2446   #if ((OS_CFG_DBG_EN == DEF_ENABLED) || (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED))
;;;2447       p_tcb->StkSize            = 0u;
00005c  60e0              STR      r0,[r4,#0xc]
;;;2448   #endif
;;;2449   
;;;2450   
;;;2451   #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
;;;2452       p_tcb->SuspendCtr         = 0u;
00005e  f8840048          STRB     r0,[r4,#0x48]
;;;2453   #endif
;;;2454   
;;;2455   #if (OS_CFG_STAT_TASK_STK_CHK_EN == DEF_ENABLED)
;;;2456       p_tcb->StkFree            = 0u;
000062  6720              STR      r0,[r4,#0x70]
;;;2457       p_tcb->StkUsed            = 0u;
000064  66e0              STR      r0,[r4,#0x6c]
;;;2458   #endif
;;;2459   
;;;2460       p_tcb->Opt                = 0u;
000066  8220              STRH     r0,[r4,#0x10]
;;;2461   
;;;2462   #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
;;;2463       p_tcb->TickRemain         = 0u;
000068  61e0              STR      r0,[r4,#0x1c]
;;;2464       p_tcb->TickCtrPrev        = 0u;
00006a  6220              STR      r0,[r4,#0x20]
;;;2465   #endif
;;;2466   
;;;2467   #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
;;;2468       p_tcb->TimeQuanta         = 0u;
;;;2469       p_tcb->TimeQuantaCtr      = 0u;
;;;2470   #endif
;;;2471   
;;;2472   #if (OS_CFG_TASK_PROFILE_EN == DEF_ENABLED)
;;;2473       p_tcb->CPUUsage           = 0u;
00006c  f8a4004a          STRH     r0,[r4,#0x4a]
;;;2474       p_tcb->CPUUsageMax        = 0u;
000070  f8a4004c          STRH     r0,[r4,#0x4c]
;;;2475       p_tcb->CtxSwCtr           = 0u;
000074  6520              STR      r0,[r4,#0x50]
;;;2476       p_tcb->CyclesDelta        = 0u;
000076  6560              STR      r0,[r4,#0x54]
;;;2477   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;2478       p_tcb->CyclesStart        = OS_TS_GET();                    /* Read the current timestamp and save                    */
000078  f7fffffe          BL       CPU_TS_TmrRd
00007c  65a0              STR      r0,[r4,#0x58]
;;;2479   #else
;;;2480       p_tcb->CyclesStart        = 0u;
;;;2481   #endif
;;;2482       p_tcb->CyclesTotal        = 0u;
00007e  2000              MOVS     r0,#0
000080  65e0              STR      r0,[r4,#0x5c]
;;;2483   #endif
;;;2484   
;;;2485   #ifdef CPU_CFG_INT_DIS_MEAS_EN
;;;2486       p_tcb->IntDisTimeMax      = 0u;
000082  6760              STR      r0,[r4,#0x74]
;;;2487   #endif
;;;2488   #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN == DEF_ENABLED)
;;;2489       p_tcb->SchedLockTimeMax   = 0u;
;;;2490   #endif
;;;2491   
;;;2492       p_tcb->PendOn             = OS_TASK_PEND_ON_NOTHING;
000084  7020              STRB     r0,[r4,#0]
;;;2493       p_tcb->PendStatus         = OS_STATUS_PEND_OK;
000086  7060              STRB     r0,[r4,#1]
;;;2494       p_tcb->TaskState          = OS_TASK_STATE_RDY;
000088  70a0              STRB     r0,[r4,#2]
;;;2495   
;;;2496       p_tcb->Prio               = OS_PRIO_INIT;
00008a  2020              MOVS     r0,#0x20
00008c  70e0              STRB     r0,[r4,#3]
;;;2497   #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
;;;2498       p_tcb->BasePrio           = OS_PRIO_INIT;
00008e  7120              STRB     r0,[r4,#4]
;;;2499       p_tcb->MutexGrpHeadPtr    = DEF_NULL;
000090  2000              MOVS     r0,#0
000092  60a0              STR      r0,[r4,#8]
;;;2500   #endif
;;;2501   
;;;2502   #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;2503       p_tcb->DbgPrevPtr         = DEF_NULL;
000094  67a0              STR      r0,[r4,#0x78]
;;;2504       p_tcb->DbgNextPtr         = DEF_NULL;
000096  67e0              STR      r0,[r4,#0x7c]
;;;2505       p_tcb->DbgNamePtr         = (CPU_CHAR *)((void *)" ");
000098  a004              ADR      r0,|L19.172|
00009a  f8c40080          STR      r0,[r4,#0x80]
00009e  f1a40434          SUB      r4,r4,#0x34
;;;2506   #endif
;;;2507   }
0000a2  bd70              POP      {r4-r6,pc}
;;;2508   
                          ENDP

                  |L19.164|
0000a4  3f546173          DCB      "?Task",0
0000a8  6b00    
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L19.172|
0000ac  2000              DCB      " ",0
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.OS_TaskQPost||, CODE, READONLY, ALIGN=2

                  OS_TaskQPost PROC
;;;2551   #if (OS_CFG_TASK_Q_EN == DEF_ENABLED)
;;;2552   void  OS_TaskQPost (OS_TCB       *p_tcb,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2553                       void         *p_void,
;;;2554                       OS_MSG_SIZE   msg_size,
;;;2555                       OS_OPT        opt,
;;;2556                       CPU_TS        ts,
;;;2557                       OS_ERR       *p_err)
;;;2558   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9dd650a          LDRD     r6,r5,[sp,#0x28]
;;;2559       CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;2560   
;;;2561   
;;;2562   
;;;2563      *p_err = OS_ERR_NONE;                                        /* Assume we won't have any errors                      */
000014  2000              MOVS     r0,#0
000016  8028              STRH     r0,[r5,#0]
;;;2564       OS_CRITICAL_ENTER();
000018  bf00              NOP      
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_SR_Save
000020  4682              MOV      r10,r0
000022  bf00              NOP      
000024  f7fffffe          BL       CPU_IntDisMeasStart
000028  bf00              NOP      
;;;2565       if (p_tcb == DEF_NULL) {                                    /* Post msg to 'self'?                                  */
00002a  b90c              CBNZ     r4,|L20.48|
;;;2566           p_tcb = OSTCBCurPtr;
00002c  4830              LDR      r0,|L20.240|
00002e  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L20.48|
;;;2567       }
;;;2568       switch (p_tcb->TaskState) {
000030  f8940036          LDRB     r0,[r4,#0x36]
000034  2808              CMP      r0,#8
000036  d24b              BCS      |L20.208|
000038  e8dff000          TBB      [pc,r0]
00003c  04051a1b          DCB      0x04,0x05,0x1a,0x1b
000040  06071c1d          DCB      0x06,0x07,0x1c,0x1d
;;;2569           case OS_TASK_STATE_RDY:
;;;2570           case OS_TASK_STATE_DLY:
000044  bf00              NOP      
;;;2571           case OS_TASK_STATE_SUSPENDED:
000046  bf00              NOP      
;;;2572           case OS_TASK_STATE_DLY_SUSPENDED:
000048  bf00              NOP      
;;;2573                OS_MsgQPut(&p_tcb->MsgQ,                           /* Deposit the message in the queue                     */
00004a  464b              MOV      r3,r9
00004c  4642              MOV      r2,r8
00004e  4639              MOV      r1,r7
000050  f1040060          ADD      r0,r4,#0x60
000054  e9cd6500          STRD     r6,r5,[sp,#0]
000058  f7fffffe          BL       OS_MsgQPut
;;;2574                           p_void,
;;;2575                           msg_size,
;;;2576                           opt,
;;;2577                           ts,
;;;2578                           p_err);
;;;2579                OS_CRITICAL_EXIT();
00005c  bf00              NOP      
00005e  f7fffffe          BL       CPU_IntDisMeasStop
000062  bf00              NOP      
000064  4650              MOV      r0,r10
000066  f7fffffe          BL       CPU_SR_Restore
00006a  bf00              NOP      
00006c  bf00              NOP      
;;;2580                break;
00006e  e03c              B        |L20.234|
;;;2581   
;;;2582           case OS_TASK_STATE_PEND:
;;;2583           case OS_TASK_STATE_PEND_TIMEOUT:
000070  bf00              NOP      
;;;2584           case OS_TASK_STATE_PEND_SUSPENDED:
000072  bf00              NOP      
;;;2585           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
000074  bf00              NOP      
;;;2586                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) {     /* Is task waiting for a message to be sent to it?      */
000076  f8940034          LDRB     r0,[r4,#0x34]
00007a  2802              CMP      r0,#2
00007c  d115              BNE      |L20.170|
;;;2587                    OS_Post(DEF_NULL,
00007e  4643              MOV      r3,r8
000080  463a              MOV      r2,r7
000082  4621              MOV      r1,r4
000084  2000              MOVS     r0,#0
000086  9600              STR      r6,[sp,#0]
000088  f7fffffe          BL       OS_Post
;;;2588                            p_tcb,
;;;2589                            p_void,
;;;2590                            msg_size,
;;;2591                            ts);
;;;2592                    OS_CRITICAL_EXIT_NO_SCHED();
00008c  bf00              NOP      
00008e  f7fffffe          BL       CPU_IntDisMeasStop
000092  bf00              NOP      
000094  4650              MOV      r0,r10
000096  f7fffffe          BL       CPU_SR_Restore
00009a  bf00              NOP      
00009c  bf00              NOP      
;;;2593                    if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
00009e  f4194f00          TST      r9,#0x8000
0000a2  d114              BNE      |L20.206|
;;;2594                        OSSched();                                 /* Run the scheduler                                    */
0000a4  f7fffffe          BL       OSSched
0000a8  e011              B        |L20.206|
                  |L20.170|
;;;2595                    }
;;;2596                } else {
;;;2597                    OS_MsgQPut(&p_tcb->MsgQ,                       /* No,  Task is pending on something else ...           */
0000aa  464b              MOV      r3,r9
0000ac  4642              MOV      r2,r8
0000ae  4639              MOV      r1,r7
0000b0  f1040060          ADD      r0,r4,#0x60
0000b4  e9cd6500          STRD     r6,r5,[sp,#0]
0000b8  f7fffffe          BL       OS_MsgQPut
;;;2598                               p_void,                             /* ... Deposit the message in the task's queue          */
;;;2599                               msg_size,
;;;2600                               opt,
;;;2601                               ts,
;;;2602                               p_err);
;;;2603                    OS_CRITICAL_EXIT();
0000bc  bf00              NOP      
0000be  f7fffffe          BL       CPU_IntDisMeasStop
0000c2  bf00              NOP      
0000c4  4650              MOV      r0,r10
0000c6  f7fffffe          BL       CPU_SR_Restore
0000ca  bf00              NOP      
0000cc  bf00              NOP      
                  |L20.206|
;;;2604                }
;;;2605                break;
0000ce  e00c              B        |L20.234|
                  |L20.208|
;;;2606   
;;;2607           default:
;;;2608                OS_CRITICAL_EXIT();
0000d0  bf00              NOP      
0000d2  f7fffffe          BL       CPU_IntDisMeasStop
0000d6  bf00              NOP      
0000d8  4650              MOV      r0,r10
0000da  f7fffffe          BL       CPU_SR_Restore
0000de  bf00              NOP      
0000e0  bf00              NOP      
;;;2609               *p_err = OS_ERR_STATE_INVALID;
0000e2  f646602d          MOV      r0,#0x6e2d
0000e6  8028              STRH     r0,[r5,#0]
;;;2610                break;
0000e8  bf00              NOP      
                  |L20.234|
0000ea  bf00              NOP                            ;2580
;;;2611       }
;;;2612   }
0000ec  e8bd87fc          POP      {r2-r10,pc}
;;;2613   #endif
                          ENDP

                  |L20.240|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskResume||, CODE, READONLY, ALIGN=1

                  OS_TaskResume PROC
;;;2637   #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
;;;2638   void  OS_TaskResume (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2639                        OS_ERR  *p_err)
;;;2640   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2641       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;2642   
;;;2643   
;;;2644       CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_IntDisMeasStart
000018  bf00              NOP      
;;;2645      *p_err  = OS_ERR_NONE;
00001a  2000              MOVS     r0,#0
00001c  8028              STRH     r0,[r5,#0]
;;;2646       switch (p_tcb->TaskState) {
00001e  f8940036          LDRB     r0,[r4,#0x36]
000022  2808              CMP      r0,#8
000024  d268              BCS      |L21.248|
000026  e8dff000          TBB      [pc,r0]
00002a  0405              DCB      0x04,0x05
00002c  0607142b          DCB      0x06,0x07,0x14,0x2b
000030  3f53              DCB      0x3f,0x53
;;;2647           case OS_TASK_STATE_RDY:
;;;2648           case OS_TASK_STATE_DLY:
000032  bf00              NOP      
;;;2649           case OS_TASK_STATE_PEND:
000034  bf00              NOP      
;;;2650           case OS_TASK_STATE_PEND_TIMEOUT:
000036  bf00              NOP      
;;;2651                CPU_CRITICAL_EXIT();
000038  bf00              NOP      
00003a  f7fffffe          BL       CPU_IntDisMeasStop
00003e  bf00              NOP      
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       CPU_SR_Restore
000046  bf00              NOP      
000048  bf00              NOP      
;;;2652               *p_err = OS_ERR_TASK_NOT_SUSPENDED;
00004a  f2471053          MOV      r0,#0x7153
00004e  8028              STRH     r0,[r5,#0]
;;;2653                break;
000050  e05f              B        |L21.274|
;;;2654   
;;;2655           case OS_TASK_STATE_SUSPENDED:
;;;2656                OS_CRITICAL_ENTER_CPU_EXIT();
;;;2657                p_tcb->SuspendCtr--;
000052  f8140f7c          LDRB     r0,[r4,#0x7c]!
000056  1e40              SUBS     r0,r0,#1
000058  7020              STRB     r0,[r4,#0]
;;;2658                if (p_tcb->SuspendCtr == 0u) {
00005a  f814097c          LDRB     r0,[r4],#-0x7c
00005e  b928              CBNZ     r0,|L21.108|
;;;2659                    p_tcb->TaskState = OS_TASK_STATE_RDY;
000060  2000              MOVS     r0,#0
000062  f8840036          STRB     r0,[r4,#0x36]
;;;2660                    OS_RdyListInsert(p_tcb);                       /* Insert the task in the ready list                    */
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       OS_RdyListInsert
                  |L21.108|
;;;2661                }
;;;2662                OS_CRITICAL_EXIT_NO_SCHED();
00006c  bf00              NOP      
00006e  f7fffffe          BL       CPU_IntDisMeasStop
000072  bf00              NOP      
000074  4630              MOV      r0,r6
000076  f7fffffe          BL       CPU_SR_Restore
00007a  bf00              NOP      
00007c  bf00              NOP      
;;;2663                break;
00007e  e048              B        |L21.274|
;;;2664   
;;;2665           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2666                p_tcb->SuspendCtr--;
000080  f8140f7c          LDRB     r0,[r4,#0x7c]!
000084  1e40              SUBS     r0,r0,#1
000086  7020              STRB     r0,[r4,#0]
;;;2667                if (p_tcb->SuspendCtr == 0u) {
000088  f814097c          LDRB     r0,[r4],#-0x7c
00008c  b910              CBNZ     r0,|L21.148|
;;;2668                    p_tcb->TaskState = OS_TASK_STATE_DLY;
00008e  2001              MOVS     r0,#1
000090  f8840036          STRB     r0,[r4,#0x36]
                  |L21.148|
;;;2669                }
;;;2670                CPU_CRITICAL_EXIT();
000094  bf00              NOP      
000096  f7fffffe          BL       CPU_IntDisMeasStop
00009a  bf00              NOP      
00009c  4630              MOV      r0,r6
00009e  f7fffffe          BL       CPU_SR_Restore
0000a2  bf00              NOP      
0000a4  bf00              NOP      
;;;2671                break;
0000a6  e034              B        |L21.274|
;;;2672   
;;;2673           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2674                p_tcb->SuspendCtr--;
0000a8  f8140f7c          LDRB     r0,[r4,#0x7c]!
0000ac  1e40              SUBS     r0,r0,#1
0000ae  7020              STRB     r0,[r4,#0]
;;;2675                if (p_tcb->SuspendCtr == 0u) {
0000b0  f814097c          LDRB     r0,[r4],#-0x7c
0000b4  b910              CBNZ     r0,|L21.188|
;;;2676                    p_tcb->TaskState = OS_TASK_STATE_PEND;
0000b6  2002              MOVS     r0,#2
0000b8  f8840036          STRB     r0,[r4,#0x36]
                  |L21.188|
;;;2677                }
;;;2678                CPU_CRITICAL_EXIT();
0000bc  bf00              NOP      
0000be  f7fffffe          BL       CPU_IntDisMeasStop
0000c2  bf00              NOP      
0000c4  4630              MOV      r0,r6
0000c6  f7fffffe          BL       CPU_SR_Restore
0000ca  bf00              NOP      
0000cc  bf00              NOP      
;;;2679                break;
0000ce  e020              B        |L21.274|
;;;2680   
;;;2681           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2682                p_tcb->SuspendCtr--;
0000d0  f8140f7c          LDRB     r0,[r4,#0x7c]!
0000d4  1e40              SUBS     r0,r0,#1
0000d6  7020              STRB     r0,[r4,#0]
;;;2683                if (p_tcb->SuspendCtr == 0u) {
0000d8  f814097c          LDRB     r0,[r4],#-0x7c
0000dc  b910              CBNZ     r0,|L21.228|
;;;2684                    p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
0000de  2003              MOVS     r0,#3
0000e0  f8840036          STRB     r0,[r4,#0x36]
                  |L21.228|
;;;2685                }
;;;2686                CPU_CRITICAL_EXIT();
0000e4  bf00              NOP      
0000e6  f7fffffe          BL       CPU_IntDisMeasStop
0000ea  bf00              NOP      
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       CPU_SR_Restore
0000f2  bf00              NOP      
0000f4  bf00              NOP      
;;;2687                break;
0000f6  e00c              B        |L21.274|
                  |L21.248|
;;;2688   
;;;2689           default:
;;;2690                CPU_CRITICAL_EXIT();
0000f8  bf00              NOP      
0000fa  f7fffffe          BL       CPU_IntDisMeasStop
0000fe  bf00              NOP      
000100  4630              MOV      r0,r6
000102  f7fffffe          BL       CPU_SR_Restore
000106  bf00              NOP      
000108  bf00              NOP      
;;;2691               *p_err = OS_ERR_STATE_INVALID;
00010a  f646602d          MOV      r0,#0x6e2d
00010e  8028              STRH     r0,[r5,#0]
                  |L21.272|
;;;2692                return;
;;;2693       }
;;;2694   
;;;2695       OSSched();
;;;2696   }
000110  bd70              POP      {r4-r6,pc}
                  |L21.274|
000112  bf00              NOP                            ;2653
000114  f7fffffe          BL       OSSched
000118  bf00              NOP      
00011a  e7f9              B        |L21.272|
;;;2697   #endif
                          ENDP


                          AREA ||i.OS_TaskReturn||, CODE, READONLY, ALIGN=2

                  OS_TaskReturn PROC
;;;2714   
;;;2715   void  OS_TaskReturn (void)
000000  b508              PUSH     {r3,lr}
;;;2716   {
;;;2717       OS_ERR  err;
;;;2718   
;;;2719   
;;;2720   
;;;2721       OSTaskReturnHook(OSTCBCurPtr);                              /* Call hook to let user decide on what to do           */
000002  4806              LDR      r0,|L22.28|
000004  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000006  f7fffffe          BL       OSTaskReturnHook
;;;2722   #if (OS_CFG_TASK_DEL_EN == DEF_ENABLED)
;;;2723       OSTaskDel( DEF_NULL,                                        /* Delete task if it accidentally returns!              */
;;;2724                 &err);
;;;2725   #else
;;;2726       while (DEF_TRUE) {
00000a  e006              B        |L22.26|
                  |L22.12|
;;;2727           OSTimeDly(OSCfg_TickRate_Hz,
00000c  466a              MOV      r2,sp
00000e  2100              MOVS     r1,#0
000010  4803              LDR      r0,|L22.32|
000012  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000014  f7fffffe          BL       OSTimeDly
;;;2728                     OS_OPT_TIME_DLY,
;;;2729                     &err);
;;;2730           (void)err;
000018  bf00              NOP      
                  |L22.26|
00001a  e7f7              B        |L22.12|
;;;2731       }
;;;2732   #endif
;;;2733   }
;;;2734   
                          ENDP

                  |L22.28|
                          DCD      OSTCBCurPtr
                  |L22.32|
                          DCD      OSCfg_TickRate_Hz

                          AREA ||i.OS_TaskSemPost||, CODE, READONLY, ALIGN=2

                  OS_TaskSemPost PROC
;;;2765   
;;;2766   OS_SEM_CTR  OS_TaskSemPost (OS_TCB  *p_tcb,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2767                               OS_OPT   opt,
;;;2768                               CPU_TS   ts,
;;;2769                               OS_ERR  *p_err)
;;;2770   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;2771       OS_SEM_CTR  ctr;
;;;2772       CPU_SR_ALLOC();
00000c  f04f0900          MOV      r9,#0
;;;2773   
;;;2774   
;;;2775   #if (OS_CFG_TS_EN == DEF_DISABLED)
;;;2776       (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
;;;2777   #endif
;;;2778   
;;;2779       OS_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4681              MOV      r9,r0
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStart
000020  bf00              NOP      
;;;2780       if (p_tcb == DEF_NULL) {                                    /* Post signal to 'self'?                               */
000022  b90c              CBNZ     r4,|L23.40|
;;;2781           p_tcb = OSTCBCurPtr;
000024  4871              LDR      r0,|L23.492|
000026  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L23.40|
;;;2782       }
;;;2783   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;2784       p_tcb->TS = ts;
000028  64a7              STR      r7,[r4,#0x48]
;;;2785   #endif
;;;2786      *p_err     = OS_ERR_NONE;                                    /* Assume we won't have any errors                      */
00002a  2000              MOVS     r0,#0
00002c  8028              STRH     r0,[r5,#0]
;;;2787       switch (p_tcb->TaskState) {
00002e  f8940036          LDRB     r0,[r4,#0x36]
000032  2808              CMP      r0,#8
000034  d277              BCS      |L23.294|
000036  e8dff000          TBB      [pc,r0]
00003a  0405              DCB      0x04,0x05
00003c  58590607          DCB      0x58,0x59,0x06,0x07
000040  5a5b              DCB      0x5a,0x5b
;;;2788           case OS_TASK_STATE_RDY:
;;;2789           case OS_TASK_STATE_DLY:
000042  bf00              NOP      
;;;2790           case OS_TASK_STATE_SUSPENDED:
000044  bf00              NOP      
;;;2791           case OS_TASK_STATE_DLY_SUSPENDED:
000046  bf00              NOP      
;;;2792                switch (sizeof(OS_SEM_CTR)) {
000048  2004              MOVS     r0,#4
00004a  2801              CMP      r0,#1
00004c  d004              BEQ      |L23.88|
00004e  2802              CMP      r0,#2
000050  d015              BEQ      |L23.126|
000052  2804              CMP      r0,#4
000054  d139              BNE      |L23.202|
000056  e026              B        |L23.166|
                  |L23.88|
;;;2793                    case 1u:
;;;2794                         if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
000058  6ce0              LDR      r0,[r4,#0x4c]
00005a  28ff              CMP      r0,#0xff
00005c  d10e              BNE      |L23.124|
;;;2795                             OS_CRITICAL_EXIT();
00005e  bf00              NOP      
000060  f7fffffe          BL       CPU_IntDisMeasStop
000064  bf00              NOP      
000066  4648              MOV      r0,r9
000068  f7fffffe          BL       CPU_SR_Restore
00006c  bf00              NOP      
00006e  bf00              NOP      
;;;2796                            *p_err = OS_ERR_SEM_OVF;
000070  f64650c5          MOV      r0,#0x6dc5
000074  8028              STRH     r0,[r5,#0]
;;;2797                             return (0u);
000076  2000              MOVS     r0,#0
                  |L23.120|
;;;2798                         }
;;;2799                         break;
;;;2800   
;;;2801                    case 2u:
;;;2802                         if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
;;;2803                             OS_CRITICAL_EXIT();
;;;2804                            *p_err = OS_ERR_SEM_OVF;
;;;2805                             return (0u);
;;;2806                         }
;;;2807                         break;
;;;2808   
;;;2809                    case 4u:
;;;2810                         if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
;;;2811                             OS_CRITICAL_EXIT();
;;;2812                            *p_err = OS_ERR_SEM_OVF;
;;;2813                             return (0u);
;;;2814                         }
;;;2815                         break;
;;;2816   
;;;2817                    default:
;;;2818                         break;
;;;2819                }
;;;2820                p_tcb->SemCtr++;                                   /* Task signaled is not pending on anything             */
;;;2821                ctr = p_tcb->SemCtr;
;;;2822                OS_CRITICAL_EXIT();
;;;2823                break;
;;;2824   
;;;2825           case OS_TASK_STATE_PEND:
;;;2826           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2827           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2828           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2829                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?               */
;;;2830                    OS_Post(DEF_NULL,                              /* Task is pending on signal                            */
;;;2831                            p_tcb,
;;;2832                            DEF_NULL,
;;;2833                            0u,
;;;2834                            ts);
;;;2835                    ctr = p_tcb->SemCtr;
;;;2836                    OS_CRITICAL_EXIT_NO_SCHED();
;;;2837                    if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
;;;2838                        OSSched();                                 /* Run the scheduler                                    */
;;;2839                    }
;;;2840                } else {
;;;2841                    switch (sizeof(OS_SEM_CTR)) {
;;;2842                        case 1u:
;;;2843                             if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
;;;2844                                 OS_CRITICAL_EXIT();
;;;2845                                *p_err = OS_ERR_SEM_OVF;
;;;2846                                 return (0u);
;;;2847                             }
;;;2848                             break;
;;;2849   
;;;2850                        case 2u:
;;;2851                             if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
;;;2852                                 OS_CRITICAL_EXIT();
;;;2853                                *p_err = OS_ERR_SEM_OVF;
;;;2854                                 return (0u);
;;;2855                             }
;;;2856                             break;
;;;2857   
;;;2858                        case 4u:
;;;2859                             if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
;;;2860                                 OS_CRITICAL_EXIT();
;;;2861                                *p_err = OS_ERR_SEM_OVF;
;;;2862                                 return (0u);
;;;2863                             }
;;;2864                             break;
;;;2865   
;;;2866                        default:
;;;2867                             break;
;;;2868                    }
;;;2869                    p_tcb->SemCtr++;                               /* No,  Task signaled is NOT pending on semaphore ...   */
;;;2870                    ctr = p_tcb->SemCtr;                           /* ... it must be waiting on something else             */
;;;2871                    OS_CRITICAL_EXIT();
;;;2872                }
;;;2873                break;
;;;2874   
;;;2875           default:
;;;2876                OS_CRITICAL_EXIT();
;;;2877               *p_err = OS_ERR_STATE_INVALID;
;;;2878                ctr   = 0u;
;;;2879                break;
;;;2880       }
;;;2881       return (ctr);
;;;2882   }
000078  e8bd83f8          POP      {r3-r9,pc}
                  |L23.124|
00007c  e026              B        |L23.204|
                  |L23.126|
00007e  6ce0              LDR      r0,[r4,#0x4c]         ;2802
000080  f5a0417f          SUB      r1,r0,#0xff00         ;2802
000084  39ff              SUBS     r1,r1,#0xff           ;2802
000086  d10d              BNE      |L23.164|
000088  bf00              NOP                            ;2803
00008a  f7fffffe          BL       CPU_IntDisMeasStop
00008e  bf00              NOP                            ;2803
000090  4648              MOV      r0,r9                 ;2803
000092  f7fffffe          BL       CPU_SR_Restore
000096  bf00              NOP                            ;2803
000098  bf00              NOP                            ;2803
00009a  f64650c5          MOV      r0,#0x6dc5            ;2804
00009e  8028              STRH     r0,[r5,#0]            ;2804
0000a0  2000              MOVS     r0,#0                 ;2805
0000a2  e7e9              B        |L23.120|
                  |L23.164|
0000a4  e012              B        |L23.204|
                  |L23.166|
0000a6  6ce0              LDR      r0,[r4,#0x4c]         ;2810
0000a8  1c40              ADDS     r0,r0,#1              ;2810
0000aa  d10d              BNE      |L23.200|
0000ac  bf00              NOP                            ;2811
0000ae  f7fffffe          BL       CPU_IntDisMeasStop
0000b2  bf00              NOP                            ;2811
0000b4  4648              MOV      r0,r9                 ;2811
0000b6  f7fffffe          BL       CPU_SR_Restore
0000ba  bf00              NOP                            ;2811
0000bc  bf00              NOP                            ;2811
0000be  f64650c5          MOV      r0,#0x6dc5            ;2812
0000c2  8028              STRH     r0,[r5,#0]            ;2812
0000c4  2000              MOVS     r0,#0                 ;2813
0000c6  e7d7              B        |L23.120|
                  |L23.200|
0000c8  e000              B        |L23.204|
                  |L23.202|
0000ca  bf00              NOP                            ;2818
                  |L23.204|
0000cc  bf00              NOP                            ;2799
0000ce  6ce0              LDR      r0,[r4,#0x4c]         ;2820
0000d0  1c40              ADDS     r0,r0,#1              ;2820
0000d2  64e0              STR      r0,[r4,#0x4c]         ;2820
0000d4  6ce6              LDR      r6,[r4,#0x4c]         ;2821
0000d6  bf00              NOP                            ;2822
0000d8  f7fffffe          BL       CPU_IntDisMeasStop
0000dc  bf00              NOP                            ;2822
0000de  4648              MOV      r0,r9                 ;2822
0000e0  f7fffffe          BL       CPU_SR_Restore
0000e4  bf00              NOP                            ;2822
0000e6  bf00              NOP                            ;2822
0000e8  e07c              B        |L23.484|
0000ea  bf00              NOP                            ;2826
0000ec  bf00              NOP                            ;2827
0000ee  bf00              NOP                            ;2828
0000f0  f8940034          LDRB     r0,[r4,#0x34]         ;2829
0000f4  2807              CMP      r0,#7                 ;2829
0000f6  d117              BNE      |L23.296|
0000f8  2300              MOVS     r3,#0                 ;2830
0000fa  461a              MOV      r2,r3                 ;2830
0000fc  4621              MOV      r1,r4                 ;2830
0000fe  4618              MOV      r0,r3                 ;2830
000100  9700              STR      r7,[sp,#0]            ;2830
000102  f7fffffe          BL       OS_Post
000106  6ce6              LDR      r6,[r4,#0x4c]         ;2835
000108  bf00              NOP                            ;2836
00010a  f7fffffe          BL       CPU_IntDisMeasStop
00010e  bf00              NOP                            ;2836
000110  4648              MOV      r0,r9                 ;2836
000112  f7fffffe          BL       CPU_SR_Restore
000116  bf00              NOP                            ;2836
000118  bf00              NOP                            ;2836
00011a  f4184f00          TST      r8,#0x8000            ;2837
00011e  d152              BNE      |L23.454|
000120  f7fffffe          BL       OSSched
000124  e04f              B        |L23.454|
                  |L23.294|
000126  e04f              B        |L23.456|
                  |L23.296|
000128  2004              MOVS     r0,#4                 ;2841
00012a  2801              CMP      r0,#1                 ;2841
00012c  d004              BEQ      |L23.312|
00012e  2802              CMP      r0,#2                 ;2841
000130  d014              BEQ      |L23.348|
000132  2804              CMP      r0,#4                 ;2841
000134  d138              BNE      |L23.424|
000136  e025              B        |L23.388|
                  |L23.312|
000138  6ce0              LDR      r0,[r4,#0x4c]         ;2843
00013a  28ff              CMP      r0,#0xff              ;2843
00013c  d10d              BNE      |L23.346|
00013e  bf00              NOP                            ;2844
000140  f7fffffe          BL       CPU_IntDisMeasStop
000144  bf00              NOP                            ;2844
000146  4648              MOV      r0,r9                 ;2844
000148  f7fffffe          BL       CPU_SR_Restore
00014c  bf00              NOP                            ;2844
00014e  bf00              NOP                            ;2844
000150  f64650c5          MOV      r0,#0x6dc5            ;2845
000154  8028              STRH     r0,[r5,#0]            ;2845
000156  2000              MOVS     r0,#0                 ;2846
000158  e78e              B        |L23.120|
                  |L23.346|
00015a  e026              B        |L23.426|
                  |L23.348|
00015c  6ce0              LDR      r0,[r4,#0x4c]         ;2851
00015e  f5a0417f          SUB      r1,r0,#0xff00         ;2851
000162  39ff              SUBS     r1,r1,#0xff           ;2851
000164  d10d              BNE      |L23.386|
000166  bf00              NOP                            ;2852
000168  f7fffffe          BL       CPU_IntDisMeasStop
00016c  bf00              NOP                            ;2852
00016e  4648              MOV      r0,r9                 ;2852
000170  f7fffffe          BL       CPU_SR_Restore
000174  bf00              NOP                            ;2852
000176  bf00              NOP                            ;2852
000178  f64650c5          MOV      r0,#0x6dc5            ;2853
00017c  8028              STRH     r0,[r5,#0]            ;2853
00017e  2000              MOVS     r0,#0                 ;2854
000180  e77a              B        |L23.120|
                  |L23.386|
000182  e012              B        |L23.426|
                  |L23.388|
000184  6ce0              LDR      r0,[r4,#0x4c]         ;2859
000186  1c40              ADDS     r0,r0,#1              ;2859
000188  d10d              BNE      |L23.422|
00018a  bf00              NOP                            ;2860
00018c  f7fffffe          BL       CPU_IntDisMeasStop
000190  bf00              NOP                            ;2860
000192  4648              MOV      r0,r9                 ;2860
000194  f7fffffe          BL       CPU_SR_Restore
000198  bf00              NOP                            ;2860
00019a  bf00              NOP                            ;2860
00019c  f64650c5          MOV      r0,#0x6dc5            ;2861
0001a0  8028              STRH     r0,[r5,#0]            ;2861
0001a2  2000              MOVS     r0,#0                 ;2862
0001a4  e768              B        |L23.120|
                  |L23.422|
0001a6  e000              B        |L23.426|
                  |L23.424|
0001a8  bf00              NOP                            ;2867
                  |L23.426|
0001aa  bf00              NOP                            ;2848
0001ac  6ce0              LDR      r0,[r4,#0x4c]         ;2869
0001ae  1c40              ADDS     r0,r0,#1              ;2869
0001b0  64e0              STR      r0,[r4,#0x4c]         ;2869
0001b2  6ce6              LDR      r6,[r4,#0x4c]         ;2870
0001b4  bf00              NOP                            ;2871
0001b6  f7fffffe          BL       CPU_IntDisMeasStop
0001ba  bf00              NOP                            ;2871
0001bc  4648              MOV      r0,r9                 ;2871
0001be  f7fffffe          BL       CPU_SR_Restore
0001c2  bf00              NOP                            ;2871
0001c4  bf00              NOP                            ;2871
                  |L23.454|
0001c6  e00d              B        |L23.484|
                  |L23.456|
0001c8  bf00              NOP                            ;2876
0001ca  f7fffffe          BL       CPU_IntDisMeasStop
0001ce  bf00              NOP                            ;2876
0001d0  4648              MOV      r0,r9                 ;2876
0001d2  f7fffffe          BL       CPU_SR_Restore
0001d6  bf00              NOP                            ;2876
0001d8  bf00              NOP                            ;2876
0001da  f646602d          MOV      r0,#0x6e2d            ;2877
0001de  8028              STRH     r0,[r5,#0]            ;2877
0001e0  2600              MOVS     r6,#0                 ;2878
0001e2  bf00              NOP                            ;2879
                  |L23.484|
0001e4  bf00              NOP                            ;2823
0001e6  4630              MOV      r0,r6                 ;2881
0001e8  e746              B        |L23.120|
;;;2883   
                          ENDP

0001ea  0000              DCW      0x0000
                  |L23.492|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskSuspend||, CODE, READONLY, ALIGN=2

                  OS_TaskSuspend PROC
;;;2999   #if (OS_CFG_TASK_SUSPEND_EN == DEF_ENABLED)
;;;3000   void  OS_TaskSuspend (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;3001                         OS_ERR  *p_err)
;;;3002   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3003       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;3004   
;;;3005   
;;;3006       CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_IntDisMeasStart
000018  bf00              NOP      
;;;3007       if (p_tcb == DEF_NULL) {                                    /* See if specified to suspend self                     */
00001a  b994              CBNZ     r4,|L24.66|
;;;3008           if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Can't suspend self when the kernel isn't running     */
00001c  4857              LDR      r0,|L24.380|
00001e  7800              LDRB     r0,[r0,#0]  ; OSRunning
000020  2801              CMP      r0,#1
000022  d00c              BEQ      |L24.62|
;;;3009               CPU_CRITICAL_EXIT();
000024  bf00              NOP      
000026  f7fffffe          BL       CPU_IntDisMeasStop
00002a  bf00              NOP      
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       CPU_SR_Restore
000032  bf00              NOP      
000034  bf00              NOP      
;;;3010              *p_err = OS_ERR_OS_NOT_RUNNING;
000036  f6456089          MOV      r0,#0x5e89
00003a  8028              STRH     r0,[r5,#0]
                  |L24.60|
;;;3011               return;
;;;3012           }
;;;3013           p_tcb = OSTCBCurPtr;
;;;3014       }
;;;3015   
;;;3016       if (p_tcb == OSTCBCurPtr) {
;;;3017           if (OSSchedLockNestingCtr > 0u) {                       /* Can't suspend when the scheduler is locked           */
;;;3018               CPU_CRITICAL_EXIT();
;;;3019              *p_err = OS_ERR_SCHED_LOCKED;
;;;3020               return;
;;;3021           }
;;;3022       }
;;;3023   
;;;3024      *p_err = OS_ERR_NONE;
;;;3025       switch (p_tcb->TaskState) {
;;;3026           case OS_TASK_STATE_RDY:
;;;3027                OS_CRITICAL_ENTER_CPU_EXIT();
;;;3028                p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
;;;3029                p_tcb->SuspendCtr = 1u;
;;;3030                OS_RdyListRemove(p_tcb);
;;;3031                OS_CRITICAL_EXIT_NO_SCHED();
;;;3032                break;
;;;3033   
;;;3034           case OS_TASK_STATE_DLY:
;;;3035                p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
;;;3036                p_tcb->SuspendCtr = 1u;
;;;3037                CPU_CRITICAL_EXIT();
;;;3038                break;
;;;3039   
;;;3040           case OS_TASK_STATE_PEND:
;;;3041                p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
;;;3042                p_tcb->SuspendCtr = 1u;
;;;3043                CPU_CRITICAL_EXIT();
;;;3044                break;
;;;3045   
;;;3046           case OS_TASK_STATE_PEND_TIMEOUT:
;;;3047                p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
;;;3048                p_tcb->SuspendCtr = 1u;
;;;3049                CPU_CRITICAL_EXIT();
;;;3050                break;
;;;3051   
;;;3052           case OS_TASK_STATE_SUSPENDED:
;;;3053           case OS_TASK_STATE_DLY_SUSPENDED:
;;;3054           case OS_TASK_STATE_PEND_SUSPENDED:
;;;3055           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;3056   			if (p_tcb->SuspendCtr == (OS_NESTING_CTR)-1) {
;;;3057                    CPU_CRITICAL_EXIT();
;;;3058                   *p_err = OS_ERR_TASK_SUSPEND_CTR_OVF;
;;;3059                    return;
;;;3060                }
;;;3061                p_tcb->SuspendCtr++;
;;;3062                CPU_CRITICAL_EXIT();
;;;3063                break;
;;;3064   
;;;3065           default:
;;;3066                CPU_CRITICAL_EXIT();
;;;3067               *p_err = OS_ERR_STATE_INVALID;
;;;3068                return;
;;;3069       }
;;;3070   
;;;3071       if (OSRunning == OS_STATE_OS_RUNNING) {                     /* Only schedule when the kernel is running             */
;;;3072           OSSched();
;;;3073       }
;;;3074   }
00003c  bd70              POP      {r4-r6,pc}
                  |L24.62|
00003e  4850              LDR      r0,|L24.384|
000040  6804              LDR      r4,[r0,#0]            ;3013  ; OSTCBCurPtr
                  |L24.66|
000042  484f              LDR      r0,|L24.384|
000044  6800              LDR      r0,[r0,#0]            ;3016  ; OSTCBCurPtr
000046  4284              CMP      r4,r0                 ;3016
000048  d10f              BNE      |L24.106|
00004a  484e              LDR      r0,|L24.388|
00004c  7800              LDRB     r0,[r0,#0]            ;3017  ; OSSchedLockNestingCtr
00004e  b160              CBZ      r0,|L24.106|
000050  bf00              NOP                            ;3018
000052  f7fffffe          BL       CPU_IntDisMeasStop
000056  bf00              NOP                            ;3018
000058  4630              MOV      r0,r6                 ;3018
00005a  f7fffffe          BL       CPU_SR_Restore
00005e  bf00              NOP                            ;3018
000060  bf00              NOP                            ;3018
000062  f6465063          MOV      r0,#0x6d63            ;3019
000066  8028              STRH     r0,[r5,#0]            ;3019
000068  e7e8              B        |L24.60|
                  |L24.106|
00006a  2000              MOVS     r0,#0                 ;3024
00006c  8028              STRH     r0,[r5,#0]            ;3024
00006e  f8940036          LDRB     r0,[r4,#0x36]         ;3025
000072  2808              CMP      r0,#8                 ;3025
000074  d26b              BCS      |L24.334|
000076  e8dff000          TBB      [pc,r0]               ;3025
00007a  0417              DCB      0x04,0x17
00007c  27374748          DCB      0x27,0x37,0x47,0x48
000080  494a              DCB      0x49,0x4a
000082  2004              MOVS     r0,#4                 ;3028
000084  f8840036          STRB     r0,[r4,#0x36]         ;3028
000088  2001              MOVS     r0,#1                 ;3029
00008a  f884007c          STRB     r0,[r4,#0x7c]         ;3029
00008e  4620              MOV      r0,r4                 ;3030
000090  f7fffffe          BL       OS_RdyListRemove
000094  bf00              NOP                            ;3031
000096  f7fffffe          BL       CPU_IntDisMeasStop
00009a  bf00              NOP                            ;3031
00009c  4630              MOV      r0,r6                 ;3031
00009e  f7fffffe          BL       CPU_SR_Restore
0000a2  bf00              NOP                            ;3031
0000a4  bf00              NOP                            ;3031
0000a6  e05f              B        |L24.360|
0000a8  2005              MOVS     r0,#5                 ;3035
0000aa  f8840036          STRB     r0,[r4,#0x36]         ;3035
0000ae  2001              MOVS     r0,#1                 ;3036
0000b0  f884007c          STRB     r0,[r4,#0x7c]         ;3036
0000b4  bf00              NOP                            ;3037
0000b6  f7fffffe          BL       CPU_IntDisMeasStop
0000ba  bf00              NOP                            ;3037
0000bc  4630              MOV      r0,r6                 ;3037
0000be  f7fffffe          BL       CPU_SR_Restore
0000c2  bf00              NOP                            ;3037
0000c4  bf00              NOP                            ;3037
0000c6  e04f              B        |L24.360|
0000c8  2006              MOVS     r0,#6                 ;3041
0000ca  f8840036          STRB     r0,[r4,#0x36]         ;3041
0000ce  2001              MOVS     r0,#1                 ;3042
0000d0  f884007c          STRB     r0,[r4,#0x7c]         ;3042
0000d4  bf00              NOP                            ;3043
0000d6  f7fffffe          BL       CPU_IntDisMeasStop
0000da  bf00              NOP                            ;3043
0000dc  4630              MOV      r0,r6                 ;3043
0000de  f7fffffe          BL       CPU_SR_Restore
0000e2  bf00              NOP                            ;3043
0000e4  bf00              NOP                            ;3043
0000e6  e03f              B        |L24.360|
0000e8  2007              MOVS     r0,#7                 ;3047
0000ea  f8840036          STRB     r0,[r4,#0x36]         ;3047
0000ee  2001              MOVS     r0,#1                 ;3048
0000f0  f884007c          STRB     r0,[r4,#0x7c]         ;3048
0000f4  bf00              NOP                            ;3049
0000f6  f7fffffe          BL       CPU_IntDisMeasStop
0000fa  bf00              NOP                            ;3049
0000fc  4630              MOV      r0,r6                 ;3049
0000fe  f7fffffe          BL       CPU_SR_Restore
000102  bf00              NOP                            ;3049
000104  bf00              NOP                            ;3049
000106  e02f              B        |L24.360|
000108  bf00              NOP                            ;3053
00010a  bf00              NOP                            ;3054
00010c  bf00              NOP                            ;3055
00010e  f894007c          LDRB     r0,[r4,#0x7c]         ;3056
000112  28ff              CMP      r0,#0xff              ;3056
000114  d10c              BNE      |L24.304|
000116  bf00              NOP                            ;3057
000118  f7fffffe          BL       CPU_IntDisMeasStop
00011c  bf00              NOP                            ;3057
00011e  4630              MOV      r0,r6                 ;3057
000120  f7fffffe          BL       CPU_SR_Restore
000124  bf00              NOP                            ;3057
000126  bf00              NOP                            ;3057
000128  f2471060          MOV      r0,#0x7160            ;3058
00012c  8028              STRH     r0,[r5,#0]            ;3058
00012e  e785              B        |L24.60|
                  |L24.304|
000130  f894007c          LDRB     r0,[r4,#0x7c]         ;3061
000134  1c40              ADDS     r0,r0,#1              ;3061
000136  f884007c          STRB     r0,[r4,#0x7c]         ;3061
00013a  bf00              NOP                            ;3062
00013c  f7fffffe          BL       CPU_IntDisMeasStop
000140  bf00              NOP                            ;3062
000142  4630              MOV      r0,r6                 ;3062
000144  f7fffffe          BL       CPU_SR_Restore
000148  bf00              NOP                            ;3062
00014a  bf00              NOP                            ;3062
00014c  e00c              B        |L24.360|
                  |L24.334|
00014e  bf00              NOP                            ;3066
000150  f7fffffe          BL       CPU_IntDisMeasStop
000154  bf00              NOP                            ;3066
000156  4630              MOV      r0,r6                 ;3066
000158  f7fffffe          BL       CPU_SR_Restore
00015c  bf00              NOP                            ;3066
00015e  bf00              NOP                            ;3066
000160  f646602d          MOV      r0,#0x6e2d            ;3067
000164  8028              STRH     r0,[r5,#0]            ;3067
000166  e769              B        |L24.60|
                  |L24.360|
000168  bf00              NOP                            ;3032
00016a  4804              LDR      r0,|L24.380|
00016c  7800              LDRB     r0,[r0,#0]            ;3071  ; OSRunning
00016e  2801              CMP      r0,#1                 ;3071
000170  d101              BNE      |L24.374|
000172  f7fffffe          BL       OSSched
                  |L24.374|
000176  bf00              NOP      
000178  e760              B        |L24.60|
;;;3075   #endif
                          ENDP

00017a  0000              DCW      0x0000
                  |L24.380|
                          DCD      OSRunning
                  |L24.384|
                          DCD      OSTCBCurPtr
                  |L24.388|
                          DCD      OSSchedLockNestingCtr
