; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\malloc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\malloc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\malloc.crf ..\..\Malloc\malloc.c]
                          THUMB

                          AREA ||i.my_mem_free||, CODE, READONLY, ALIGN=2

                  my_mem_free PROC
;;;117    //返回值:0,释放成功;1,释放失败;  
;;;118    u8 my_mem_free(u8 memx,u32 offset)  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;119    {  
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;120        int i;  
;;;121        if(!mallco_dev.memrdy[memx])//未初始化,先执行初始化
000008  4815              LDR      r0,|L1.96|
00000a  5d00              LDRB     r0,[r0,r4]
00000c  b938              CBNZ     r0,|L1.30|
;;;122    	{
;;;123    		mallco_dev.init(memx);    
00000e  4814              LDR      r0,|L1.96|
000010  3810              SUBS     r0,r0,#0x10
000012  6801              LDR      r1,[r0,#0]  ; mallco_dev
000014  4620              MOV      r0,r4
000016  4788              BLX      r1
;;;124            return 1;//未初始化  
000018  2001              MOVS     r0,#1
                  |L1.26|
;;;125        }  
;;;126        if(offset<memsize[memx])//偏移在内存池内. 
;;;127        {  
;;;128            int index=offset/memblksize[memx];			//偏移所在内存块号码  
;;;129            int nmemb=mallco_dev.memmap[memx][index];	//内存块数量
;;;130            for(i=0;i<nmemb;i++)  						//内存块清零
;;;131            {  
;;;132                mallco_dev.memmap[memx][index+i]=0;  
;;;133            }  
;;;134            return 0;  
;;;135        }else return 2;//偏移超区了.  
;;;136    }  
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.30|
00001e  4811              LDR      r0,|L1.100|
000020  f8500024          LDR      r0,[r0,r4,LSL #2]     ;126
000024  42b0              CMP      r0,r6                 ;126
000026  d919              BLS      |L1.92|
000028  480f              LDR      r0,|L1.104|
00002a  f8500024          LDR      r0,[r0,r4,LSL #2]     ;128
00002e  fbb6f1f0          UDIV     r1,r6,r0              ;128
000032  480b              LDR      r0,|L1.96|
000034  1f00              SUBS     r0,r0,#4              ;129
000036  f8500024          LDR      r0,[r0,r4,LSL #2]     ;129
00003a  f8302011          LDRH     r2,[r0,r1,LSL #1]     ;129
00003e  2500              MOVS     r5,#0                 ;130
000040  e008              B        |L1.84|
                  |L1.66|
000042  2300              MOVS     r3,#0                 ;132
000044  4806              LDR      r0,|L1.96|
000046  1f00              SUBS     r0,r0,#4              ;132
000048  f8500024          LDR      r0,[r0,r4,LSL #2]     ;132
00004c  194f              ADDS     r7,r1,r5              ;132
00004e  f8203017          STRH     r3,[r0,r7,LSL #1]     ;132
000052  1c6d              ADDS     r5,r5,#1              ;130
                  |L1.84|
000054  4295              CMP      r5,r2                 ;130
000056  dbf4              BLT      |L1.66|
000058  2000              MOVS     r0,#0                 ;134
00005a  e7de              B        |L1.26|
                  |L1.92|
00005c  2002              MOVS     r0,#2                 ;135
00005e  e7dc              B        |L1.26|
;;;137    //释放内存(外部调用) 
                          ENDP

                  |L1.96|
                          DCD      mallco_dev+0x10
                  |L1.100|
                          DCD      memsize
                  |L1.104|
                          DCD      memblksize

                          AREA ||i.my_mem_init||, CODE, READONLY, ALIGN=2

                  my_mem_init PROC
;;;65     //memx:所属内存块
;;;66     void my_mem_init(u8 memx)  
000000  b510              PUSH     {r4,lr}
;;;67     {  
000002  4604              MOV      r4,r0
;;;68       mymemset(mallco_dev.memmap[memx], 0,memtblsize[memx]*2);//内存状态表数据清零  
000004  490c              LDR      r1,|L2.56|
000006  f8511024          LDR      r1,[r1,r4,LSL #2]
00000a  004a              LSLS     r2,r1,#1
00000c  490b              LDR      r1,|L2.60|
00000e  f8510024          LDR      r0,[r1,r4,LSL #2]
000012  2100              MOVS     r1,#0
000014  f7fffffe          BL       mymemset
;;;69     	mymemset(mallco_dev.membase[memx], 0,memsize[memx]);	  //内存池所有数据清零  
000018  4909              LDR      r1,|L2.64|
00001a  f8512024          LDR      r2,[r1,r4,LSL #2]
00001e  4907              LDR      r1,|L2.60|
000020  1f09              SUBS     r1,r1,#4
000022  f8510024          LDR      r0,[r1,r4,LSL #2]
000026  2100              MOVS     r1,#0
000028  f7fffffe          BL       mymemset
;;;70     	mallco_dev.memrdy[memx]=1;								              //内存管理初始化OK  
00002c  2101              MOVS     r1,#1
00002e  4803              LDR      r0,|L2.60|
000030  1d00              ADDS     r0,r0,#4
000032  5501              STRB     r1,[r0,r4]
;;;71     }  
000034  bd10              POP      {r4,pc}
;;;72     //获取内存使用率
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      memtblsize
                  |L2.60|
                          DCD      mallco_dev+0xc
                  |L2.64|
                          DCD      memsize

                          AREA ||i.my_mem_malloc||, CODE, READONLY, ALIGN=2

                  my_mem_malloc PROC
;;;88     //返回值:0XFFFFFFFF,代表错误;其他,内存偏移地址 
;;;89     u32 my_mem_malloc(u8 memx,u32 size)  
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;90     {  
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;91         signed long offset=0;  
000008  2500              MOVS     r5,#0
;;;92         u32         nmemb;	//需要的内存块数  
;;;93     	  u32         cmemb=0;//连续空内存块数
00000a  46a9              MOV      r9,r5
;;;94         u32         i;  
;;;95         if(!mallco_dev.memrdy[memx])mallco_dev.init(memx);//未初始化,先执行初始化 
00000c  4823              LDR      r0,|L3.156|
00000e  5d00              LDRB     r0,[r0,r4]
000010  b920              CBNZ     r0,|L3.28|
000012  4822              LDR      r0,|L3.156|
000014  3810              SUBS     r0,r0,#0x10
000016  6801              LDR      r1,[r0,#0]  ; mallco_dev
000018  4620              MOV      r0,r4
00001a  4788              BLX      r1
                  |L3.28|
;;;96         if(size==0)return 0XFFFFFFFF;//不需要分配
00001c  b91f              CBNZ     r7,|L3.38|
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L3.34|
;;;97         nmemb=size/memblksize[memx];  	//获取需要分配的连续内存块数
;;;98         if(size%memblksize[memx])nmemb++;  
;;;99         for(offset=memtblsize[memx]-1;offset>=0;offset--)//搜索整个内存控制区  
;;;100        {     
;;;101    		if(!mallco_dev.memmap[memx][offset])cmemb++;//连续空内存块数增加
;;;102    		else cmemb=0;								//连续内存块清零
;;;103    		if(cmemb==nmemb)							//找到了连续nmemb个空内存块
;;;104    		{
;;;105                for(i=0;i<nmemb;i++)  					//标注内存块非空 
;;;106                {  
;;;107                    mallco_dev.memmap[memx][offset+i]=nmemb;  
;;;108                }  
;;;109                return (offset*memblksize[memx]);//返回偏移地址  
;;;110    		}
;;;111        }  
;;;112        return 0XFFFFFFFF;//未找到符合分配条件的内存块  
;;;113    }  
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L3.38|
000026  481e              LDR      r0,|L3.160|
000028  f8500024          LDR      r0,[r0,r4,LSL #2]     ;97
00002c  fbb7f6f0          UDIV     r6,r7,r0              ;97
000030  481b              LDR      r0,|L3.160|
000032  f8500024          LDR      r0,[r0,r4,LSL #2]     ;98
000036  fbb7f1f0          UDIV     r1,r7,r0              ;98
00003a  fb007011          MLS      r0,r0,r1,r7           ;98
00003e  b100              CBZ      r0,|L3.66|
000040  1c76              ADDS     r6,r6,#1              ;98
                  |L3.66|
000042  4818              LDR      r0,|L3.164|
000044  f8500024          LDR      r0,[r0,r4,LSL #2]     ;99
000048  1e45              SUBS     r5,r0,#1              ;99
00004a  e022              B        |L3.146|
                  |L3.76|
00004c  4813              LDR      r0,|L3.156|
00004e  1f00              SUBS     r0,r0,#4              ;101
000050  f8500024          LDR      r0,[r0,r4,LSL #2]     ;101
000054  f8300015          LDRH     r0,[r0,r5,LSL #1]     ;101
000058  b910              CBNZ     r0,|L3.96|
00005a  f1090901          ADD      r9,r9,#1              ;101
00005e  e001              B        |L3.100|
                  |L3.96|
000060  f04f0900          MOV      r9,#0                 ;102
                  |L3.100|
000064  45b1              CMP      r9,r6                 ;103
000066  d113              BNE      |L3.144|
000068  f04f0800          MOV      r8,#0                 ;105
00006c  e009              B        |L3.130|
                  |L3.110|
00006e  480b              LDR      r0,|L3.156|
000070  1f00              SUBS     r0,r0,#4              ;107
000072  f8500024          LDR      r0,[r0,r4,LSL #2]     ;107
000076  eb050208          ADD      r2,r5,r8              ;107
00007a  f8206012          STRH     r6,[r0,r2,LSL #1]     ;107
00007e  f1080801          ADD      r8,r8,#1              ;105
                  |L3.130|
000082  45b0              CMP      r8,r6                 ;105
000084  d3f3              BCC      |L3.110|
000086  4806              LDR      r0,|L3.160|
000088  f8500024          LDR      r0,[r0,r4,LSL #2]     ;109
00008c  4368              MULS     r0,r5,r0              ;109
00008e  e7c8              B        |L3.34|
                  |L3.144|
000090  1e6d              SUBS     r5,r5,#1              ;99
                  |L3.146|
000092  2d00              CMP      r5,#0                 ;99
000094  dada              BGE      |L3.76|
000096  f04f30ff          MOV      r0,#0xffffffff        ;112
00009a  e7c2              B        |L3.34|
;;;114    //释放内存(内部调用) 
                          ENDP

                  |L3.156|
                          DCD      mallco_dev+0x10
                  |L3.160|
                          DCD      memblksize
                  |L3.164|
                          DCD      memtblsize

                          AREA ||i.my_mem_perused||, CODE, READONLY, ALIGN=2

                  my_mem_perused PROC
;;;74     //返回值:使用率(0~100)
;;;75     u8 my_mem_perused(u8 memx)  
000000  b510              PUSH     {r4,lr}
;;;76     {  
000002  4601              MOV      r1,r0
;;;77         u32 used=0;  
000004  2300              MOVS     r3,#0
;;;78         u32 i;  
;;;79         for(i=0;i<memtblsize[memx];i++)  
000006  2200              MOVS     r2,#0
000008  e007              B        |L4.26|
                  |L4.10|
;;;80         {  
;;;81             if(mallco_dev.memmap[memx][i])used++; 
00000a  480b              LDR      r0,|L4.56|
00000c  f8500021          LDR      r0,[r0,r1,LSL #2]
000010  f8300012          LDRH     r0,[r0,r2,LSL #1]
000014  b100              CBZ      r0,|L4.24|
000016  1c5b              ADDS     r3,r3,#1
                  |L4.24|
000018  1c52              ADDS     r2,r2,#1              ;79
                  |L4.26|
00001a  4808              LDR      r0,|L4.60|
00001c  f8500021          LDR      r0,[r0,r1,LSL #2]     ;79
000020  4290              CMP      r0,r2                 ;79
000022  d8f2              BHI      |L4.10|
;;;82         } 
;;;83         return (used*100)/(memtblsize[memx]);  
000024  2064              MOVS     r0,#0x64
000026  4358              MULS     r0,r3,r0
000028  4c04              LDR      r4,|L4.60|
00002a  f8544021          LDR      r4,[r4,r1,LSL #2]
00002e  fbb0f0f4          UDIV     r0,r0,r4
000032  b2c0              UXTB     r0,r0
;;;84     }  
000034  bd10              POP      {r4,pc}
;;;85     //内存分配(内部调用)
                          ENDP

000036  0000              DCW      0x0000
                  |L4.56|
                          DCD      mallco_dev+0xc
                  |L4.60|
                          DCD      memtblsize

                          AREA ||i.myfree||, CODE, READONLY, ALIGN=2

                  myfree PROC
;;;139    //ptr:内存首地址 
;;;140    void myfree(u8 memx,void *ptr)  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;141    {  
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;142    	CPU_SR_ALLOC(); 
000008  2700              MOVS     r7,#0
;;;143    	u32 offset;  
;;;144    	if(ptr==NULL)return;//地址为0.  
00000a  b90c              CBNZ     r4,|L5.16|
                  |L5.12|
;;;145     	//My_Printf("free:%d,%x\r\n",memx,ptr);
;;;146    	OS_CRITICAL_ENTER();		//进入临界区(无法被中断打断)     
;;;147     	offset=(u32)ptr-(u32)mallco_dev.membase[memx];  
;;;148        my_mem_free(memx,offset);	//释放内存     
;;;149    	OS_CRITICAL_EXIT();			//退出临界区(可以被中断打断) 
;;;150    }  
00000c  e8bd81f0          POP      {r4-r8,pc}
                  |L5.16|
000010  bf00              NOP                            ;146
000012  bf00              NOP                            ;146
000014  f7fffffe          BL       CPU_SR_Save
000018  4607              MOV      r7,r0                 ;146
00001a  bf00              NOP                            ;146
00001c  f7fffffe          BL       CPU_IntDisMeasStart
000020  bf00              NOP                            ;146
000022  4809              LDR      r0,|L5.72|
000024  f8500025          LDR      r0,[r0,r5,LSL #2]     ;147
000028  1a26              SUBS     r6,r4,r0              ;147
00002a  4631              MOV      r1,r6                 ;148
00002c  4628              MOV      r0,r5                 ;148
00002e  f7fffffe          BL       my_mem_free
000032  bf00              NOP                            ;149
000034  f7fffffe          BL       CPU_IntDisMeasStop
000038  bf00              NOP                            ;149
00003a  4638              MOV      r0,r7                 ;149
00003c  f7fffffe          BL       CPU_SR_Restore
000040  bf00              NOP                            ;149
000042  bf00              NOP                            ;149
000044  bf00              NOP      
000046  e7e1              B        |L5.12|
;;;151    //分配内存(外部调用)
                          ENDP

                  |L5.72|
                          DCD      mallco_dev+0x8

                          AREA ||i.mymalloc||, CODE, READONLY, ALIGN=2

                  mymalloc PROC
;;;154    //返回值:分配到的内存首地址.
;;;155    void *mymalloc(u8 memx,u32 size)  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;156    {  
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;157    	CPU_SR_ALLOC();
000008  2700              MOVS     r7,#0
;;;158      u32 offset;  
;;;159    	//My_Printf("m:%d,%d\r\n",memx,size);
;;;160    	OS_CRITICAL_ENTER();		//进入临界区(无法被中断打断)   
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  f7fffffe          BL       CPU_SR_Save
000012  4607              MOV      r7,r0
000014  bf00              NOP      
000016  f7fffffe          BL       CPU_IntDisMeasStart
00001a  bf00              NOP      
;;;161    	offset=my_mem_malloc(memx,size);  	   	
00001c  4631              MOV      r1,r6
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       my_mem_malloc
000024  4604              MOV      r4,r0
;;;162    	OS_CRITICAL_EXIT();			//退出临界区(可以被中断打断) 			   
000026  bf00              NOP      
000028  f7fffffe          BL       CPU_IntDisMeasStop
00002c  bf00              NOP      
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       CPU_SR_Restore
000034  bf00              NOP      
000036  bf00              NOP      
;;;163      if(offset==0XFFFFFFFF)return NULL;  
000038  1c60              ADDS     r0,r4,#1
00003a  d101              BNE      |L6.64|
                  |L6.60|
;;;164      else return (void*)((u32)mallco_dev.membase[memx]+offset);  
;;;165    }  
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L6.64|
000040  4802              LDR      r0,|L6.76|
000042  f8500025          LDR      r0,[r0,r5,LSL #2]     ;164
000046  4420              ADD      r0,r0,r4              ;164
000048  e7f8              B        |L6.60|
;;;166    //重新分配内存(外部调用)
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      mallco_dev+0x8

                          AREA ||i.mymemcpy||, CODE, READONLY, ALIGN=1

                  mymemcpy PROC
;;;47     //n:需要复制的内存长度(字节为单位)
;;;48     void mymemcpy(void *des,void *src,u32 n)  
000000  b570              PUSH     {r4-r6,lr}
;;;49     {  
000002  4603              MOV      r3,r0
;;;50         u8 *xdes=des;
000004  4618              MOV      r0,r3
;;;51     		u8 *xsrc=src; 
000006  460c              MOV      r4,r1
;;;52         while(n--)*xdes++=*xsrc++; 
000008  e003              B        |L7.18|
                  |L7.10|
00000a  f8145b01          LDRB     r5,[r4],#1
00000e  f8005b01          STRB     r5,[r0],#1
                  |L7.18|
000012  0015              MOVS     r5,r2
000014  f1a20201          SUB      r2,r2,#1
000018  d1f7              BNE      |L7.10|
;;;53     		*xdes++ = 0;
00001a  f8005b01          STRB     r5,[r0],#1
;;;54     }  
00001e  bd70              POP      {r4-r6,pc}
;;;55     //设置内存
                          ENDP


                          AREA ||i.mymemset||, CODE, READONLY, ALIGN=1

                  mymemset PROC
;;;58     //count:需要设置的内存大小(字节为单位)
;;;59     void mymemset(void *s,u8 c,u32 count)  
000000  b530              PUSH     {r4,r5,lr}
;;;60     {  
;;;61         u8 *xs = s;  
000002  4603              MOV      r3,r0
;;;62         while(count--)*xs++=c;  
000004  e001              B        |L8.10|
                  |L8.6|
000006  f8031b01          STRB     r1,[r3],#1
                  |L8.10|
00000a  0014              MOVS     r4,r2
00000c  f1a20201          SUB      r2,r2,#1
000010  d1f9              BNE      |L8.6|
;;;63     }	   
000012  bd30              POP      {r4,r5,pc}
;;;64     //内存管理初始化  
                          ENDP


                          AREA ||i.myrealloc||, CODE, READONLY, ALIGN=2

                  myrealloc PROC
;;;170    //返回值:新分配到的内存首地址.
;;;171    void *myrealloc(u8 memx,void *ptr,u32 size)  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;172    {  
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;173      u32 offset; 
;;;174    	CPU_SR_ALLOC(); 
00000a  f04f0800          MOV      r8,#0
;;;175    	OS_CRITICAL_ENTER();		//进入临界区(无法被中断打断)   
00000e  bf00              NOP      
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_SR_Save
000016  4680              MOV      r8,r0
000018  bf00              NOP      
00001a  f7fffffe          BL       CPU_IntDisMeasStart
00001e  bf00              NOP      
;;;176      offset=my_mem_malloc(memx,size);  
000020  4631              MOV      r1,r6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       my_mem_malloc
000028  4604              MOV      r4,r0
;;;177    	OS_CRITICAL_EXIT();			//退出临界区(可以被中断打断) 		
00002a  bf00              NOP      
00002c  f7fffffe          BL       CPU_IntDisMeasStop
000030  bf00              NOP      
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       CPU_SR_Restore
000038  bf00              NOP      
00003a  bf00              NOP      
;;;178      if(offset==0XFFFFFFFF)return NULL;     
00003c  1c60              ADDS     r0,r4,#1
00003e  d101              BNE      |L9.68|
                  |L9.64|
;;;179      else  
;;;180      {  									   
;;;181    	    mymemcpy((void*)((u32)mallco_dev.membase[memx]+offset),ptr,size);	//拷贝旧内存内容到新内存   
;;;182          myfree(memx,ptr);  											  		                    //释放旧内存
;;;183          return (void*)((u32)mallco_dev.membase[memx]+offset);  				    //返回新内存首地址
;;;184      }  
;;;185    }
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L9.68|
000044  4908              LDR      r1,|L9.104|
000046  f8511025          LDR      r1,[r1,r5,LSL #2]     ;181
00004a  1908              ADDS     r0,r1,r4              ;181
00004c  4632              MOV      r2,r6                 ;181
00004e  4639              MOV      r1,r7                 ;181
000050  f7fffffe          BL       mymemcpy
000054  4639              MOV      r1,r7                 ;182
000056  4628              MOV      r0,r5                 ;182
000058  f7fffffe          BL       myfree
00005c  4802              LDR      r0,|L9.104|
00005e  f8500025          LDR      r0,[r0,r5,LSL #2]     ;183
000062  4420              ADD      r0,r0,r4              ;183
000064  e7ec              B        |L9.64|
;;;186    
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      mallco_dev+0x8

                          AREA ||.bss||, DATA, NOINIT, ALIGN=5

                  mem1base
                          %        2560
                  mem1mapbase
                          %        160

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  memtblsize
                          DCD      0x00000050
                  memblksize
                          DCD      0x00000020
                  memsize
                          DCD      0x00000a00

                          AREA ||.data||, DATA, ALIGN=2

                  mallco_dev
                          DCD      my_mem_init
                          DCD      my_mem_perused
                          DCD      mem1base
                          DCD      mem1mapbase
000010  00000000          DCB      0x00,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Malloc\\malloc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_malloc_c_4dd4ad64____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_malloc_c_4dd4ad64____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_malloc_c_4dd4ad64____REVSH|
#line 128
|__asm___8_malloc_c_4dd4ad64____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
