; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\lib_mem.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\lib_mem.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\lib_mem.crf ..\..\uCOS-III\uC-LIB\lib_mem.c]
                          THUMB

                          AREA ||i.Mem_Clr||, CODE, READONLY, ALIGN=1

                  Mem_Clr PROC
;;;263    
;;;264    void  Mem_Clr (void        *pmem,
000000  b530              PUSH     {r4,r5,lr}
;;;265                   CPU_SIZE_T   size)
;;;266    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;267        Mem_Set(pmem,
000006  4622              MOV      r2,r4
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       Mem_Set
;;;268                0u,                                                 /* See Note #2.                                         */
;;;269                size);
;;;270    }
000010  bd30              POP      {r4,r5,pc}
;;;271    
                          ENDP


                          AREA ||i.Mem_Cmp||, CODE, READONLY, ALIGN=1

                  Mem_Cmp PROC
;;;647    
;;;648    CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;649                          const  void        *p2_mem,
;;;650                                 CPU_SIZE_T   size)
;;;651    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;652               CPU_SIZE_T    size_rem;
;;;653               CPU_ALIGN    *p1_mem_align;
;;;654               CPU_ALIGN    *p2_mem_align;
;;;655        const  CPU_INT08U   *p1_mem_08;
;;;656        const  CPU_INT08U   *p2_mem_08;
;;;657               CPU_DATA      i;
;;;658               CPU_DATA      mem_align_mod_1;
;;;659               CPU_DATA      mem_align_mod_2;
;;;660               CPU_BOOLEAN   mem_aligned;
;;;661               CPU_BOOLEAN   mem_cmp;
;;;662    
;;;663    
;;;664        if (size < 1) {                                             /* See Note #1.                                         */
00000a  b915              CBNZ     r5,|L2.18|
;;;665            return (DEF_YES);
00000c  2001              MOVS     r0,#1
                  |L2.14|
;;;666        }
;;;667        if (p1_mem == (void *)0) {
;;;668            return (DEF_NO);
;;;669        }
;;;670        if (p2_mem == (void *)0) {
;;;671            return (DEF_NO);
;;;672        }
;;;673    
;;;674    
;;;675        mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
;;;676        size_rem        =  size;
;;;677                                                                    /* Start @ end of mem bufs (see Note #2).               */
;;;678        p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
;;;679        p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
;;;680                                                                    /* See Note #4.                                         */
;;;681        mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
;;;682        mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
;;;683    
;;;684        mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
;;;685    
;;;686        if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
;;;687                                                                    /* ... optimize cmp for mem buf alignment.              */
;;;688            if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
;;;689                i = mem_align_mod_1;
;;;690                while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
;;;691                       (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
;;;692                       (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
;;;693                    p1_mem_08--;
;;;694                    p2_mem_08--;
;;;695                    if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
;;;696                         mem_cmp = DEF_NO;
;;;697                    }
;;;698                    size_rem -= sizeof(CPU_INT08U);
;;;699                    i--;
;;;700                }
;;;701            }
;;;702    
;;;703            if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
;;;704                p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3.                                         */
;;;705                p2_mem_align = (CPU_ALIGN *)p2_mem_08;
;;;706    
;;;707                while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
;;;708                       (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
;;;709                    p1_mem_align--;
;;;710                    p2_mem_align--;
;;;711                    if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
;;;712                         mem_cmp = DEF_NO;
;;;713                    }
;;;714                    size_rem -= sizeof(CPU_ALIGN);
;;;715                }
;;;716    
;;;717                p1_mem_08 = (CPU_INT08U *)p1_mem_align;
;;;718                p2_mem_08 = (CPU_INT08U *)p2_mem_align;
;;;719            }
;;;720        }
;;;721    
;;;722        while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
;;;723               (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
;;;724            p1_mem_08--;
;;;725            p2_mem_08--;
;;;726            if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
;;;727                 mem_cmp = DEF_NO;
;;;728            }
;;;729            size_rem -= sizeof(CPU_INT08U);
;;;730        }
;;;731    
;;;732        return (mem_cmp);
;;;733    }
00000e  e8bd8ff8          POP      {r3-r11,pc}
                  |L2.18|
000012  f1b80f00          CMP      r8,#0                 ;667
000016  d101              BNE      |L2.28|
000018  2000              MOVS     r0,#0                 ;668
00001a  e7f8              B        |L2.14|
                  |L2.28|
00001c  f1b90f00          CMP      r9,#0                 ;670
000020  d101              BNE      |L2.38|
000022  2000              MOVS     r0,#0                 ;671
000024  e7f3              B        |L2.14|
                  |L2.38|
000026  2401              MOVS     r4,#1                 ;675
000028  4629              MOV      r1,r5                 ;676
00002a  eb080205          ADD      r2,r8,r5              ;678
00002e  eb090305          ADD      r3,r9,r5              ;679
000032  f0020c03          AND      r12,r2,#3             ;681
000036  f0030b03          AND      r11,r3,#3             ;682
00003a  45dc              CMP      r12,r11               ;684
00003c  d101              BNE      |L2.66|
00003e  2001              MOVS     r0,#1                 ;684
000040  e000              B        |L2.68|
                  |L2.66|
000042  2000              MOVS     r0,#0                 ;684
                  |L2.68|
000044  9000              STR      r0,[sp,#0]            ;684
000046  9800              LDR      r0,[sp,#0]            ;686
000048  2801              CMP      r0,#1                 ;686
00004a  d129              BNE      |L2.160|
00004c  f1bc0f00          CMP      r12,#0                ;688
000050  d012              BEQ      |L2.120|
000052  46e2              MOV      r10,r12               ;689
000054  e00a              B        |L2.108|
                  |L2.86|
000056  1e52              SUBS     r2,r2,#1              ;693
000058  1e5b              SUBS     r3,r3,#1              ;694
00005a  7810              LDRB     r0,[r2,#0]            ;695
00005c  f893e000          LDRB     lr,[r3,#0]            ;695
000060  4570              CMP      r0,lr                 ;695
000062  d000              BEQ      |L2.102|
000064  2400              MOVS     r4,#0                 ;696
                  |L2.102|
000066  1e49              SUBS     r1,r1,#1              ;698
000068  f1aa0a01          SUB      r10,r10,#1            ;699
                  |L2.108|
00006c  2c01              CMP      r4,#1                 ;690
00006e  d103              BNE      |L2.120|
000070  b111              CBZ      r1,|L2.120|
000072  f1ba0f00          CMP      r10,#0                ;692
000076  d1ee              BNE      |L2.86|
                  |L2.120|
000078  2c01              CMP      r4,#1                 ;703
00007a  d111              BNE      |L2.160|
00007c  4616              MOV      r6,r2                 ;704
00007e  461f              MOV      r7,r3                 ;705
000080  e008              B        |L2.148|
                  |L2.130|
000082  1f36              SUBS     r6,r6,#4              ;709
000084  1f3f              SUBS     r7,r7,#4              ;710
000086  6830              LDR      r0,[r6,#0]            ;711
000088  f8d7e000          LDR      lr,[r7,#0]            ;711
00008c  4570              CMP      r0,lr                 ;711
00008e  d000              BEQ      |L2.146|
000090  2400              MOVS     r4,#0                 ;712
                  |L2.146|
000092  1f09              SUBS     r1,r1,#4              ;714
                  |L2.148|
000094  2c01              CMP      r4,#1                 ;707
000096  d101              BNE      |L2.156|
000098  2904              CMP      r1,#4                 ;708
00009a  d2f2              BCS      |L2.130|
                  |L2.156|
00009c  4632              MOV      r2,r6                 ;717
00009e  463b              MOV      r3,r7                 ;718
                  |L2.160|
0000a0  e008              B        |L2.180|
                  |L2.162|
0000a2  1e52              SUBS     r2,r2,#1              ;724
0000a4  1e5b              SUBS     r3,r3,#1              ;725
0000a6  7810              LDRB     r0,[r2,#0]            ;726
0000a8  f893e000          LDRB     lr,[r3,#0]            ;726
0000ac  4570              CMP      r0,lr                 ;726
0000ae  d000              BEQ      |L2.178|
0000b0  2400              MOVS     r4,#0                 ;727
                  |L2.178|
0000b2  1e49              SUBS     r1,r1,#1              ;729
                  |L2.180|
0000b4  2c01              CMP      r4,#1                 ;722
0000b6  d101              BNE      |L2.188|
0000b8  2900              CMP      r1,#0                 ;723
0000ba  d1f2              BNE      |L2.162|
                  |L2.188|
0000bc  4620              MOV      r0,r4                 ;732
0000be  e7a6              B        |L2.14|
;;;734    
                          ENDP


                          AREA ||i.Mem_DynPoolBlkFree||, CODE, READONLY, ALIGN=1

                  Mem_DynPoolBlkFree PROC
;;;2079   
;;;2080   void  Mem_DynPoolBlkFree (MEM_DYN_POOL  *p_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2081                             void          *p_blk,
;;;2082                             LIB_ERR       *p_err)
;;;2083   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;2084       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;2085   
;;;2086   
;;;2087   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2088       if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
;;;2089           CPU_SW_EXCEPTION(;);
;;;2090           return;
;;;2091       }
;;;2092   
;;;2093       if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
;;;2094          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;2095           return;
;;;2096       }
;;;2097   
;;;2098       if (p_blk == DEF_NULL) {
;;;2099          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;2100           return;
;;;2101       }
;;;2102   #endif
;;;2103   
;;;2104       if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {       /* Ensure pool is not full.                             */
00000c  6960              LDR      r0,[r4,#0x14]
00000e  b320              CBZ      r0,|L3.90|
;;;2105           CPU_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4607              MOV      r7,r0
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStart
000020  bf00              NOP      
;;;2106           if (p_pool->BlkAllocCnt == 0u) {
000022  69a0              LDR      r0,[r4,#0x18]
000024  b968              CBNZ     r0,|L3.66|
;;;2107               CPU_CRITICAL_EXIT();
000026  bf00              NOP      
000028  f7fffffe          BL       CPU_IntDisMeasStop
00002c  bf00              NOP      
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       CPU_SR_Restore
000034  bf00              NOP      
000036  bf00              NOP      
;;;2108   
;;;2109              *p_err = LIB_MEM_ERR_POOL_FULL;
000038  f24270dd          MOV      r0,#0x27dd
00003c  8030              STRH     r0,[r6,#0]
                  |L3.62|
;;;2110               return;
;;;2111           }
;;;2112   
;;;2113           p_pool->BlkAllocCnt--;
;;;2114           CPU_CRITICAL_EXIT();
;;;2115       }
;;;2116   
;;;2117       CPU_CRITICAL_ENTER();
;;;2118      *((void **)p_blk)   = p_pool->BlkFreePtr;
;;;2119       p_pool->BlkFreePtr = p_blk;
;;;2120       CPU_CRITICAL_EXIT();
;;;2121   
;;;2122      *p_err = LIB_MEM_ERR_NONE;
;;;2123   }
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L3.66|
000042  69a0              LDR      r0,[r4,#0x18]         ;2113
000044  1e40              SUBS     r0,r0,#1              ;2113
000046  61a0              STR      r0,[r4,#0x18]         ;2113
000048  bf00              NOP                            ;2114
00004a  f7fffffe          BL       CPU_IntDisMeasStop
00004e  bf00              NOP                            ;2114
000050  4638              MOV      r0,r7                 ;2114
000052  f7fffffe          BL       CPU_SR_Restore
000056  bf00              NOP                            ;2114
000058  bf00              NOP                            ;2114
                  |L3.90|
00005a  bf00              NOP                            ;2117
00005c  bf00              NOP                            ;2117
00005e  f7fffffe          BL       CPU_SR_Save
000062  4607              MOV      r7,r0                 ;2117
000064  bf00              NOP                            ;2117
000066  f7fffffe          BL       CPU_IntDisMeasStart
00006a  bf00              NOP                            ;2117
00006c  6920              LDR      r0,[r4,#0x10]         ;2118
00006e  6028              STR      r0,[r5,#0]            ;2118
000070  6125              STR      r5,[r4,#0x10]         ;2119
000072  bf00              NOP                            ;2120
000074  f7fffffe          BL       CPU_IntDisMeasStop
000078  bf00              NOP                            ;2120
00007a  4638              MOV      r0,r7                 ;2120
00007c  f7fffffe          BL       CPU_SR_Restore
000080  bf00              NOP                            ;2120
000082  bf00              NOP                            ;2120
000084  f2427010          MOV      r0,#0x2710            ;2122
000088  8030              STRH     r0,[r6,#0]            ;2122
00008a  bf00              NOP      
00008c  e7d7              B        |L3.62|
;;;2124   
                          ENDP


                          AREA ||i.Mem_DynPoolBlkGet||, CODE, READONLY, ALIGN=1

                  Mem_DynPoolBlkGet PROC
;;;1987   
;;;1988   void  *Mem_DynPoolBlkGet (MEM_DYN_POOL  *p_pool,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1989                             LIB_ERR       *p_err)
;;;1990   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1991              void      *p_blk;
;;;1992       const  CPU_CHAR  *p_pool_name;
;;;1993       CPU_SR_ALLOC();
000008  f04f0800          MOV      r8,#0
;;;1994   
;;;1995   
;;;1996   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1997       if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
;;;1998           CPU_SW_EXCEPTION(DEF_NULL);
;;;1999           return (DEF_NULL);
;;;2000       }
;;;2001   
;;;2002       if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
;;;2003          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;2004           return (DEF_NULL);
;;;2005       }
;;;2006   #endif
;;;2007   
;;;2008                                                                   /* Ensure pool is not empty if qty is limited.          */
;;;2009       if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
00000c  6960              LDR      r0,[r4,#0x14]
00000e  b338              CBZ      r0,|L4.96|
;;;2010           CPU_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4680              MOV      r8,r0
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStart
000020  bf00              NOP      
;;;2011           if (p_pool->BlkAllocCnt >= p_pool->BlkQtyMax) {
000022  e9d41005          LDRD     r1,r0,[r4,#0x14]
000026  4288              CMP      r0,r1
000028  d30e              BCC      |L4.72|
;;;2012               CPU_CRITICAL_EXIT();
00002a  bf00              NOP      
00002c  f7fffffe          BL       CPU_IntDisMeasStop
000030  bf00              NOP      
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       CPU_SR_Restore
000038  bf00              NOP      
00003a  bf00              NOP      
;;;2013   
;;;2014              *p_err = LIB_MEM_ERR_POOL_EMPTY;
00003c  f24270de          MOV      r0,#0x27de
000040  8028              STRH     r0,[r5,#0]
;;;2015               return (DEF_NULL);
000042  2000              MOVS     r0,#0
                  |L4.68|
;;;2016           }
;;;2017   
;;;2018           p_pool->BlkAllocCnt++;
;;;2019           CPU_CRITICAL_EXIT();
;;;2020       }
;;;2021   
;;;2022                                                                   /* --------------- ALLOC FROM FREE LIST --------------- */
;;;2023       CPU_CRITICAL_ENTER();
;;;2024       if (p_pool->BlkFreePtr != DEF_NULL) {
;;;2025           p_blk              = p_pool->BlkFreePtr;
;;;2026           p_pool->BlkFreePtr = *((void **)p_blk);
;;;2027           CPU_CRITICAL_EXIT();
;;;2028   
;;;2029          *p_err = LIB_MEM_ERR_NONE;
;;;2030   
;;;2031           return (p_blk);
;;;2032       }
;;;2033       CPU_CRITICAL_EXIT();
;;;2034   
;;;2035                                                                   /* ------------------ ALLOC NEW BLK ------------------- */
;;;2036   #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
;;;2037       p_pool_name = p_pool->NamePtr;
;;;2038   #else
;;;2039       p_pool_name = DEF_NULL;
;;;2040   #endif
;;;2041       p_blk = Mem_SegAllocInternal(p_pool_name,
;;;2042                                    p_pool->PoolSegPtr,
;;;2043                                    p_pool->BlkSize,
;;;2044                                    p_pool->BlkAlign,
;;;2045                                    p_pool->BlkPaddingAlign,
;;;2046                                    DEF_NULL,
;;;2047                                    p_err);
;;;2048       if (*p_err != LIB_MEM_ERR_NONE) {
;;;2049           return (DEF_NULL);
;;;2050       }
;;;2051   
;;;2052       return (p_blk);
;;;2053   }
000044  e8bd83fe          POP      {r1-r9,pc}
                  |L4.72|
000048  69a0              LDR      r0,[r4,#0x18]         ;2018
00004a  1c40              ADDS     r0,r0,#1              ;2018
00004c  61a0              STR      r0,[r4,#0x18]         ;2018
00004e  bf00              NOP                            ;2019
000050  f7fffffe          BL       CPU_IntDisMeasStop
000054  bf00              NOP                            ;2019
000056  4640              MOV      r0,r8                 ;2019
000058  f7fffffe          BL       CPU_SR_Restore
00005c  bf00              NOP                            ;2019
00005e  bf00              NOP                            ;2019
                  |L4.96|
000060  bf00              NOP                            ;2023
000062  bf00              NOP                            ;2023
000064  f7fffffe          BL       CPU_SR_Save
000068  4680              MOV      r8,r0                 ;2023
00006a  bf00              NOP                            ;2023
00006c  f7fffffe          BL       CPU_IntDisMeasStart
000070  bf00              NOP                            ;2023
000072  6920              LDR      r0,[r4,#0x10]         ;2024
000074  b180              CBZ      r0,|L4.152|
000076  6926              LDR      r6,[r4,#0x10]         ;2025
000078  6830              LDR      r0,[r6,#0]            ;2026
00007a  6120              STR      r0,[r4,#0x10]         ;2026
00007c  bf00              NOP                            ;2027
00007e  f7fffffe          BL       CPU_IntDisMeasStop
000082  bf00              NOP                            ;2027
000084  4640              MOV      r0,r8                 ;2027
000086  f7fffffe          BL       CPU_SR_Restore
00008a  bf00              NOP                            ;2027
00008c  bf00              NOP                            ;2027
00008e  f2427010          MOV      r0,#0x2710            ;2029
000092  8028              STRH     r0,[r5,#0]            ;2029
000094  4630              MOV      r0,r6                 ;2031
000096  e7d5              B        |L4.68|
                  |L4.152|
000098  bf00              NOP                            ;2033
00009a  f7fffffe          BL       CPU_IntDisMeasStop
00009e  bf00              NOP                            ;2033
0000a0  4640              MOV      r0,r8                 ;2033
0000a2  f7fffffe          BL       CPU_SR_Restore
0000a6  bf00              NOP                            ;2033
0000a8  bf00              NOP                            ;2033
0000aa  2700              MOVS     r7,#0                 ;2039
0000ac  2100              MOVS     r1,#0                 ;2041
0000ae  68e0              LDR      r0,[r4,#0xc]          ;2041
0000b0  e88d0023          STM      sp,{r0,r1,r5}         ;2041
0000b4  4638              MOV      r0,r7                 ;2041
0000b6  e894000e          LDM      r4,{r1-r3}            ;2041
0000ba  f7fffffe          BL       Mem_SegAllocInternal
0000be  4606              MOV      r6,r0                 ;2041
0000c0  8828              LDRH     r0,[r5,#0]            ;2048
0000c2  f5a0511c          SUB      r1,r0,#0x2700         ;2048
0000c6  3910              SUBS     r1,r1,#0x10           ;2048
0000c8  d001              BEQ      |L4.206|
0000ca  2000              MOVS     r0,#0                 ;2049
0000cc  e7ba              B        |L4.68|
                  |L4.206|
0000ce  4630              MOV      r0,r6                 ;2052
0000d0  e7b8              B        |L4.68|
;;;2054   
                          ENDP


                          AREA ||i.Mem_DynPoolBlkNbrAvailGet||, CODE, READONLY, ALIGN=1

                  Mem_DynPoolBlkNbrAvailGet PROC
;;;2150   
;;;2151   CPU_SIZE_T  Mem_DynPoolBlkNbrAvailGet (MEM_DYN_POOL  *p_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2152                                          LIB_ERR       *p_err)
;;;2153   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2154       CPU_SIZE_T  blk_nbr_avail;
;;;2155       CPU_SR_ALLOC();
000008  2700              MOVS     r7,#0
;;;2156   
;;;2157   
;;;2158   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2159       if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
;;;2160           CPU_SW_EXCEPTION(0);
;;;2161           return(0);
;;;2162       }
;;;2163   
;;;2164       if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
;;;2165          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;2166           return (0u);
;;;2167       }
;;;2168   #endif
;;;2169   
;;;2170       if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
00000a  6960              LDR      r0,[r4,#0x14]
00000c  b1c0              CBZ      r0,|L5.64|
;;;2171           CPU_CRITICAL_ENTER();
00000e  bf00              NOP      
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_SR_Save
000016  4607              MOV      r7,r0
000018  bf00              NOP      
00001a  f7fffffe          BL       CPU_IntDisMeasStart
00001e  bf00              NOP      
;;;2172           blk_nbr_avail = p_pool->BlkQtyMax - p_pool->BlkAllocCnt;
000020  e9d40105          LDRD     r0,r1,[r4,#0x14]
000024  1a46              SUBS     r6,r0,r1
;;;2173           CPU_CRITICAL_EXIT();
000026  bf00              NOP      
000028  f7fffffe          BL       CPU_IntDisMeasStop
00002c  bf00              NOP      
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       CPU_SR_Restore
000034  bf00              NOP      
000036  bf00              NOP      
;;;2174   
;;;2175          *p_err = LIB_MEM_ERR_NONE;
000038  f2427010          MOV      r0,#0x2710
00003c  8028              STRH     r0,[r5,#0]
00003e  e003              B        |L5.72|
                  |L5.64|
;;;2176       } else {
;;;2177           blk_nbr_avail = 0u;
000040  2600              MOVS     r6,#0
;;;2178          *p_err         = LIB_MEM_ERR_POOL_UNLIMITED;
000042  f24270df          MOV      r0,#0x27df
000046  8028              STRH     r0,[r5,#0]
                  |L5.72|
;;;2179       }
;;;2180   
;;;2181       return (blk_nbr_avail);
000048  4630              MOV      r0,r6
;;;2182   }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;2183   
                          ENDP


                          AREA ||i.Mem_DynPoolCreate||, CODE, READONLY, ALIGN=2

                  Mem_DynPoolCreate PROC
;;;1855   
;;;1856   void  Mem_DynPoolCreate (const  CPU_CHAR      *p_name,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1857                                   MEM_DYN_POOL  *p_pool,
;;;1858                                   MEM_SEG       *p_seg,
;;;1859                                   CPU_SIZE_T     blk_size,
;;;1860                                   CPU_SIZE_T     blk_align,
;;;1861                                   CPU_SIZE_T     blk_qty_init,
;;;1862                                   CPU_SIZE_T     blk_qty_max,
;;;1863                                   LIB_ERR       *p_err)
;;;1864   {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
00000c  461f              MOV      r7,r3
00000e  e9ddab10          LDRD     r10,r11,[sp,#0x40]
000012  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;1865       if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
000016  b904              CBNZ     r4,|L6.26|
;;;1866   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1867           p_seg = &Mem_SegHeap;
000018  4c08              LDR      r4,|L6.60|
                  |L6.26|
;;;1868   #else
;;;1869          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1870           return;
;;;1871   #endif
;;;1872       }
;;;1873   
;;;1874       Mem_DynPoolCreateInternal(p_name,
00001a  2001              MOVS     r0,#1
00001c  463b              MOV      r3,r7
00001e  4622              MOV      r2,r4
000020  4631              MOV      r1,r6
000022  e9cdab03          STRD     r10,r11,[sp,#0xc]
000026  e9cd0901          STRD     r0,r9,[sp,#4]
00002a  f8cd8000          STR      r8,[sp,#0]
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       Mem_DynPoolCreateInternal
;;;1875                                 p_pool,
;;;1876                                 p_seg,
;;;1877                                 blk_size,
;;;1878                                 blk_align,
;;;1879                                 LIB_MEM_PADDING_ALIGN_NONE,
;;;1880                                 blk_qty_init,
;;;1881                                 blk_qty_max,
;;;1882                                 p_err);
;;;1883   }
000034  b005              ADD      sp,sp,#0x14
000036  e8bd8ff0          POP      {r4-r11,pc}
;;;1884   
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_DynPoolCreateHW||, CODE, READONLY, ALIGN=2

                  Mem_DynPoolCreateHW PROC
;;;1927   
;;;1928   void  Mem_DynPoolCreateHW (const  CPU_CHAR      *p_name,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1929                                     MEM_DYN_POOL  *p_pool,
;;;1930                                     MEM_SEG       *p_seg,
;;;1931                                     CPU_SIZE_T     blk_size,
;;;1932                                     CPU_SIZE_T     blk_align,
;;;1933                                     CPU_SIZE_T     blk_qty_init,
;;;1934                                     CPU_SIZE_T     blk_qty_max,
;;;1935                                     LIB_ERR       *p_err)
;;;1936   {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
00000c  461f              MOV      r7,r3
00000e  e9ddab10          LDRD     r10,r11,[sp,#0x40]
000012  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;1937       if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
000016  b904              CBNZ     r4,|L7.26|
;;;1938   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1939           p_seg = &Mem_SegHeap;
000018  4c08              LDR      r4,|L7.60|
                  |L7.26|
;;;1940   #else
;;;1941          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1942           return;
;;;1943   #endif
;;;1944       }
;;;1945   
;;;1946       Mem_DynPoolCreateInternal(p_name,
00001a  6920              LDR      r0,[r4,#0x10]
00001c  463b              MOV      r3,r7
00001e  4622              MOV      r2,r4
000020  4631              MOV      r1,r6
000022  e9cdab03          STRD     r10,r11,[sp,#0xc]
000026  e9cd0901          STRD     r0,r9,[sp,#4]
00002a  f8cd8000          STR      r8,[sp,#0]
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       Mem_DynPoolCreateInternal
;;;1947                                 p_pool,
;;;1948                                 p_seg,
;;;1949                                 blk_size,
;;;1950                                 blk_align,
;;;1951                                 p_seg->PaddingAlign,
;;;1952                                 blk_qty_init,
;;;1953                                 blk_qty_max,
;;;1954                                 p_err);
;;;1955   }
000034  b005              ADD      sp,sp,#0x14
000036  e8bd8ff0          POP      {r4-r11,pc}
;;;1956   
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_DynPoolCreateInternal||, CODE, READONLY, ALIGN=2

                  Mem_DynPoolCreateInternal PROC
;;;2728   
;;;2729   static  void  Mem_DynPoolCreateInternal (const  CPU_CHAR      *p_name,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2730                                                   MEM_DYN_POOL  *p_pool,
;;;2731                                                   MEM_SEG       *p_seg,
;;;2732                                                   CPU_SIZE_T     blk_size,
;;;2733                                                   CPU_SIZE_T     blk_align,
;;;2734                                                   CPU_SIZE_T     blk_padding_align,
;;;2735                                                   CPU_SIZE_T     blk_qty_init,
;;;2736                                                   CPU_SIZE_T     blk_qty_max,
;;;2737                                                   LIB_ERR       *p_err)
;;;2738   {
000004  b083              SUB      sp,sp,#0xc
000006  460c              MOV      r4,r1
000008  4692              MOV      r10,r2
00000a  461d              MOV      r5,r3
00000c  f8ddb050          LDR      r11,[sp,#0x50]
000010  f8dd9048          LDR      r9,[sp,#0x48]
;;;2739       CPU_INT08U  *p_blks          = DEF_NULL;
000014  2600              MOVS     r6,#0
;;;2740       CPU_SIZE_T   blk_size_align;
;;;2741       CPU_SIZE_T   blk_align_worst = DEF_MAX(blk_align, blk_padding_align);
000016  e9dd0110          LDRD     r0,r1,[sp,#0x40]
00001a  4288              CMP      r0,r1
00001c  d901              BLS      |L8.34|
00001e  9810              LDR      r0,[sp,#0x40]
000020  e000              B        |L8.36|
                  |L8.34|
000022  9811              LDR      r0,[sp,#0x44]
                  |L8.36|
000024  4680              MOV      r8,r0
;;;2742   
;;;2743   
;;;2744   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2745       if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
;;;2746           CPU_SW_EXCEPTION(;);
;;;2747           return;
;;;2748       }
;;;2749   
;;;2750       if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
;;;2751          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;2752           return;
;;;2753       }
;;;2754   
;;;2755       if (blk_size < 1u) {                                        /* Chk for inv blk size.                                */
;;;2756          *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;2757           return;
;;;2758       }
;;;2759   
;;;2760       if ((blk_qty_max  != LIB_MEM_BLK_QTY_UNLIMITED) &&          /* Chk for invalid blk qty.                             */
;;;2761           (blk_qty_init >  blk_qty_max)) {
;;;2762          *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
;;;2763           return;
;;;2764       }
;;;2765   
;;;2766       if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk for illegal align spec.                          */
;;;2767          *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
;;;2768           return;
;;;2769       }
;;;2770   #endif
;;;2771   
;;;2772                                                                   /* Calc blk size with align.                            */
;;;2773       if (blk_size < sizeof(void *)) {                            /* If size if smaller than ptr ...                      */
000026  2d04              CMP      r5,#4
000028  d20e              BCS      |L8.72|
;;;2774                                                                   /* ... inc size to ptr size.                            */
;;;2775           blk_size_align = MATH_ROUND_INC_UP_PWR2(sizeof(void *), blk_align_worst);
00002a  f1a80001          SUB      r0,r8,#1
00002e  2104              MOVS     r1,#4
000030  ea210000          BIC      r0,r1,r0
000034  f1a80101          SUB      r1,r8,#1
000038  f0110f04          TST      r1,#4
00003c  d101              BNE      |L8.66|
00003e  2100              MOVS     r1,#0
000040  e000              B        |L8.68|
                  |L8.66|
000042  4641              MOV      r1,r8
                  |L8.68|
000044  1847              ADDS     r7,r0,r1
000046  e009              B        |L8.92|
                  |L8.72|
;;;2776       } else {
;;;2777           blk_size_align = MATH_ROUND_INC_UP_PWR2(blk_size, blk_align_worst);
000048  f1a80001          SUB      r0,r8,#1
00004c  ea250100          BIC      r1,r5,r0
000050  4228              TST      r0,r5
000052  d101              BNE      |L8.88|
000054  2000              MOVS     r0,#0
000056  e000              B        |L8.90|
                  |L8.88|
000058  4640              MOV      r0,r8
                  |L8.90|
00005a  180f              ADDS     r7,r1,r0
                  |L8.92|
;;;2778       }
;;;2779   
;;;2780       if (blk_qty_init != 0u) {                                   /* Alloc init blks.                                     */
00005c  f1b90f00          CMP      r9,#0
000060  d01b              BEQ      |L8.154|
;;;2781           p_blks = (CPU_INT08U *)Mem_SegAllocInternal(p_name,
000062  2000              MOVS     r0,#0
000064  2101              MOVS     r1,#1
000066  e9cd0b01          STRD     r0,r11,[sp,#4]
00006a  9100              STR      r1,[sp,#0]
00006c  9810              LDR      r0,[sp,#0x40]
00006e  2804              CMP      r0,#4
000070  d901              BLS      |L8.118|
;;;2782                                                       p_seg,
;;;2783                                                       blk_size_align * blk_qty_init,
;;;2784                                                       DEF_MAX(blk_align, sizeof(void *)),
000072  9810              LDR      r0,[sp,#0x40]
000074  e000              B        |L8.120|
                  |L8.118|
000076  2004              MOVS     r0,#4
                  |L8.120|
000078  4603              MOV      r3,r0
00007a  fb07f209          MUL      r2,r7,r9
00007e  4651              MOV      r1,r10
000080  9803              LDR      r0,[sp,#0xc]
000082  f7fffffe          BL       Mem_SegAllocInternal
000086  4606              MOV      r6,r0
;;;2785                                                       LIB_MEM_PADDING_ALIGN_NONE,
;;;2786                                                       DEF_NULL,
;;;2787                                                       p_err);
;;;2788           if (*p_err != LIB_MEM_ERR_NONE) {
000088  f8bb0000          LDRH     r0,[r11,#0]
00008c  f5a0511c          SUB      r1,r0,#0x2700
000090  3910              SUBS     r1,r1,#0x10
000092  d002              BEQ      |L8.154|
                  |L8.148|
;;;2789               return;
;;;2790           }
;;;2791       }
;;;2792   
;;;2793   
;;;2794                                                                   /* ----------------- CREATE POOL DATA ----------------- */
;;;2795   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;2796       p_pool->PoolSegPtr      = ((p_seg != DEF_NULL) ? p_seg : &Mem_SegHeap);
;;;2797   #else
;;;2798       p_pool->PoolSegPtr      =   p_seg;
;;;2799   #endif
;;;2800       p_pool->BlkSize         =   blk_size;
;;;2801       p_pool->BlkAlign        =   blk_align_worst;
;;;2802       p_pool->BlkPaddingAlign =   blk_padding_align;
;;;2803       p_pool->BlkQtyMax       =   blk_qty_max;
;;;2804       p_pool->BlkAllocCnt     =   0u;
;;;2805   
;;;2806       if (blk_qty_init != 0u) {                                   /* Init free list.                                      */
;;;2807           CPU_SIZE_T  i;
;;;2808   
;;;2809   
;;;2810           p_pool->BlkFreePtr = (void *)p_blks;
;;;2811           for (i = 0u; i < blk_qty_init - 1u; i++) {
;;;2812              *((void **)p_blks)  = p_blks + blk_size_align;
;;;2813               p_blks            += blk_size_align;
;;;2814           }
;;;2815          *((void **)p_blks) = DEF_NULL;
;;;2816       } else {
;;;2817           p_pool->BlkFreePtr = DEF_NULL;
;;;2818       }
;;;2819   
;;;2820   #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
;;;2821       p_pool->NamePtr = p_name;
;;;2822   #endif
;;;2823   
;;;2824      *p_err = LIB_MEM_ERR_NONE;
;;;2825   }
000094  b007              ADD      sp,sp,#0x1c
000096  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.154|
00009a  f1ba0f00          CMP      r10,#0                ;2796
00009e  d001              BEQ      |L8.164|
0000a0  4650              MOV      r0,r10                ;2796
0000a2  e000              B        |L8.166|
                  |L8.164|
0000a4  4811              LDR      r0,|L8.236|
                  |L8.166|
0000a6  6020              STR      r0,[r4,#0]            ;2796
0000a8  6065              STR      r5,[r4,#4]            ;2800
0000aa  f8c48008          STR      r8,[r4,#8]            ;2801
0000ae  9811              LDR      r0,[sp,#0x44]         ;2802
0000b0  60e0              STR      r0,[r4,#0xc]          ;2802
0000b2  9813              LDR      r0,[sp,#0x4c]         ;2803
0000b4  6160              STR      r0,[r4,#0x14]         ;2803
0000b6  2000              MOVS     r0,#0                 ;2804
0000b8  61a0              STR      r0,[r4,#0x18]         ;2804
0000ba  f1b90f00          CMP      r9,#0                 ;2806
0000be  d00d              BEQ      |L8.220|
0000c0  6126              STR      r6,[r4,#0x10]         ;2810
0000c2  bf00              NOP                            ;2811
0000c4  e003              B        |L8.206|
                  |L8.198|
0000c6  19f1              ADDS     r1,r6,r7              ;2812
0000c8  6031              STR      r1,[r6,#0]            ;2812
0000ca  443e              ADD      r6,r6,r7              ;2813
0000cc  1c40              ADDS     r0,r0,#1              ;2811
                  |L8.206|
0000ce  f1a90101          SUB      r1,r9,#1              ;2811
0000d2  4281              CMP      r1,r0                 ;2811
0000d4  d8f7              BHI      |L8.198|
0000d6  2100              MOVS     r1,#0                 ;2815
0000d8  6031              STR      r1,[r6,#0]            ;2815
0000da  e001              B        |L8.224|
                  |L8.220|
0000dc  2000              MOVS     r0,#0                 ;2817
0000de  6120              STR      r0,[r4,#0x10]         ;2817
                  |L8.224|
0000e0  f2427010          MOV      r0,#0x2710            ;2824
0000e4  f8ab0000          STRH     r0,[r11,#0]           ;2824
0000e8  bf00              NOP      
0000ea  e7d3              B        |L8.148|
;;;2826   
                          ENDP

                  |L8.236|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_HeapAlloc||, CODE, READONLY, ALIGN=2

                  Mem_HeapAlloc PROC
;;;776    #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;777    void  *Mem_HeapAlloc (CPU_SIZE_T   size,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;778                          CPU_SIZE_T   align,
;;;779                          CPU_SIZE_T  *p_bytes_reqd,
;;;780                          LIB_ERR     *p_err)
;;;781    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;782        void  *p_mem;
;;;783    
;;;784    
;;;785        p_mem = Mem_SegAllocInternal(DEF_NULL,
00000c  2001              MOVS     r0,#1
00000e  4633              MOV      r3,r6
000010  462a              MOV      r2,r5
000012  4909              LDR      r1,|L9.56|
000014  e9cd7401          STRD     r7,r4,[sp,#4]
000018  9000              STR      r0,[sp,#0]
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       Mem_SegAllocInternal
000020  4680              MOV      r8,r0
;;;786                                    &Mem_SegHeap,
;;;787                                     size,
;;;788                                     align,
;;;789                                     LIB_MEM_CFG_HEAP_PADDING_ALIGN,
;;;790                                     p_bytes_reqd,
;;;791                                     p_err);
;;;792        if (*p_err == LIB_MEM_ERR_SEG_OVF) {
000022  8820              LDRH     r0,[r4,#0]
000024  f5a0511c          SUB      r1,r0,#0x2700
000028  39d9              SUBS     r1,r1,#0xd9
00002a  d102              BNE      |L9.50|
;;;793           *p_err = LIB_MEM_ERR_HEAP_OVF;
00002c  f24270e3          MOV      r0,#0x27e3
000030  8020              STRH     r0,[r4,#0]
                  |L9.50|
;;;794        }
;;;795    
;;;796        return (p_mem);
000032  4640              MOV      r0,r8
;;;797    }
000034  e8bd83fe          POP      {r1-r9,pc}
;;;798    #endif
                          ENDP

                  |L9.56|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_HeapGetSizeRem||, CODE, READONLY, ALIGN=2

                  Mem_HeapGetSizeRem PROC
;;;828    #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;829    CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
000000  b570              PUSH     {r4-r6,lr}
;;;830                                    LIB_ERR     *p_err)
;;;831    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;832        CPU_SIZE_T  rem_size;
;;;833    
;;;834    
;;;835        rem_size = Mem_SegRemSizeGet(&Mem_SegHeap,
000006  4623              MOV      r3,r4
000008  2200              MOVS     r2,#0
00000a  4629              MOV      r1,r5
00000c  4806              LDR      r0,|L10.40|
00000e  f7fffffe          BL       Mem_SegRemSizeGet
000012  4606              MOV      r6,r0
;;;836                                      align,
;;;837                                      DEF_NULL,
;;;838                                      p_err);
;;;839        if (*p_err != LIB_MEM_ERR_NONE) {
000014  8820              LDRH     r0,[r4,#0]
000016  f5a0511c          SUB      r1,r0,#0x2700
00001a  3910              SUBS     r1,r1,#0x10
00001c  d001              BEQ      |L10.34|
;;;840            return (0u);
00001e  2000              MOVS     r0,#0
                  |L10.32|
;;;841        }
;;;842    
;;;843        return (rem_size);
;;;844    }
000020  bd70              POP      {r4-r6,pc}
                  |L10.34|
000022  4630              MOV      r0,r6                 ;843
000024  e7fc              B        |L10.32|
;;;845    #endif
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_Init||, CODE, READONLY, ALIGN=2

                  Mem_Init PROC
;;;208    
;;;209    void  Mem_Init (void)
000000  b53e              PUSH     {r1-r5,lr}
;;;210    {
;;;211    
;;;212                                                                    /* ------------------ INIT SEG LIST ------------------- */
;;;213        Mem_SegHeadPtr = DEF_NULL;
000002  2000              MOVS     r0,#0
000004  490b              LDR      r1,|L11.52|
000006  6008              STR      r0,[r1,#0]  ; Mem_SegHeadPtr
;;;214    
;;;215    #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;216        {
;;;217            LIB_ERR   err;
;;;218            CPU_ADDR  heap_base_addr;
;;;219    
;;;220    
;;;221                                                                    /* ------------------ INIT HEAP SEG ------------------- */
;;;222    #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
;;;223            heap_base_addr = LIB_MEM_CFG_HEAP_BASE_ADDR;
;;;224    #else
;;;225            heap_base_addr = (CPU_ADDR)&Mem_Heap[0u];
000008  4c0b              LDR      r4,|L11.56|
;;;226    #endif
;;;227    
;;;228            Mem_SegCreate("Heap",
00000a  a802              ADD      r0,sp,#8
00000c  2101              MOVS     r1,#1
00000e  028b              LSLS     r3,r1,#10
000010  4622              MOV      r2,r4
000012  e9cd1000          STRD     r1,r0,[sp,#0]
000016  4909              LDR      r1,|L11.60|
000018  a009              ADR      r0,|L11.64|
00001a  f7fffffe          BL       Mem_SegCreate
;;;229                          &Mem_SegHeap,                             /* Create heap seg.                                     */
;;;230                           heap_base_addr,
;;;231                           LIB_MEM_CFG_HEAP_SIZE,
;;;232                           LIB_MEM_PADDING_ALIGN_NONE,
;;;233                          &err);
;;;234            if (err != LIB_MEM_ERR_NONE) {
00001e  f8bd0008          LDRH     r0,[sp,#8]
000022  f5a0511c          SUB      r1,r0,#0x2700
000026  3910              SUBS     r1,r1,#0x10
000028  d003              BEQ      |L11.50|
;;;235                CPU_SW_EXCEPTION(;);
00002a  bf00              NOP      
00002c  f7fffffe          BL       CPU_SW_Exception
000030  bf00              NOP      
                  |L11.50|
;;;236            }
;;;237        }
;;;238    #endif
;;;239    }
000032  bd3e              POP      {r1-r5,pc}
;;;240    
                          ENDP

                  |L11.52|
                          DCD      Mem_SegHeadPtr
                  |L11.56|
                          DCD      Mem_Heap
                  |L11.60|
                          DCD      Mem_SegHeap
                  |L11.64|
000040  48656170          DCB      "Heap",0
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.Mem_Move||, CODE, READONLY, ALIGN=1

                  Mem_Move PROC
;;;523    
;;;524    void  Mem_Move (       void        *pdest,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;525                    const  void        *psrc,
;;;526                           CPU_SIZE_T   size)
;;;527    {
000004  b085              SUB      sp,sp,#0x14
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
;;;528               CPU_SIZE_T    size_rem;
;;;529               CPU_SIZE_T    mem_gap_octets;
;;;530               CPU_ALIGN    *pmem_align_dest;
;;;531        const  CPU_ALIGN    *pmem_align_src;
;;;532               CPU_INT08U   *pmem_08_dest;
;;;533        const  CPU_INT08U   *pmem_08_src;
;;;534               CPU_INT08S    i;
;;;535               CPU_DATA      mem_align_mod_dest;
;;;536               CPU_DATA      mem_align_mod_src;
;;;537               CPU_BOOLEAN   mem_aligned;
;;;538    
;;;539    
;;;540    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;541        if (size < 1) {
;;;542            return;
;;;543        }
;;;544        if (pdest == (void *)0) {
;;;545            return;
;;;546        }
;;;547        if (psrc  == (void *)0) {
;;;548            return;
;;;549        }
;;;550    #endif
;;;551    
;;;552        pmem_08_src  = (const CPU_INT08U *)psrc;
00000c  4646              MOV      r6,r8
;;;553        pmem_08_dest = (      CPU_INT08U *)pdest;
00000e  463d              MOV      r5,r7
;;;554        if (pmem_08_src > pmem_08_dest) {
000010  42ae              CMP      r6,r5
000012  d907              BLS      |L12.36|
;;;555            Mem_Copy(pdest, psrc, size);
000014  464a              MOV      r2,r9
000016  4641              MOV      r1,r8
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       Mem_Copy
                  |L12.30|
;;;556            return;
;;;557        }
;;;558    
;;;559        size_rem           =  size;
;;;560    
;;;561        pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
;;;562        pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
;;;563    
;;;564        mem_gap_octets     = pmem_08_dest - pmem_08_src;
;;;565    
;;;566    
;;;567        if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
;;;568    
;;;569                                                                    /* See Note #4.                                         */
;;;570            mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
;;;571            mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
;;;572    
;;;573            mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
;;;574    
;;;575            if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
;;;576                                                                    /* ... optimize copy for mem buf alignment.             */
;;;577                if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
;;;578                    i = mem_align_mod_dest;
;;;579                    while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
;;;580                           (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
;;;581                       *pmem_08_dest-- = *pmem_08_src--;
;;;582                        size_rem      -=  sizeof(CPU_INT08U);
;;;583                        i--;
;;;584                    }
;;;585                }
;;;586    
;;;587                                                                    /* See Note #3.                                         */
;;;588                pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
;;;589                pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
;;;590                while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
;;;591                   *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
;;;592                    size_rem         -=  sizeof(CPU_ALIGN);
;;;593                }
;;;594    
;;;595                pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
;;;596                pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
;;;597    
;;;598            }
;;;599        }
;;;600    
;;;601        while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
;;;602           *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
;;;603            size_rem      -=  sizeof(CPU_INT08U);
;;;604        }
;;;605    }
00001e  b005              ADD      sp,sp,#0x14
000020  e8bd8ff0          POP      {r4-r11,pc}
                  |L12.36|
000024  464c              MOV      r4,r9                 ;559
000026  eb070009          ADD      r0,r7,r9              ;561
00002a  1e45              SUBS     r5,r0,#1              ;561
00002c  eb080009          ADD      r0,r8,r9              ;562
000030  1e46              SUBS     r6,r0,#1              ;562
000032  1ba8              SUBS     r0,r5,r6              ;564
000034  9004              STR      r0,[sp,#0x10]         ;564
000036  9804              LDR      r0,[sp,#0x10]         ;567
000038  2804              CMP      r0,#4                 ;567
00003a  d334              BCC      |L12.166|
00003c  f0050003          AND      r0,r5,#3              ;570
000040  9002              STR      r0,[sp,#8]            ;570
000042  f0060103          AND      r1,r6,#3              ;571
000046  9101              STR      r1,[sp,#4]            ;571
000048  e9dd1001          LDRD     r1,r0,[sp,#4]         ;573
00004c  4288              CMP      r0,r1                 ;573
00004e  d101              BNE      |L12.84|
000050  2001              MOVS     r0,#1                 ;573
000052  e000              B        |L12.86|
                  |L12.84|
000054  2000              MOVS     r0,#0                 ;573
                  |L12.86|
000056  9000              STR      r0,[sp,#0]            ;573
000058  9800              LDR      r0,[sp,#0]            ;575
00005a  2801              CMP      r0,#1                 ;575
00005c  d123              BNE      |L12.166|
00005e  9802              LDR      r0,[sp,#8]            ;577
000060  2803              CMP      r0,#3                 ;577
000062  d010              BEQ      |L12.134|
000064  9802              LDR      r0,[sp,#8]            ;578
000066  b240              SXTB     r0,r0                 ;578
000068  9003              STR      r0,[sp,#0xc]          ;578
00006a  e008              B        |L12.126|
                  |L12.108|
00006c  f8160901          LDRB     r0,[r6],#-1           ;581
000070  f8050901          STRB     r0,[r5],#-1           ;581
000074  1e64              SUBS     r4,r4,#1              ;582
000076  9803              LDR      r0,[sp,#0xc]          ;583
000078  1e40              SUBS     r0,r0,#1              ;583
00007a  b240              SXTB     r0,r0                 ;583
00007c  9003              STR      r0,[sp,#0xc]          ;583
                  |L12.126|
00007e  b114              CBZ      r4,|L12.134|
000080  9803              LDR      r0,[sp,#0xc]          ;580
000082  2800              CMP      r0,#0                 ;580
000084  daf2              BGE      |L12.108|
                  |L12.134|
000086  f1a50a03          SUB      r10,r5,#3             ;588
00008a  f1a60b03          SUB      r11,r6,#3             ;589
00008e  e004              B        |L12.154|
                  |L12.144|
000090  f85b0904          LDR      r0,[r11],#-4          ;591
000094  f84a0904          STR      r0,[r10],#-4          ;591
000098  1f24              SUBS     r4,r4,#4              ;592
                  |L12.154|
00009a  2c04              CMP      r4,#4                 ;590
00009c  d2f8              BCS      |L12.144|
00009e  f10a0503          ADD      r5,r10,#3             ;595
0000a2  f10b0603          ADD      r6,r11,#3             ;596
                  |L12.166|
0000a6  e004              B        |L12.178|
                  |L12.168|
0000a8  f8160901          LDRB     r0,[r6],#-1           ;602
0000ac  f8050901          STRB     r0,[r5],#-1           ;602
0000b0  1e64              SUBS     r4,r4,#1              ;603
                  |L12.178|
0000b2  2c00              CMP      r4,#0                 ;601
0000b4  d1f8              BNE      |L12.168|
0000b6  bf00              NOP      
0000b8  e7b1              B        |L12.30|
;;;606    
                          ENDP


                          AREA ||i.Mem_PoolBlkFree||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkFree PROC
;;;1694   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1695   void  Mem_PoolBlkFree (MEM_POOL  *p_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1696                          void      *p_blk,
;;;1697                          LIB_ERR   *p_err)
;;;1698   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1699   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1700       CPU_SIZE_T   tbl_ix;
;;;1701       CPU_BOOLEAN  addr_valid;
;;;1702   #endif
;;;1703       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;1704   
;;;1705   
;;;1706   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL FREE -------------- */
;;;1707       if (p_err == DEF_NULL) {
;;;1708           CPU_SW_EXCEPTION(;);
;;;1709           return;
;;;1710       }
;;;1711   
;;;1712       if (p_pool == DEF_NULL) {                                   /* Validate mem ptrs.                                   */
;;;1713          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1714           return;
;;;1715       }
;;;1716   
;;;1717       if (p_blk == DEF_NULL) {
;;;1718          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1719           return;
;;;1720       }
;;;1721   
;;;1722       addr_valid = Mem_PoolBlkIsValidAddr(p_pool, p_blk);         /* Validate mem blk as valid pool blk addr.             */
;;;1723       if (addr_valid != DEF_OK) {
;;;1724          *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR;
;;;1725           return;
;;;1726       }
;;;1727   
;;;1728       CPU_CRITICAL_ENTER();                                       /* Make sure blk isn't already in free list.            */
;;;1729       for (tbl_ix = 0u; tbl_ix < p_pool->BlkNbr; tbl_ix++) {
;;;1730           if (p_pool->BlkFreeTbl[tbl_ix] == p_blk) {
;;;1731               CPU_CRITICAL_EXIT();
;;;1732              *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
;;;1733               return;
;;;1734           }
;;;1735       }
;;;1736   #else                                                           /* Double-free possibility if not in critical section.  */
;;;1737       CPU_CRITICAL_ENTER();
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_SR_Save
000014  4607              MOV      r7,r0
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_IntDisMeasStart
00001c  bf00              NOP      
;;;1738   #endif
;;;1739                                                                   /* --------------- FREE MEM BLK TO POOL --------------- */
;;;1740       if (p_pool->BlkFreeTblIx >= p_pool->BlkNbr) {
00001e  68a1              LDR      r1,[r4,#8]
000020  6960              LDR      r0,[r4,#0x14]
000022  4288              CMP      r0,r1
000024  d30d              BCC      |L13.66|
;;;1741           CPU_CRITICAL_EXIT();
000026  bf00              NOP      
000028  f7fffffe          BL       CPU_IntDisMeasStop
00002c  bf00              NOP      
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       CPU_SR_Restore
000034  bf00              NOP      
000036  bf00              NOP      
;;;1742          *p_err = LIB_MEM_ERR_POOL_FULL;
000038  f24270dd          MOV      r0,#0x27dd
00003c  8028              STRH     r0,[r5,#0]
                  |L13.62|
;;;1743           return;
;;;1744       }
;;;1745   
;;;1746       p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = p_blk;
;;;1747       p_pool->BlkFreeTblIx                     += 1u;
;;;1748       CPU_CRITICAL_EXIT();
;;;1749   
;;;1750      *p_err = LIB_MEM_ERR_NONE;
;;;1751   }
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L13.66|
000042  e9d40104          LDRD     r0,r1,[r4,#0x10]      ;1746
000046  f8406021          STR      r6,[r0,r1,LSL #2]     ;1746
00004a  6960              LDR      r0,[r4,#0x14]         ;1747
00004c  1c40              ADDS     r0,r0,#1              ;1747
00004e  6160              STR      r0,[r4,#0x14]         ;1747
000050  bf00              NOP                            ;1748
000052  f7fffffe          BL       CPU_IntDisMeasStop
000056  bf00              NOP                            ;1748
000058  4638              MOV      r0,r7                 ;1748
00005a  f7fffffe          BL       CPU_SR_Restore
00005e  bf00              NOP                            ;1748
000060  bf00              NOP                            ;1748
000062  f2427010          MOV      r0,#0x2710            ;1750
000066  8028              STRH     r0,[r5,#0]            ;1750
000068  bf00              NOP      
00006a  e7e8              B        |L13.62|
;;;1752   #endif
                          ENDP


                          AREA ||i.Mem_PoolBlkGet||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkGet PROC
;;;1610   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1611   void  *Mem_PoolBlkGet (MEM_POOL    *p_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1612                          CPU_SIZE_T   size,
;;;1613                          LIB_ERR     *p_err)
;;;1614   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;1615       CPU_INT08U  *p_blk;
;;;1616       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;1617   
;;;1618   
;;;1619      (void)&size;                                                 /* Prevent possible 'variable unused' warning.          */
;;;1620   
;;;1621   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL GET --------------- */
;;;1622       if (p_err == DEF_NULL) {                                    /* Validate err ptr.                                    */
;;;1623           CPU_SW_EXCEPTION(DEF_NULL);
;;;1624           return (DEF_NULL);
;;;1625       }
;;;1626   
;;;1627       if (p_pool == DEF_NULL) {                                   /* Validate pool ptr.                                   */
;;;1628          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1629           return (DEF_NULL);
;;;1630       }
;;;1631   
;;;1632       if (size < 1u) {                                            /* Validate req'd size as non-NULL.                     */
;;;1633          *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;1634           return (DEF_NULL);
;;;1635       }
;;;1636   
;;;1637       if (size > p_pool->BlkSize) {                               /* Validate req'd size <= mem pool blk size.            */
;;;1638          *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;1639           return (DEF_NULL);
;;;1640       }
;;;1641   #endif
;;;1642   
;;;1643   
;;;1644                                                                   /* -------------- GET MEM BLK FROM POOL --------------- */
;;;1645       p_blk = DEF_NULL;
00000c  2600              MOVS     r6,#0
;;;1646       CPU_CRITICAL_ENTER();
00000e  bf00              NOP      
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_SR_Save
000016  4607              MOV      r7,r0
000018  bf00              NOP      
00001a  f7fffffe          BL       CPU_IntDisMeasStart
00001e  bf00              NOP      
;;;1647       if (p_pool->BlkFreeTblIx > 0u) {
000020  6960              LDR      r0,[r4,#0x14]
000022  b158              CBZ      r0,|L14.60|
;;;1648           p_pool->BlkFreeTblIx                     -= 1u;
000024  6960              LDR      r0,[r4,#0x14]
000026  1e40              SUBS     r0,r0,#1
000028  6160              STR      r0,[r4,#0x14]
;;;1649           p_blk                                     = p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx];
00002a  e9d40104          LDRD     r0,r1,[r4,#0x10]
00002e  f8506021          LDR      r6,[r0,r1,LSL #2]
;;;1650           p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = DEF_NULL;
000032  2000              MOVS     r0,#0
000034  e9d41204          LDRD     r1,r2,[r4,#0x10]
000038  f8410022          STR      r0,[r1,r2,LSL #2]
                  |L14.60|
;;;1651       }
;;;1652       CPU_CRITICAL_EXIT();
00003c  bf00              NOP      
00003e  f7fffffe          BL       CPU_IntDisMeasStop
000042  bf00              NOP      
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       CPU_SR_Restore
00004a  bf00              NOP      
00004c  bf00              NOP      
;;;1653   
;;;1654       if (p_blk == DEF_NULL) {
00004e  b91e              CBNZ     r6,|L14.88|
;;;1655          *p_err = LIB_MEM_ERR_POOL_EMPTY;
000050  f24270de          MOV      r0,#0x27de
000054  8028              STRH     r0,[r5,#0]
000056  e002              B        |L14.94|
                  |L14.88|
;;;1656       } else {
;;;1657          *p_err = LIB_MEM_ERR_NONE;
000058  f2427010          MOV      r0,#0x2710
00005c  8028              STRH     r0,[r5,#0]
                  |L14.94|
;;;1658       }
;;;1659   
;;;1660       return (p_blk);
00005e  4630              MOV      r0,r6
;;;1661   }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;1662   #endif
                          ENDP


                          AREA ||i.Mem_PoolBlkGetNbrAvail||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkGetNbrAvail PROC
;;;1779   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1780   MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *p_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1781                                             LIB_ERR   *p_err)
;;;1782   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1783       CPU_SIZE_T  nbr_avail;
;;;1784       CPU_SR_ALLOC();
000008  2700              MOVS     r7,#0
;;;1785   
;;;1786   
;;;1787   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1788                                                                   /* --------------- VALIDATE RTN ERR PTR --------------- */
;;;1789       if (p_err == DEF_NULL) {
;;;1790           CPU_SW_EXCEPTION(0u);
;;;1791           return (0u);
;;;1792       }
;;;1793                                                                   /* ---------------- VALIDATE MEM POOL ----------------- */
;;;1794       if (p_pool == DEF_NULL) {                                   /* Validate mem ptr.                                    */
;;;1795          *p_err =  LIB_MEM_ERR_NULL_PTR;
;;;1796           return (0u);
;;;1797       }
;;;1798   #endif
;;;1799   
;;;1800       CPU_CRITICAL_ENTER();
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  f7fffffe          BL       CPU_SR_Save
000012  4607              MOV      r7,r0
000014  bf00              NOP      
000016  f7fffffe          BL       CPU_IntDisMeasStart
00001a  bf00              NOP      
;;;1801       nbr_avail = p_pool->BlkFreeTblIx;
00001c  6966              LDR      r6,[r4,#0x14]
;;;1802       CPU_CRITICAL_EXIT();
00001e  bf00              NOP      
000020  f7fffffe          BL       CPU_IntDisMeasStop
000024  bf00              NOP      
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       CPU_SR_Restore
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;1803   
;;;1804      *p_err = LIB_MEM_ERR_NONE;
000030  f2427010          MOV      r0,#0x2710
000034  8028              STRH     r0,[r5,#0]
;;;1805   
;;;1806       return (nbr_avail);
000036  4630              MOV      r0,r6
;;;1807   }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;1808   #endif
                          ENDP


                          AREA ||i.Mem_PoolClr||, CODE, READONLY, ALIGN=1

                  Mem_PoolClr PROC
;;;1553   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1554   void  Mem_PoolClr (MEM_POOL  *p_pool,
000000  2200              MOVS     r2,#0
;;;1555                      LIB_ERR   *p_err)
;;;1556   {
;;;1557   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
;;;1558       if (p_err == DEF_NULL) {
;;;1559           CPU_SW_EXCEPTION(;);
;;;1560           return;
;;;1561       }
;;;1562   
;;;1563                                                                   /* -------------- VALIDATE MEM POOL PTR --------------- */
;;;1564       if (p_pool == DEF_NULL) {
;;;1565          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1566           return;
;;;1567       }
;;;1568   #endif
;;;1569   
;;;1570       p_pool->PoolAddrStart = DEF_NULL;
000002  6002              STR      r2,[r0,#0]
;;;1571       p_pool->PoolAddrEnd   = DEF_NULL;
000004  6042              STR      r2,[r0,#4]
;;;1572       p_pool->BlkSize       = 0u;
000006  60c2              STR      r2,[r0,#0xc]
;;;1573       p_pool->BlkNbr        = 0u;
000008  6082              STR      r2,[r0,#8]
;;;1574       p_pool->BlkFreeTbl    = DEF_NULL;
00000a  6102              STR      r2,[r0,#0x10]
;;;1575       p_pool->BlkFreeTblIx  = 0u;
00000c  6142              STR      r2,[r0,#0x14]
;;;1576   
;;;1577      *p_err = LIB_MEM_ERR_NONE;
00000e  f2427210          MOV      r2,#0x2710
000012  800a              STRH     r2,[r1,#0]
;;;1578   }
000014  4770              BX       lr
;;;1579   #endif
                          ENDP


                          AREA ||i.Mem_PoolCreate||, CODE, READONLY, ALIGN=2

                  Mem_PoolCreate PROC
;;;1361   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1362   void  Mem_PoolCreate (MEM_POOL          *p_pool,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1363                         void              *p_mem_base,
;;;1364                         CPU_SIZE_T         mem_size,
;;;1365                         MEM_POOL_BLK_QTY   blk_nbr,
;;;1366                         CPU_SIZE_T         blk_size,
;;;1367                         CPU_SIZE_T         blk_align,
;;;1368                         CPU_SIZE_T        *p_bytes_reqd,
;;;1369                         LIB_ERR           *p_err)
;;;1370   {
000004  b087              SUB      sp,sp,#0x1c
000006  4605              MOV      r5,r0
000008  4688              MOV      r8,r1
00000a  461e              MOV      r6,r3
00000c  9c17              LDR      r4,[sp,#0x5c]
;;;1371       MEM_SEG           *p_seg;
;;;1372       void              *p_pool_mem;
;;;1373       CPU_SIZE_T         pool_size;
;;;1374       CPU_SIZE_T         blk_size_align;
;;;1375       CPU_ADDR           pool_addr_end;
;;;1376       MEM_POOL_BLK_QTY   blk_ix;
;;;1377       CPU_INT08U        *p_blk;
;;;1378       CPU_SR_ALLOC();
00000e  2000              MOVS     r0,#0
000010  9003              STR      r0,[sp,#0xc]
;;;1379   
;;;1380   
;;;1381   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* --------------- VALIDATE RTN ERR PTR --------------- */
;;;1382       if (p_err == DEF_NULL) {
;;;1383           CPU_SW_EXCEPTION(;);
;;;1384           return;
;;;1385       }
;;;1386   
;;;1387                                                                   /* ------------- VALIDATE MEM POOL CREATE ------------- */
;;;1388       if (p_pool == DEF_NULL) {
;;;1389          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1390           return;
;;;1391       }
;;;1392   
;;;1393       if (p_mem_base != DEF_NULL) {
;;;1394           if (mem_size < 1u) {
;;;1395              *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
;;;1396               return;
;;;1397           }
;;;1398       }
;;;1399   
;;;1400       if (blk_nbr < 1u) {
;;;1401          *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
;;;1402           return;
;;;1403       }
;;;1404   
;;;1405       if (blk_size < 1u) {
;;;1406          *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;1407           return;
;;;1408       }
;;;1409   
;;;1410       if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk that req alignment is a pwr of 2.                */
;;;1411          *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
;;;1412           return;
;;;1413       }
;;;1414   #endif
;;;1415   
;;;1416       Mem_PoolClr(p_pool, p_err);                                 /* Init mem pool.                                       */
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       Mem_PoolClr
;;;1417       if (*p_err != LIB_MEM_ERR_NONE) {
00001a  8820              LDRH     r0,[r4,#0]
00001c  f5a0511c          SUB      r1,r0,#0x2700
000020  3910              SUBS     r1,r1,#0x10
000022  d002              BEQ      |L17.42|
                  |L17.36|
;;;1418            return;
;;;1419       }
;;;1420   
;;;1421                                                                   /* -------- DETERMINE AND/OR ALLOC SEG TO USE --------- */
;;;1422       if (p_mem_base == DEF_NULL) {                               /* Use heap seg.                                        */
;;;1423           p_seg = &Mem_SegHeap;
;;;1424       } else {                                                    /* Use other seg.                                       */
;;;1425           CPU_CRITICAL_ENTER();
;;;1426           p_seg = Mem_SegOverlapChkCritical((CPU_ADDR)p_mem_base,
;;;1427                                                       mem_size,
;;;1428                                                       p_err);
;;;1429           switch (*p_err) {
;;;1430               case LIB_MEM_ERR_INVALID_SEG_EXISTS:                /* Seg already exists.                                  */
;;;1431                    break;
;;;1432   
;;;1433               case LIB_MEM_ERR_NONE:                              /* Seg must be created.                                 */
;;;1434                    p_seg = (MEM_SEG *)Mem_SegAllocExtCritical(&Mem_SegHeap,
;;;1435                                                                sizeof(MEM_SEG),
;;;1436                                                                sizeof(CPU_ALIGN),
;;;1437                                                                LIB_MEM_PADDING_ALIGN_NONE,
;;;1438                                                                p_bytes_reqd,
;;;1439                                                                p_err);
;;;1440                    if (*p_err != LIB_MEM_ERR_NONE) {
;;;1441                        CPU_CRITICAL_EXIT();
;;;1442                        return;
;;;1443                    }
;;;1444   
;;;1445   #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
;;;1446                    Mem_SegAllocTrackCritical("Unknown segment data",
;;;1447                                              &Mem_SegHeap,
;;;1448                                               sizeof(MEM_SEG),
;;;1449                                               p_err);
;;;1450                    if (*p_err != LIB_MEM_ERR_NONE) {
;;;1451                        CPU_CRITICAL_EXIT();
;;;1452                        return;
;;;1453                    }
;;;1454   #endif
;;;1455   
;;;1456                    Mem_SegCreateCritical(          DEF_NULL,
;;;1457                                                    p_seg,
;;;1458                                          (CPU_ADDR)p_mem_base,
;;;1459                                                    LIB_MEM_PADDING_ALIGN_NONE,
;;;1460                                                    mem_size);
;;;1461                    break;
;;;1462   
;;;1463   
;;;1464               case LIB_MEM_ERR_INVALID_SEG_OVERLAP:
;;;1465               default:
;;;1466                    CPU_CRITICAL_EXIT();
;;;1467                    return;                                        /* Prevent 'break NOT reachable' compiler warning.      */
;;;1468           }
;;;1469   
;;;1470           CPU_CRITICAL_EXIT();
;;;1471       }
;;;1472   
;;;1473   
;;;1474                                                                   /* ---------------- ALLOC MEM FOR POOL ---------------- */
;;;1475                                                                   /* Calc blk size with align.                            */
;;;1476       blk_size_align =  MATH_ROUND_INC_UP_PWR2(blk_size, blk_align);
;;;1477       pool_size      =  blk_size_align * blk_nbr;                 /* Calc required size for pool.                         */
;;;1478   
;;;1479                                                                   /* Alloc mem for pool.                                  */
;;;1480       p_pool_mem = (void *)Mem_SegAllocInternal("Unnamed static pool",
;;;1481                                                  p_seg,
;;;1482                                                  pool_size,
;;;1483                                                  blk_align,
;;;1484                                                  LIB_MEM_PADDING_ALIGN_NONE,
;;;1485                                                  p_bytes_reqd,
;;;1486                                                  p_err);
;;;1487       if (*p_err != LIB_MEM_ERR_NONE) {
;;;1488           return;
;;;1489       }
;;;1490   
;;;1491                                                                   /* ------------ ALLOC MEM FOR FREE BLK TBL ------------ */
;;;1492       p_pool->BlkFreeTbl = (void *)Mem_SegAllocInternal("Unnamed static pool free blk tbl",
;;;1493                                                         &Mem_SegHeap,
;;;1494                                                          blk_nbr * sizeof(void *),
;;;1495                                                          sizeof(CPU_ALIGN),
;;;1496                                                          LIB_MEM_PADDING_ALIGN_NONE,
;;;1497                                                          p_bytes_reqd,
;;;1498                                                          p_err);
;;;1499       if (*p_err != LIB_MEM_ERR_NONE) {
;;;1500           return;
;;;1501       }
;;;1502   
;;;1503                                                                   /* ------------------ INIT BLK LIST ------------------- */
;;;1504       p_blk = (CPU_INT08U *)p_pool_mem;
;;;1505       for (blk_ix = 0; blk_ix < blk_nbr; blk_ix++) {
;;;1506           p_pool->BlkFreeTbl[blk_ix]  = p_blk;
;;;1507           p_blk                      += blk_size_align;
;;;1508       }
;;;1509   
;;;1510   
;;;1511                                                                   /* ------------------ INIT POOL DATA ------------------ */
;;;1512       pool_addr_end         = (CPU_ADDR)p_pool_mem + (pool_size - 1u);
;;;1513       p_pool->PoolAddrStart =  p_pool_mem;
;;;1514       p_pool->PoolAddrEnd   = (void *)pool_addr_end;
;;;1515       p_pool->BlkNbr        =  blk_nbr;
;;;1516       p_pool->BlkSize       =  blk_size_align;
;;;1517       p_pool->BlkFreeTblIx  =  blk_nbr;
;;;1518   }
000024  b00b              ADD      sp,sp,#0x2c
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L17.42|
00002a  f1b80f00          CMP      r8,#0                 ;1422
00002e  d102              BNE      |L17.54|
000030  f8df9148          LDR      r9,|L17.380|
000034  e04f              B        |L17.214|
                  |L17.54|
000036  bf00              NOP                            ;1425
000038  bf00              NOP                            ;1425
00003a  f7fffffe          BL       CPU_SR_Save
00003e  9003              STR      r0,[sp,#0xc]          ;1425
000040  bf00              NOP                            ;1425
000042  f7fffffe          BL       CPU_IntDisMeasStart
000046  bf00              NOP                            ;1425
000048  4622              MOV      r2,r4                 ;1426
00004a  4640              MOV      r0,r8                 ;1426
00004c  9909              LDR      r1,[sp,#0x24]         ;1426
00004e  f7fffffe          BL       Mem_SegOverlapChkCritical
000052  4681              MOV      r9,r0                 ;1426
000054  8820              LDRH     r0,[r4,#0]            ;1429
000056  f5a0501c          SUB      r0,r0,#0x2700         ;1429
00005a  3810              SUBS     r0,r0,#0x10           ;1429
00005c  d004              BEQ      |L17.104|
00005e  286f              CMP      r0,#0x6f              ;1429
000060  d025              BEQ      |L17.174|
000062  2870              CMP      r0,#0x70              ;1429
000064  d122              BNE      |L17.172|
000066  e02c              B        |L17.194|
                  |L17.104|
000068  9816              LDR      r0,[sp,#0x58]         ;1434
00006a  2301              MOVS     r3,#1                 ;1434
00006c  2204              MOVS     r2,#4                 ;1434
00006e  2114              MOVS     r1,#0x14              ;1434
000070  e9cd0400          STRD     r0,r4,[sp,#0]         ;1434
000074  4841              LDR      r0,|L17.380|
000076  f7fffffe          BL       Mem_SegAllocExtCritical
00007a  4681              MOV      r9,r0                 ;1434
00007c  8820              LDRH     r0,[r4,#0]            ;1440
00007e  f5a0511c          SUB      r1,r0,#0x2700         ;1440
000082  3910              SUBS     r1,r1,#0x10           ;1440
000084  d009              BEQ      |L17.154|
000086  bf00              NOP                            ;1441
000088  f7fffffe          BL       CPU_IntDisMeasStop
00008c  bf00              NOP                            ;1441
00008e  9803              LDR      r0,[sp,#0xc]          ;1441
000090  f7fffffe          BL       CPU_SR_Restore
000094  bf00              NOP                            ;1441
000096  bf00              NOP                            ;1441
000098  e7c4              B        |L17.36|
                  |L17.154|
00009a  9809              LDR      r0,[sp,#0x24]         ;1456
00009c  2301              MOVS     r3,#1                 ;1456
00009e  4642              MOV      r2,r8                 ;1456
0000a0  4649              MOV      r1,r9                 ;1456
0000a2  9000              STR      r0,[sp,#0]            ;1456
0000a4  2000              MOVS     r0,#0                 ;1456
0000a6  f7fffffe          BL       Mem_SegCreateCritical
0000aa  e00a              B        |L17.194|
                  |L17.172|
0000ac  bf00              NOP                            ;1464
                  |L17.174|
0000ae  bf00              NOP                            ;1466
0000b0  f7fffffe          BL       CPU_IntDisMeasStop
0000b4  bf00              NOP                            ;1466
0000b6  9803              LDR      r0,[sp,#0xc]          ;1466
0000b8  f7fffffe          BL       CPU_SR_Restore
0000bc  bf00              NOP                            ;1466
0000be  bf00              NOP                            ;1466
0000c0  e7b0              B        |L17.36|
                  |L17.194|
0000c2  bf00              NOP                            ;1431
0000c4  bf00              NOP                            ;1470
0000c6  f7fffffe          BL       CPU_IntDisMeasStop
0000ca  bf00              NOP                            ;1470
0000cc  9803              LDR      r0,[sp,#0xc]          ;1470
0000ce  f7fffffe          BL       CPU_SR_Restore
0000d2  bf00              NOP                            ;1470
0000d4  bf00              NOP                            ;1470
                  |L17.214|
0000d6  9815              LDR      r0,[sp,#0x54]         ;1476
0000d8  1e41              SUBS     r1,r0,#1              ;1476
0000da  9814              LDR      r0,[sp,#0x50]         ;1476
0000dc  ea200101          BIC      r1,r0,r1              ;1476
0000e0  9815              LDR      r0,[sp,#0x54]         ;1476
0000e2  1e40              SUBS     r0,r0,#1              ;1476
0000e4  9a14              LDR      r2,[sp,#0x50]         ;1476
0000e6  4210              TST      r0,r2                 ;1476
0000e8  d101              BNE      |L17.238|
0000ea  2000              MOVS     r0,#0                 ;1476
0000ec  e000              B        |L17.240|
                  |L17.238|
0000ee  9815              LDR      r0,[sp,#0x54]         ;1476
                  |L17.240|
0000f0  eb010a00          ADD      r10,r1,r0             ;1476
0000f4  fb0af006          MUL      r0,r10,r6             ;1477
0000f8  9006              STR      r0,[sp,#0x18]         ;1477
0000fa  2101              MOVS     r1,#1                 ;1480
0000fc  9816              LDR      r0,[sp,#0x58]         ;1480
0000fe  e9cd0401          STRD     r0,r4,[sp,#4]         ;1480
000102  9100              STR      r1,[sp,#0]            ;1480
000104  4649              MOV      r1,r9                 ;1480
000106  a01e              ADR      r0,|L17.384|
000108  9b15              LDR      r3,[sp,#0x54]         ;1480
00010a  9a06              LDR      r2,[sp,#0x18]         ;1480
00010c  f7fffffe          BL       Mem_SegAllocInternal
000110  4607              MOV      r7,r0                 ;1480
000112  8820              LDRH     r0,[r4,#0]            ;1487
000114  f5a0511c          SUB      r1,r0,#0x2700         ;1487
000118  3910              SUBS     r1,r1,#0x10           ;1487
00011a  d000              BEQ      |L17.286|
00011c  e782              B        |L17.36|
                  |L17.286|
00011e  2101              MOVS     r1,#1                 ;1492
000120  9816              LDR      r0,[sp,#0x58]         ;1492
000122  00b2              LSLS     r2,r6,#2              ;1492
000124  2304              MOVS     r3,#4                 ;1492
000126  e9cd0401          STRD     r0,r4,[sp,#4]         ;1492
00012a  9100              STR      r1,[sp,#0]            ;1492
00012c  4913              LDR      r1,|L17.380|
00012e  a019              ADR      r0,|L17.404|
000130  f7fffffe          BL       Mem_SegAllocInternal
000134  6128              STR      r0,[r5,#0x10]         ;1492
000136  8820              LDRH     r0,[r4,#0]            ;1499
000138  f5a0511c          SUB      r1,r0,#0x2700         ;1499
00013c  3910              SUBS     r1,r1,#0x10           ;1499
00013e  d000              BEQ      |L17.322|
000140  e770              B        |L17.36|
                  |L17.322|
000142  9704              STR      r7,[sp,#0x10]         ;1504
000144  f04f0b00          MOV      r11,#0                ;1505
000148  e008              B        |L17.348|
                  |L17.330|
00014a  9804              LDR      r0,[sp,#0x10]         ;1506
00014c  6929              LDR      r1,[r5,#0x10]         ;1506
00014e  f841002b          STR      r0,[r1,r11,LSL #2]    ;1506
000152  9804              LDR      r0,[sp,#0x10]         ;1507
000154  4450              ADD      r0,r0,r10             ;1507
000156  9004              STR      r0,[sp,#0x10]         ;1507
000158  f10b0b01          ADD      r11,r11,#1            ;1505
                  |L17.348|
00015c  45b3              CMP      r11,r6                ;1505
00015e  d3f4              BCC      |L17.330|
000160  9806              LDR      r0,[sp,#0x18]         ;1512
000162  1e40              SUBS     r0,r0,#1              ;1512
000164  4438              ADD      r0,r0,r7              ;1512
000166  9005              STR      r0,[sp,#0x14]         ;1512
000168  602f              STR      r7,[r5,#0]            ;1513
00016a  9805              LDR      r0,[sp,#0x14]         ;1514
00016c  6068              STR      r0,[r5,#4]            ;1514
00016e  60ae              STR      r6,[r5,#8]            ;1515
000170  f8c5a00c          STR      r10,[r5,#0xc]         ;1516
000174  616e              STR      r6,[r5,#0x14]         ;1517
000176  bf00              NOP      
000178  e754              B        |L17.36|
;;;1519   #endif
                          ENDP

00017a  0000              DCW      0x0000
                  |L17.380|
                          DCD      Mem_SegHeap
                  |L17.384|
000180  556e6e61          DCB      "Unnamed static pool",0
000184  6d656420
000188  73746174
00018c  69632070
000190  6f6f6c00
                  |L17.404|
000194  556e6e61          DCB      "Unnamed static pool free blk tbl",0
000198  6d656420
00019c  73746174
0001a0  69632070
0001a4  6f6f6c20
0001a8  66726565
0001ac  20626c6b
0001b0  2074626c
0001b4  00      
0001b5  00                DCB      0
0001b6  00                DCB      0
0001b7  00                DCB      0

                          AREA ||i.Mem_SegAlloc||, CODE, READONLY, ALIGN=2

                  Mem_SegAlloc PROC
;;;1124   
;;;1125   void  *Mem_SegAlloc (const  CPU_CHAR    *p_name,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1126                               MEM_SEG     *p_seg,
;;;1127                               CPU_SIZE_T   size,
;;;1128                               LIB_ERR     *p_err)
;;;1129   {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;1130       void  *p_blk;
;;;1131   
;;;1132   
;;;1133       if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
00000c  b904              CBNZ     r4,|L18.16|
;;;1134   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1135           p_seg = &Mem_SegHeap;
00000e  4c08              LDR      r4,|L18.48|
                  |L18.16|
;;;1136   #else
;;;1137          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1138           return (DEF_NULL);
;;;1139   #endif
;;;1140       }
;;;1141   
;;;1142       p_blk = Mem_SegAllocInternal(p_name,
000010  2000              MOVS     r0,#0
000012  2101              MOVS     r1,#1
000014  2304              MOVS     r3,#4
000016  4642              MOV      r2,r8
000018  e9cd0501          STRD     r0,r5,[sp,#4]
00001c  9100              STR      r1,[sp,#0]
00001e  4621              MOV      r1,r4
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       Mem_SegAllocInternal
000026  4606              MOV      r6,r0
;;;1143                                    p_seg,
;;;1144                                    size,
;;;1145                                    sizeof(CPU_ALIGN),
;;;1146                                    LIB_MEM_PADDING_ALIGN_NONE,
;;;1147                                    DEF_NULL,
;;;1148                                    p_err);
;;;1149   
;;;1150       return (p_blk);
000028  4630              MOV      r0,r6
;;;1151   }
00002a  e8bd83fe          POP      {r1-r9,pc}
;;;1152   
                          ENDP

00002e  0000              DCW      0x0000
                  |L18.48|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_SegAllocExt||, CODE, READONLY, ALIGN=2

                  Mem_SegAllocExt PROC
;;;1191   
;;;1192   void  *Mem_SegAllocExt (const  CPU_CHAR    *p_name,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1193                                  MEM_SEG     *p_seg,
;;;1194                                  CPU_SIZE_T   size,
;;;1195                                  CPU_SIZE_T   align,
;;;1196                                  CPU_SIZE_T  *p_bytes_reqd,
;;;1197                                  LIB_ERR     *p_err)
;;;1198   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;1199       void  *p_blk;
;;;1200   
;;;1201   
;;;1202       if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
000010  b904              CBNZ     r4,|L19.20|
;;;1203   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1204           p_seg = &Mem_SegHeap;
000012  4c07              LDR      r4,|L19.48|
                  |L19.20|
;;;1205   #else
;;;1206          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1207           return (DEF_NULL);
;;;1208   #endif
;;;1209       }
;;;1210   
;;;1211       p_blk = Mem_SegAllocInternal(p_name,
000014  2001              MOVS     r0,#1
000016  4643              MOV      r3,r8
000018  463a              MOV      r2,r7
00001a  4621              MOV      r1,r4
00001c  e88d0601          STM      sp,{r0,r9,r10}
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       Mem_SegAllocInternal
000026  4605              MOV      r5,r0
;;;1212                                    p_seg,
;;;1213                                    size,
;;;1214                                    align,
;;;1215                                    LIB_MEM_PADDING_ALIGN_NONE,
;;;1216                                    p_bytes_reqd,
;;;1217                                    p_err);
;;;1218   
;;;1219       return (p_blk);
000028  4628              MOV      r0,r5
;;;1220   }
00002a  e8bd8ffe          POP      {r1-r11,pc}
;;;1221   
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_SegAllocExtCritical||, CODE, READONLY, ALIGN=1

                  Mem_SegAllocExtCritical PROC
;;;2573   
;;;2574   static  void  *Mem_SegAllocExtCritical (MEM_SEG     *p_seg,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;2575                                           CPU_SIZE_T   size,
;;;2576                                           CPU_SIZE_T   align,
;;;2577                                           CPU_SIZE_T   padding_align,
;;;2578                                           CPU_SIZE_T  *p_bytes_reqd,
;;;2579                                           LIB_ERR     *p_err)
;;;2580   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  e9ddc809          LDRD     r12,r8,[sp,#0x24]
;;;2581       CPU_ADDR    blk_addr;
;;;2582       CPU_ADDR    addr_next;
;;;2583       CPU_SIZE_T  size_rem_seg;
;;;2584       CPU_SIZE_T  size_tot_blk;
;;;2585       CPU_SIZE_T  blk_align = DEF_MAX(align, padding_align);
00000e  4599              CMP      r9,r3
000010  d901              BLS      |L20.22|
000012  4648              MOV      r0,r9
000014  e000              B        |L20.24|
                  |L20.22|
000016  4618              MOV      r0,r3
                  |L20.24|
000018  4682              MOV      r10,r0
;;;2586   
;;;2587   
;;;2588       blk_addr     = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext,      /* Compute align'ed blk addr.                           */
00001a  f1aa0b01          SUB      r11,r10,#1
00001e  68a0              LDR      r0,[r4,#8]
000020  ea20000b          BIC      r0,r0,r11
000024  f1aa0e01          SUB      lr,r10,#1
000028  f8d4b008          LDR      r11,[r4,#8]
00002c  ea1b0f0e          TST      r11,lr
000030  d102              BNE      |L20.56|
000032  f04f0b00          MOV      r11,#0
000036  e000              B        |L20.58|
                  |L20.56|
000038  46d3              MOV      r11,r10
                  |L20.58|
00003a  eb00010b          ADD      r1,r0,r11
;;;2589                                             blk_align);
;;;2590       addr_next    = MATH_ROUND_INC_UP_PWR2(blk_addr + size,      /* Compute addr of next alloc.                          */
00003e  1948              ADDS     r0,r1,r5
000040  f1a30b01          SUB      r11,r3,#1
000044  ea20000b          BIC      r0,r0,r11
000048  eb010b05          ADD      r11,r1,r5
00004c  f1a30e01          SUB      lr,r3,#1
000050  ea1b0f0e          TST      r11,lr
000054  d102              BNE      |L20.92|
000056  f04f0b00          MOV      r11,#0
00005a  e000              B        |L20.94|
                  |L20.92|
00005c  469b              MOV      r11,r3
                  |L20.94|
00005e  eb00020b          ADD      r2,r0,r11
;;;2591                                             padding_align);
;;;2592       size_rem_seg = p_seg->AddrEnd - p_seg->AddrNext + 1u;
000062  e9d40b01          LDRD     r0,r11,[r4,#4]
000066  eba0000b          SUB      r0,r0,r11
00006a  1c46              ADDS     r6,r0,#1
;;;2593       size_tot_blk = addr_next - p_seg->AddrNext;                 /* Compute tot blk size including align and padding.    */
00006c  68a0              LDR      r0,[r4,#8]
00006e  1a17              SUBS     r7,r2,r0
;;;2594       if (size_rem_seg < size_tot_blk) {                          /* If seg doesn't have enough space ...                 */
000070  42be              CMP      r6,r7
000072  d20c              BCS      |L20.142|
;;;2595           if (p_bytes_reqd != DEF_NULL) {                         /* ... calc nbr of req'd bytes.                         */
000074  f1bc0f00          CMP      r12,#0
000078  d002              BEQ      |L20.128|
;;;2596              *p_bytes_reqd = size_tot_blk - size_rem_seg;
00007a  1bb8              SUBS     r0,r7,r6
00007c  f8cc0000          STR      r0,[r12,#0]
                  |L20.128|
;;;2597           }
;;;2598   
;;;2599          *p_err = LIB_MEM_ERR_SEG_OVF;
000080  f24270d9          MOV      r0,#0x27d9
000084  f8a80000          STRH     r0,[r8,#0]
;;;2600           return (DEF_NULL);
000088  2000              MOVS     r0,#0
                  |L20.138|
;;;2601       }
;;;2602   
;;;2603       p_seg->AddrNext = addr_next;
;;;2604   
;;;2605      *p_err = LIB_MEM_ERR_NONE;
;;;2606   
;;;2607       return ((void *)blk_addr);
;;;2608   }
00008a  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.142|
00008e  60a2              STR      r2,[r4,#8]            ;2603
000090  f2427010          MOV      r0,#0x2710            ;2605
000094  f8a80000          STRH     r0,[r8,#0]            ;2605
000098  4608              MOV      r0,r1                 ;2607
00009a  e7f6              B        |L20.138|
;;;2609   
                          ENDP


                          AREA ||i.Mem_SegAllocHW||, CODE, READONLY, ALIGN=2

                  Mem_SegAllocHW PROC
;;;1261   
;;;1262   void  *Mem_SegAllocHW (const  CPU_CHAR    *p_name,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1263                                 MEM_SEG     *p_seg,
;;;1264                                 CPU_SIZE_T   size,
;;;1265                                 CPU_SIZE_T   align,
;;;1266                                 CPU_SIZE_T  *p_bytes_reqd,
;;;1267                                 LIB_ERR     *p_err)
;;;1268   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
;;;1269       void  *p_blk;
;;;1270   
;;;1271   
;;;1272       if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
000010  b904              CBNZ     r4,|L21.20|
;;;1273   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1274           p_seg = &Mem_SegHeap;
000012  4c07              LDR      r4,|L21.48|
                  |L21.20|
;;;1275   #else
;;;1276          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1277           return (DEF_NULL);
;;;1278   #endif
;;;1279       }
;;;1280   
;;;1281       p_blk = Mem_SegAllocInternal(p_name,
000014  6920              LDR      r0,[r4,#0x10]
000016  4643              MOV      r3,r8
000018  463a              MOV      r2,r7
00001a  4621              MOV      r1,r4
00001c  e88d0601          STM      sp,{r0,r9,r10}
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       Mem_SegAllocInternal
000026  4605              MOV      r5,r0
;;;1282                                    p_seg,
;;;1283                                    size,
;;;1284                                    align,
;;;1285                                    p_seg->PaddingAlign,
;;;1286                                    p_bytes_reqd,
;;;1287                                    p_err);
;;;1288   
;;;1289       return (p_blk);
000028  4628              MOV      r0,r5
;;;1290   }
00002a  e8bd8ffe          POP      {r1-r11,pc}
;;;1291   
                          ENDP

00002e  0000              DCW      0x0000
                  |L21.48|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_SegAllocInternal||, CODE, READONLY, ALIGN=1

                  Mem_SegAllocInternal PROC
;;;2479   
;;;2480   static  void  *Mem_SegAllocInternal (const  CPU_CHAR    *p_name,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2481                                               MEM_SEG     *p_seg,
;;;2482                                               CPU_SIZE_T   size,
;;;2483                                               CPU_SIZE_T   align,
;;;2484                                               CPU_SIZE_T   padding_align,
;;;2485                                               CPU_SIZE_T  *p_bytes_reqd,
;;;2486                                               LIB_ERR     *p_err)
;;;2487   {
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
00000a  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
00000e  9f0e              LDR      r7,[sp,#0x38]
;;;2488       void  *p_blk;
;;;2489       CPU_SR_ALLOC();
000010  f04f0b00          MOV      r11,#0
;;;2490   
;;;2491   
;;;2492   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2493       if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
;;;2494           CPU_SW_EXCEPTION(DEF_NULL);
;;;2495           return (DEF_NULL);
;;;2496       }
;;;2497   
;;;2498       if (size < 1u) {                                            /* Chk for invalid sized mem req.                       */
;;;2499          *p_err = LIB_MEM_ERR_INVALID_MEM_SIZE;
;;;2500           return (DEF_NULL);
;;;2501       }
;;;2502   
;;;2503       if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk that align is a pwr of 2.                        */
;;;2504          *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
;;;2505           return (DEF_NULL);
;;;2506       }
;;;2507   #endif
;;;2508   
;;;2509       CPU_CRITICAL_ENTER();
000014  bf00              NOP      
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_SR_Save
00001c  4683              MOV      r11,r0
00001e  bf00              NOP      
000020  f7fffffe          BL       CPU_IntDisMeasStart
000024  bf00              NOP      
;;;2510       p_blk = Mem_SegAllocExtCritical(p_seg,
000026  464b              MOV      r3,r9
000028  4632              MOV      r2,r6
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  e9cda700          STRD     r10,r7,[sp,#0]
000032  f7fffffe          BL       Mem_SegAllocExtCritical
000036  4680              MOV      r8,r0
;;;2511                                       size,
;;;2512                                       align,
;;;2513                                       padding_align,
;;;2514                                       p_bytes_reqd,
;;;2515                                       p_err);
;;;2516       if (*p_err != LIB_MEM_ERR_NONE) {
000038  8838              LDRH     r0,[r7,#0]
00003a  f5a0511c          SUB      r1,r0,#0x2700
00003e  3910              SUBS     r1,r1,#0x10
000040  d00b              BEQ      |L22.90|
;;;2517           CPU_CRITICAL_EXIT();
000042  bf00              NOP      
000044  f7fffffe          BL       CPU_IntDisMeasStop
000048  bf00              NOP      
00004a  4658              MOV      r0,r11
00004c  f7fffffe          BL       CPU_SR_Restore
000050  bf00              NOP      
000052  bf00              NOP      
;;;2518           return (DEF_NULL);
000054  2000              MOVS     r0,#0
                  |L22.86|
;;;2519       }
;;;2520   
;;;2521   #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
;;;2522       Mem_SegAllocTrackCritical(p_name,
;;;2523                                 p_seg,
;;;2524                                 size,
;;;2525                                 p_err);
;;;2526       if (*p_err != LIB_MEM_ERR_NONE) {
;;;2527           CPU_CRITICAL_EXIT();
;;;2528           return (DEF_NULL);
;;;2529       }
;;;2530   #else
;;;2531       (void)&p_name;
;;;2532   #endif
;;;2533       CPU_CRITICAL_EXIT();
;;;2534   
;;;2535       return (p_blk);
;;;2536   }
000056  e8bd9ffc          POP      {r2-r12,pc}
                  |L22.90|
00005a  bf00              NOP                            ;2533
00005c  f7fffffe          BL       CPU_IntDisMeasStop
000060  bf00              NOP                            ;2533
000062  4658              MOV      r0,r11                ;2533
000064  f7fffffe          BL       CPU_SR_Restore
000068  bf00              NOP                            ;2533
00006a  bf00              NOP                            ;2533
00006c  4640              MOV      r0,r8                 ;2535
00006e  e7f2              B        |L22.86|
;;;2537   
                          ENDP


                          AREA ||i.Mem_SegClr||, CODE, READONLY, ALIGN=1

                  Mem_SegClr PROC
;;;971    #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_DISABLED)
;;;972    void  Mem_SegClr (MEM_SEG  *p_seg,
000000  b570              PUSH     {r4-r6,lr}
;;;973                      LIB_ERR  *p_err)
;;;974    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;975        CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;976    
;;;977    
;;;978    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;979        if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
;;;980            CPU_SW_EXCEPTION(;);
;;;981            return;
;;;982        }
;;;983    
;;;984        if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
;;;985           *p_err = LIB_MEM_ERR_NULL_PTR;
;;;986            return;
;;;987        }
;;;988    #endif
;;;989    
;;;990        CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_IntDisMeasStart
000018  bf00              NOP      
;;;991        p_seg->AddrNext = p_seg->AddrBase;
00001a  6820              LDR      r0,[r4,#0]
00001c  60a0              STR      r0,[r4,#8]
;;;992        CPU_CRITICAL_EXIT();
00001e  bf00              NOP      
000020  f7fffffe          BL       CPU_IntDisMeasStop
000024  bf00              NOP      
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       CPU_SR_Restore
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;993    
;;;994       *p_err = LIB_MEM_ERR_NONE;
000030  f2427010          MOV      r0,#0x2710
000034  8028              STRH     r0,[r5,#0]
;;;995    }
000036  bd70              POP      {r4-r6,pc}
;;;996    #endif
                          ENDP


                          AREA ||i.Mem_SegCreate||, CODE, READONLY, ALIGN=1

                  Mem_SegCreate PROC
;;;886    
;;;887    void  Mem_SegCreate (const  CPU_CHAR    *p_name,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;888                                MEM_SEG     *p_seg,
;;;889                                CPU_ADDR     seg_base_addr,
;;;890                                CPU_SIZE_T   size,
;;;891                                CPU_SIZE_T   padding_align,
;;;892                                LIB_ERR     *p_err)
;;;893    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
00000c  e9dd890a          LDRD     r8,r9,[sp,#0x28]
;;;894        CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;895    
;;;896    
;;;897    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;898        if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
;;;899            CPU_SW_EXCEPTION(;);
;;;900            return;
;;;901        }
;;;902    
;;;903        if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
;;;904           *p_err = LIB_MEM_ERR_NULL_PTR;
;;;905            return;
;;;906        }
;;;907    
;;;908        if (size < 1u) {                                            /* Chk for invalid sized seg.                           */
;;;909           *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
;;;910            return;
;;;911        }
;;;912                                                                    /* Chk for addr space ovf.                              */
;;;913        if (seg_base_addr + (size - 1u) < seg_base_addr) {
;;;914           *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
;;;915            return;
;;;916        }
;;;917    
;;;918        if ((padding_align               != LIB_MEM_PADDING_ALIGN_NONE) &&
;;;919            (MATH_IS_PWR2(padding_align) != DEF_YES)) {
;;;920           *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
;;;921            return;
;;;922        }
;;;923    #endif
;;;924    
;;;925        CPU_CRITICAL_ENTER();
000014  bf00              NOP      
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_SR_Save
00001c  4682              MOV      r10,r0
00001e  bf00              NOP      
000020  f7fffffe          BL       CPU_IntDisMeasStart
000024  bf00              NOP      
;;;926    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;927        (void)Mem_SegOverlapChkCritical(seg_base_addr,              /* Chk for overlap.                                     */
;;;928                                        size,
;;;929                                        p_err);
;;;930        if (*p_err != LIB_MEM_ERR_NONE) {
;;;931            CPU_CRITICAL_EXIT();
;;;932            return;
;;;933        }
;;;934    #endif
;;;935    
;;;936        Mem_SegCreateCritical(p_name,                               /* Create seg.                                          */
000026  4643              MOV      r3,r8
000028  463a              MOV      r2,r7
00002a  4631              MOV      r1,r6
00002c  4628              MOV      r0,r5
00002e  9400              STR      r4,[sp,#0]
000030  f7fffffe          BL       Mem_SegCreateCritical
;;;937                              p_seg,
;;;938                              seg_base_addr,
;;;939                              padding_align,
;;;940                              size);
;;;941        CPU_CRITICAL_EXIT();
000034  bf00              NOP      
000036  f7fffffe          BL       CPU_IntDisMeasStop
00003a  bf00              NOP      
00003c  4650              MOV      r0,r10
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP      
000044  bf00              NOP      
;;;942    
;;;943       *p_err = LIB_MEM_ERR_NONE;
000046  f2427010          MOV      r0,#0x2710
00004a  f8a90000          STRH     r0,[r9,#0]
;;;944    }
00004e  e8bd8ff8          POP      {r3-r11,pc}
;;;945    
                          ENDP


                          AREA ||i.Mem_SegCreateCritical||, CODE, READONLY, ALIGN=2

                  Mem_SegCreateCritical PROC
;;;2346   
;;;2347   static  void  Mem_SegCreateCritical(const  CPU_CHAR    *p_name,
000000  b530              PUSH     {r4,r5,lr}
;;;2348                                              MEM_SEG     *p_seg,
;;;2349                                              CPU_ADDR     seg_base_addr,
;;;2350                                              CPU_SIZE_T   padding_align,
;;;2351                                              CPU_SIZE_T   size)
;;;2352   {
000002  9c03              LDR      r4,[sp,#0xc]
;;;2353       p_seg->AddrBase         =  seg_base_addr;
000004  600a              STR      r2,[r1,#0]
;;;2354       p_seg->AddrEnd          = (seg_base_addr + (size - 1u));
000006  1e65              SUBS     r5,r4,#1
000008  4415              ADD      r5,r5,r2
00000a  604d              STR      r5,[r1,#4]
;;;2355       p_seg->AddrNext         =  seg_base_addr;
00000c  608a              STR      r2,[r1,#8]
;;;2356       p_seg->NextPtr          =  Mem_SegHeadPtr;
00000e  4d03              LDR      r5,|L25.28|
000010  682d              LDR      r5,[r5,#0]  ; Mem_SegHeadPtr
000012  60cd              STR      r5,[r1,#0xc]
;;;2357       p_seg->PaddingAlign     =  padding_align;
000014  610b              STR      r3,[r1,#0x10]
;;;2358   
;;;2359   #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
;;;2360       p_seg->NamePtr          = p_name;
;;;2361       p_seg->AllocInfoHeadPtr = DEF_NULL;
;;;2362   #else
;;;2363       (void)&p_name;
;;;2364   #endif
;;;2365   
;;;2366       Mem_SegHeadPtr = p_seg;
000016  4d01              LDR      r5,|L25.28|
000018  6029              STR      r1,[r5,#0]  ; Mem_SegHeadPtr
;;;2367   }
00001a  bd30              POP      {r4,r5,pc}
;;;2368   
                          ENDP

                  |L25.28|
                          DCD      Mem_SegHeadPtr

                          AREA ||i.Mem_SegOverlapChkCritical||, CODE, READONLY, ALIGN=2

                  Mem_SegOverlapChkCritical PROC
;;;2396   #if  (LIB_MEM_CFG_HEAP_SIZE      >  0u)
;;;2397   static  MEM_SEG  *Mem_SegOverlapChkCritical (CPU_ADDR     seg_base_addr,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2398                                                CPU_SIZE_T   size,
;;;2399                                                LIB_ERR     *p_err)
;;;2400   {
000002  4603              MOV      r3,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;2401       MEM_SEG   *p_seg_chk;
;;;2402       CPU_ADDR   seg_new_end;
;;;2403       CPU_ADDR   seg_chk_start;
;;;2404       CPU_ADDR   seg_chk_end;
;;;2405   
;;;2406   
;;;2407       seg_new_end = seg_base_addr + (size - 1u);
000008  1e70              SUBS     r0,r6,#1
00000a  18c7              ADDS     r7,r0,r3
;;;2408       p_seg_chk   = Mem_SegHeadPtr;
00000c  4811              LDR      r0,|L26.84|
00000e  6801              LDR      r1,[r0,#0]  ; Mem_SegHeadPtr
;;;2409   
;;;2410       while (p_seg_chk != DEF_NULL) {
000010  e018              B        |L26.68|
                  |L26.18|
;;;2411           seg_chk_start = (CPU_ADDR)p_seg_chk->AddrBase;
000012  680a              LDR      r2,[r1,#0]
;;;2412           seg_chk_end   = (CPU_ADDR)p_seg_chk->AddrEnd;
000014  684d              LDR      r5,[r1,#4]
;;;2413   
;;;2414           if ((seg_base_addr == seg_chk_start) && (seg_new_end == seg_chk_end)) {
000016  4293              CMP      r3,r2
000018  d106              BNE      |L26.40|
00001a  42af              CMP      r7,r5
00001c  d104              BNE      |L26.40|
;;;2415              *p_err = LIB_MEM_ERR_INVALID_SEG_EXISTS;
00001e  f44f501e          MOV      r0,#0x2780
000022  8020              STRH     r0,[r4,#0]
;;;2416               return (p_seg_chk);
000024  4608              MOV      r0,r1
                  |L26.38|
;;;2417           } else if (((seg_base_addr >= seg_chk_start) && (seg_base_addr <= seg_chk_end)) ||
;;;2418                      ((seg_base_addr <= seg_chk_start) && (seg_new_end   >= seg_chk_start))) {
;;;2419              *p_err = LIB_MEM_ERR_INVALID_SEG_OVERLAP;
;;;2420               return (p_seg_chk);
;;;2421           }
;;;2422   
;;;2423           p_seg_chk = p_seg_chk->NextPtr;
;;;2424       }
;;;2425   
;;;2426      *p_err = LIB_MEM_ERR_NONE;
;;;2427   
;;;2428       return (DEF_NULL);
;;;2429   }
000026  bdf0              POP      {r4-r7,pc}
                  |L26.40|
000028  4293              CMP      r3,r2                 ;2417
00002a  d301              BCC      |L26.48|
00002c  42ab              CMP      r3,r5                 ;2417
00002e  d903              BLS      |L26.56|
                  |L26.48|
000030  4293              CMP      r3,r2                 ;2418
000032  d806              BHI      |L26.66|
000034  4297              CMP      r7,r2                 ;2418
000036  d304              BCC      |L26.66|
                  |L26.56|
000038  f242707f          MOV      r0,#0x277f            ;2419
00003c  8020              STRH     r0,[r4,#0]            ;2419
00003e  4608              MOV      r0,r1                 ;2420
000040  e7f1              B        |L26.38|
                  |L26.66|
000042  68c9              LDR      r1,[r1,#0xc]          ;2423
                  |L26.68|
000044  2900              CMP      r1,#0                 ;2410
000046  d1e4              BNE      |L26.18|
000048  f2427010          MOV      r0,#0x2710            ;2426
00004c  8020              STRH     r0,[r4,#0]            ;2426
00004e  2000              MOVS     r0,#0                 ;2428
000050  e7e9              B        |L26.38|
;;;2430   #endif
                          ENDP

000052  0000              DCW      0x0000
                  |L26.84|
                          DCD      Mem_SegHeadPtr

                          AREA ||i.Mem_SegRemSizeGet||, CODE, READONLY, ALIGN=2

                  Mem_SegRemSizeGet PROC
;;;1028   
;;;1029   CPU_SIZE_T  Mem_SegRemSizeGet (MEM_SEG       *p_seg,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1030                                  CPU_SIZE_T     align,
;;;1031                                  MEM_SEG_INFO  *p_seg_info,
;;;1032                                  LIB_ERR       *p_err)
;;;1033   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  469a              MOV      r10,r3
;;;1034       CPU_SIZE_T  rem_size;
;;;1035       CPU_SIZE_T  total_size;
;;;1036       CPU_SIZE_T  used_size;
;;;1037       CPU_ADDR    next_addr_align;
;;;1038       CPU_SR_ALLOC();
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;1039   
;;;1040   
;;;1041   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1042       if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
;;;1043           CPU_SW_EXCEPTION(0);
;;;1044           return (0);
;;;1045       }
;;;1046   
;;;1047       if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk for invalid align val.                           */
;;;1048          *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
;;;1049           return (0u);
;;;1050       }
;;;1051   #endif
;;;1052   
;;;1053       if (p_seg == DEF_NULL) {                                    /* Dflt to heap in case p_seg is null.                  */
000010  b904              CBNZ     r4,|L27.20|
;;;1054   #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
;;;1055           p_seg = &Mem_SegHeap;
000012  4c20              LDR      r4,|L27.148|
                  |L27.20|
;;;1056   #else
;;;1057          *p_err = LIB_MEM_ERR_NULL_PTR;
;;;1058           return (0u);
;;;1059   #endif
;;;1060       }
;;;1061   
;;;1062       CPU_CRITICAL_ENTER();                                       /* Calc seg stats.                                      */
000014  bf00              NOP      
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_SR_Save
00001c  9000              STR      r0,[sp,#0]
00001e  bf00              NOP      
000020  f7fffffe          BL       CPU_IntDisMeasStart
000024  bf00              NOP      
;;;1063       next_addr_align = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext, align);
000026  1e79              SUBS     r1,r7,#1
000028  68a0              LDR      r0,[r4,#8]
00002a  4388              BICS     r0,r0,r1
00002c  1e7a              SUBS     r2,r7,#1
00002e  68a1              LDR      r1,[r4,#8]
000030  4211              TST      r1,r2
000032  d101              BNE      |L27.56|
000034  2100              MOVS     r1,#0
000036  e000              B        |L27.58|
                  |L27.56|
000038  4639              MOV      r1,r7
                  |L27.58|
00003a  1846              ADDS     r6,r0,r1
;;;1064       CPU_CRITICAL_EXIT();
00003c  bf00              NOP      
00003e  f7fffffe          BL       CPU_IntDisMeasStop
000042  bf00              NOP      
000044  9800              LDR      r0,[sp,#0]
000046  f7fffffe          BL       CPU_SR_Restore
00004a  bf00              NOP      
00004c  bf00              NOP      
;;;1065   
;;;1066       total_size = p_seg->AddrEnd  - p_seg->AddrBase + 1u;
00004e  e9d41000          LDRD     r1,r0,[r4,#0]
000052  1a40              SUBS     r0,r0,r1
000054  f1000901          ADD      r9,r0,#1
;;;1067       used_size  = p_seg->AddrNext - p_seg->AddrBase;
000058  6821              LDR      r1,[r4,#0]
00005a  68a0              LDR      r0,[r4,#8]
00005c  eba00b01          SUB      r11,r0,r1
;;;1068   
;;;1069       if (next_addr_align > p_seg->AddrEnd){
000060  6860              LDR      r0,[r4,#4]
000062  42b0              CMP      r0,r6
000064  d202              BCS      |L27.108|
;;;1070           next_addr_align = 0u;
000066  2600              MOVS     r6,#0
;;;1071           rem_size        = 0u;
000068  46b0              MOV      r8,r6
00006a  e003              B        |L27.116|
                  |L27.108|
;;;1072       } else {
;;;1073           rem_size        = total_size - (next_addr_align - p_seg->AddrBase);
00006c  6820              LDR      r0,[r4,#0]
00006e  1a30              SUBS     r0,r6,r0
000070  eba90800          SUB      r8,r9,r0
                  |L27.116|
;;;1074       }
;;;1075   
;;;1076       if (p_seg_info != DEF_NULL) {
000074  b135              CBZ      r5,|L27.132|
;;;1077           p_seg_info->TotalSize     = total_size;
000076  f8c59004          STR      r9,[r5,#4]
;;;1078           p_seg_info->UsedSize      = used_size;
00007a  f8c5b000          STR      r11,[r5,#0]
;;;1079           p_seg_info->AddrBase      = p_seg->AddrBase;
00007e  6820              LDR      r0,[r4,#0]
000080  60a8              STR      r0,[r5,#8]
;;;1080           p_seg_info->AddrNextAlloc = next_addr_align;
000082  60ee              STR      r6,[r5,#0xc]
                  |L27.132|
;;;1081       }
;;;1082   
;;;1083      *p_err = LIB_MEM_ERR_NONE;
000084  f2427010          MOV      r0,#0x2710
000088  f8aa0000          STRH     r0,[r10,#0]
;;;1084   
;;;1085       return (rem_size);
00008c  4640              MOV      r0,r8
;;;1086   }
00008e  e8bd8ff8          POP      {r3-r11,pc}
;;;1087   
                          ENDP

000092  0000              DCW      0x0000
                  |L27.148|
                          DCD      Mem_SegHeap

                          AREA ||i.Mem_Set||, CODE, READONLY, ALIGN=1

                  Mem_Set PROC
;;;304    
;;;305    void  Mem_Set (void        *pmem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;306                   CPU_INT08U   data_val,
;;;307                   CPU_SIZE_T   size)
;;;308    {
000004  4605              MOV      r5,r0
000006  460b              MOV      r3,r1
000008  4694              MOV      r12,r2
;;;309        CPU_SIZE_T   size_rem;
;;;310        CPU_ALIGN    data_align;
;;;311        CPU_ALIGN   *pmem_align;
;;;312        CPU_INT08U  *pmem_08;
;;;313        CPU_DATA     mem_align_mod;
;;;314        CPU_DATA     i;
;;;315    
;;;316    
;;;317    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;318        if (size < 1) {                                             /* See Note #1.                                         */
;;;319            return;
;;;320        }
;;;321        if (pmem == (void *)0) {
;;;322            return;
;;;323        }
;;;324    #endif
;;;325    
;;;326    
;;;327        data_align = 0u;
00000a  2700              MOVS     r7,#0
;;;328        for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
00000c  2400              MOVS     r4,#0
00000e  e002              B        |L28.22|
                  |L28.16|
;;;329            data_align <<=  DEF_OCTET_NBR_BITS;
000010  023f              LSLS     r7,r7,#8
;;;330            data_align  |= (CPU_ALIGN)data_val;
000012  431f              ORRS     r7,r7,r3
000014  1c64              ADDS     r4,r4,#1              ;328
                  |L28.22|
000016  2c04              CMP      r4,#4                 ;328
000018  d3fa              BCC      |L28.16|
;;;331        }
;;;332    
;;;333        size_rem      =  size;
00001a  4660              MOV      r0,r12
;;;334        mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
00001c  f0050603          AND      r6,r5,#3
;;;335    
;;;336        pmem_08 = (CPU_INT08U *)pmem;
000020  4629              MOV      r1,r5
;;;337        if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
000022  b146              CBZ      r6,|L28.54|
;;;338            i = mem_align_mod;
000024  4634              MOV      r4,r6
;;;339            while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
000026  e003              B        |L28.48|
                  |L28.40|
;;;340                   (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
;;;341               *pmem_08++ = data_val;
000028  f8013b01          STRB     r3,[r1],#1
;;;342                size_rem -= sizeof(CPU_INT08U);
00002c  1e40              SUBS     r0,r0,#1
;;;343                i++;
00002e  1c64              ADDS     r4,r4,#1
                  |L28.48|
000030  b108              CBZ      r0,|L28.54|
000032  2c04              CMP      r4,#4                 ;340
000034  d3f8              BCC      |L28.40|
                  |L28.54|
;;;344            }
;;;345        }
;;;346    
;;;347        pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2.                                         */
000036  460a              MOV      r2,r1
;;;348        while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
000038  e001              B        |L28.62|
                  |L28.58|
;;;349           *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
00003a  c280              STM      r2!,{r7}
;;;350            size_rem    -= sizeof(CPU_ALIGN);
00003c  1f00              SUBS     r0,r0,#4
                  |L28.62|
00003e  2804              CMP      r0,#4                 ;348
000040  d2fb              BCS      |L28.58|
;;;351        }
;;;352    
;;;353        pmem_08 = (CPU_INT08U *)pmem_align;
000042  4611              MOV      r1,r2
;;;354        while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
000044  e002              B        |L28.76|
                  |L28.70|
;;;355           *pmem_08++   = data_val;
000046  f8013b01          STRB     r3,[r1],#1
;;;356            size_rem   -= sizeof(CPU_INT08U);
00004a  1e40              SUBS     r0,r0,#1
                  |L28.76|
00004c  2800              CMP      r0,#0                 ;354
00004e  d1fa              BNE      |L28.70|
;;;357        }
;;;358    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;359    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Mem_Heap
                          %        1024
                  Mem_SegHeap
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  Mem_SegHeadPtr
                          DCD      0x00000000
