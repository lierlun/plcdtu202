; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\os_sem.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\os_sem.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\os_sem.crf ..\..\uCOS-III\uCOS-III\Source\os_sem.c]
                          THUMB

                          AREA ||i.OSSemCreate||, CODE, READONLY, ALIGN=2

                  OSSemCreate PROC
;;;72     
;;;73     void  OSSemCreate (OS_SEM      *p_sem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;74                        CPU_CHAR    *p_name,
;;;75                        OS_SEM_CTR   cnt,
;;;76                        OS_ERR      *p_err)
;;;77     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;78         CPU_SR_ALLOC();
00000c  f04f0800          MOV      r8,#0
;;;79     
;;;80     
;;;81     
;;;82     #ifdef OS_SAFETY_CRITICAL
;;;83         if (p_err == DEF_NULL) {
;;;84             OS_SAFETY_CRITICAL_EXCEPTION();
;;;85             return;
;;;86         }
;;;87     #endif
;;;88     
;;;89     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;90         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;91            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;92             return;
;;;93         }
;;;94     #endif
;;;95     
;;;96     #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;97         if (OSIntNestingCtr > 0u) {                                 /* Not allowed to be called from an ISR                 */
000010  4817              LDR      r0,|L1.112|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000014  b120              CBZ      r0,|L1.32|
;;;98            *p_err = OS_ERR_CREATE_ISR;
000016  f64260e1          MOV      r0,#0x2ee1
00001a  8028              STRH     r0,[r5,#0]
                  |L1.28|
;;;99             return;
;;;100        }
;;;101    #endif
;;;102    
;;;103    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;104        if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
;;;105           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;106            return;
;;;107        }
;;;108    #endif
;;;109    
;;;110        OS_CRITICAL_ENTER();
;;;111    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;112        p_sem->Type    = OS_OBJ_TYPE_SEM;                           /* Mark the data structure as a semaphore               */
;;;113    #endif
;;;114        p_sem->Ctr     = cnt;                                       /* Set semaphore value                                  */
;;;115    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;116        p_sem->TS      = 0u;
;;;117    #endif
;;;118    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;119        p_sem->NamePtr = p_name;                                    /* Save the name of the semaphore                       */
;;;120    #else
;;;121        (void)&p_name;
;;;122    #endif
;;;123        OS_PendListInit(&p_sem->PendList);                          /* Initialize the waiting list                          */
;;;124    
;;;125    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;126        OS_SemDbgListAdd(p_sem);
;;;127        OSSemQty++;
;;;128    #endif
;;;129    
;;;130    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;131        TRACE_OS_SEM_CREATE(p_sem, p_name);                         /* Record the event.                                    */
;;;132    #endif
;;;133    
;;;134        OS_CRITICAL_EXIT_NO_SCHED();
;;;135       *p_err = OS_ERR_NONE;
;;;136    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.32|
000020  bf00              NOP                            ;110
000022  bf00              NOP                            ;110
000024  f7fffffe          BL       CPU_SR_Save
000028  4680              MOV      r8,r0                 ;110
00002a  bf00              NOP                            ;110
00002c  f7fffffe          BL       CPU_IntDisMeasStart
000030  bf00              NOP                            ;110
000032  4810              LDR      r0,|L1.116|
000034  6020              STR      r0,[r4,#0]            ;112
000036  6227              STR      r7,[r4,#0x20]         ;114
000038  2000              MOVS     r0,#0                 ;116
00003a  6260              STR      r0,[r4,#0x24]         ;116
00003c  6066              STR      r6,[r4,#4]            ;119
00003e  f1040008          ADD      r0,r4,#8              ;123
000042  f7fffffe          BL       OS_PendListInit
000046  4620              MOV      r0,r4                 ;126
000048  f7fffffe          BL       OS_SemDbgListAdd
00004c  480a              LDR      r0,|L1.120|
00004e  8800              LDRH     r0,[r0,#0]            ;127  ; OSSemQty
000050  1c40              ADDS     r0,r0,#1              ;127
000052  4909              LDR      r1,|L1.120|
000054  8008              STRH     r0,[r1,#0]            ;127
000056  bf00              NOP                            ;134
000058  f7fffffe          BL       CPU_IntDisMeasStop
00005c  bf00              NOP                            ;134
00005e  4640              MOV      r0,r8                 ;134
000060  f7fffffe          BL       CPU_SR_Restore
000064  bf00              NOP                            ;134
000066  bf00              NOP                            ;134
000068  2000              MOVS     r0,#0                 ;135
00006a  8028              STRH     r0,[r5,#0]            ;135
00006c  bf00              NOP      
00006e  e7d5              B        |L1.28|
;;;137    
                          ENDP

                  |L1.112|
                          DCD      OSIntNestingCtr
                  |L1.116|
                          DCD      0x414d4553
                  |L1.120|
                          DCD      OSSemQty

                          AREA ||i.OSSemDel||, CODE, READONLY, ALIGN=2

                  OSSemDel PROC
;;;176    #if (OS_CFG_SEM_DEL_EN == DEF_ENABLED)
;;;177    OS_OBJ_QTY  OSSemDel (OS_SEM  *p_sem,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;178                          OS_OPT   opt,
;;;179                          OS_ERR  *p_err)
;;;180    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;181        OS_OBJ_QTY     nbr_tasks;
;;;182        OS_PEND_DATA  *p_pend_data;
;;;183        OS_PEND_LIST  *p_pend_list;
;;;184        OS_TCB        *p_tcb;
;;;185        CPU_TS         ts;
;;;186        CPU_SR_ALLOC();
00000a  f04f0b00          MOV      r11,#0
;;;187    
;;;188    
;;;189    
;;;190    #ifdef OS_SAFETY_CRITICAL
;;;191        if (p_err == DEF_NULL) {
;;;192            OS_SAFETY_CRITICAL_EXCEPTION();
;;;193            return (0u);
;;;194        }
;;;195    #endif
;;;196    
;;;197    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;198        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;199           *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
;;;200            return (0u);
;;;201        }
;;;202    #endif
;;;203    
;;;204    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;205        if (OSIntNestingCtr > 0u) {                                 /* Not allowed to delete a semaphore from an ISR        */
00000e  4843              LDR      r0,|L2.284|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000012  b128              CBZ      r0,|L2.32|
;;;206           *p_err = OS_ERR_DEL_ISR;
000014  f24320c9          MOV      r0,#0x32c9
000018  8020              STRH     r0,[r4,#0]
;;;207            return (0u);
00001a  2000              MOVS     r0,#0
                  |L2.28|
;;;208        }
;;;209    #endif
;;;210    
;;;211    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;212        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;213           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;214            return (0u);
;;;215        }
;;;216    #endif
;;;217    
;;;218    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;219        if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
;;;220           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;221            return (0u);
;;;222        }
;;;223    #endif
;;;224    
;;;225    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;226        if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
;;;227           *p_err = OS_ERR_OBJ_TYPE;
;;;228            return (0u);
;;;229        }
;;;230    #endif
;;;231    
;;;232        CPU_CRITICAL_ENTER();
;;;233        p_pend_list = &p_sem->PendList;
;;;234        nbr_tasks   = 0u;
;;;235        switch (opt) {
;;;236            case OS_OPT_DEL_NO_PEND:                                /* Delete semaphore only if no task waiting             */
;;;237                 if (p_pend_list->HeadPtr == DEF_NULL) {
;;;238    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;239                     OS_SemDbgListRemove(p_sem);
;;;240                     OSSemQty--;
;;;241    #endif
;;;242    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;243                     TRACE_OS_SEM_DEL(p_sem);                       /* Record the event.                                    */
;;;244    #endif
;;;245                     OS_SemClr(p_sem);
;;;246                     CPU_CRITICAL_EXIT();
;;;247                    *p_err = OS_ERR_NONE;
;;;248                 } else {
;;;249                     CPU_CRITICAL_EXIT();
;;;250                    *p_err = OS_ERR_TASK_WAITING;
;;;251                 }
;;;252                 break;
;;;253    
;;;254            case OS_OPT_DEL_ALWAYS:                                 /* Always delete the semaphore                          */
;;;255                 OS_CRITICAL_ENTER_CPU_EXIT();
;;;256    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;257                 ts = OS_TS_GET();                                  /* Get local time stamp so all tasks get the same time  */
;;;258    #else
;;;259                 ts = 0u;
;;;260    #endif
;;;261                 while (p_pend_list->HeadPtr != DEF_NULL) {         /* Remove all tasks on the pend list                    */
;;;262                     p_pend_data = p_pend_list->HeadPtr;
;;;263                     p_tcb       = p_pend_data->TCBPtr;
;;;264                     OS_PendObjDel((OS_PEND_OBJ *)((void *)p_sem),
;;;265                                   p_tcb,
;;;266                                   ts);
;;;267                     nbr_tasks++;
;;;268                 }
;;;269    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;270                 OS_SemDbgListRemove(p_sem);
;;;271                 OSSemQty--;
;;;272    #endif
;;;273    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;274                 TRACE_OS_SEM_DEL(p_sem);                           /* Record the event.                                    */
;;;275    #endif
;;;276                 OS_SemClr(p_sem);
;;;277                 OS_CRITICAL_EXIT_NO_SCHED();
;;;278                 OSSched();                                         /* Find highest priority task ready to run              */
;;;279                *p_err = OS_ERR_NONE;
;;;280                 break;
;;;281    
;;;282            default:
;;;283                 CPU_CRITICAL_EXIT();
;;;284                *p_err = OS_ERR_OPT_INVALID;
;;;285                 break;
;;;286        }
;;;287        return (nbr_tasks);
;;;288    }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L2.32|
000020  493f              LDR      r1,|L2.288|
000022  6830              LDR      r0,[r6,#0]            ;226
000024  4288              CMP      r0,r1                 ;226
000026  d004              BEQ      |L2.50|
000028  f64550c4          MOV      r0,#0x5dc4            ;227
00002c  8020              STRH     r0,[r4,#0]            ;227
00002e  2000              MOVS     r0,#0                 ;228
000030  e7f4              B        |L2.28|
                  |L2.50|
000032  bf00              NOP                            ;232
000034  bf00              NOP                            ;232
000036  f7fffffe          BL       CPU_SR_Save
00003a  4683              MOV      r11,r0                ;232
00003c  bf00              NOP                            ;232
00003e  f7fffffe          BL       CPU_IntDisMeasStart
000042  bf00              NOP                            ;232
000044  f1060508          ADD      r5,r6,#8              ;233
000048  2700              MOVS     r7,#0                 ;234
00004a  f1b80f00          CMP      r8,#0                 ;235
00004e  d003              BEQ      |L2.88|
000050  f1b80f01          CMP      r8,#1                 ;235
000054  d151              BNE      |L2.250|
000056  e025              B        |L2.164|
                  |L2.88|
000058  6828              LDR      r0,[r5,#0]            ;237
00005a  b9b0              CBNZ     r0,|L2.138|
00005c  4630              MOV      r0,r6                 ;239
00005e  f7fffffe          BL       OS_SemDbgListRemove
000062  4830              LDR      r0,|L2.292|
000064  8800              LDRH     r0,[r0,#0]            ;240  ; OSSemQty
000066  1e40              SUBS     r0,r0,#1              ;240
000068  492e              LDR      r1,|L2.292|
00006a  8008              STRH     r0,[r1,#0]            ;240
00006c  4630              MOV      r0,r6                 ;245
00006e  f7fffffe          BL       OS_SemClr
000072  bf00              NOP                            ;246
000074  f7fffffe          BL       CPU_IntDisMeasStop
000078  bf00              NOP                            ;246
00007a  4658              MOV      r0,r11                ;246
00007c  f7fffffe          BL       CPU_SR_Restore
000080  bf00              NOP                            ;246
000082  bf00              NOP                            ;246
000084  2000              MOVS     r0,#0                 ;247
000086  8020              STRH     r0,[r4,#0]            ;247
000088  e00b              B        |L2.162|
                  |L2.138|
00008a  bf00              NOP                            ;249
00008c  f7fffffe          BL       CPU_IntDisMeasStop
000090  bf00              NOP                            ;249
000092  4658              MOV      r0,r11                ;249
000094  f7fffffe          BL       CPU_SR_Restore
000098  bf00              NOP                            ;249
00009a  bf00              NOP                            ;249
00009c  f247105f          MOV      r0,#0x715f            ;250
0000a0  8020              STRH     r0,[r4,#0]            ;250
                  |L2.162|
0000a2  e037              B        |L2.276|
                  |L2.164|
0000a4  f7fffffe          BL       CPU_TS_TmrRd
0000a8  9000              STR      r0,[sp,#0]            ;257
0000aa  e00a              B        |L2.194|
                  |L2.172|
0000ac  f8d59000          LDR      r9,[r5,#0]            ;262
0000b0  f8d9a008          LDR      r10,[r9,#8]           ;263
0000b4  4651              MOV      r1,r10                ;264
0000b6  4630              MOV      r0,r6                 ;264
0000b8  9a00              LDR      r2,[sp,#0]            ;264
0000ba  f7fffffe          BL       OS_PendObjDel
0000be  1c78              ADDS     r0,r7,#1              ;267
0000c0  b287              UXTH     r7,r0                 ;267
                  |L2.194|
0000c2  6828              LDR      r0,[r5,#0]            ;261
0000c4  2800              CMP      r0,#0                 ;261
0000c6  d1f1              BNE      |L2.172|
0000c8  4630              MOV      r0,r6                 ;270
0000ca  f7fffffe          BL       OS_SemDbgListRemove
0000ce  4815              LDR      r0,|L2.292|
0000d0  8800              LDRH     r0,[r0,#0]            ;271  ; OSSemQty
0000d2  1e40              SUBS     r0,r0,#1              ;271
0000d4  4913              LDR      r1,|L2.292|
0000d6  8008              STRH     r0,[r1,#0]            ;271
0000d8  4630              MOV      r0,r6                 ;276
0000da  f7fffffe          BL       OS_SemClr
0000de  bf00              NOP                            ;277
0000e0  f7fffffe          BL       CPU_IntDisMeasStop
0000e4  bf00              NOP                            ;277
0000e6  4658              MOV      r0,r11                ;277
0000e8  f7fffffe          BL       CPU_SR_Restore
0000ec  bf00              NOP                            ;277
0000ee  bf00              NOP                            ;277
0000f0  f7fffffe          BL       OSSched
0000f4  2000              MOVS     r0,#0                 ;279
0000f6  8020              STRH     r0,[r4,#0]            ;279
0000f8  e00c              B        |L2.276|
                  |L2.250|
0000fa  bf00              NOP                            ;283
0000fc  f7fffffe          BL       CPU_IntDisMeasStop
000100  bf00              NOP                            ;283
000102  4658              MOV      r0,r11                ;283
000104  f7fffffe          BL       CPU_SR_Restore
000108  bf00              NOP                            ;283
00010a  bf00              NOP                            ;283
00010c  f6456025          MOV      r0,#0x5e25            ;284
000110  8020              STRH     r0,[r4,#0]            ;284
000112  bf00              NOP                            ;285
                  |L2.276|
000114  bf00              NOP                            ;252
000116  4638              MOV      r0,r7                 ;287
000118  e780              B        |L2.28|
;;;289    #endif
                          ENDP

00011a  0000              DCW      0x0000
                  |L2.284|
                          DCD      OSIntNestingCtr
                  |L2.288|
                          DCD      0x414d4553
                  |L2.292|
                          DCD      OSSemQty

                          AREA ||i.OSSemPend||, CODE, READONLY, ALIGN=2

                  OSSemPend PROC
;;;340    
;;;341    OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;342                           OS_TICK   timeout,
;;;343                           OS_OPT    opt,
;;;344                           CPU_TS   *p_ts,
;;;345                           OS_ERR   *p_err)
;;;346    {
000004  b088              SUB      sp,sp,#0x20
000006  4605              MOV      r5,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  461c              MOV      r4,r3
00000e  9e10              LDR      r6,[sp,#0x40]
;;;347        OS_SEM_CTR    ctr;
;;;348        OS_PEND_DATA  pend_data;
;;;349        CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;350    
;;;351    
;;;352    #if (OS_CFG_TS_EN == DEF_DISABLED)
;;;353        (void)&p_ts;                                                /* Prevent compiler warning for not using 'ts'          */
;;;354    #endif
;;;355    
;;;356    #ifdef OS_SAFETY_CRITICAL
;;;357        if (p_err == DEF_NULL) {
;;;358            OS_SAFETY_CRITICAL_EXCEPTION();
;;;359            return (0u);
;;;360        }
;;;361    #endif
;;;362    
;;;363    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;364        if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
000014  485e              LDR      r0,|L3.400|
000016  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000018  b130              CBZ      r0,|L3.40|
;;;365    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;366            TRACE_OS_SEM_PEND_FAILED(p_sem);                        /* Record the event.                                    */
;;;367    #endif
;;;368           *p_err = OS_ERR_PEND_ISR;
00001a  f24610ae          MOV      r0,#0x61ae
00001e  8030              STRH     r0,[r6,#0]
;;;369            return (0u);
000020  2000              MOVS     r0,#0
                  |L3.34|
;;;370        }
;;;371    #endif
;;;372    
;;;373    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;374        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;375           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;376            return (0u);
;;;377        }
;;;378    #endif
;;;379    
;;;380    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;381        if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
;;;382           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;383            return (0u);
;;;384        }
;;;385        switch (opt) {                                              /* Validate 'opt'                                       */
;;;386            case OS_OPT_PEND_BLOCKING:
;;;387            case OS_OPT_PEND_NON_BLOCKING:
;;;388                 break;
;;;389    
;;;390            default:
;;;391    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;392                 TRACE_OS_SEM_PEND_FAILED(p_sem);                   /* Record the event.                                    */
;;;393    #endif
;;;394                *p_err = OS_ERR_OPT_INVALID;
;;;395                 return (0u);
;;;396        }
;;;397    #endif
;;;398    
;;;399    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;400        if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
;;;401    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;402            TRACE_OS_SEM_PEND_FAILED(p_sem);                        /* Record the event.                                    */
;;;403    #endif
;;;404           *p_err = OS_ERR_OBJ_TYPE;
;;;405            return (0u);
;;;406        }
;;;407    #endif
;;;408    
;;;409    
;;;410        CPU_CRITICAL_ENTER();
;;;411        if (p_sem->Ctr > 0u) {                                      /* Resource available?                                  */
;;;412            p_sem->Ctr--;                                           /* Yes, caller may proceed                              */
;;;413    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;414            if (p_ts != DEF_NULL) {
;;;415               *p_ts = p_sem->TS;                                   /* get timestamp of last post                           */
;;;416            }
;;;417    #endif
;;;418            ctr   = p_sem->Ctr;
;;;419            CPU_CRITICAL_EXIT();
;;;420           *p_err = OS_ERR_NONE;
;;;421    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;422            TRACE_OS_SEM_PEND(p_sem);                               /* Record the event.                                    */
;;;423    #endif
;;;424            return (ctr);
;;;425        }
;;;426    
;;;427        if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
;;;428    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;429            if (p_ts != DEF_NULL) {
;;;430               *p_ts = 0u;
;;;431            }
;;;432    #endif
;;;433            ctr   = p_sem->Ctr;                                     /* No                                                   */
;;;434            CPU_CRITICAL_EXIT();
;;;435           *p_err = OS_ERR_PEND_WOULD_BLOCK;
;;;436    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;437            TRACE_OS_SEM_PEND_FAILED(p_sem);                        /* Record the event.                                    */
;;;438    #endif
;;;439            return (ctr);
;;;440        } else {                                                    /* Yes                                                  */
;;;441            if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
;;;442    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;443                if (p_ts != DEF_NULL) {
;;;444                   *p_ts = 0u;
;;;445                }
;;;446    #endif
;;;447                CPU_CRITICAL_EXIT();
;;;448    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;449                TRACE_OS_SEM_PEND_FAILED(p_sem);                    /* Record the event.                                    */
;;;450    #endif
;;;451               *p_err = OS_ERR_SCHED_LOCKED;
;;;452                return (0u);
;;;453            }
;;;454        }
;;;455                                                                    /* Lock the scheduler/re-enable interrupts              */
;;;456        OS_CRITICAL_ENTER_CPU_EXIT();
;;;457        OS_Pend(&pend_data,                                         /* Block task pending on Semaphore                      */
;;;458                (OS_PEND_OBJ *)((void *)p_sem),
;;;459                OS_TASK_PEND_ON_SEM,
;;;460                timeout);
;;;461        OS_CRITICAL_EXIT_NO_SCHED();
;;;462    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;463        TRACE_OS_SEM_PEND_BLOCK(p_sem);                             /* Record the event.                                    */
;;;464    #endif
;;;465        OSSched();                                                  /* Find the next highest priority task ready to run     */
;;;466    
;;;467        CPU_CRITICAL_ENTER();
;;;468        switch (OSTCBCurPtr->PendStatus) {
;;;469            case OS_STATUS_PEND_OK:                                 /* We got the semaphore                                 */
;;;470    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;471                 if (p_ts != DEF_NULL) {
;;;472                    *p_ts = OSTCBCurPtr->TS;
;;;473                 }
;;;474    #endif
;;;475    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;476                 TRACE_OS_SEM_PEND(p_sem);                          /* Record the event.                                    */
;;;477    #endif
;;;478                *p_err = OS_ERR_NONE;
;;;479                 break;
;;;480    
;;;481            case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
;;;482    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;483                 if (p_ts != DEF_NULL) {
;;;484                    *p_ts = OSTCBCurPtr->TS;
;;;485                 }
;;;486    #endif
;;;487    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;488                 TRACE_OS_SEM_PEND_FAILED(p_sem);                   /* Record the event.                                    */
;;;489    #endif
;;;490                *p_err = OS_ERR_PEND_ABORT;
;;;491                 break;
;;;492    
;;;493            case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get semaphore within timeout */
;;;494    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;495                 if (p_ts != DEF_NULL) {
;;;496                    *p_ts = 0u;
;;;497                 }
;;;498    #endif
;;;499    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;500                 TRACE_OS_SEM_PEND_FAILED(p_sem);                   /* Record the event.                                    */
;;;501    #endif
;;;502                *p_err = OS_ERR_TIMEOUT;
;;;503                 break;
;;;504    
;;;505            case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
;;;506    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;507                 if (p_ts != DEF_NULL) {
;;;508                    *p_ts = OSTCBCurPtr->TS;
;;;509                 }
;;;510    #endif
;;;511    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;512                 TRACE_OS_SEM_PEND_FAILED(p_sem);                   /* Record the event.                                    */
;;;513    #endif
;;;514                *p_err = OS_ERR_OBJ_DEL;
;;;515                 break;
;;;516    
;;;517            default:
;;;518    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;519                 TRACE_OS_SEM_PEND_FAILED(p_sem);                   /* Record the event.                                    */
;;;520    #endif
;;;521                *p_err = OS_ERR_STATUS_INVALID;
;;;522                 CPU_CRITICAL_EXIT();
;;;523                 return (0u);
;;;524        }
;;;525        ctr = p_sem->Ctr;
;;;526        CPU_CRITICAL_EXIT();
;;;527        return (ctr);
;;;528    }
000022  b008              ADD      sp,sp,#0x20
000024  e8bd87f0          POP      {r4-r10,pc}
                  |L3.40|
000028  495a              LDR      r1,|L3.404|
00002a  6828              LDR      r0,[r5,#0]            ;400
00002c  4288              CMP      r0,r1                 ;400
00002e  d004              BEQ      |L3.58|
000030  f64550c4          MOV      r0,#0x5dc4            ;404
000034  8030              STRH     r0,[r6,#0]            ;404
000036  2000              MOVS     r0,#0                 ;405
000038  e7f3              B        |L3.34|
                  |L3.58|
00003a  bf00              NOP                            ;410
00003c  bf00              NOP                            ;410
00003e  f7fffffe          BL       CPU_SR_Save
000042  4682              MOV      r10,r0                ;410
000044  bf00              NOP                            ;410
000046  f7fffffe          BL       CPU_IntDisMeasStart
00004a  bf00              NOP                            ;410
00004c  6a28              LDR      r0,[r5,#0x20]         ;411
00004e  b198              CBZ      r0,|L3.120|
000050  6a28              LDR      r0,[r5,#0x20]         ;412
000052  1e40              SUBS     r0,r0,#1              ;412
000054  6228              STR      r0,[r5,#0x20]         ;412
000056  b10c              CBZ      r4,|L3.92|
000058  6a68              LDR      r0,[r5,#0x24]         ;415
00005a  6020              STR      r0,[r4,#0]            ;415
                  |L3.92|
00005c  6a2f              LDR      r7,[r5,#0x20]         ;418
00005e  bf00              NOP                            ;419
000060  f7fffffe          BL       CPU_IntDisMeasStop
000064  bf00              NOP                            ;419
000066  4650              MOV      r0,r10                ;419
000068  f7fffffe          BL       CPU_SR_Restore
00006c  bf00              NOP                            ;419
00006e  bf00              NOP                            ;419
000070  2000              MOVS     r0,#0                 ;420
000072  8030              STRH     r0,[r6,#0]            ;420
000074  4638              MOV      r0,r7                 ;424
000076  e7d4              B        |L3.34|
                  |L3.120|
000078  f4194f00          TST      r9,#0x8000            ;427
00007c  d011              BEQ      |L3.162|
00007e  b10c              CBZ      r4,|L3.132|
000080  2000              MOVS     r0,#0                 ;430
000082  6020              STR      r0,[r4,#0]            ;430
                  |L3.132|
000084  6a2f              LDR      r7,[r5,#0x20]         ;433
000086  bf00              NOP                            ;434
000088  f7fffffe          BL       CPU_IntDisMeasStop
00008c  bf00              NOP                            ;434
00008e  4650              MOV      r0,r10                ;434
000090  f7fffffe          BL       CPU_SR_Restore
000094  bf00              NOP                            ;434
000096  bf00              NOP                            ;434
000098  f24610b0          MOV      r0,#0x61b0            ;435
00009c  8030              STRH     r0,[r6,#0]            ;435
00009e  4638              MOV      r0,r7                 ;439
0000a0  e7bf              B        |L3.34|
                  |L3.162|
0000a2  483d              LDR      r0,|L3.408|
0000a4  7800              LDRB     r0,[r0,#0]            ;441  ; OSSchedLockNestingCtr
0000a6  b180              CBZ      r0,|L3.202|
0000a8  b10c              CBZ      r4,|L3.174|
0000aa  2000              MOVS     r0,#0                 ;444
0000ac  6020              STR      r0,[r4,#0]            ;444
                  |L3.174|
0000ae  bf00              NOP                            ;447
0000b0  f7fffffe          BL       CPU_IntDisMeasStop
0000b4  bf00              NOP                            ;447
0000b6  4650              MOV      r0,r10                ;447
0000b8  f7fffffe          BL       CPU_SR_Restore
0000bc  bf00              NOP                            ;447
0000be  bf00              NOP                            ;447
0000c0  f6465063          MOV      r0,#0x6d63            ;451
0000c4  8030              STRH     r0,[r6,#0]            ;451
0000c6  2000              MOVS     r0,#0                 ;452
0000c8  e7ab              B        |L3.34|
                  |L3.202|
0000ca  4643              MOV      r3,r8                 ;457
0000cc  2206              MOVS     r2,#6                 ;457
0000ce  4629              MOV      r1,r5                 ;457
0000d0  4668              MOV      r0,sp                 ;457
0000d2  f7fffffe          BL       OS_Pend
0000d6  bf00              NOP                            ;461
0000d8  f7fffffe          BL       CPU_IntDisMeasStop
0000dc  bf00              NOP                            ;461
0000de  4650              MOV      r0,r10                ;461
0000e0  f7fffffe          BL       CPU_SR_Restore
0000e4  bf00              NOP                            ;461
0000e6  bf00              NOP                            ;461
0000e8  f7fffffe          BL       OSSched
0000ec  bf00              NOP                            ;467
0000ee  bf00              NOP                            ;467
0000f0  f7fffffe          BL       CPU_SR_Save
0000f4  4682              MOV      r10,r0                ;467
0000f6  bf00              NOP                            ;467
0000f8  f7fffffe          BL       CPU_IntDisMeasStart
0000fc  bf00              NOP                            ;467
0000fe  4827              LDR      r0,|L3.412|
000100  6800              LDR      r0,[r0,#0]            ;468  ; OSTCBCurPtr
000102  f8900035          LDRB     r0,[r0,#0x35]         ;468
000106  b130              CBZ      r0,|L3.278|
000108  2801              CMP      r0,#1                 ;468
00010a  d00c              BEQ      |L3.294|
00010c  2802              CMP      r0,#2                 ;468
00010e  d01a              BEQ      |L3.326|
000110  2803              CMP      r0,#3                 ;468
000112  d121              BNE      |L3.344|
000114  e010              B        |L3.312|
                  |L3.278|
000116  b11c              CBZ      r4,|L3.288|
000118  4820              LDR      r0,|L3.412|
00011a  6800              LDR      r0,[r0,#0]            ;472  ; OSTCBCurPtr
00011c  6c80              LDR      r0,[r0,#0x48]         ;472
00011e  6020              STR      r0,[r4,#0]            ;472
                  |L3.288|
000120  2000              MOVS     r0,#0                 ;478
000122  8030              STRH     r0,[r6,#0]            ;478
000124  e026              B        |L3.372|
                  |L3.294|
000126  b11c              CBZ      r4,|L3.304|
000128  481c              LDR      r0,|L3.412|
00012a  6800              LDR      r0,[r0,#0]            ;484  ; OSTCBCurPtr
00012c  6c80              LDR      r0,[r0,#0x48]         ;484
00012e  6020              STR      r0,[r4,#0]            ;484
                  |L3.304|
000130  f24610a9          MOV      r0,#0x61a9            ;490
000134  8030              STRH     r0,[r6,#0]            ;490
000136  e01d              B        |L3.372|
                  |L3.312|
000138  b10c              CBZ      r4,|L3.318|
00013a  2000              MOVS     r0,#0                 ;496
00013c  6020              STR      r0,[r4,#0]            ;496
                  |L3.318|
00013e  f24720d9          MOV      r0,#0x72d9            ;502
000142  8030              STRH     r0,[r6,#0]            ;502
000144  e016              B        |L3.372|
                  |L3.326|
000146  b11c              CBZ      r4,|L3.336|
000148  4814              LDR      r0,|L3.412|
00014a  6800              LDR      r0,[r0,#0]            ;508  ; OSTCBCurPtr
00014c  6c80              LDR      r0,[r0,#0x48]         ;508
00014e  6020              STR      r0,[r4,#0]            ;508
                  |L3.336|
000150  f64550c2          MOV      r0,#0x5dc2            ;514
000154  8030              STRH     r0,[r6,#0]            ;514
000156  e00d              B        |L3.372|
                  |L3.344|
000158  f646602e          MOV      r0,#0x6e2e            ;521
00015c  8030              STRH     r0,[r6,#0]            ;521
00015e  bf00              NOP                            ;522
000160  f7fffffe          BL       CPU_IntDisMeasStop
000164  bf00              NOP                            ;522
000166  4650              MOV      r0,r10                ;522
000168  f7fffffe          BL       CPU_SR_Restore
00016c  bf00              NOP                            ;522
00016e  bf00              NOP                            ;522
000170  2000              MOVS     r0,#0                 ;523
000172  e756              B        |L3.34|
                  |L3.372|
000174  bf00              NOP                            ;479
000176  6a2f              LDR      r7,[r5,#0x20]         ;525
000178  bf00              NOP                            ;526
00017a  f7fffffe          BL       CPU_IntDisMeasStop
00017e  bf00              NOP                            ;526
000180  4650              MOV      r0,r10                ;526
000182  f7fffffe          BL       CPU_SR_Restore
000186  bf00              NOP                            ;526
000188  bf00              NOP                            ;526
00018a  4638              MOV      r0,r7                 ;527
00018c  e749              B        |L3.34|
;;;529    
                          ENDP

00018e  0000              DCW      0x0000
                  |L3.400|
                          DCD      OSIntNestingCtr
                  |L3.404|
                          DCD      0x414d4553
                  |L3.408|
                          DCD      OSSchedLockNestingCtr
                  |L3.412|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSSemPendAbort||, CODE, READONLY, ALIGN=2

                  OSSemPendAbort PROC
;;;565    #if (OS_CFG_SEM_PEND_ABORT_EN == DEF_ENABLED)
;;;566    OS_OBJ_QTY  OSSemPendAbort (OS_SEM  *p_sem,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;567                                OS_OPT   opt,
;;;568                                OS_ERR  *p_err)
;;;569    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;570        OS_PEND_LIST  *p_pend_list;
;;;571        OS_TCB        *p_tcb;
;;;572        CPU_TS         ts;
;;;573        OS_OBJ_QTY     nbr_tasks;
;;;574        CPU_SR_ALLOC();
00000a  f04f0a00          MOV      r10,#0
;;;575    
;;;576    
;;;577    
;;;578    #ifdef OS_SAFETY_CRITICAL
;;;579        if (p_err == DEF_NULL) {
;;;580            OS_SAFETY_CRITICAL_EXCEPTION();
;;;581            return (0u);
;;;582        }
;;;583    #endif
;;;584    
;;;585    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;586        if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
00000e  482c              LDR      r0,|L4.192|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000012  b128              CBZ      r0,|L4.32|
;;;587           *p_err =  OS_ERR_PEND_ABORT_ISR;
000014  f24610aa          MOV      r0,#0x61aa
000018  8020              STRH     r0,[r4,#0]
;;;588            return (0u);
00001a  2000              MOVS     r0,#0
                  |L4.28|
;;;589        }
;;;590    #endif
;;;591    
;;;592    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;593        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;594           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;595            return (0u);
;;;596        }
;;;597    #endif
;;;598    
;;;599    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;600        if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
;;;601           *p_err =  OS_ERR_OBJ_PTR_NULL;
;;;602            return (0u);
;;;603        }
;;;604        switch (opt) {                                              /* Validate 'opt'                                       */
;;;605            case OS_OPT_PEND_ABORT_1:
;;;606            case OS_OPT_PEND_ABORT_ALL:
;;;607            case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
;;;608            case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
;;;609                 break;
;;;610    
;;;611            default:
;;;612                *p_err =  OS_ERR_OPT_INVALID;
;;;613                 return (0u);
;;;614        }
;;;615    #endif
;;;616    
;;;617    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;618        if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
;;;619           *p_err =  OS_ERR_OBJ_TYPE;
;;;620            return (0u);
;;;621        }
;;;622    #endif
;;;623    
;;;624        CPU_CRITICAL_ENTER();
;;;625        p_pend_list = &p_sem->PendList;
;;;626        if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on semaphore?                       */
;;;627            CPU_CRITICAL_EXIT();                                    /* No                                                   */
;;;628           *p_err =  OS_ERR_PEND_ABORT_NONE;
;;;629            return (0u);
;;;630        }
;;;631    
;;;632        OS_CRITICAL_ENTER_CPU_EXIT();
;;;633        nbr_tasks = 0u;
;;;634    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;635        ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
;;;636    #else
;;;637        ts        = 0u;
;;;638    #endif
;;;639        while (p_pend_list->HeadPtr != DEF_NULL) {
;;;640            p_tcb = p_pend_list->HeadPtr->TCBPtr;
;;;641            OS_PendAbort((OS_PEND_OBJ *)((void *)p_sem),
;;;642                         p_tcb,
;;;643                         ts);
;;;644            nbr_tasks++;
;;;645            if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
;;;646                break;                                              /* No                                                   */
;;;647            }
;;;648        }
;;;649        OS_CRITICAL_EXIT_NO_SCHED();
;;;650    
;;;651        if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
;;;652            OSSched();                                              /* Run the scheduler                                    */
;;;653        }
;;;654    
;;;655       *p_err = OS_ERR_NONE;
;;;656        return (nbr_tasks);
;;;657    }
00001c  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.32|
000020  4928              LDR      r1,|L4.196|
000022  6830              LDR      r0,[r6,#0]            ;618
000024  4288              CMP      r0,r1                 ;618
000026  d004              BEQ      |L4.50|
000028  f64550c4          MOV      r0,#0x5dc4            ;619
00002c  8020              STRH     r0,[r4,#0]            ;619
00002e  2000              MOVS     r0,#0                 ;620
000030  e7f4              B        |L4.28|
                  |L4.50|
000032  bf00              NOP                            ;624
000034  bf00              NOP                            ;624
000036  f7fffffe          BL       CPU_SR_Save
00003a  4682              MOV      r10,r0                ;624
00003c  bf00              NOP                            ;624
00003e  f7fffffe          BL       CPU_IntDisMeasStart
000042  bf00              NOP                            ;624
000044  f1060508          ADD      r5,r6,#8              ;625
000048  6828              LDR      r0,[r5,#0]            ;626
00004a  b968              CBNZ     r0,|L4.104|
00004c  bf00              NOP                            ;627
00004e  f7fffffe          BL       CPU_IntDisMeasStop
000052  bf00              NOP                            ;627
000054  4650              MOV      r0,r10                ;627
000056  f7fffffe          BL       CPU_SR_Restore
00005a  bf00              NOP                            ;627
00005c  bf00              NOP                            ;627
00005e  f24610ab          MOV      r0,#0x61ab            ;628
000062  8020              STRH     r0,[r4,#0]            ;628
000064  2000              MOVS     r0,#0                 ;629
000066  e7d9              B        |L4.28|
                  |L4.104|
000068  f04f0800          MOV      r8,#0                 ;633
00006c  f7fffffe          BL       CPU_TS_TmrRd
000070  4683              MOV      r11,r0                ;635
000072  e00f              B        |L4.148|
                  |L4.116|
000074  6828              LDR      r0,[r5,#0]            ;640
000076  f8d09008          LDR      r9,[r0,#8]            ;640
00007a  465a              MOV      r2,r11                ;641
00007c  4649              MOV      r1,r9                 ;641
00007e  4630              MOV      r0,r6                 ;641
000080  f7fffffe          BL       OS_PendAbort
000084  f1080001          ADD      r0,r8,#1              ;644
000088  fa1ff880          UXTH     r8,r0                 ;644
00008c  f5b77f80          CMP      r7,#0x100             ;645
000090  d000              BEQ      |L4.148|
000092  e002              B        |L4.154|
                  |L4.148|
000094  6828              LDR      r0,[r5,#0]            ;639
000096  2800              CMP      r0,#0                 ;639
000098  d1ec              BNE      |L4.116|
                  |L4.154|
00009a  bf00              NOP                            ;646
00009c  bf00              NOP                            ;649
00009e  f7fffffe          BL       CPU_IntDisMeasStop
0000a2  bf00              NOP                            ;649
0000a4  4650              MOV      r0,r10                ;649
0000a6  f7fffffe          BL       CPU_SR_Restore
0000aa  bf00              NOP                            ;649
0000ac  bf00              NOP                            ;649
0000ae  f4174f00          TST      r7,#0x8000            ;651
0000b2  d101              BNE      |L4.184|
0000b4  f7fffffe          BL       OSSched
                  |L4.184|
0000b8  2000              MOVS     r0,#0                 ;655
0000ba  8020              STRH     r0,[r4,#0]            ;655
0000bc  4640              MOV      r0,r8                 ;656
0000be  e7ad              B        |L4.28|
;;;658    #endif
                          ENDP

                  |L4.192|
                          DCD      OSIntNestingCtr
                  |L4.196|
                          DCD      0x414d4553

                          AREA ||i.OSSemPost||, CODE, READONLY, ALIGN=2

                  OSSemPost PROC
;;;694    
;;;695    OS_SEM_CTR  OSSemPost (OS_SEM  *p_sem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;696                           OS_OPT   opt,
;;;697                           OS_ERR  *p_err)
;;;698    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;699        OS_SEM_CTR  ctr;
;;;700        CPU_TS      ts;
;;;701    
;;;702    
;;;703    
;;;704    #ifdef OS_SAFETY_CRITICAL
;;;705        if (p_err == DEF_NULL) {
;;;706            OS_SAFETY_CRITICAL_EXCEPTION();
;;;707            return (0u);
;;;708        }
;;;709    #endif
;;;710    
;;;711    #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
;;;712        if (OSRunning != OS_STATE_OS_RUNNING) {
;;;713           *p_err = OS_ERR_OS_NOT_RUNNING;
;;;714            return (0u);
;;;715        }
;;;716    #endif
;;;717    
;;;718    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;719        if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
;;;720    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;721            TRACE_OS_SEM_POST_FAILED(p_sem);                        /* Record the event.                                    */
;;;722    #endif
;;;723           *p_err  = OS_ERR_OBJ_PTR_NULL;
;;;724            return (0u);
;;;725        }
;;;726        switch (opt) {                                              /* Validate 'opt'                                       */
;;;727            case OS_OPT_POST_1:
;;;728            case OS_OPT_POST_ALL:
;;;729            case OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:
;;;730            case OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
;;;731                 break;
;;;732    
;;;733            default:
;;;734    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;735                 TRACE_OS_SEM_POST_FAILED(p_sem);                   /* Record the event.                                    */
;;;736    #endif
;;;737                *p_err =  OS_ERR_OPT_INVALID;
;;;738                 return (0u);
;;;739        }
;;;740    #endif
;;;741    
;;;742    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;743        if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
00000a  490b              LDR      r1,|L5.56|
00000c  6828              LDR      r0,[r5,#0]
00000e  4288              CMP      r0,r1
000010  d005              BEQ      |L5.30|
;;;744    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;745            TRACE_OS_SEM_POST_FAILED(p_sem);                        /* Record the event.                                    */
;;;746    #endif
;;;747           *p_err = OS_ERR_OBJ_TYPE;
000012  f64550c4          MOV      r0,#0x5dc4
000016  8020              STRH     r0,[r4,#0]
;;;748            return (0u);
000018  2000              MOVS     r0,#0
                  |L5.26|
;;;749        }
;;;750    #endif
;;;751    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;752        ts = OS_TS_GET();                                           /* Get timestamp                                        */
;;;753    #else
;;;754        ts = 0u;
;;;755    #endif
;;;756    
;;;757    #if (OS_CFG_ISR_POST_DEFERRED_EN == DEF_ENABLED)
;;;758        if (OSIntNestingCtr > 0u) {                                 /* See if called from an ISR                            */
;;;759            OS_IntQPost(OS_OBJ_TYPE_SEM,                            /* Post to ISR queue                                    */
;;;760                        (void      *)p_sem,
;;;761                        DEF_NULL,
;;;762                        0u,
;;;763                        0u,
;;;764                        opt,
;;;765                        ts,
;;;766                        p_err);
;;;767            return (0u);
;;;768        }
;;;769    #endif
;;;770    
;;;771    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN == DEF_ENABLED))
;;;772        TRACE_OS_SEM_POST(p_sem);                                   /* Record the event.                                    */
;;;773    #endif
;;;774    
;;;775        ctr = OS_SemPost(p_sem,                                     /* Post to semaphore                                    */
;;;776                         opt,
;;;777                         ts,
;;;778                         p_err);
;;;779    
;;;780        return (ctr);
;;;781    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L5.30|
00001e  f7fffffe          BL       CPU_TS_TmrRd
000022  4680              MOV      r8,r0                 ;752
000024  4623              MOV      r3,r4                 ;775
000026  4642              MOV      r2,r8                 ;775
000028  4631              MOV      r1,r6                 ;775
00002a  4628              MOV      r0,r5                 ;775
00002c  f7fffffe          BL       OS_SemPost
000030  4607              MOV      r7,r0                 ;775
000032  4638              MOV      r0,r7                 ;780
000034  e7f1              B        |L5.26|
;;;782    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x414d4553

                          AREA ||i.OSSemSet||, CODE, READONLY, ALIGN=2

                  OSSemSet PROC
;;;812    #if (OS_CFG_SEM_SET_EN == DEF_ENABLED)
;;;813    void  OSSemSet (OS_SEM      *p_sem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;814                    OS_SEM_CTR   cnt,
;;;815                    OS_ERR      *p_err)
;;;816    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;817        OS_PEND_LIST  *p_pend_list;
;;;818        CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;819    
;;;820    
;;;821    
;;;822    #ifdef OS_SAFETY_CRITICAL
;;;823        if (p_err == DEF_NULL) {
;;;824            OS_SAFETY_CRITICAL_EXCEPTION();
;;;825            return;
;;;826        }
;;;827    #endif
;;;828    
;;;829    #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
;;;830        if (OSIntNestingCtr > 0u) {                                 /* Can't call this function from an ISR                 */
00000e  4819              LDR      r0,|L6.116|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000012  b120              CBZ      r0,|L6.30|
;;;831           *p_err = OS_ERR_SET_ISR;
000014  f64650c6          MOV      r0,#0x6dc6
000018  8028              STRH     r0,[r5,#0]
                  |L6.26|
;;;832            return;
;;;833        }
;;;834    #endif
;;;835    
;;;836    #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
;;;837        if (p_sem == DEF_NULL) {                                    /* Validate 'p_sem'                                     */
;;;838           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;839            return;
;;;840        }
;;;841    #endif
;;;842    
;;;843    #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
;;;844        if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
;;;845           *p_err = OS_ERR_OBJ_TYPE;
;;;846            return;
;;;847        }
;;;848    #endif
;;;849    
;;;850       *p_err = OS_ERR_NONE;
;;;851        CPU_CRITICAL_ENTER();
;;;852        if (p_sem->Ctr > 0u) {                                      /* See if semaphore already has a count                 */
;;;853            p_sem->Ctr = cnt;                                       /* Yes, set it to the new value specified.              */
;;;854        } else {
;;;855            p_pend_list = &p_sem->PendList;                         /* No                                                   */
;;;856            if (p_pend_list->HeadPtr == DEF_NULL) {                 /* See if task(s) waiting?                              */
;;;857                p_sem->Ctr = cnt;                                   /* No, OK to set the value                              */
;;;858            } else {
;;;859               *p_err      = OS_ERR_TASK_WAITING;
;;;860            }
;;;861        }
;;;862        CPU_CRITICAL_EXIT();
;;;863    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L6.30|
00001e  4916              LDR      r1,|L6.120|
000020  6820              LDR      r0,[r4,#0]            ;844
000022  4288              CMP      r0,r1                 ;844
000024  d003              BEQ      |L6.46|
000026  f64550c4          MOV      r0,#0x5dc4            ;845
00002a  8028              STRH     r0,[r5,#0]            ;845
00002c  e7f5              B        |L6.26|
                  |L6.46|
00002e  2000              MOVS     r0,#0                 ;850
000030  8028              STRH     r0,[r5,#0]            ;850
000032  bf00              NOP                            ;851
000034  bf00              NOP                            ;851
000036  f7fffffe          BL       CPU_SR_Save
00003a  4680              MOV      r8,r0                 ;851
00003c  bf00              NOP                            ;851
00003e  f7fffffe          BL       CPU_IntDisMeasStart
000042  bf00              NOP                            ;851
000044  6a20              LDR      r0,[r4,#0x20]         ;852
000046  b108              CBZ      r0,|L6.76|
000048  6226              STR      r6,[r4,#0x20]         ;853
00004a  e008              B        |L6.94|
                  |L6.76|
00004c  f1040708          ADD      r7,r4,#8              ;855
000050  6838              LDR      r0,[r7,#0]            ;856
000052  b908              CBNZ     r0,|L6.88|
000054  6226              STR      r6,[r4,#0x20]         ;857
000056  e002              B        |L6.94|
                  |L6.88|
000058  f247105f          MOV      r0,#0x715f            ;859
00005c  8028              STRH     r0,[r5,#0]            ;859
                  |L6.94|
00005e  bf00              NOP                            ;862
000060  f7fffffe          BL       CPU_IntDisMeasStop
000064  bf00              NOP                            ;862
000066  4640              MOV      r0,r8                 ;862
000068  f7fffffe          BL       CPU_SR_Restore
00006c  bf00              NOP                            ;862
00006e  bf00              NOP                            ;862
000070  bf00              NOP      
000072  e7d2              B        |L6.26|
;;;864    #endif
                          ENDP

                  |L6.116|
                          DCD      OSIntNestingCtr
                  |L6.120|
                          DCD      0x414d4553

                          AREA ||i.OS_SemClr||, CODE, READONLY, ALIGN=2

                  OS_SemClr PROC
;;;882    
;;;883    void  OS_SemClr (OS_SEM  *p_sem)
000000  b510              PUSH     {r4,lr}
;;;884    {
000002  4604              MOV      r4,r0
;;;885    #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
;;;886        p_sem->Type    = OS_OBJ_TYPE_NONE;                          /* Mark the data structure as a NONE                    */
000004  4805              LDR      r0,|L7.28|
000006  6020              STR      r0,[r4,#0]
;;;887    #endif
;;;888        p_sem->Ctr     = 0u;                                        /* Set semaphore value                                  */
000008  2000              MOVS     r0,#0
00000a  6220              STR      r0,[r4,#0x20]
;;;889    #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;890        p_sem->TS      = 0u;                                        /* Clear the time stamp                                 */
00000c  6260              STR      r0,[r4,#0x24]
;;;891    #endif
;;;892    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;893        p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
00000e  a004              ADR      r0,|L7.32|
000010  6060              STR      r0,[r4,#4]
;;;894    #endif
;;;895        OS_PendListInit(&p_sem->PendList);                          /* Initialize the waiting list                          */
000012  f1040008          ADD      r0,r4,#8
000016  f7fffffe          BL       OS_PendListInit
;;;896    }
00001a  bd10              POP      {r4,pc}
;;;897    
                          ENDP

                  |L7.28|
                          DCD      0x454e4f4e
                  |L7.32|
000020  3f53454d          DCB      "?SEM",0
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0

                          AREA ||i.OS_SemDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_SemDbgListAdd PROC
;;;914    #if (OS_CFG_DBG_EN == DEF_ENABLED)
;;;915    void  OS_SemDbgListAdd (OS_SEM  *p_sem)
000000  a109              ADR      r1,|L8.40|
;;;916    {
;;;917        p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
000002  61c1              STR      r1,[r0,#0x1c]
;;;918        p_sem->DbgPrevPtr               = DEF_NULL;
000004  2100              MOVS     r1,#0
000006  6141              STR      r1,[r0,#0x14]
;;;919        if (OSSemDbgListPtr == DEF_NULL) {
000008  4908              LDR      r1,|L8.44|
00000a  6809              LDR      r1,[r1,#0]  ; OSSemDbgListPtr
00000c  b911              CBNZ     r1,|L8.20|
;;;920            p_sem->DbgNextPtr           = DEF_NULL;
00000e  2100              MOVS     r1,#0
000010  6181              STR      r1,[r0,#0x18]
000012  e005              B        |L8.32|
                  |L8.20|
;;;921        } else {
;;;922            p_sem->DbgNextPtr           =  OSSemDbgListPtr;
000014  4905              LDR      r1,|L8.44|
000016  6809              LDR      r1,[r1,#0]  ; OSSemDbgListPtr
000018  6181              STR      r1,[r0,#0x18]
;;;923            OSSemDbgListPtr->DbgPrevPtr =  p_sem;
00001a  4904              LDR      r1,|L8.44|
00001c  6809              LDR      r1,[r1,#0]  ; OSSemDbgListPtr
00001e  6148              STR      r0,[r1,#0x14]
                  |L8.32|
;;;924        }
;;;925        OSSemDbgListPtr                 =  p_sem;
000020  4902              LDR      r1,|L8.44|
000022  6008              STR      r0,[r1,#0]  ; OSSemDbgListPtr
;;;926    }
000024  4770              BX       lr
;;;927    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
000028  2000              DCB      " ",0
00002a  00                DCB      0
00002b  00                DCB      0
                  |L8.44|
                          DCD      OSSemDbgListPtr

                          AREA ||i.OS_SemDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_SemDbgListRemove PROC
;;;929    
;;;930    void  OS_SemDbgListRemove (OS_SEM  *p_sem)
000000  6942              LDR      r2,[r0,#0x14]
;;;931    {
;;;932        OS_SEM  *p_sem_next;
;;;933        OS_SEM  *p_sem_prev;
;;;934    
;;;935    
;;;936        p_sem_prev = p_sem->DbgPrevPtr;
;;;937        p_sem_next = p_sem->DbgNextPtr;
000002  6981              LDR      r1,[r0,#0x18]
;;;938    
;;;939        if (p_sem_prev == DEF_NULL) {
000004  b93a              CBNZ     r2,|L9.22|
;;;940            OSSemDbgListPtr = p_sem_next;
000006  4b09              LDR      r3,|L9.44|
000008  6019              STR      r1,[r3,#0]  ; OSSemDbgListPtr
;;;941            if (p_sem_next != DEF_NULL) {
00000a  b109              CBZ      r1,|L9.16|
;;;942                p_sem_next->DbgPrevPtr = DEF_NULL;
00000c  2300              MOVS     r3,#0
00000e  614b              STR      r3,[r1,#0x14]
                  |L9.16|
;;;943            }
;;;944            p_sem->DbgNextPtr = DEF_NULL;
000010  2300              MOVS     r3,#0
000012  6183              STR      r3,[r0,#0x18]
000014  e009              B        |L9.42|
                  |L9.22|
;;;945    
;;;946        } else if (p_sem_next == DEF_NULL) {
000016  b919              CBNZ     r1,|L9.32|
;;;947            p_sem_prev->DbgNextPtr = DEF_NULL;
000018  2300              MOVS     r3,#0
00001a  6193              STR      r3,[r2,#0x18]
;;;948            p_sem->DbgPrevPtr      = DEF_NULL;
00001c  6143              STR      r3,[r0,#0x14]
00001e  e004              B        |L9.42|
                  |L9.32|
;;;949    
;;;950        } else {
;;;951            p_sem_prev->DbgNextPtr =  p_sem_next;
000020  6191              STR      r1,[r2,#0x18]
;;;952            p_sem_next->DbgPrevPtr =  p_sem_prev;
000022  614a              STR      r2,[r1,#0x14]
;;;953            p_sem->DbgNextPtr      = DEF_NULL;
000024  2300              MOVS     r3,#0
000026  6183              STR      r3,[r0,#0x18]
;;;954            p_sem->DbgPrevPtr      = DEF_NULL;
000028  6143              STR      r3,[r0,#0x14]
                  |L9.42|
;;;955        }
;;;956    }
00002a  4770              BX       lr
;;;957    #endif
                          ENDP

                  |L9.44|
                          DCD      OSSemDbgListPtr

                          AREA ||i.OS_SemPost||, CODE, READONLY, ALIGN=1

                  OS_SemPost PROC
;;;989    
;;;990    OS_SEM_CTR  OS_SemPost (OS_SEM  *p_sem,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;991                            OS_OPT   opt,
;;;992                            CPU_TS   ts,
;;;993                            OS_ERR  *p_err)
;;;994    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;995        OS_SEM_CTR     ctr;
;;;996        OS_PEND_LIST  *p_pend_list;
;;;997        OS_PEND_DATA  *p_pend_data;
;;;998        OS_PEND_DATA  *p_pend_data_next;
;;;999        OS_TCB        *p_tcb;
;;;1000       CPU_SR_ALLOC();
00000c  2000              MOVS     r0,#0
00000e  9001              STR      r0,[sp,#4]
;;;1001   
;;;1002   
;;;1003       CPU_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  9001              STR      r0,[sp,#4]
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStart
000020  bf00              NOP      
;;;1004       p_pend_list = &p_sem->PendList;
000022  f1040908          ADD      r9,r4,#8
;;;1005       if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on semaphore?                       */
000026  f8d90000          LDR      r0,[r9,#0]
00002a  bb28              CBNZ     r0,|L10.120|
;;;1006           if (p_sem->Ctr == (OS_SEM_CTR)-1) {
00002c  6a20              LDR      r0,[r4,#0x20]
00002e  1c40              ADDS     r0,r0,#1
000030  d10e              BNE      |L10.80|
;;;1007              CPU_CRITICAL_EXIT();
000032  bf00              NOP      
000034  f7fffffe          BL       CPU_IntDisMeasStop
000038  bf00              NOP      
00003a  9801              LDR      r0,[sp,#4]
00003c  f7fffffe          BL       CPU_SR_Restore
000040  bf00              NOP      
000042  bf00              NOP      
;;;1008             *p_err = OS_ERR_SEM_OVF;
000044  f64650c5          MOV      r0,#0x6dc5
000048  8028              STRH     r0,[r5,#0]
;;;1009              return (0u);
00004a  2000              MOVS     r0,#0
                  |L10.76|
;;;1010           }
;;;1011           p_sem->Ctr++;                                           /* No                                                   */
;;;1012           ctr       = p_sem->Ctr;
;;;1013   #if (OS_CFG_TS_EN == DEF_ENABLED)
;;;1014           p_sem->TS = ts;                                         /* Save timestamp in semaphore control block            */
;;;1015   #endif
;;;1016           CPU_CRITICAL_EXIT();
;;;1017          *p_err     = OS_ERR_NONE;
;;;1018           return (ctr);
;;;1019       }
;;;1020   
;;;1021       OS_CRITICAL_ENTER_CPU_EXIT();
;;;1022       p_pend_data = p_pend_list->HeadPtr;
;;;1023       while (p_pend_data != DEF_NULL) {
;;;1024           p_tcb            = p_pend_data->TCBPtr;
;;;1025           p_pend_data_next = p_pend_data->NextPtr;
;;;1026           OS_Post((OS_PEND_OBJ *)((void *)p_sem),
;;;1027                   p_tcb,
;;;1028                   DEF_NULL,
;;;1029                   0u,
;;;1030                   ts);
;;;1031           if ((opt & OS_OPT_POST_ALL) == 0) {                     /* Post to all tasks waiting?                           */
;;;1032               break;                                              /* No                                                   */
;;;1033           }
;;;1034           p_pend_data = p_pend_data_next;
;;;1035       }
;;;1036       OS_CRITICAL_EXIT_NO_SCHED();
;;;1037       if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
;;;1038           OSSched();                                              /* Run the scheduler                                    */
;;;1039       }
;;;1040      *p_err = OS_ERR_NONE;
;;;1041       return (0u);
;;;1042   }
00004c  e8bd8ffe          POP      {r1-r11,pc}
                  |L10.80|
000050  6a20              LDR      r0,[r4,#0x20]         ;1011
000052  1c40              ADDS     r0,r0,#1              ;1011
000054  6220              STR      r0,[r4,#0x20]         ;1011
000056  f8d4a020          LDR      r10,[r4,#0x20]        ;1012
00005a  f8c48024          STR      r8,[r4,#0x24]         ;1014
00005e  bf00              NOP                            ;1016
000060  f7fffffe          BL       CPU_IntDisMeasStop
000064  bf00              NOP                            ;1016
000066  9801              LDR      r0,[sp,#4]            ;1016
000068  f7fffffe          BL       CPU_SR_Restore
00006c  bf00              NOP                            ;1016
00006e  bf00              NOP                            ;1016
000070  2000              MOVS     r0,#0                 ;1017
000072  8028              STRH     r0,[r5,#0]            ;1017
000074  4650              MOV      r0,r10                ;1018
000076  e7e9              B        |L10.76|
                  |L10.120|
000078  f8d96000          LDR      r6,[r9,#0]            ;1022
00007c  e010              B        |L10.160|
                  |L10.126|
00007e  68b0              LDR      r0,[r6,#8]            ;1024
000080  9002              STR      r0,[sp,#8]            ;1024
000082  f8d6b004          LDR      r11,[r6,#4]           ;1025
000086  2300              MOVS     r3,#0                 ;1026
000088  461a              MOV      r2,r3                 ;1026
00008a  f8cd8000          STR      r8,[sp,#0]            ;1026
00008e  4620              MOV      r0,r4                 ;1026
000090  9902              LDR      r1,[sp,#8]            ;1026
000092  f7fffffe          BL       OS_Post
000096  f4177f00          TST      r7,#0x200             ;1031
00009a  d100              BNE      |L10.158|
00009c  e002              B        |L10.164|
                  |L10.158|
00009e  465e              MOV      r6,r11                ;1034
                  |L10.160|
0000a0  2e00              CMP      r6,#0                 ;1023
0000a2  d1ec              BNE      |L10.126|
                  |L10.164|
0000a4  bf00              NOP                            ;1032
0000a6  bf00              NOP                            ;1036
0000a8  f7fffffe          BL       CPU_IntDisMeasStop
0000ac  bf00              NOP                            ;1036
0000ae  9801              LDR      r0,[sp,#4]            ;1036
0000b0  f7fffffe          BL       CPU_SR_Restore
0000b4  bf00              NOP                            ;1036
0000b6  bf00              NOP                            ;1036
0000b8  f4174f00          TST      r7,#0x8000            ;1037
0000bc  d101              BNE      |L10.194|
0000be  f7fffffe          BL       OSSched
                  |L10.194|
0000c2  2000              MOVS     r0,#0                 ;1040
0000c4  8028              STRH     r0,[r5,#0]            ;1040
0000c6  bf00              NOP                            ;1041
0000c8  e7c0              B        |L10.76|
;;;1043   
                          ENDP

