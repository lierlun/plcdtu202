; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\bsp_uart.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\bsp_uart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\bsp_uart.crf ..\..\User\bsp\src\bsp_uart.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;93     */
;;;94     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;95     {
;;;96     	if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L1.8|
;;;97     	{
;;;98     		#if UART1_FIFO_EN == 1
;;;99     			return &g_tUart1;
000004  4809              LDR      r0,|L1.44|
                  |L1.6|
;;;100    		#else
;;;101    			return 0;
;;;102    		#endif
;;;103    	}
;;;104    	else if (_ucPort == COM2)
;;;105    	{
;;;106    		#if UART2_FIFO_EN == 1
;;;107    			return &g_tUart2;
;;;108    		#else
;;;109    			return 0;
;;;110    		#endif
;;;111    	}
;;;112    	else if (_ucPort == COM3)
;;;113    	{
;;;114    		#if UART3_FIFO_EN == 1
;;;115    			return &g_tUart3;
;;;116    		#else
;;;117    			return 0;
;;;118    		#endif
;;;119    	}
;;;120    	else if (_ucPort == COM4)
;;;121    	{
;;;122    		#if UART4_FIFO_EN == 1
;;;123    			return &g_tUart4;
;;;124    		#else
;;;125    			return 0;
;;;126    		#endif
;;;127    	}
;;;128    	else if (_ucPort == COM5)
;;;129    	{
;;;130    		#if UART5_FIFO_EN == 1
;;;131    			return &g_tUart5;
;;;132    		#else
;;;133    			return 0;
;;;134    		#endif
;;;135    	}
;;;136    	else
;;;137    	{
;;;138    		/* 不做任何处理 */
;;;139    		return 0;
;;;140    	}
;;;141    }
000006  4770              BX       lr
                  |L1.8|
000008  2901              CMP      r1,#1                 ;104
00000a  d101              BNE      |L1.16|
00000c  4808              LDR      r0,|L1.48|
00000e  e7fa              B        |L1.6|
                  |L1.16|
000010  2902              CMP      r1,#2                 ;112
000012  d101              BNE      |L1.24|
000014  2000              MOVS     r0,#0                 ;117
000016  e7f6              B        |L1.6|
                  |L1.24|
000018  2903              CMP      r1,#3                 ;120
00001a  d101              BNE      |L1.32|
00001c  2000              MOVS     r0,#0                 ;125
00001e  e7f2              B        |L1.6|
                  |L1.32|
000020  2904              CMP      r1,#4                 ;128
000022  d101              BNE      |L1.40|
000024  2000              MOVS     r0,#0                 ;133
000026  e7ee              B        |L1.6|
                  |L1.40|
000028  2000              MOVS     r0,#0                 ;139
00002a  e7ec              B        |L1.6|
;;;142    
                          ENDP

                  |L1.44|
                          DCD      g_tUart1
                  |L1.48|
                          DCD      g_tUart2

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;794    */
;;;795    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;796    {
;;;797    	NVIC_InitTypeDef NVIC_InitStructure;
;;;798    
;;;799    	/* Configure the NVIC Preemption Priority Bits */
;;;800    	/*	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  --- 在 bsp.c 中 bsp_Init() 中配置中断优先级组 */
;;;801    
;;;802    #if UART1_FIFO_EN == 1
;;;803    	/* 使能串口1中断 */
;;;804    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000002  2025              MOVS     r0,#0x25
000004  f88d0000          STRB     r0,[sp,#0]
;;;805    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000008  2000              MOVS     r0,#0
00000a  f88d0002          STRB     r0,[sp,#2]
;;;806    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00000e  2001              MOVS     r0,#1
000010  f88d0003          STRB     r0,[sp,#3]
;;;807    	NVIC_Init(&NVIC_InitStructure);
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       NVIC_Init
;;;808    #endif
;;;809    
;;;810    #if UART2_FIFO_EN == 1
;;;811    	/* 使能串口2中断 */
;;;812    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
00001a  2026              MOVS     r0,#0x26
00001c  f88d0000          STRB     r0,[sp,#0]
;;;813    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000020  2001              MOVS     r0,#1
000022  f88d0002          STRB     r0,[sp,#2]
;;;814    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000026  f88d0003          STRB     r0,[sp,#3]
;;;815    	NVIC_Init(&NVIC_InitStructure);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       NVIC_Init
;;;816    #endif
;;;817    
;;;818    #if UART3_FIFO_EN == 1
;;;819    	/* 使能串口3中断t */
;;;820    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
;;;821    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
;;;822    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;823    	NVIC_Init(&NVIC_InitStructure);
;;;824    #endif
;;;825    
;;;826    #if UART4_FIFO_EN == 1
;;;827    	/* 使能串口4中断t */
;;;828    	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
;;;829    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
;;;830    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;831    	NVIC_Init(&NVIC_InitStructure);
;;;832    #endif
;;;833    
;;;834    #if UART5_FIFO_EN == 1
;;;835    	/* 使能串口5中断t */
;;;836    	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
;;;837    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
;;;838    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;839    	NVIC_Init(&NVIC_InitStructure);
;;;840    #endif
;;;841    
;;;842    #if UART6_FIFO_EN == 1
;;;843    	/* 使能串口6中断t */
;;;844    	NVIC_InitStructure.NVIC_IRQChannel = USART6_IRQn;
;;;845    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 5;
;;;846    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;847    	NVIC_Init(&NVIC_InitStructure);
;;;848    #endif
;;;849    }
000030  bd08              POP      {r3,pc}
;;;850    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;554    */
;;;555    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;556    {
000002  b085              SUB      sp,sp,#0x14
;;;557    	GPIO_InitTypeDef GPIO_InitStructure;
;;;558    	USART_InitTypeDef USART_InitStructure;
;;;559    
;;;560    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;561    
;;;562    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;563    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;564    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;565    
;;;566    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;567    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;568    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;569    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d0012          STRB     r0,[sp,#0x12]
;;;570    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  483a              LDR      r0,|L3.276|
00002c  f7fffffe          BL       GPIO_Init
;;;571    
;;;572    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;573    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;574    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;575    	*/
;;;576    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;577    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;578    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  4834              LDR      r0,|L3.276|
000042  f7fffffe          BL       GPIO_Init
;;;579    	
;;;580    	/* 第4步： 配置串口硬件参数 */
;;;581    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
000046  f44f5016          MOV      r0,#0x2580
00004a  9000              STR      r0,[sp,#0]
;;;582    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;583    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;584    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;585    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;586    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;587    	USART_Init(USART1, &USART_InitStructure);
000064  4669              MOV      r1,sp
000066  482c              LDR      r0,|L3.280|
000068  f7fffffe          BL       USART_Init
;;;588    
;;;589    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
00006c  2201              MOVS     r2,#1
00006e  f2405125          MOV      r1,#0x525
000072  4829              LDR      r0,|L3.280|
000074  f7fffffe          BL       USART_ITConfig
;;;590    	/*
;;;591    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;592    		注意: 不要在此处打开发送中断
;;;593    		发送中断使能在SendUart()函数打开
;;;594    	*/
;;;595    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000078  2101              MOVS     r1,#1
00007a  4827              LDR      r0,|L3.280|
00007c  f7fffffe          BL       USART_Cmd
;;;596    
;;;597    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;598    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;599    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000080  2140              MOVS     r1,#0x40
000082  4825              LDR      r0,|L3.280|
000084  f7fffffe          BL       USART_ClearFlag
;;;600    #endif
;;;601    
;;;602    #if UART2_FIFO_EN == 1		/* 串口2 TX = PA2， RX = PA3  */
;;;603    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;604    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000088  2101              MOVS     r1,#1
00008a  2005              MOVS     r0,#5
00008c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;605    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
000090  2101              MOVS     r1,#1
000092  0448              LSLS     r0,r1,#17
000094  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;606    
;;;607    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;608    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000098  2004              MOVS     r0,#4
00009a  f8ad0010          STRH     r0,[sp,#0x10]
;;;609    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00009e  2018              MOVS     r0,#0x18
0000a0  f88d0013          STRB     r0,[sp,#0x13]
;;;610    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a4  2003              MOVS     r0,#3
0000a6  f88d0012          STRB     r0,[sp,#0x12]
;;;611    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000aa  a904              ADD      r1,sp,#0x10
0000ac  4819              LDR      r0,|L3.276|
0000ae  f7fffffe          BL       GPIO_Init
;;;612    
;;;613    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;614    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;615    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;616    	*/
;;;617    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
0000b2  2008              MOVS     r0,#8
0000b4  f8ad0010          STRH     r0,[sp,#0x10]
;;;618    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000b8  2004              MOVS     r0,#4
0000ba  f88d0013          STRB     r0,[sp,#0x13]
;;;619    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000be  a904              ADD      r1,sp,#0x10
0000c0  4814              LDR      r0,|L3.276|
0000c2  f7fffffe          BL       GPIO_Init
;;;620    	/*  第3步已经做了，因此这步可以不做
;;;621    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;622    	*/
;;;623    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000c6  a904              ADD      r1,sp,#0x10
0000c8  4812              LDR      r0,|L3.276|
0000ca  f7fffffe          BL       GPIO_Init
;;;624    
;;;625    	/* 第4步： 配置串口硬件参数 */
;;;626    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
0000ce  f44f30e1          MOV      r0,#0x1c200
0000d2  9000              STR      r0,[sp,#0]
;;;627    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000d4  2000              MOVS     r0,#0
0000d6  f8ad0004          STRH     r0,[sp,#4]
;;;628    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000da  f8ad0006          STRH     r0,[sp,#6]
;;;629    	USART_InitStructure.USART_Parity = USART_Parity_No ;
0000de  f8ad0008          STRH     r0,[sp,#8]
;;;630    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000e2  f8ad000c          STRH     r0,[sp,#0xc]
;;;631    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;		/* 仅选择接收模式 */
0000e6  200c              MOVS     r0,#0xc
0000e8  f8ad000a          STRH     r0,[sp,#0xa]
;;;632    	USART_Init(USART2, &USART_InitStructure);
0000ec  4669              MOV      r1,sp
0000ee  480b              LDR      r0,|L3.284|
0000f0  f7fffffe          BL       USART_Init
;;;633    
;;;634    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0000f4  2201              MOVS     r2,#1
0000f6  f2405125          MOV      r1,#0x525
0000fa  4808              LDR      r0,|L3.284|
0000fc  f7fffffe          BL       USART_ITConfig
;;;635    	/*
;;;636    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;637    		注意: 不要在此处打开发送中断
;;;638    		发送中断使能在SendUart()函数打开
;;;639    	*/
;;;640    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
000100  2101              MOVS     r1,#1
000102  4806              LDR      r0,|L3.284|
000104  f7fffffe          BL       USART_Cmd
;;;641    
;;;642    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;643    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;644    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000108  2140              MOVS     r1,#0x40
00010a  4804              LDR      r0,|L3.284|
00010c  f7fffffe          BL       USART_ClearFlag
;;;645    #endif
;;;646    
;;;647    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;648    
;;;649    	/* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;650    	{
;;;651    		RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
;;;652    
;;;653    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;654    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;655    		GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
;;;656    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
;;;657    	}
;;;658    
;;;659    	/* 第1步： 开启GPIO和UART时钟 */
;;;660    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
;;;661    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
;;;662    
;;;663    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;664    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;665    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;666    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;667    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;668    
;;;669    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;670    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;671    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;672    	*/
;;;673    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;674    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;675    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;676    	/*  第3步已经做了，因此这步可以不做
;;;677    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;678    	*/
;;;679    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;680    
;;;681    	/* 第4步： 配置串口硬件参数 */
;;;682    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
;;;683    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;684    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;685    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;686    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;687    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;688    	USART_Init(USART3, &USART_InitStructure);
;;;689    
;;;690    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;691    	/*
;;;692    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;693    		注意: 不要在此处打开发送中断
;;;694    		发送中断使能在SendUart()函数打开
;;;695    	*/
;;;696    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
;;;697    
;;;698    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;699    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;700    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;701    #endif
;;;702    
;;;703    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;704    	/* 第1步： 开启GPIO和UART时钟 */
;;;705    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
;;;706    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;707    
;;;708    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;709    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;710    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;711    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;712    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;713    
;;;714    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;715    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;716    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;717    	*/
;;;718    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;719    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;720    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;721    
;;;722    	/* 第4步： 配置串口硬件参数 */
;;;723    	USART_InitStructure.USART_BaudRate = UART4_BAUD;	/* 波特率 */
;;;724    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;725    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;726    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;727    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;728    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;729    	USART_Init(UART4, &USART_InitStructure);
;;;730    
;;;731    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;732    	/*
;;;733    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;734    		注意: 不要在此处打开发送中断
;;;735    		发送中断使能在SendUart()函数打开
;;;736    	*/
;;;737    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;738    
;;;739    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;740    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;741    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;742    #endif
;;;743    
;;;744    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;745    	/* 第1步： 开启GPIO和UART时钟 */
;;;746    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
;;;747    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;748    
;;;749    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;750    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;751    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;752    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;753    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;754    
;;;755    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;756    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;757    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;758    	*/
;;;759    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;760    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;761    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;762    
;;;763    
;;;764    	/* 第4步： 配置串口硬件参数 */
;;;765    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;766    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;767    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;768    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;769    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;770    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;771    	USART_Init(UART5, &USART_InitStructure);
;;;772    
;;;773    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;774    	/*
;;;775    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;776    		注意: 不要在此处打开发送中断
;;;777    		发送中断使能在SendUart()函数打开
;;;778    	*/
;;;779    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;780    
;;;781    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;782    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;783    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;784    #endif
;;;785    }
000110  b005              ADD      sp,sp,#0x14
000112  bd00              POP      {pc}
;;;786    
                          ENDP

                  |L3.276|
                          DCD      0x40010800
                  |L3.280|
                          DCD      0x40013800
                  |L3.284|
                          DCD      0x40004400

                          AREA ||i.RS485_InitTXE||, CODE, READONLY, ALIGN=2

                  RS485_InitTXE PROC
;;;300    */
;;;301    void RS485_InitTXE(void)
000000  b508              PUSH     {r3,lr}
;;;302    {
;;;303    	GPIO_InitTypeDef GPIO_InitStructure;
;;;304    
;;;305    	RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;306    
;;;307    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;308    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;309    	GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000016  2002              MOVS     r0,#2
000018  f8ad0000          STRH     r0,[sp,#0]
;;;310    	GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L4.40|
000020  f7fffffe          BL       GPIO_Init
;;;311    }
000024  bd08              POP      {r3,pc}
;;;312    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40010c00

                          AREA ||i.RS485_ReciveNew||, CODE, READONLY, ALIGN=1

                  RS485_ReciveNew PROC
;;;422    */
;;;423    void RS485_ReciveNew(uint8_t _byte)
000000  4770              BX       lr
;;;424    {
;;;425    }
;;;426    
                          ENDP


                          AREA ||i.RS485_SendBefor||, CODE, READONLY, ALIGN=2

                  RS485_SendBefor PROC
;;;364    */
;;;365    void RS485_SendBefor(void)
000000  b510              PUSH     {r4,lr}
;;;366    {
;;;367    	BSP_OS_TimeDlyMs(5);
000002  2005              MOVS     r0,#5
000004  f7fffffe          BL       BSP_OS_TimeDlyMs
;;;368    	RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000008  2002              MOVS     r0,#2
00000a  4901              LDR      r1,|L6.16|
00000c  6008              STR      r0,[r1,#0]
;;;369    }
00000e  bd10              POP      {r4,pc}
;;;370    
                          ENDP

                  |L6.16|
                          DCD      0x40010c10

                          AREA ||i.RS485_SendBuf||, CODE, READONLY, ALIGN=1

                  RS485_SendBuf PROC
;;;394    */
;;;395    void RS485_SendBuf(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;396    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;397    	comSendBuf(COM3, _ucaBuf, _usLen);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       comSendBuf
;;;398    }
000010  bd70              POP      {r4-r6,pc}
;;;399    
                          ENDP


                          AREA ||i.RS485_SendOver||, CODE, READONLY, ALIGN=2

                  RS485_SendOver PROC
;;;379    */
;;;380    void RS485_SendOver(void)
000000  b510              PUSH     {r4,lr}
;;;381    {
;;;382    	BSP_OS_TimeDlyMs(5);
000002  2005              MOVS     r0,#5
000004  f7fffffe          BL       BSP_OS_TimeDlyMs
;;;383    	RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000008  2002              MOVS     r0,#2
00000a  4901              LDR      r1,|L8.16|
00000c  6008              STR      r0,[r1,#0]
;;;384    }
00000e  bd10              POP      {r4,pc}
;;;385    
                          ENDP

                  |L8.16|
                          DCD      0x40010c14

                          AREA ||i.RS485_SendStr||, CODE, READONLY, ALIGN=1

                  RS485_SendStr PROC
;;;409    */
;;;410    void RS485_SendStr(char *_pBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;411    {
000002  4604              MOV      r4,r0
;;;412    	RS485_SendBuf((uint8_t *)_pBuf, strlen(_pBuf));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       strlen
00000a  b285              UXTH     r5,r0
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RS485_SendBuf
;;;413    }
000014  bd70              POP      {r4-r6,pc}
;;;414    
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1074   #if UART1_FIFO_EN == 1
;;;1075   void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1076   {
;;;1077   #if uCOS_EN == 1 
;;;1078   	CPU_SR_ALLOC();
000002  2400              MOVS     r4,#0
;;;1079   
;;;1080       CPU_CRITICAL_ENTER();
000004  bf00              NOP      
000006  bf00              NOP      
000008  f7fffffe          BL       CPU_SR_Save
00000c  4604              MOV      r4,r0
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_IntDisMeasStart
000014  bf00              NOP      
;;;1081       OSIntEnter();                                          
000016  f7fffffe          BL       OSIntEnter
;;;1082       CPU_CRITICAL_EXIT();
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStop
000020  bf00              NOP      
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       CPU_SR_Restore
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1083   #endif
;;;1084   	
;;;1085   	UartIRQ(&g_tUart1);
00002c  4802              LDR      r0,|L10.56|
00002e  f7fffffe          BL       UartIRQ
;;;1086   	
;;;1087   #if uCOS_EN == 1 
;;;1088   	OSIntExit(); 
000032  f7fffffe          BL       OSIntExit
;;;1089   #endif
;;;1090   }
000036  bd10              POP      {r4,pc}
;;;1091   #endif
                          ENDP

                  |L10.56|
                          DCD      g_tUart1

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;1093   #if UART2_FIFO_EN == 1
;;;1094   void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1095   {
;;;1096   #if uCOS_EN == 1 
;;;1097   	CPU_SR_ALLOC();
000002  2400              MOVS     r4,#0
;;;1098   
;;;1099       CPU_CRITICAL_ENTER();
000004  bf00              NOP      
000006  bf00              NOP      
000008  f7fffffe          BL       CPU_SR_Save
00000c  4604              MOV      r4,r0
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_IntDisMeasStart
000014  bf00              NOP      
;;;1100       OSIntEnter();                                          
000016  f7fffffe          BL       OSIntEnter
;;;1101       CPU_CRITICAL_EXIT();
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStop
000020  bf00              NOP      
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       CPU_SR_Restore
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1102   #endif
;;;1103   	
;;;1104   	UartIRQ(&g_tUart2);
00002c  4802              LDR      r0,|L11.56|
00002e  f7fffffe          BL       UartIRQ
;;;1105   	
;;;1106   #if uCOS_EN == 1 
;;;1107   	OSIntExit(); 
000032  f7fffffe          BL       OSIntExit
;;;1108   #endif
;;;1109   }
000036  bd10              POP      {r4,pc}
;;;1110   #endif
                          ENDP

                  |L11.56|
                          DCD      g_tUart2

                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;934    */
;;;935    static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;936    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;937    	uint16_t usCount;
;;;938    	
;;;939    #if uCOS_EN == 1 
;;;940    	CPU_SR_ALLOC();
000008  2700              MOVS     r7,#0
;;;941    #endif
;;;942    
;;;943    	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;944    	DISABLE_INT();
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  f7fffffe          BL       CPU_SR_Save
000012  4607              MOV      r7,r0
000014  bf00              NOP      
000016  f7fffffe          BL       CPU_IntDisMeasStart
00001a  bf00              NOP      
;;;945    	usCount = _pUart->usRxCount;
00001c  8be6              LDRH     r6,[r4,#0x1e]
;;;946    	ENABLE_INT();
00001e  bf00              NOP      
000020  f7fffffe          BL       CPU_IntDisMeasStop
000024  bf00              NOP      
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       CPU_SR_Restore
00002c  bf00              NOP      
00002e  bf00              NOP      
;;;947    
;;;948    	/* 如果读和写索引相同，则返回0 */
;;;949    	//if (_pUart->usRxRead == usRxWrite)
;;;950    	if (usCount == 0)	/* 已经没有数据 */
000030  b916              CBNZ     r6,|L12.56|
;;;951    	{
;;;952    		return 0;
000032  2000              MOVS     r0,#0
                  |L12.52|
;;;953    	}
;;;954    	else
;;;955    	{
;;;956    		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
;;;957    
;;;958    		/* 改写FIFO读索引 */
;;;959    		DISABLE_INT();
;;;960    		if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;961    		{
;;;962    			_pUart->usRxRead = 0;
;;;963    		}
;;;964    		_pUart->usRxCount--;
;;;965    		ENABLE_INT();
;;;966    		return 1;
;;;967    	}
;;;968    }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L12.56|
000038  8ba1              LDRH     r1,[r4,#0x1c]         ;956
00003a  68e0              LDR      r0,[r4,#0xc]          ;956
00003c  5c40              LDRB     r0,[r0,r1]            ;956
00003e  7028              STRB     r0,[r5,#0]            ;956
000040  bf00              NOP                            ;959
000042  bf00              NOP                            ;959
000044  f7fffffe          BL       CPU_SR_Save
000048  4607              MOV      r7,r0                 ;959
00004a  bf00              NOP                            ;959
00004c  f7fffffe          BL       CPU_IntDisMeasStart
000050  bf00              NOP                            ;959
000052  8ba0              LDRH     r0,[r4,#0x1c]         ;960
000054  1c40              ADDS     r0,r0,#1              ;960
000056  b280              UXTH     r0,r0                 ;960
000058  83a0              STRH     r0,[r4,#0x1c]         ;960
00005a  8a61              LDRH     r1,[r4,#0x12]         ;960
00005c  4288              CMP      r0,r1                 ;960
00005e  db01              BLT      |L12.100|
000060  2000              MOVS     r0,#0                 ;962
000062  83a0              STRH     r0,[r4,#0x1c]         ;962
                  |L12.100|
000064  8be0              LDRH     r0,[r4,#0x1e]         ;964
000066  1e40              SUBS     r0,r0,#1              ;964
000068  83e0              STRH     r0,[r4,#0x1e]         ;964
00006a  bf00              NOP                            ;965
00006c  f7fffffe          BL       CPU_IntDisMeasStop
000070  bf00              NOP                            ;965
000072  4638              MOV      r0,r7                 ;965
000074  f7fffffe          BL       CPU_SR_Restore
000078  bf00              NOP                            ;965
00007a  bf00              NOP                            ;965
00007c  2001              MOVS     r0,#1                 ;966
00007e  e7d9              B        |L12.52|
;;;969    
                          ENDP


                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;977    */
;;;978    static void UartIRQ(UART_T *_pUart)
000000  b570              PUSH     {r4-r6,lr}
;;;979    {
000002  4604              MOV      r4,r0
;;;980    	/* 处理接收中断  */
;;;981    	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  6860              LDR      r0,[r4,#4]
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b300              CBZ      r0,|L13.82|
;;;982    	{
;;;983    		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;984    		uint8_t ch;
;;;985    
;;;986    		ch = USART_ReceiveData(_pUart->uart);
000010  6860              LDR      r0,[r4,#4]
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c5              UXTB     r5,r0
;;;987    		_pUart->pRxBuf[_pUart->usRxWrite] = ch;
000018  8b61              LDRH     r1,[r4,#0x1a]
00001a  68e0              LDR      r0,[r4,#0xc]
00001c  5445              STRB     r5,[r0,r1]
;;;988    		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
00001e  8b60              LDRH     r0,[r4,#0x1a]
000020  1c40              ADDS     r0,r0,#1
000022  b280              UXTH     r0,r0
000024  8360              STRH     r0,[r4,#0x1a]
000026  8a61              LDRH     r1,[r4,#0x12]
000028  4288              CMP      r0,r1
00002a  db01              BLT      |L13.48|
;;;989    		{
;;;990    			_pUart->usRxWrite = 0;
00002c  2000              MOVS     r0,#0
00002e  8360              STRH     r0,[r4,#0x1a]
                  |L13.48|
;;;991    		}
;;;992    		if (_pUart->usRxCount < _pUart->usRxBufSize)
000030  8be0              LDRH     r0,[r4,#0x1e]
000032  8a61              LDRH     r1,[r4,#0x12]
000034  4288              CMP      r0,r1
000036  da02              BGE      |L13.62|
;;;993    		{
;;;994    			_pUart->usRxCount++;
000038  8be0              LDRH     r0,[r4,#0x1e]
00003a  1c40              ADDS     r0,r0,#1
00003c  83e0              STRH     r0,[r4,#0x1e]
                  |L13.62|
;;;995    		}
;;;996    		
;;;997    		//用于超时成帧,30ms
;;;998    		bsp_StartTimer(_pUart->ucPort, 30);
00003e  7820              LDRB     r0,[r4,#0]
000040  211e              MOVS     r1,#0x1e
000042  f7fffffe          BL       bsp_StartTimer
;;;999    
;;;1000   		
;;;1001   		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;1002   		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;1003   		//if (_pUart->usRxCount == 1)
;;;1004   		{
;;;1005   			if (_pUart->ReciveNew)
000046  6aa0              LDR      r0,[r4,#0x28]
000048  b110              CBZ      r0,|L13.80|
;;;1006   			{
;;;1007   				_pUart->ReciveNew(ch);
00004a  4628              MOV      r0,r5
00004c  6aa1              LDR      r1,[r4,#0x28]
00004e  4788              BLX      r1
                  |L13.80|
;;;1008   			}
;;;1009   		}
;;;1010   	}
000050  bf00              NOP      
                  |L13.82|
;;;1011   
;;;1012   	/* 处理发送缓冲区空中断 */
;;;1013   	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
000052  f2407127          MOV      r1,#0x727
000056  6860              LDR      r0,[r4,#4]
000058  f7fffffe          BL       USART_GetITStatus
00005c  b308              CBZ      r0,|L13.162|
;;;1014   	{
;;;1015   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1016   		if (_pUart->usTxCount == 0)
00005e  8b20              LDRH     r0,[r4,#0x18]
000060  b960              CBNZ     r0,|L13.124|
;;;1017   		{
;;;1018   			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;1019   			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
000062  2200              MOVS     r2,#0
000064  f2407127          MOV      r1,#0x727
000068  6860              LDR      r0,[r4,#4]
00006a  f7fffffe          BL       USART_ITConfig
;;;1020   
;;;1021   			/* 使能数据发送完毕中断 */
;;;1022   			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
00006e  2201              MOVS     r2,#1
000070  f2406126          MOV      r1,#0x626
000074  6860              LDR      r0,[r4,#4]
000076  f7fffffe          BL       USART_ITConfig
00007a  e037              B        |L13.236|
                  |L13.124|
;;;1023   		}
;;;1024   		else
;;;1025   		{
;;;1026   			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;1027   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
00007c  8ae3              LDRH     r3,[r4,#0x16]
00007e  68a2              LDR      r2,[r4,#8]
000080  5cd1              LDRB     r1,[r2,r3]
000082  6860              LDR      r0,[r4,#4]
000084  f7fffffe          BL       USART_SendData
;;;1028   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
000088  8ae0              LDRH     r0,[r4,#0x16]
00008a  1c40              ADDS     r0,r0,#1
00008c  b280              UXTH     r0,r0
00008e  82e0              STRH     r0,[r4,#0x16]
000090  8a21              LDRH     r1,[r4,#0x10]
000092  4288              CMP      r0,r1
000094  db01              BLT      |L13.154|
;;;1029   			{
;;;1030   				_pUart->usTxRead = 0;
000096  2000              MOVS     r0,#0
000098  82e0              STRH     r0,[r4,#0x16]
                  |L13.154|
;;;1031   			}
;;;1032   			_pUart->usTxCount--;
00009a  8b20              LDRH     r0,[r4,#0x18]
00009c  1e40              SUBS     r0,r0,#1
00009e  8320              STRH     r0,[r4,#0x18]
0000a0  e024              B        |L13.236|
                  |L13.162|
;;;1033   		}
;;;1034   
;;;1035   	}
;;;1036   	/* 数据bit位全部发送完毕的中断 */
;;;1037   	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
0000a2  f2406126          MOV      r1,#0x626
0000a6  6860              LDR      r0,[r4,#4]
0000a8  f7fffffe          BL       USART_GetITStatus
0000ac  b1f0              CBZ      r0,|L13.236|
;;;1038   	{
;;;1039   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1040   		if (_pUart->usTxCount == 0)
0000ae  8b20              LDRH     r0,[r4,#0x18]
0000b0  b950              CBNZ     r0,|L13.200|
;;;1041   		{
;;;1042   			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;1043   			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
0000b2  2200              MOVS     r2,#0
0000b4  f2406126          MOV      r1,#0x626
0000b8  6860              LDR      r0,[r4,#4]
0000ba  f7fffffe          BL       USART_ITConfig
;;;1044   
;;;1045   			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1046   			if (_pUart->SendOver)
0000be  6a60              LDR      r0,[r4,#0x24]
0000c0  b1a0              CBZ      r0,|L13.236|
;;;1047   			{
;;;1048   				_pUart->SendOver();
0000c2  6a60              LDR      r0,[r4,#0x24]
0000c4  4780              BLX      r0
0000c6  e011              B        |L13.236|
                  |L13.200|
;;;1049   			}
;;;1050   		}
;;;1051   		else
;;;1052   		{
;;;1053   			/* 正常情况下，不会进入此分支 */
;;;1054   
;;;1055   			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1056   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000c8  8ae3              LDRH     r3,[r4,#0x16]
0000ca  68a2              LDR      r2,[r4,#8]
0000cc  5cd1              LDRB     r1,[r2,r3]
0000ce  6860              LDR      r0,[r4,#4]
0000d0  f7fffffe          BL       USART_SendData
;;;1057   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000d4  8ae0              LDRH     r0,[r4,#0x16]
0000d6  1c40              ADDS     r0,r0,#1
0000d8  b280              UXTH     r0,r0
0000da  82e0              STRH     r0,[r4,#0x16]
0000dc  8a21              LDRH     r1,[r4,#0x10]
0000de  4288              CMP      r0,r1
0000e0  db01              BLT      |L13.230|
;;;1058   			{
;;;1059   				_pUart->usTxRead = 0;
0000e2  2000              MOVS     r0,#0
0000e4  82e0              STRH     r0,[r4,#0x16]
                  |L13.230|
;;;1060   			}
;;;1061   			_pUart->usTxCount--;
0000e6  8b20              LDRH     r0,[r4,#0x18]
0000e8  1e40              SUBS     r0,r0,#1
0000ea  8320              STRH     r0,[r4,#0x18]
                  |L13.236|
;;;1062   		}
;;;1063   	}
;;;1064   }
0000ec  bd70              POP      {r4-r6,pc}
;;;1065   
                          ENDP


                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;858    */
;;;859    static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;860    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;861    	uint16_t i;
;;;862    
;;;863    #if uCOS_EN == 1 
;;;864    	CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;865    #endif
;;;866    
;;;867    	for (i = 0; i < _usLen; i++)
00000e  2500              MOVS     r5,#0
000010  e041              B        |L14.150|
                  |L14.18|
;;;868    	{
;;;869    		/* 如果发送缓冲区已经满了，则等待缓冲区空 */
;;;870    	#if 0
;;;871    		/*
;;;872    			在调试GPRS例程时，下面的代码出现死机，while 死循环
;;;873    			原因： 发送第1个字节时 _pUart->usTxWrite = 1；_pUart->usTxRead = 0;
;;;874    			将导致while(1) 无法退出
;;;875    		*/
;;;876    		while (1)
;;;877    		{
;;;878    			uint16_t usRead;
;;;879    
;;;880    			DISABLE_INT();
;;;881    			usRead = _pUart->usTxRead;
;;;882    			ENABLE_INT();
;;;883    
;;;884    			if (++usRead >= _pUart->usTxBufSize)
;;;885    			{
;;;886    				usRead = 0;
;;;887    			}
;;;888    
;;;889    			if (usRead != _pUart->usTxWrite)
;;;890    			{
;;;891    				break;
;;;892    			}
;;;893    		}
;;;894    	#else
;;;895    		/* 当 _pUart->usTxBufSize == 1 时, 下面的函数会死掉(待完善) */
;;;896    		while (1)
000012  e01a              B        |L14.74|
                  |L14.20|
;;;897    		{
;;;898    			__IO uint16_t usCount;
;;;899    
;;;900    			DISABLE_INT();
000014  bf00              NOP      
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_SR_Save
00001c  4680              MOV      r8,r0
00001e  bf00              NOP      
000020  f7fffffe          BL       CPU_IntDisMeasStart
000024  bf00              NOP      
;;;901    			usCount = _pUart->usTxCount;
000026  8b20              LDRH     r0,[r4,#0x18]
000028  9000              STR      r0,[sp,#0]
;;;902    			ENABLE_INT();
00002a  bf00              NOP      
00002c  f7fffffe          BL       CPU_IntDisMeasStop
000030  bf00              NOP      
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       CPU_SR_Restore
000038  bf00              NOP      
00003a  bf00              NOP      
;;;903    
;;;904    			if (usCount < _pUart->usTxBufSize)
00003c  8a20              LDRH     r0,[r4,#0x10]
00003e  f8bd1000          LDRH     r1,[sp,#0]
000042  4288              CMP      r0,r1
000044  dd00              BLE      |L14.72|
;;;905    			{
;;;906    				break;
000046  e001              B        |L14.76|
                  |L14.72|
;;;907    			}
;;;908    		}
000048  bf00              NOP      
                  |L14.74|
00004a  e7e3              B        |L14.20|
                  |L14.76|
00004c  bf00              NOP                            ;906
;;;909    	#endif
;;;910    
;;;911    		/* 将新数据填入发送缓冲区 */
;;;912    		_pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
00004e  5d70              LDRB     r0,[r6,r5]
000050  8aa2              LDRH     r2,[r4,#0x14]
000052  68a1              LDR      r1,[r4,#8]
000054  5488              STRB     r0,[r1,r2]
;;;913    
;;;914    		DISABLE_INT();
000056  bf00              NOP      
000058  bf00              NOP      
00005a  f7fffffe          BL       CPU_SR_Save
00005e  4680              MOV      r8,r0
000060  bf00              NOP      
000062  f7fffffe          BL       CPU_IntDisMeasStart
000066  bf00              NOP      
;;;915    		if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
000068  8aa0              LDRH     r0,[r4,#0x14]
00006a  1c40              ADDS     r0,r0,#1
00006c  b280              UXTH     r0,r0
00006e  82a0              STRH     r0,[r4,#0x14]
000070  8a21              LDRH     r1,[r4,#0x10]
000072  4288              CMP      r0,r1
000074  db01              BLT      |L14.122|
;;;916    		{
;;;917    			_pUart->usTxWrite = 0;
000076  2000              MOVS     r0,#0
000078  82a0              STRH     r0,[r4,#0x14]
                  |L14.122|
;;;918    		}
;;;919    		_pUart->usTxCount++;
00007a  8b20              LDRH     r0,[r4,#0x18]
00007c  1c40              ADDS     r0,r0,#1
00007e  8320              STRH     r0,[r4,#0x18]
;;;920    		ENABLE_INT();
000080  bf00              NOP      
000082  f7fffffe          BL       CPU_IntDisMeasStop
000086  bf00              NOP      
000088  4640              MOV      r0,r8
00008a  f7fffffe          BL       CPU_SR_Restore
00008e  bf00              NOP      
000090  bf00              NOP      
000092  1c68              ADDS     r0,r5,#1              ;867
000094  b285              UXTH     r5,r0                 ;867
                  |L14.150|
000096  42bd              CMP      r5,r7                 ;867
000098  dbbb              BLT      |L14.18|
;;;921    	}
;;;922    
;;;923    	USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
00009a  2201              MOVS     r2,#1
00009c  f2407127          MOV      r1,#0x727
0000a0  6860              LDR      r0,[r4,#4]
0000a2  f7fffffe          BL       USART_ITConfig
;;;924    }
0000a6  e8bd83f8          POP      {r3-r9,pc}
;;;925    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;434    */
;;;435    static void UartVarInit(void)
000000  2000              MOVS     r0,#0
;;;436    {
;;;437    #if UART1_FIFO_EN == 1
;;;438    	g_tUart1.ucPort = COM1;                   /* 串口1*/
000002  4918              LDR      r1,|L15.100|
000004  7008              STRB     r0,[r1,#0]
;;;439    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000006  4818              LDR      r0,|L15.104|
000008  6048              STR      r0,[r1,#4]  ; g_tUart1
;;;440    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
00000a  4818              LDR      r0,|L15.108|
00000c  6088              STR      r0,[r1,#8]  ; g_tUart1
;;;441    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000e  4818              LDR      r0,|L15.112|
000010  60c8              STR      r0,[r1,#0xc]  ; g_tUart1
;;;442    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000012  f44f7000          MOV      r0,#0x200
000016  8208              STRH     r0,[r1,#0x10]
;;;443    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000018  8248              STRH     r0,[r1,#0x12]
;;;444    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
00001a  2000              MOVS     r0,#0
00001c  8288              STRH     r0,[r1,#0x14]
;;;445    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001e  82c8              STRH     r0,[r1,#0x16]
;;;446    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
000020  8348              STRH     r0,[r1,#0x1a]
;;;447    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
000022  8388              STRH     r0,[r1,#0x1c]
;;;448    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000024  83c8              STRH     r0,[r1,#0x1e]
;;;449    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000026  8308              STRH     r0,[r1,#0x18]
;;;450    	g_tUart1.SendBefor = RS485_SendBefor;						/* 发送数据前的回调函数 */
000028  4812              LDR      r0,|L15.116|
00002a  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;451    	g_tUart1.SendOver = RS485_SendOver;						/* 发送完毕后的回调函数 */
00002c  4812              LDR      r0,|L15.120|
00002e  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;452    	g_tUart1.ReciveNew = RS485_ReciveNew;						/* 接收到新数据后的回调函数 */
000030  4812              LDR      r0,|L15.124|
000032  6288              STR      r0,[r1,#0x28]  ; g_tUart1
;;;453    #endif
;;;454    
;;;455    #if UART2_FIFO_EN == 1
;;;456    	g_tUart2.ucPort = COM2;                   /* 串口2*/
000034  2001              MOVS     r0,#1
000036  4912              LDR      r1,|L15.128|
000038  7008              STRB     r0,[r1,#0]
;;;457    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
00003a  4812              LDR      r0,|L15.132|
00003c  6048              STR      r0,[r1,#4]  ; g_tUart2
;;;458    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
00003e  4812              LDR      r0,|L15.136|
000040  6088              STR      r0,[r1,#8]  ; g_tUart2
;;;459    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
000042  4812              LDR      r0,|L15.140|
000044  60c8              STR      r0,[r1,#0xc]  ; g_tUart2
;;;460    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000046  f44f7000          MOV      r0,#0x200
00004a  8208              STRH     r0,[r1,#0x10]
;;;461    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
00004c  8248              STRH     r0,[r1,#0x12]
;;;462    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
00004e  2000              MOVS     r0,#0
000050  8288              STRH     r0,[r1,#0x14]
;;;463    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
000052  82c8              STRH     r0,[r1,#0x16]
;;;464    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
000054  8348              STRH     r0,[r1,#0x1a]
;;;465    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
000056  8388              STRH     r0,[r1,#0x1c]
;;;466    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
000058  83c8              STRH     r0,[r1,#0x1e]
;;;467    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
00005a  8308              STRH     r0,[r1,#0x18]
;;;468    	g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
00005c  6208              STR      r0,[r1,#0x20]  ; g_tUart2
;;;469    	g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
00005e  6248              STR      r0,[r1,#0x24]  ; g_tUart2
;;;470    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000060  6288              STR      r0,[r1,#0x28]  ; g_tUart2
;;;471    #endif
;;;472    
;;;473    #if UART3_FIFO_EN == 1
;;;474      g_tUart3.ucPort = COM3;                   /* 串口3*/
;;;475    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
;;;476    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
;;;477    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
;;;478    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;479    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;480    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;481    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
;;;482    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;483    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
;;;484    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
;;;485    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
;;;486    	g_tUart3.SendBefor = 0;		/* 发送数据前的回调函数 */
;;;487    	g_tUart3.SendOver = 0;			/* 发送完毕后的回调函数 */
;;;488    	g_tUart3.ReciveNew = 0;		/* 接收到新数据后的回调函数 */
;;;489    #endif
;;;490    
;;;491    #if UART4_FIFO_EN == 1
;;;492      g_tUart4.ucPort = COM4;                   /* 串口4*/
;;;493    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;494    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;495    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;496    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;497    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;498    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;499    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;500    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;501    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;502    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;503    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
;;;504    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;505    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;506    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;507    #endif
;;;508    
;;;509    #if UART5_FIFO_EN == 1
;;;510      g_tUart5.ucPort = COM5;                   /* 串口5*/
;;;511    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;512    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;513    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;514    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;515    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;516    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;517    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;518    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;519    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;520    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;521    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
;;;522    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;523    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;524    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;525    #endif
;;;526    
;;;527    
;;;528    #if UART6_FIFO_EN == 1
;;;529      g_tUart6.ucPort = COM6;                   /* 串口6*/
;;;530    	g_tUart6.uart = USART6;						/* STM32 串口设备 */
;;;531    	g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
;;;532    	g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
;;;533    	g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;534    	g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;535    	g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;536    	g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
;;;537    	g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;538    	g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
;;;539    	g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
;;;540    	g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */
;;;541    	g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;542    	g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;543    	g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;544    #endif
;;;545    }
000062  4770              BX       lr
;;;546    
                          ENDP

                  |L15.100|
                          DCD      g_tUart1
                  |L15.104|
                          DCD      0x40013800
                  |L15.108|
                          DCD      g_TxBuf1
                  |L15.112|
                          DCD      g_RxBuf1
                  |L15.116|
                          DCD      RS485_SendBefor
                  |L15.120|
                          DCD      RS485_SendOver
                  |L15.124|
                          DCD      RS485_ReciveNew
                  |L15.128|
                          DCD      g_tUart2
                  |L15.132|
                          DCD      0x40004400
                  |L15.136|
                          DCD      g_TxBuf2
                  |L15.140|
                          DCD      g_RxBuf2

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;74     */
;;;75     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;76     {
;;;77     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;78     
;;;79     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;80     
;;;81     	RS485_InitTXE();	/* 配置RS485芯片的发送使能硬件，配置为推挽输出 */
00000a  f7fffffe          BL       RS485_InitTXE
;;;82     
;;;83     	ConfigUartNVIC();	/* 配置串口中断 */
00000e  f7fffffe          BL       ConfigUartNVIC
;;;84     }
000012  bd10              POP      {r4,pc}
;;;85     
                          ENDP


                          AREA ||i.bsp_SetUartBaud||, CODE, READONLY, ALIGN=1

                  bsp_SetUartBaud PROC
;;;321    */
;;;322    void bsp_SetUartBaud(COM_PORT_E _ucPort,uint32_t _baud)
000000  b57f              PUSH     {r0-r6,lr}
;;;323    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;324    	UART_T *pUart;
;;;325    	USART_InitTypeDef USART_InitStructure;
;;;326    	pUart = ComToUart(_ucPort);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;327    	if (pUart == 0)
00000e  b904              CBNZ     r4,|L17.18|
                  |L17.16|
;;;328    	{
;;;329    		return;
;;;330    	}
;;;331    	
;;;332      USART_Cmd(pUart->uart, DISABLE);		/* 禁止串口 */
;;;333    	
;;;334    	/* 第2步： 配置串口硬件参数 */
;;;335    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
;;;336    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;337    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;338    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;339    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;340    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;341    	USART_Init(pUart->uart, &USART_InitStructure);
;;;342    	
;;;343    	USART_ITConfig(pUart->uart, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;344    	/*
;;;345    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;346    		注意: 不要在此处打开发送中断
;;;347    		发送中断使能在SendUart()函数打开
;;;348    	*/
;;;349    	USART_Cmd(pUart->uart, ENABLE);		/* 使能串口 */
;;;350    
;;;351    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;352    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;353    	USART_ClearFlag(pUart->uart, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;354    }
000010  bd7f              POP      {r0-r6,pc}
                  |L17.18|
000012  2100              MOVS     r1,#0                 ;332
000014  6860              LDR      r0,[r4,#4]            ;332
000016  f7fffffe          BL       USART_Cmd
00001a  9500              STR      r5,[sp,#0]            ;335
00001c  2000              MOVS     r0,#0                 ;336
00001e  f8ad0004          STRH     r0,[sp,#4]            ;336
000022  f8ad0006          STRH     r0,[sp,#6]            ;337
000026  f8ad0008          STRH     r0,[sp,#8]            ;338
00002a  f8ad000c          STRH     r0,[sp,#0xc]          ;339
00002e  200c              MOVS     r0,#0xc               ;340
000030  f8ad000a          STRH     r0,[sp,#0xa]          ;340
000034  4669              MOV      r1,sp                 ;341
000036  6860              LDR      r0,[r4,#4]            ;341
000038  f7fffffe          BL       USART_Init
00003c  2201              MOVS     r2,#1                 ;343
00003e  f2405125          MOV      r1,#0x525             ;343
000042  6860              LDR      r0,[r4,#4]            ;343
000044  f7fffffe          BL       USART_ITConfig
000048  2101              MOVS     r1,#1                 ;349
00004a  6860              LDR      r0,[r4,#4]            ;349
00004c  f7fffffe          BL       USART_Cmd
000050  2140              MOVS     r1,#0x40              ;353
000052  6860              LDR      r0,[r4,#4]            ;353
000054  f7fffffe          BL       USART_ClearFlag
000058  bf00              NOP      
00005a  e7d9              B        |L17.16|
;;;355    
                          ENDP


                          AREA ||i.comClearFifo||, CODE, READONLY, ALIGN=1

                  comClearFifo PROC
;;;280    */
;;;281    void comClearFifo(COM_PORT_E _ucPort)
000000  b510              PUSH     {r4,lr}
;;;282    {
000002  4604              MOV      r4,r0
;;;283    	comClearRxFifo(_ucPort);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       comClearRxFifo
;;;284    	comClearTxFifo(_ucPort);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       comClearTxFifo
;;;285    	
;;;286    	//停止超时成帧定时器
;;;287    	bsp_StopTimer(_ucPort);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       bsp_StopTimer
;;;288    }
000016  bd10              POP      {r4,pc}
;;;289    
                          ENDP


                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;257    */
;;;258    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;259    {
000002  4603              MOV      r3,r0
;;;260    	UART_T *pUart;
;;;261    
;;;262    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;263    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L19.16|
                  |L19.14|
;;;264    	{
;;;265    		return;
;;;266    	}
;;;267    
;;;268    	pUart->usRxWrite = 0;
;;;269    	pUart->usRxRead = 0;
;;;270    	pUart->usRxCount = 0;
;;;271    }
00000e  bd00              POP      {pc}
                  |L19.16|
000010  2000              MOVS     r0,#0                 ;268
000012  8350              STRH     r0,[r2,#0x1a]         ;268
000014  8390              STRH     r0,[r2,#0x1c]         ;269
000016  83d0              STRH     r0,[r2,#0x1e]         ;270
000018  bf00              NOP      
00001a  e7f8              B        |L19.14|
;;;272    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;234    */
;;;235    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;236    {
000002  4603              MOV      r3,r0
;;;237    	UART_T *pUart;
;;;238    
;;;239    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;240    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L20.16|
                  |L20.14|
;;;241    	{
;;;242    		return;
;;;243    	}
;;;244    
;;;245    	pUart->usTxWrite = 0;
;;;246    	pUart->usTxRead = 0;
;;;247    	pUart->usTxCount = 0;
;;;248    }
00000e  bd00              POP      {pc}
                  |L20.16|
000010  2000              MOVS     r0,#0                 ;245
000012  8290              STRH     r0,[r2,#0x14]         ;245
000014  82d0              STRH     r0,[r2,#0x16]         ;246
000016  8310              STRH     r0,[r2,#0x18]         ;247
000018  bf00              NOP      
00001a  e7f8              B        |L20.14|
;;;249    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;213    */
;;;214    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;215    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;216    	UART_T *pUart;
;;;217    
;;;218    	pUart = ComToUart(_ucPort);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;219    	if (pUart == 0)
00000e  b90c              CBNZ     r4,|L21.20|
;;;220    	{
;;;221    		return 0;
000010  2000              MOVS     r0,#0
                  |L21.18|
;;;222    	}
;;;223    
;;;224    	return UartGetChar(pUart, _pByte);
;;;225    }
000012  bd70              POP      {r4-r6,pc}
                  |L21.20|
000014  4631              MOV      r1,r6                 ;224
000016  4620              MOV      r0,r4                 ;224
000018  f7fffffe          BL       UartGetChar
00001c  e7f9              B        |L21.18|
;;;226    
                          ENDP


                          AREA ||i.comGetWaitSend||, CODE, READONLY, ALIGN=1

                  comGetWaitSend PROC
;;;150    */
;;;151    uint16_t comGetWaitSend(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;152    {
000002  4603              MOV      r3,r0
;;;153    	UART_T *pUart;
;;;154    
;;;155    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;156    	if (pUart == 0)
00000c  b90a              CBNZ     r2,|L22.18|
;;;157    	{
;;;158    		return 0;
00000e  2000              MOVS     r0,#0
                  |L22.16|
;;;159    	}
;;;160    	return pUart->usTxCount;
;;;161    }
000010  bd00              POP      {pc}
                  |L22.18|
000012  8b10              LDRH     r0,[r2,#0x18]         ;160
000014  e7fc              B        |L22.16|
;;;162    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;172    */
;;;173    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;174    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;175    	UART_T *pUart;
;;;176    
;;;177    	pUart = ComToUart(_ucPort);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ComToUart
000010  4604              MOV      r4,r0
;;;178    	if (pUart == 0)
000012  b90c              CBNZ     r4,|L23.24|
                  |L23.20|
;;;179    	{
;;;180    		return;
;;;181    	}
;;;182    
;;;183    	if (pUart->SendBefor != 0)
;;;184    	{
;;;185    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
;;;186    	}
;;;187    
;;;188    	UartSend(pUart, _ucaBuf, _usLen);
;;;189    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L23.24|
000018  6a20              LDR      r0,[r4,#0x20]         ;183
00001a  b108              CBZ      r0,|L23.32|
00001c  6a20              LDR      r0,[r4,#0x20]         ;185
00001e  4780              BLX      r0                    ;185
                  |L23.32|
000020  463a              MOV      r2,r7                 ;188
000022  4631              MOV      r1,r6                 ;188
000024  4620              MOV      r0,r4                 ;188
000026  f7fffffe          BL       UartSend
00002a  bf00              NOP      
00002c  e7f2              B        |L23.20|
;;;190    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;199    */
;;;200    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;201    {
000002  4604              MOV      r4,r0
;;;202    	comSendBuf(_ucPort, &_ucByte, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       comSendBuf
;;;203    }
00000e  bd1c              POP      {r2-r4,pc}
;;;204    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart1
                          %        44
                  g_TxBuf1
                          %        512
                  g_RxBuf1
                          %        512
                  g_tUart2
                          %        44
                  g_TxBuf2
                          %        512
                  g_RxBuf2
                          %        512

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_uart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_bsp_uart_c_b28b0d00____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_bsp_uart_c_b28b0d00____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_bsp_uart_c_b28b0d00____REVSH|
#line 128
|__asm___10_bsp_uart_c_b28b0d00____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
