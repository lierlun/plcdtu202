; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\bsp_iwdg.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\bsp_iwdg.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\bsp_iwdg.crf ..\..\User\bsp\src\bsp_iwdg.c]
                          THUMB

                          AREA ||i.IWDG_Feed||, CODE, READONLY, ALIGN=1

                  IWDG_Feed PROC
;;;95     */
;;;96     void IWDG_Feed(void)
000000  b510              PUSH     {r4,lr}
;;;97     {
;;;98     	IWDG_ReloadCounter();
000002  f7fffffe          BL       IWDG_ReloadCounter
;;;99     }
000006  bd10              POP      {r4,pc}
;;;100    
                          ENDP


                          AREA ||i.bsp_InitIwdg||, CODE, READONLY, ALIGN=2

                  bsp_InitIwdg PROC
;;;34     */
;;;35     void bsp_InitIwdg(uint32_t _ulIWDGTime)
000000  b510              PUSH     {r4,lr}
;;;36     {
000002  4604              MOV      r4,r0
;;;37     		
;;;38     	/* 检测系统是否从独立看门狗复位中恢复 */
;;;39     	if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET)
000004  207d              MOVS     r0,#0x7d
000006  f7fffffe          BL       RCC_GetFlagStatus
00000a  b108              CBZ      r0,|L2.16|
;;;40     	{		
;;;41     		/* 清除复位标志 */
;;;42     		RCC_ClearFlag();
00000c  f7fffffe          BL       RCC_ClearFlag
                  |L2.16|
;;;43     	}
;;;44     	else
;;;45     	{
;;;46     		/* 标志没有设置 */
;;;47     
;;;48     	}
;;;49     	
;;;50     #if 0
;;;51     	/* 通过TIM5输入捕获得到LSI频率 */
;;;52     	LsiFreq = GetLSIFrequency();
;;;53     #else
;;;54     	/* 使能LSI */
;;;55     	RCC_LSICmd(ENABLE);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       RCC_LSICmd
;;;56     	
;;;57     	/* 等待直到LSI就绪 */
;;;58     	while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
000016  bf00              NOP      
                  |L2.24|
000018  2061              MOVS     r0,#0x61
00001a  f7fffffe          BL       RCC_GetFlagStatus
00001e  2800              CMP      r0,#0
000020  d0fa              BEQ      |L2.24|
;;;59     	{}
;;;60     	
;;;61         /* */		
;;;62     	LsiFreq = 32000;
000022  f44f40fa          MOV      r0,#0x7d00
000026  4908              LDR      r1,|L2.72|
000028  6008              STR      r0,[r1,#0]  ; LsiFreq
;;;63     #endif
;;;64     	
;;;65     	/* 写入0x5555表示允许访问IWDG_PR 和IWDG_RLR寄存器 */
;;;66     	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
00002a  f2455055          MOV      r0,#0x5555
00002e  f7fffffe          BL       IWDG_WriteAccessCmd
;;;67     	
;;;68     	/*  LSI/32 分频*/
;;;69     	IWDG_SetPrescaler(IWDG_Prescaler_32);
000032  2003              MOVS     r0,#3
000034  f7fffffe          BL       IWDG_SetPrescaler
;;;70     	
;;;71     	/*特别注意，由于这里_ulIWDGTime的最小单位是ms, 所以这里重装计数的
;;;72     	  计数时 需要除以1000
;;;73     	 Counter Reload Value = (_ulIWDGTime / 1000) /(1 / IWDG counter clock period)
;;;74     	                      = (_ulIWDGTime / 1000) / (32/LSI)
;;;75     	                      = (_ulIWDGTime / 1000) / (32/LsiFreq)
;;;76     	                      = LsiFreq * _ulIWDGTime / 32000
;;;77     	 实际测试LsiFreq = 34000，所以这里取1的时候 大概就是1ms 
;;;78     	*/
;;;79     	IWDG_SetReload(_ulIWDGTime);
000038  b2a0              UXTH     r0,r4
00003a  f7fffffe          BL       IWDG_SetReload
;;;80     	
;;;81     	/* 重载IWDG计数 */
;;;82     	IWDG_ReloadCounter();
00003e  f7fffffe          BL       IWDG_ReloadCounter
;;;83     	
;;;84     	/* 使能 IWDG (LSI oscillator 由硬件使能) */
;;;85     	IWDG_Enable();		
000042  f7fffffe          BL       IWDG_Enable
;;;86     }
000046  bd10              POP      {r4,pc}
;;;87     
                          ENDP

                  |L2.72|
                          DCD      LsiFreq

                          AREA ||.data||, DATA, ALIGN=2

                  LsiFreq
                          DCD      0x00000000
                  CaptureNumber
                          DCD      0x00000000
                  PeriodValue
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_iwdg.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_bsp_iwdg_c_LsiFreq____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_bsp_iwdg_c_LsiFreq____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_bsp_iwdg_c_LsiFreq____REVSH|
#line 128
|__asm___10_bsp_iwdg_c_LsiFreq____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
