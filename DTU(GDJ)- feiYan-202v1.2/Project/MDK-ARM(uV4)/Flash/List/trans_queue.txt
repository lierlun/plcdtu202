; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\trans_queue.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\trans_queue.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\trans_queue.crf ..\..\User\Modbus\Trans_queue.c]
                          THUMB

                          AREA ||i.T_ClearQueue||, CODE, READONLY, ALIGN=1

                  T_ClearQueue PROC
;;;159     *---------------------------------------------------------------------------*/
;;;160    State T_ClearQueue(TCircleQueue *queue )
000000  4601              MOV      r1,r0
;;;161    {
;;;162        queue->front = 0;
000002  2000              MOVS     r0,#0
000004  f8c101a4          STR      r0,[r1,#0x1a4]
;;;163    	  queue->rear = 0;
000008  f8c101a8          STR      r0,[r1,#0x1a8]
;;;164        queue->count = 0;
00000c  f8c101ac          STR      r0,[r1,#0x1ac]
;;;165        return OK;
000010  2001              MOVS     r0,#1
;;;166    
;;;167    }
000012  4770              BX       lr
;;;168    
                          ENDP


                          AREA ||i.T_DeQueue||, CODE, READONLY, ALIGN=1

                  T_DeQueue PROC
;;;94      *---------------------------------------------------------------------------*/
;;;95     State T_DeQueue(TCircleQueue *queue,ElemType *e)
000000  b570              PUSH     {r4-r6,lr}
;;;96     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;97         //判断队列是否为空
;;;98         if(queue->count == 0)
000006  f8d401ac          LDR      r0,[r4,#0x1ac]
00000a  b908              CBNZ     r0,|L2.16|
;;;99     	  return ERROR;
00000c  2000              MOVS     r0,#0
                  |L2.14|
;;;100        //保存返回值
;;;101        *e = queue->data[queue->front];
;;;102        //更新队头指针
;;;103        queue->front = (queue->front + 1) % T_QUEUESIZE;
;;;104        //更新队列长度
;;;105        queue->count--;
;;;106        return OK;
;;;107    
;;;108    }
00000e  bd70              POP      {r4-r6,pc}
                  |L2.16|
000010  f8d401a4          LDR      r0,[r4,#0x1a4]        ;101
000014  ebc000c0          RSB      r0,r0,r0,LSL #3       ;101
000018  eb040180          ADD      r1,r4,r0,LSL #2       ;101
00001c  221c              MOVS     r2,#0x1c              ;101
00001e  4628              MOV      r0,r5                 ;101
000020  f7fffffe          BL       __aeabi_memcpy4
000024  f8d401a4          LDR      r0,[r4,#0x1a4]        ;103
000028  1c40              ADDS     r0,r0,#1              ;103
00002a  210f              MOVS     r1,#0xf               ;103
00002c  fb90f2f1          SDIV     r2,r0,r1              ;103
000030  fb010012          MLS      r0,r1,r2,r0           ;103
000034  f8c401a4          STR      r0,[r4,#0x1a4]        ;103
000038  f8d401ac          LDR      r0,[r4,#0x1ac]        ;105
00003c  1e40              SUBS     r0,r0,#1              ;105
00003e  f8c401ac          STR      r0,[r4,#0x1ac]        ;105
000042  2001              MOVS     r0,#1                 ;106
000044  e7e3              B        |L2.14|
;;;109    
                          ENDP


                          AREA ||i.T_EnQueue||, CODE, READONLY, ALIGN=1

                  T_EnQueue PROC
;;;69      *---------------------------------------------------------------------------*/
;;;70     State T_EnQueue(TCircleQueue *queue, ElemType e)
000000  b40f              PUSH     {r0-r3}
;;;71     {
000002  b510              PUSH     {r4,lr}
000004  4604              MOV      r4,r0
;;;72         //验证队列是否已满
;;;73         if(queue->count == T_QUEUESIZE)
000006  f8d401ac          LDR      r0,[r4,#0x1ac]
00000a  280f              CMP      r0,#0xf
00000c  d103              BNE      |L3.22|
;;;74            return ERROR;
00000e  2000              MOVS     r0,#0
                  |L3.16|
;;;75         //入队
;;;76         queue->data[queue->rear] = e;
;;;77         //对尾指针后移
;;;78         queue->rear = (queue->rear + 1) % T_QUEUESIZE;
;;;79         //更新队列长度
;;;80         queue->count++;
;;;81         return OK;
;;;82     
;;;83     }
000010  bc10              POP      {r4}
000012  f85dfb14          LDR      pc,[sp],#0x14
                  |L3.22|
000016  f8d411a8          LDR      r1,[r4,#0x1a8]        ;76
00001a  ebc101c1          RSB      r1,r1,r1,LSL #3       ;76
00001e  eb040081          ADD      r0,r4,r1,LSL #2       ;76
000022  221c              MOVS     r2,#0x1c              ;76
000024  a903              ADD      r1,sp,#0xc            ;76
000026  f7fffffe          BL       __aeabi_memcpy4
00002a  f8d401a8          LDR      r0,[r4,#0x1a8]        ;78
00002e  1c40              ADDS     r0,r0,#1              ;78
000030  210f              MOVS     r1,#0xf               ;78
000032  fb90f2f1          SDIV     r2,r0,r1              ;78
000036  fb010012          MLS      r0,r1,r2,r0           ;78
00003a  f8c401a8          STR      r0,[r4,#0x1a8]        ;78
00003e  f8d401ac          LDR      r0,[r4,#0x1ac]        ;80
000042  1c40              ADDS     r0,r0,#1              ;80
000044  f8c401ac          STR      r0,[r4,#0x1ac]        ;80
000048  2001              MOVS     r0,#1                 ;81
00004a  e7e1              B        |L3.16|
;;;84     
                          ENDP


                          AREA ||i.T_GetHead||, CODE, READONLY, ALIGN=1

                  T_GetHead PROC
;;;120     *---------------------------------------------------------------------------*/
;;;121    State T_GetHead(TCircleQueue *queue,ElemType *e)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;123        //判断队列是否为空
;;;124        if(queue->count == 0)
000006  f8d401ac          LDR      r0,[r4,#0x1ac]
00000a  b908              CBNZ     r0,|L4.16|
;;;125    	   return ERROR;
00000c  2000              MOVS     r0,#0
                  |L4.14|
;;;126    
;;;127        *e = queue->data[queue->front];
;;;128    	return OK;
;;;129    }
00000e  bd70              POP      {r4-r6,pc}
                  |L4.16|
000010  f8d401a4          LDR      r0,[r4,#0x1a4]        ;127
000014  ebc000c0          RSB      r0,r0,r0,LSL #3       ;127
000018  eb040180          ADD      r1,r4,r0,LSL #2       ;127
00001c  221c              MOVS     r2,#0x1c              ;127
00001e  4628              MOV      r0,r5                 ;127
000020  f7fffffe          BL       __aeabi_memcpy4
000024  2001              MOVS     r0,#1                 ;128
000026  e7f2              B        |L4.14|
;;;130    
                          ENDP


                          AREA ||i.T_GetLength||, CODE, READONLY, ALIGN=1

                  T_GetLength PROC
;;;177     *---------------------------------------------------------------------------*/
;;;178    int T_GetLength(TCircleQueue *queue)
000000  4601              MOV      r1,r0
;;;179    {
;;;180        return queue->count;
000002  f8d101ac          LDR      r0,[r1,#0x1ac]
;;;181    }
000006  4770              BX       lr
                          ENDP


                          AREA ||i.T_InitQueue||, CODE, READONLY, ALIGN=1

                  T_InitQueue PROC
;;;12      *---------------------------------------------------------------------------*/
;;;13     State T_InitQueue(TCircleQueue *queue)
000000  4601              MOV      r1,r0
;;;14     {
;;;15         queue->front = 0; 
000002  2000              MOVS     r0,#0
000004  f8c101a4          STR      r0,[r1,#0x1a4]
;;;16     	  queue->rear = 0;
000008  f8c101a8          STR      r0,[r1,#0x1a8]
;;;17         queue->count = 0;
00000c  f8c101ac          STR      r0,[r1,#0x1ac]
;;;18         return OK;
000010  2001              MOVS     r0,#1
;;;19     }
000012  4770              BX       lr
;;;20     
                          ENDP


                          AREA ||i.T_IsQueueEmpty||, CODE, READONLY, ALIGN=1

                  T_IsQueueEmpty PROC
;;;34      *---------------------------------------------------------------------------*/
;;;35     State T_IsQueueEmpty(TCircleQueue *queue)
000000  4601              MOV      r1,r0
;;;36     {
;;;37         if(queue->count == 0)
000002  f8d101ac          LDR      r0,[r1,#0x1ac]
000006  b908              CBNZ     r0,|L7.12|
;;;38             return TRUE;
000008  2001              MOVS     r0,#1
                  |L7.10|
;;;39         else
;;;40             return FALSE;
;;;41     }
00000a  4770              BX       lr
                  |L7.12|
00000c  2000              MOVS     r0,#0                 ;40
00000e  e7fc              B        |L7.10|
;;;42     
                          ENDP


                          AREA ||i.T_IsQueueFull||, CODE, READONLY, ALIGN=1

                  T_IsQueueFull PROC
;;;51      *---------------------------------------------------------------------------*/
;;;52     State T_IsQueueFull(TCircleQueue *queue)
000000  4601              MOV      r1,r0
;;;53     {
;;;54         if(queue->count == T_QUEUESIZE)
000002  f8d101ac          LDR      r0,[r1,#0x1ac]
000006  280f              CMP      r0,#0xf
000008  d101              BNE      |L8.14|
;;;55             return TRUE;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;56         else
;;;57             return FALSE;
;;;58     }
00000c  4770              BX       lr
                  |L8.14|
00000e  2000              MOVS     r0,#0                 ;57
000010  e7fc              B        |L8.12|
;;;59     
                          ENDP


                          AREA ||i.T_SetHead||, CODE, READONLY, ALIGN=1

                  T_SetHead PROC
;;;140     *---------------------------------------------------------------------------*/
;;;141    State T_SetHead(TCircleQueue *queue,ElemType e)
000000  b40f              PUSH     {r0-r3}
;;;142    {
000002  b510              PUSH     {r4,lr}
000004  4604              MOV      r4,r0
;;;143        //判断队列是否为空
;;;144        if(queue->count == 0)
000006  f8d401ac          LDR      r0,[r4,#0x1ac]
00000a  b918              CBNZ     r0,|L9.20|
;;;145    	   return ERROR;
00000c  2000              MOVS     r0,#0
                  |L9.14|
;;;146    
;;;147        queue->data[queue->front] = e;
;;;148    	return OK;
;;;149    }
00000e  bc10              POP      {r4}
000010  f85dfb14          LDR      pc,[sp],#0x14
                  |L9.20|
000014  f8d411a4          LDR      r1,[r4,#0x1a4]        ;147
000018  ebc101c1          RSB      r1,r1,r1,LSL #3       ;147
00001c  eb040081          ADD      r0,r4,r1,LSL #2       ;147
000020  221c              MOVS     r2,#0x1c              ;147
000022  a903              ADD      r1,sp,#0xc            ;147
000024  f7fffffe          BL       __aeabi_memcpy4
000028  2001              MOVS     r0,#1                 ;148
00002a  e7f0              B        |L9.14|
;;;150    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Trans_Queue
                          %        432
