; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\lib_str.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\lib_str.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\lib_str.crf ..\..\uCOS-III\uC-LIB\lib_str.c]
                          THUMB

                          AREA ||i.Str_Cat||, CODE, READONLY, ALIGN=1

                  Str_Cat PROC
;;;540    
;;;541    CPU_CHAR  *Str_Cat (       CPU_CHAR  *pstr_dest,
000000  b570              PUSH     {r4-r6,lr}
;;;542                        const  CPU_CHAR  *pstr_cat)
;;;543    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;544        CPU_CHAR  *pstr_rtn;
;;;545    
;;;546    
;;;547        pstr_rtn = Str_Cat_N(pstr_dest,
000006  f04f32ff          MOV      r2,#0xffffffff
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       Str_Cat_N
000012  4606              MOV      r6,r0
;;;548                             pstr_cat,
;;;549                             DEF_INT_CPU_U_MAX_VAL);
;;;550    
;;;551        return (pstr_rtn);
000014  4630              MOV      r0,r6
;;;552    }
000016  bd70              POP      {r4-r6,pc}
;;;553    
                          ENDP


                          AREA ||i.Str_Cat_N||, CODE, READONLY, ALIGN=1

                  Str_Cat_N PROC
;;;622    
;;;623    CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
000000  b570              PUSH     {r4-r6,lr}
;;;624                          const  CPU_CHAR    *pstr_cat,
;;;625                                 CPU_SIZE_T   len_max)
;;;626    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;627               CPU_CHAR    *pstr_cat_dest;
;;;628        const  CPU_CHAR    *pstr_cat_src;
;;;629               CPU_SIZE_T   len_cat;
;;;630    
;;;631                                                                    /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
;;;632        if (pstr_dest == (CPU_CHAR *)0) {
000008  b90b              CBNZ     r3,|L2.14|
;;;633            return ((CPU_CHAR *)0);
00000a  2000              MOVS     r0,#0
                  |L2.12|
;;;634        }
;;;635        if (pstr_cat  == (const CPU_CHAR *)0) {
;;;636            return ((CPU_CHAR *)0);
;;;637        }
;;;638    
;;;639        if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
;;;640            return ((CPU_CHAR *)pstr_dest);
;;;641        }
;;;642    
;;;643    
;;;644        pstr_cat_dest = pstr_dest;
;;;645        while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
;;;646               (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
;;;647            pstr_cat_dest++;
;;;648        }
;;;649        if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
;;;650            return ((CPU_CHAR *)0);
;;;651        }
;;;652    
;;;653        pstr_cat_src = pstr_cat;
;;;654        len_cat      = 0u;
;;;655    
;;;656        while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
;;;657               ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
;;;658               (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
;;;659               ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
;;;660           *pstr_cat_dest = *pstr_cat_src;
;;;661            pstr_cat_dest++;
;;;662            pstr_cat_src++;
;;;663            len_cat++;
;;;664        }
;;;665                                                                    /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
;;;666        if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
;;;667            (pstr_cat_src  == (const CPU_CHAR *)0)) {
;;;668             return ((CPU_CHAR *)0);
;;;669        }
;;;670    
;;;671       *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
;;;672    
;;;673    
;;;674        return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
;;;675    }
00000c  bd70              POP      {r4-r6,pc}
                  |L2.14|
00000e  b90c              CBNZ     r4,|L2.20|
000010  2000              MOVS     r0,#0                 ;636
000012  e7fb              B        |L2.12|
                  |L2.20|
000014  b90d              CBNZ     r5,|L2.26|
000016  4618              MOV      r0,r3                 ;640
000018  e7f8              B        |L2.12|
                  |L2.26|
00001a  4619              MOV      r1,r3                 ;644
00001c  e000              B        |L2.32|
                  |L2.30|
00001e  1c49              ADDS     r1,r1,#1              ;647
                  |L2.32|
000020  b111              CBZ      r1,|L2.40|
000022  7808              LDRB     r0,[r1,#0]            ;646
000024  2800              CMP      r0,#0                 ;646
000026  d1fa              BNE      |L2.30|
                  |L2.40|
000028  b909              CBNZ     r1,|L2.46|
00002a  2000              MOVS     r0,#0                 ;650
00002c  e7ee              B        |L2.12|
                  |L2.46|
00002e  4622              MOV      r2,r4                 ;653
000030  2600              MOVS     r6,#0                 ;654
000032  e004              B        |L2.62|
                  |L2.52|
000034  7810              LDRB     r0,[r2,#0]            ;660
000036  7008              STRB     r0,[r1,#0]            ;660
000038  1c49              ADDS     r1,r1,#1              ;661
00003a  1c52              ADDS     r2,r2,#1              ;662
00003c  1c76              ADDS     r6,r6,#1              ;663
                  |L2.62|
00003e  b121              CBZ      r1,|L2.74|
000040  b11a              CBZ      r2,|L2.74|
000042  7810              LDRB     r0,[r2,#0]            ;658
000044  b108              CBZ      r0,|L2.74|
000046  42ae              CMP      r6,r5                 ;659
000048  d3f4              BCC      |L2.52|
                  |L2.74|
00004a  b101              CBZ      r1,|L2.78|
00004c  b90a              CBNZ     r2,|L2.82|
                  |L2.78|
00004e  2000              MOVS     r0,#0                 ;668
000050  e7dc              B        |L2.12|
                  |L2.82|
000052  2000              MOVS     r0,#0                 ;671
000054  7008              STRB     r0,[r1,#0]            ;671
000056  4618              MOV      r0,r3                 ;674
000058  e7d8              B        |L2.12|
;;;676    
                          ENDP


                          AREA ||i.Str_Char||, CODE, READONLY, ALIGN=1

                  Str_Char PROC
;;;1269   
;;;1270   CPU_CHAR  *Str_Char (const  CPU_CHAR  *pstr,
000000  b570              PUSH     {r4-r6,lr}
;;;1271                               CPU_CHAR   srch_char)
;;;1272   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1273       CPU_CHAR  *pstr_rtn;
;;;1274   
;;;1275   
;;;1276       pstr_rtn = Str_Char_N(pstr,
000006  4622              MOV      r2,r4
000008  f04f31ff          MOV      r1,#0xffffffff
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       Str_Char_N
000012  4606              MOV      r6,r0
;;;1277                             DEF_INT_CPU_U_MAX_VAL,
;;;1278                             srch_char);
;;;1279   
;;;1280       return (pstr_rtn);
000014  4630              MOV      r0,r6
;;;1281   }
000016  bd70              POP      {r4-r6,pc}
;;;1282   
                          ENDP


                          AREA ||i.Str_Char_Last||, CODE, READONLY, ALIGN=1

                  Str_Char_Last PROC
;;;1446   
;;;1447   CPU_CHAR  *Str_Char_Last (const  CPU_CHAR  *pstr,
000000  b570              PUSH     {r4-r6,lr}
;;;1448                                    CPU_CHAR   srch_char)
;;;1449   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1450       CPU_CHAR  *pstr_rtn;
;;;1451   
;;;1452   
;;;1453       pstr_rtn = Str_Char_Last_N(pstr,
000006  4622              MOV      r2,r4
000008  f04f31ff          MOV      r1,#0xffffffff
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       Str_Char_Last_N
000012  4606              MOV      r6,r0
;;;1454                                  DEF_INT_CPU_U_MAX_VAL,
;;;1455                                  srch_char);
;;;1456   
;;;1457       return (pstr_rtn);
000014  4630              MOV      r0,r6
;;;1458   }
000016  bd70              POP      {r4-r6,pc}
;;;1459   
                          ENDP


                          AREA ||i.Str_Char_Last_N||, CODE, READONLY, ALIGN=1

                  Str_Char_Last_N PROC
;;;1528   
;;;1529   CPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1530                                      CPU_SIZE_T   len_max,
;;;1531                                      CPU_CHAR     srch_char)
;;;1532   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1533       const  CPU_CHAR    *pstr_char;
;;;1534              CPU_SIZE_T   str_len_max;
;;;1535              CPU_SIZE_T   str_len;
;;;1536   
;;;1537   
;;;1538       if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
00000a  b915              CBNZ     r5,|L5.18|
;;;1539           return ((CPU_CHAR *)0);
00000c  2000              MOVS     r0,#0
                  |L5.14|
;;;1540       }
;;;1541   
;;;1542       if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
;;;1543           return ((CPU_CHAR *)0);
;;;1544       }
;;;1545   
;;;1546   
;;;1547       pstr_char    = pstr;
;;;1548        str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
;;;1549        str_len     = Str_Len_N(pstr_char, str_len_max);
;;;1550       pstr_char   += str_len;
;;;1551   
;;;1552       if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
;;;1553           return ((CPU_CHAR *)0);
;;;1554       }
;;;1555   
;;;1556       while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
;;;1557              (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
;;;1558           pstr_char--;
;;;1559       }
;;;1560   
;;;1561   
;;;1562       if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
;;;1563            return ((CPU_CHAR *)0);
;;;1564       }
;;;1565   
;;;1566   
;;;1567       return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
;;;1568   }
00000e  e8bd83f0          POP      {r4-r9,pc}
                  |L5.18|
000012  b90e              CBNZ     r6,|L5.24|
000014  2000              MOVS     r0,#0                 ;1543
000016  e7fa              B        |L5.14|
                  |L5.24|
000018  462c              MOV      r4,r5                 ;1547
00001a  f1a60901          SUB      r9,r6,#1              ;1548
00001e  4649              MOV      r1,r9                 ;1549
000020  4620              MOV      r0,r4                 ;1549
000022  f7fffffe          BL       Str_Len_N
000026  4680              MOV      r8,r0                 ;1549
000028  4444              ADD      r4,r4,r8              ;1550
00002a  b90c              CBNZ     r4,|L5.48|
00002c  2000              MOVS     r0,#0                 ;1553
00002e  e7ee              B        |L5.14|
                  |L5.48|
000030  e000              B        |L5.52|
                  |L5.50|
000032  1e64              SUBS     r4,r4,#1              ;1558
                  |L5.52|
000034  42ac              CMP      r4,r5                 ;1556
000036  d002              BEQ      |L5.62|
000038  7820              LDRB     r0,[r4,#0]            ;1557
00003a  42b8              CMP      r0,r7                 ;1557
00003c  d1f9              BNE      |L5.50|
                  |L5.62|
00003e  7820              LDRB     r0,[r4,#0]            ;1562
000040  42b8              CMP      r0,r7                 ;1562
000042  d001              BEQ      |L5.72|
000044  2000              MOVS     r0,#0                 ;1563
000046  e7e2              B        |L5.14|
                  |L5.72|
000048  4620              MOV      r0,r4                 ;1567
00004a  e7e0              B        |L5.14|
;;;1569   
                          ENDP


                          AREA ||i.Str_Char_N||, CODE, READONLY, ALIGN=1

                  Str_Char_N PROC
;;;1349   
;;;1350   CPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
000000  b530              PUSH     {r4,r5,lr}
;;;1351                                 CPU_SIZE_T   len_max,
;;;1352                                 CPU_CHAR     srch_char)
;;;1353   {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
000006  4615              MOV      r5,r2
;;;1354       const  CPU_CHAR    *pstr_char;
;;;1355              CPU_SIZE_T   len_srch;
;;;1356   
;;;1357   
;;;1358       if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
000008  b90c              CBNZ     r4,|L6.14|
;;;1359           return ((CPU_CHAR *)0);
00000a  2000              MOVS     r0,#0
                  |L6.12|
;;;1360       }
;;;1361   
;;;1362       if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
;;;1363           return ((CPU_CHAR *)0);
;;;1364       }
;;;1365   
;;;1366   
;;;1367       pstr_char = pstr;
;;;1368       len_srch  = 0u;
;;;1369   
;;;1370       while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
;;;1371              (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
;;;1372              (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
;;;1373              ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
;;;1374           pstr_char++;
;;;1375           len_srch++;
;;;1376       }
;;;1377   
;;;1378   
;;;1379       if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
;;;1380           return ((CPU_CHAR *)0);
;;;1381       }
;;;1382   
;;;1383       if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
;;;1384           return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
;;;1385       }
;;;1386   
;;;1387       if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
;;;1388            return ((CPU_CHAR *)0);
;;;1389       }
;;;1390   
;;;1391   
;;;1392       return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
;;;1393   }
00000c  bd30              POP      {r4,r5,pc}
                  |L6.14|
00000e  b90b              CBNZ     r3,|L6.20|
000010  2000              MOVS     r0,#0                 ;1363
000012  e7fb              B        |L6.12|
                  |L6.20|
000014  4621              MOV      r1,r4                 ;1367
000016  2200              MOVS     r2,#0                 ;1368
000018  e001              B        |L6.30|
                  |L6.26|
00001a  1c49              ADDS     r1,r1,#1              ;1374
00001c  1c52              ADDS     r2,r2,#1              ;1375
                  |L6.30|
00001e  b131              CBZ      r1,|L6.46|
000020  7808              LDRB     r0,[r1,#0]            ;1371
000022  b120              CBZ      r0,|L6.46|
000024  7808              LDRB     r0,[r1,#0]            ;1372
000026  42a8              CMP      r0,r5                 ;1372
000028  d001              BEQ      |L6.46|
00002a  429a              CMP      r2,r3                 ;1373
00002c  d3f5              BCC      |L6.26|
                  |L6.46|
00002e  b909              CBNZ     r1,|L6.52|
000030  2000              MOVS     r0,#0                 ;1380
000032  e7eb              B        |L6.12|
                  |L6.52|
000034  429a              CMP      r2,r3                 ;1383
000036  d301              BCC      |L6.60|
000038  2000              MOVS     r0,#0                 ;1384
00003a  e7e7              B        |L6.12|
                  |L6.60|
00003c  7808              LDRB     r0,[r1,#0]            ;1387
00003e  42a8              CMP      r0,r5                 ;1387
000040  d001              BEQ      |L6.70|
000042  2000              MOVS     r0,#0                 ;1388
000044  e7e2              B        |L6.12|
                  |L6.70|
000046  4608              MOV      r0,r1                 ;1392
000048  e7e0              B        |L6.12|
;;;1394   
                          ENDP


                          AREA ||i.Str_Char_Replace||, CODE, READONLY, ALIGN=1

                  Str_Char_Replace PROC
;;;1607   
;;;1608   CPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1609                                CPU_CHAR   char_srch,
;;;1610                                CPU_CHAR   char_replace)
;;;1611   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1612       CPU_CHAR  *pstr_rtn;
;;;1613   
;;;1614   
;;;1615       pstr_rtn = Str_Char_Replace_N(pstr,
000008  f04f33ff          MOV      r3,#0xffffffff
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       Str_Char_Replace_N
000016  4607              MOV      r7,r0
;;;1616                                     char_srch,
;;;1617                                     char_replace,
;;;1618                                     DEF_INT_CPU_U_MAX_VAL);
;;;1619   
;;;1620       return (pstr_rtn);
000018  4638              MOV      r0,r7
;;;1621   }
00001a  bdf0              POP      {r4-r7,pc}
;;;1622   
                          ENDP


                          AREA ||i.Str_Char_Replace_N||, CODE, READONLY, ALIGN=1

                  Str_Char_Replace_N PROC
;;;1669   
;;;1670   CPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
000000  b570              PUSH     {r4-r6,lr}
;;;1671                                  CPU_CHAR     char_srch,
;;;1672                                  CPU_CHAR     char_replace,
;;;1673                                  CPU_SIZE_T   len_max)
;;;1674   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1675       CPU_CHAR    *pstr_char;
;;;1676       CPU_SIZE_T   len;
;;;1677   
;;;1678   
;;;1679       if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
000008  b90c              CBNZ     r4,|L8.14|
;;;1680           return ((CPU_CHAR *)0);
00000a  2000              MOVS     r0,#0
                  |L8.12|
;;;1681       }
;;;1682   
;;;1683       if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
;;;1684           return ((CPU_CHAR *)0);
;;;1685       }
;;;1686   
;;;1687       pstr_char = pstr;
;;;1688       len       = len_max;
;;;1689   
;;;1690       while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
;;;1691              (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
;;;1692              ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
;;;1693   
;;;1694           if (*pstr_char == char_srch) {
;;;1695               *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
;;;1696           }
;;;1697   
;;;1698           pstr_char++;
;;;1699           len--;
;;;1700       }
;;;1701   
;;;1702       return (pstr);
;;;1703   }
00000c  bd70              POP      {r4-r6,pc}
                  |L8.14|
00000e  b90b              CBNZ     r3,|L8.20|
000010  2000              MOVS     r0,#0                 ;1684
000012  e7fb              B        |L8.12|
                  |L8.20|
000014  4621              MOV      r1,r4                 ;1687
000016  461a              MOV      r2,r3                 ;1688
000018  e005              B        |L8.38|
                  |L8.26|
00001a  7808              LDRB     r0,[r1,#0]            ;1694
00001c  42a8              CMP      r0,r5                 ;1694
00001e  d100              BNE      |L8.34|
000020  700e              STRB     r6,[r1,#0]            ;1695
                  |L8.34|
000022  1c49              ADDS     r1,r1,#1              ;1698
000024  1e52              SUBS     r2,r2,#1              ;1699
                  |L8.38|
000026  b119              CBZ      r1,|L8.48|
000028  7808              LDRB     r0,[r1,#0]            ;1691
00002a  b108              CBZ      r0,|L8.48|
00002c  2a00              CMP      r2,#0                 ;1692
00002e  d1f4              BNE      |L8.26|
                  |L8.48|
000030  4620              MOV      r0,r4                 ;1702
000032  e7eb              B        |L8.12|
;;;1704   
                          ENDP


                          AREA ||i.Str_Cmp||, CODE, READONLY, ALIGN=1

                  Str_Cmp PROC
;;;752    
;;;753    CPU_INT16S  Str_Cmp (const  CPU_CHAR  *p1_str,
000000  b570              PUSH     {r4-r6,lr}
;;;754                         const  CPU_CHAR  *p2_str)
;;;755    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;756        CPU_INT16S  cmp_val;
;;;757    
;;;758    
;;;759        cmp_val = Str_Cmp_N(p1_str,
000006  f04f32ff          MOV      r2,#0xffffffff
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       Str_Cmp_N
000012  4606              MOV      r6,r0
;;;760                            p2_str,
;;;761                            DEF_INT_CPU_U_MAX_VAL);
;;;762    
;;;763        return (cmp_val);
000014  4630              MOV      r0,r6
;;;764    }
000016  bd70              POP      {r4-r6,pc}
;;;765    
                          ENDP


                          AREA ||i.Str_CmpIgnoreCase||, CODE, READONLY, ALIGN=1

                  Str_CmpIgnoreCase PROC
;;;1017   
;;;1018   CPU_INT16S  Str_CmpIgnoreCase (const  CPU_CHAR  *p1_str,
000000  b570              PUSH     {r4-r6,lr}
;;;1019                                  const  CPU_CHAR  *p2_str)
;;;1020   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1021       CPU_INT16S  cmp_val;
;;;1022   
;;;1023   
;;;1024       cmp_val = Str_CmpIgnoreCase_N(p1_str,
000006  f04f32ff          MOV      r2,#0xffffffff
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       Str_CmpIgnoreCase_N
000012  4606              MOV      r6,r0
;;;1025                                     p2_str,
;;;1026                                     DEF_INT_CPU_U_MAX_VAL);
;;;1027   
;;;1028       return (cmp_val);
000014  4630              MOV      r0,r6
;;;1029   }
000016  bd70              POP      {r4-r6,pc}
;;;1030   
                          ENDP


                          AREA ||i.Str_CmpIgnoreCase_N||, CODE, READONLY, ALIGN=1

                  Str_CmpIgnoreCase_N PROC
;;;1128   
;;;1129   CPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1130                                    const  CPU_CHAR    *p2_str,
;;;1131                                           CPU_SIZE_T   len_max)
;;;1132   {
000004  b082              SUB      sp,sp,#8
000006  4680              MOV      r8,r0
000008  460e              MOV      r6,r1
;;;1133       const  CPU_CHAR    *p1_str_cmp;
;;;1134       const  CPU_CHAR    *p2_str_cmp;
;;;1135       const  CPU_CHAR    *p1_str_cmp_next;
;;;1136       const  CPU_CHAR    *p2_str_cmp_next;
;;;1137              CPU_CHAR     char_1;
;;;1138              CPU_CHAR     char_2;
;;;1139              CPU_INT16S   cmp_val;
;;;1140              CPU_SIZE_T   cmp_len;
;;;1141   
;;;1142   
;;;1143       if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
00000a  9804              LDR      r0,[sp,#0x10]
00000c  b918              CBNZ     r0,|L11.22|
;;;1144           return (0);
00000e  2000              MOVS     r0,#0
                  |L11.16|
;;;1145       }
;;;1146   
;;;1147       if (p1_str == (const CPU_CHAR *)0) {
;;;1148           if (p2_str == (const CPU_CHAR *)0) {
;;;1149               return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
;;;1150           }
;;;1151           char_2  =  ASCII_ToLower(*p2_str);
;;;1152           cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
;;;1153           return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
;;;1154       }
;;;1155       if (p2_str == (const CPU_CHAR *)0) {
;;;1156           char_1  =  ASCII_ToLower(*p1_str);
;;;1157           cmp_val = (CPU_INT16S)char_1;
;;;1158           return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
;;;1159       }
;;;1160   
;;;1161   
;;;1162       p1_str_cmp      = p1_str;
;;;1163       p2_str_cmp      = p2_str;
;;;1164       p1_str_cmp_next = p1_str_cmp;
;;;1165       p2_str_cmp_next = p2_str_cmp;
;;;1166       p1_str_cmp_next++;
;;;1167       p2_str_cmp_next++;
;;;1168       char_1          = ASCII_ToLower(*p1_str_cmp);
;;;1169       char_2          = ASCII_ToLower(*p2_str_cmp);
;;;1170       cmp_len         = 0u;
;;;1171   
;;;1172       while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
;;;1173              (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
;;;1174              ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
;;;1175              ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
;;;1176              ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
;;;1177           p1_str_cmp++;
;;;1178           p2_str_cmp++;
;;;1179           p1_str_cmp_next++;
;;;1180           p2_str_cmp_next++;
;;;1181           cmp_len++;
;;;1182           char_1 = ASCII_ToLower(*p1_str_cmp);
;;;1183           char_2 = ASCII_ToLower(*p2_str_cmp);
;;;1184       }
;;;1185   
;;;1186   
;;;1187       if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
;;;1188           return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
;;;1189       }
;;;1190   
;;;1191       if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
;;;1192                                                                   /* ... calc & rtn char diff  (see Note #3c1).           */
;;;1193            cmp_val = (CPU_INT16S)((CPU_INT16S)char_1 - (CPU_INT16S)char_2);
;;;1194   
;;;1195       } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
;;;1196            cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
;;;1197   
;;;1198       } else {
;;;1199           if (p1_str_cmp_next == (const CPU_CHAR *)0) {
;;;1200               if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
;;;1201                   cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
;;;1202               } else {                                            /* If p1_str_cmp_next NULL, ...                         */
;;;1203                   char_2  =  ASCII_ToLower(*p2_str_cmp_next);
;;;1204                                                                   /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
;;;1205                   cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
;;;1206               }
;;;1207           } else {                                                /* If p2_str_cmp_next NULL, ...                         */
;;;1208               char_1  =  ASCII_ToLower(*p1_str_cmp_next);
;;;1209               cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
;;;1210           }
;;;1211       }
;;;1212   
;;;1213   
;;;1214       return (cmp_val);
;;;1215   }
000010  b005              ADD      sp,sp,#0x14
000012  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.22|
000016  f1b80f00          CMP      r8,#0                 ;1147
00001a  d109              BNE      |L11.48|
00001c  b90e              CBNZ     r6,|L11.34|
00001e  2000              MOVS     r0,#0                 ;1149
000020  e7f6              B        |L11.16|
                  |L11.34|
000022  7830              LDRB     r0,[r6,#0]            ;1151
000024  f7fffffe          BL       ASCII_ToLower
000028  4607              MOV      r7,r0                 ;1151
00002a  427c              RSBS     r4,r7,#0              ;1152
00002c  4620              MOV      r0,r4                 ;1153
00002e  e7ef              B        |L11.16|
                  |L11.48|
000030  b93e              CBNZ     r6,|L11.66|
000032  f8980000          LDRB     r0,[r8,#0]            ;1156
000036  f7fffffe          BL       ASCII_ToLower
00003a  4605              MOV      r5,r0                 ;1156
00003c  462c              MOV      r4,r5                 ;1157
00003e  4620              MOV      r0,r4                 ;1158
000040  e7e6              B        |L11.16|
                  |L11.66|
000042  46c1              MOV      r9,r8                 ;1162
000044  46b2              MOV      r10,r6                ;1163
000046  46c8              MOV      r8,r9                 ;1164
000048  46c3              MOV      r11,r8                ;1164
00004a  4656              MOV      r6,r10                ;1165
00004c  f8cda004          STR      r10,[sp,#4]           ;1165
000050  46d8              MOV      r8,r11                ;1166
000052  f10b0b01          ADD      r11,r11,#1            ;1166
000056  9e01              LDR      r6,[sp,#4]            ;1167
000058  1c70              ADDS     r0,r6,#1              ;1167
00005a  9001              STR      r0,[sp,#4]            ;1167
00005c  46c8              MOV      r8,r9                 ;1168
00005e  f8990000          LDRB     r0,[r9,#0]            ;1168
000062  f7fffffe          BL       ASCII_ToLower
000066  4605              MOV      r5,r0                 ;1168
000068  4656              MOV      r6,r10                ;1169
00006a  f89a0000          LDRB     r0,[r10,#0]           ;1169
00006e  f7fffffe          BL       ASCII_ToLower
000072  4607              MOV      r7,r0                 ;1169
000074  2000              MOVS     r0,#0                 ;1170
000076  9000              STR      r0,[sp,#0]            ;1170
000078  e015              B        |L11.166|
                  |L11.122|
00007a  f1090901          ADD      r9,r9,#1              ;1177
00007e  f10a0a01          ADD      r10,r10,#1            ;1178
000082  f10b0b01          ADD      r11,r11,#1            ;1179
000086  9801              LDR      r0,[sp,#4]            ;1180
000088  1c40              ADDS     r0,r0,#1              ;1180
00008a  9001              STR      r0,[sp,#4]            ;1180
00008c  9800              LDR      r0,[sp,#0]            ;1181
00008e  1c40              ADDS     r0,r0,#1              ;1181
000090  9000              STR      r0,[sp,#0]            ;1181
000092  f8990000          LDRB     r0,[r9,#0]            ;1182
000096  f7fffffe          BL       ASCII_ToLower
00009a  4605              MOV      r5,r0                 ;1182
00009c  f89a0000          LDRB     r0,[r10,#0]           ;1183
0000a0  f7fffffe          BL       ASCII_ToLower
0000a4  4607              MOV      r7,r0                 ;1183
                  |L11.166|
0000a6  42bd              CMP      r5,r7                 ;1172
0000a8  d10b              BNE      |L11.194|
0000aa  f8990000          LDRB     r0,[r9,#0]            ;1173
0000ae  b140              CBZ      r0,|L11.194|
0000b0  f1bb0f00          CMP      r11,#0                ;1174
0000b4  d005              BEQ      |L11.194|
0000b6  9801              LDR      r0,[sp,#4]            ;1175
0000b8  b118              CBZ      r0,|L11.194|
0000ba  9904              LDR      r1,[sp,#0x10]         ;1176
0000bc  9800              LDR      r0,[sp,#0]            ;1176
0000be  4288              CMP      r0,r1                 ;1176
0000c0  d3db              BCC      |L11.122|
                  |L11.194|
0000c2  9904              LDR      r1,[sp,#0x10]         ;1187
0000c4  9800              LDR      r0,[sp,#0]            ;1187
0000c6  4288              CMP      r0,r1                 ;1187
0000c8  d101              BNE      |L11.206|
0000ca  2000              MOVS     r0,#0                 ;1188
0000cc  e7a0              B        |L11.16|
                  |L11.206|
0000ce  42bd              CMP      r5,r7                 ;1191
0000d0  d001              BEQ      |L11.214|
0000d2  1bec              SUBS     r4,r5,r7              ;1193
0000d4  e016              B        |L11.260|
                  |L11.214|
0000d6  b90d              CBNZ     r5,|L11.220|
0000d8  2400              MOVS     r4,#0                 ;1196
0000da  e013              B        |L11.260|
                  |L11.220|
0000dc  f1bb0f00          CMP      r11,#0                ;1199
0000e0  d10a              BNE      |L11.248|
0000e2  9801              LDR      r0,[sp,#4]            ;1200
0000e4  b908              CBNZ     r0,|L11.234|
0000e6  2400              MOVS     r4,#0                 ;1201
0000e8  e00c              B        |L11.260|
                  |L11.234|
0000ea  9901              LDR      r1,[sp,#4]            ;1203
0000ec  7808              LDRB     r0,[r1,#0]            ;1203
0000ee  f7fffffe          BL       ASCII_ToLower
0000f2  4607              MOV      r7,r0                 ;1203
0000f4  427c              RSBS     r4,r7,#0              ;1205
0000f6  e005              B        |L11.260|
                  |L11.248|
0000f8  f89b0000          LDRB     r0,[r11,#0]           ;1208
0000fc  f7fffffe          BL       ASCII_ToLower
000100  4605              MOV      r5,r0                 ;1208
000102  462c              MOV      r4,r5                 ;1209
                  |L11.260|
000104  4620              MOV      r0,r4                 ;1214
000106  e783              B        |L11.16|
;;;1216   
                          ENDP


                          AREA ||i.Str_Cmp_N||, CODE, READONLY, ALIGN=1

                  Str_Cmp_N PROC
;;;853    
;;;854    CPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;855                           const  CPU_CHAR    *p2_str,
;;;856                                  CPU_SIZE_T   len_max)
;;;857    {
000004  4605              MOV      r5,r0
000006  460b              MOV      r3,r1
000008  4694              MOV      r12,r2
;;;858        const  CPU_CHAR    *p1_str_cmp;
;;;859        const  CPU_CHAR    *p2_str_cmp;
;;;860        const  CPU_CHAR    *p1_str_cmp_next;
;;;861        const  CPU_CHAR    *p2_str_cmp_next;
;;;862               CPU_INT16S   cmp_val;
;;;863               CPU_SIZE_T   cmp_len;
;;;864    
;;;865    
;;;866        if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
00000a  f1bc0f00          CMP      r12,#0
00000e  d102              BNE      |L12.22|
;;;867            return (0);
000010  2000              MOVS     r0,#0
                  |L12.18|
;;;868        }
;;;869    
;;;870        if (p1_str == (const CPU_CHAR *)0) {
;;;871            if (p2_str == (const CPU_CHAR *)0) {
;;;872                return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
;;;873            }
;;;874            cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str));
;;;875            return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
;;;876        }
;;;877        if (p2_str == (const CPU_CHAR *)0) {
;;;878            cmp_val = (CPU_INT16S)(*p1_str);
;;;879            return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
;;;880        }
;;;881    
;;;882    
;;;883        p1_str_cmp      = p1_str;
;;;884        p2_str_cmp      = p2_str;
;;;885        p1_str_cmp_next = p1_str_cmp;
;;;886        p2_str_cmp_next = p2_str_cmp;
;;;887        p1_str_cmp_next++;
;;;888        p2_str_cmp_next++;
;;;889        cmp_len         = 0u;
;;;890    
;;;891        while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
;;;892               (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
;;;893               ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
;;;894               ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
;;;895               ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
;;;896            p1_str_cmp++;
;;;897            p2_str_cmp++;
;;;898            p1_str_cmp_next++;
;;;899            p2_str_cmp_next++;
;;;900            cmp_len++;
;;;901        }
;;;902    
;;;903    
;;;904        if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
;;;905            return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
;;;906        }
;;;907    
;;;908        if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
;;;909                                                                    /* ... calc & rtn char diff  (see Note #3c1).           */
;;;910             cmp_val = (CPU_INT16S)((CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp));
;;;911    
;;;912        } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
;;;913             cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
;;;914    
;;;915        } else {
;;;916            if (p1_str_cmp_next == (const CPU_CHAR *)0) {
;;;917                if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
;;;918                    cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
;;;919                } else {                                            /* If p1_str_cmp_next NULL, ...                         */
;;;920                                                                    /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
;;;921                    cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next));
;;;922                }
;;;923            } else {                                                /* If p2_str_cmp_next NULL, ...                         */
;;;924                cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
;;;925            }
;;;926        }
;;;927    
;;;928    
;;;929        return (cmp_val);
;;;930    }
000012  e8bd83f0          POP      {r4-r9,pc}
                  |L12.22|
000016  b935              CBNZ     r5,|L12.38|
000018  b90b              CBNZ     r3,|L12.30|
00001a  2000              MOVS     r0,#0                 ;872
00001c  e7f9              B        |L12.18|
                  |L12.30|
00001e  7818              LDRB     r0,[r3,#0]            ;874
000020  4242              RSBS     r2,r0,#0              ;874
000022  4610              MOV      r0,r2                 ;875
000024  e7f5              B        |L12.18|
                  |L12.38|
000026  b913              CBNZ     r3,|L12.46|
000028  782a              LDRB     r2,[r5,#0]            ;878
00002a  4610              MOV      r0,r2                 ;879
00002c  e7f1              B        |L12.18|
                  |L12.46|
00002e  4629              MOV      r1,r5                 ;883
000030  461c              MOV      r4,r3                 ;884
000032  460f              MOV      r7,r1                 ;885
000034  4626              MOV      r6,r4                 ;886
000036  1c7f              ADDS     r7,r7,#1              ;887
000038  1c76              ADDS     r6,r6,#1              ;888
00003a  f04f0800          MOV      r8,#0                 ;889
00003e  e005              B        |L12.76|
                  |L12.64|
000040  1c49              ADDS     r1,r1,#1              ;896
000042  1c64              ADDS     r4,r4,#1              ;897
000044  1c7f              ADDS     r7,r7,#1              ;898
000046  1c76              ADDS     r6,r6,#1              ;899
000048  f1080801          ADD      r8,r8,#1              ;900
                  |L12.76|
00004c  7808              LDRB     r0,[r1,#0]            ;891
00004e  f8949000          LDRB     r9,[r4,#0]            ;891
000052  4548              CMP      r0,r9                 ;891
000054  d105              BNE      |L12.98|
000056  7808              LDRB     r0,[r1,#0]            ;892
000058  b118              CBZ      r0,|L12.98|
00005a  b117              CBZ      r7,|L12.98|
00005c  b10e              CBZ      r6,|L12.98|
00005e  45e0              CMP      r8,r12                ;895
000060  d3ee              BCC      |L12.64|
                  |L12.98|
000062  45e0              CMP      r8,r12                ;904
000064  d101              BNE      |L12.106|
000066  2000              MOVS     r0,#0                 ;905
000068  e7d3              B        |L12.18|
                  |L12.106|
00006a  7808              LDRB     r0,[r1,#0]            ;908
00006c  f8949000          LDRB     r9,[r4,#0]            ;908
000070  4548              CMP      r0,r9                 ;908
000072  d005              BEQ      |L12.128|
000074  7808              LDRB     r0,[r1,#0]            ;910
000076  f8949000          LDRB     r9,[r4,#0]            ;910
00007a  eba00209          SUB      r2,r0,r9              ;910
00007e  e00b              B        |L12.152|
                  |L12.128|
000080  7808              LDRB     r0,[r1,#0]            ;912
000082  b908              CBNZ     r0,|L12.136|
000084  2200              MOVS     r2,#0                 ;913
000086  e007              B        |L12.152|
                  |L12.136|
000088  b92f              CBNZ     r7,|L12.150|
00008a  b90e              CBNZ     r6,|L12.144|
00008c  2200              MOVS     r2,#0                 ;918
00008e  e003              B        |L12.152|
                  |L12.144|
000090  7830              LDRB     r0,[r6,#0]            ;921
000092  4242              RSBS     r2,r0,#0              ;921
000094  e000              B        |L12.152|
                  |L12.150|
000096  783a              LDRB     r2,[r7,#0]            ;924
                  |L12.152|
000098  4610              MOV      r0,r2                 ;929
00009a  e7ba              B        |L12.18|
;;;931    
                          ENDP


                          AREA ||i.Str_Copy||, CODE, READONLY, ALIGN=1

                  Str_Copy PROC
;;;349    
;;;350    CPU_CHAR  *Str_Copy (       CPU_CHAR  *pstr_dest,
000000  b570              PUSH     {r4-r6,lr}
;;;351                         const  CPU_CHAR  *pstr_src)
;;;352    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;353        CPU_CHAR  *pstr_rtn;
;;;354    
;;;355    
;;;356        pstr_rtn = Str_Copy_N(pstr_dest,
000006  f04f32ff          MOV      r2,#0xffffffff
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       Str_Copy_N
000012  4606              MOV      r6,r0
;;;357                              pstr_src,
;;;358                              DEF_INT_CPU_U_MAX_VAL);
;;;359    
;;;360        return (pstr_rtn);
000014  4630              MOV      r0,r6
;;;361    }
000016  bd70              POP      {r4-r6,pc}
;;;362    
                          ENDP


                          AREA ||i.Str_Copy_N||, CODE, READONLY, ALIGN=1

                  Str_Copy_N PROC
;;;439    
;;;440    CPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
000000  b570              PUSH     {r4-r6,lr}
;;;441                           const  CPU_CHAR    *pstr_src,
;;;442                                  CPU_SIZE_T   len_max)
;;;443    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;444               CPU_CHAR    *pstr_copy_dest;
;;;445        const  CPU_CHAR    *pstr_copy_src;
;;;446               CPU_SIZE_T   len_copy;
;;;447    
;;;448                                                                    /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
;;;449        if (pstr_dest == (CPU_CHAR *)0) {
000008  b90c              CBNZ     r4,|L14.14|
;;;450            return ((CPU_CHAR *)0);
00000a  2000              MOVS     r0,#0
                  |L14.12|
;;;451        }
;;;452        if (pstr_src  == (const CPU_CHAR *)0) {
;;;453            return ((CPU_CHAR *)0);
;;;454        }
;;;455    
;;;456    
;;;457        pstr_copy_dest = pstr_dest;
;;;458        pstr_copy_src  = pstr_src;
;;;459        len_copy       = 0u;
;;;460    
;;;461        while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
;;;462               ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
;;;463               (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
;;;464               ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
;;;465           *pstr_copy_dest = *pstr_copy_src;
;;;466            pstr_copy_dest++;
;;;467            pstr_copy_src++;
;;;468            len_copy++;
;;;469        }
;;;470                                                                    /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
;;;471        if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
;;;472            (pstr_copy_src  == (const CPU_CHAR *)0)) {
;;;473             return ((CPU_CHAR *)0);
;;;474        }
;;;475    
;;;476        if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
;;;477           *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
;;;478        }
;;;479    
;;;480    
;;;481        return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
;;;482    }
00000c  bd70              POP      {r4-r6,pc}
                  |L14.14|
00000e  b90d              CBNZ     r5,|L14.20|
000010  2000              MOVS     r0,#0                 ;453
000012  e7fb              B        |L14.12|
                  |L14.20|
000014  4621              MOV      r1,r4                 ;457
000016  462a              MOV      r2,r5                 ;458
000018  2300              MOVS     r3,#0                 ;459
00001a  e004              B        |L14.38|
                  |L14.28|
00001c  7810              LDRB     r0,[r2,#0]            ;465
00001e  7008              STRB     r0,[r1,#0]            ;465
000020  1c49              ADDS     r1,r1,#1              ;466
000022  1c52              ADDS     r2,r2,#1              ;467
000024  1c5b              ADDS     r3,r3,#1              ;468
                  |L14.38|
000026  b121              CBZ      r1,|L14.50|
000028  b11a              CBZ      r2,|L14.50|
00002a  7810              LDRB     r0,[r2,#0]            ;463
00002c  b108              CBZ      r0,|L14.50|
00002e  42b3              CMP      r3,r6                 ;464
000030  d3f4              BCC      |L14.28|
                  |L14.50|
000032  b101              CBZ      r1,|L14.54|
000034  b90a              CBNZ     r2,|L14.58|
                  |L14.54|
000036  2000              MOVS     r0,#0                 ;473
000038  e7e8              B        |L14.12|
                  |L14.58|
00003a  42b3              CMP      r3,r6                 ;476
00003c  d201              BCS      |L14.66|
00003e  2000              MOVS     r0,#0                 ;477
000040  7008              STRB     r0,[r1,#0]            ;477
                  |L14.66|
000042  4620              MOV      r0,r4                 ;481
000044  e7e2              B        |L14.12|
;;;483    
                          ENDP


                          AREA ||i.Str_FmtNbr_Int32||, CODE, READONLY, ALIGN=1

                  Str_FmtNbr_Int32 PROC
;;;3446   
;;;3447   static  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;3448                                        CPU_INT08U    nbr_dig,
;;;3449                                        CPU_INT08U    nbr_base,
;;;3450                                        CPU_BOOLEAN   nbr_neg,
;;;3451                                        CPU_CHAR      lead_char,
;;;3452                                        CPU_BOOLEAN   lower_case,
;;;3453                                        CPU_BOOLEAN   nul,
;;;3454                                        CPU_CHAR     *pstr)
;;;3455   {
000004  b08d              SUB      sp,sp,#0x34
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  9e1a              LDR      r6,[sp,#0x68]
;;;3456       CPU_CHAR     *pstr_fmt;
;;;3457       CPU_DATA      i;
;;;3458       CPU_INT32U    nbr_fmt = 0;
00000c  2000              MOVS     r0,#0
00000e  900c              STR      r0,[sp,#0x30]
;;;3459       CPU_INT32U    nbr_log;
;;;3460       CPU_INT08U    nbr_dig_max;
;;;3461       CPU_INT08U    nbr_dig_min;
;;;3462       CPU_INT08U    nbr_dig_fmtd;
;;;3463       CPU_INT08U    nbr_neg_sign;
;;;3464       CPU_INT08U    nbr_lead_char;
;;;3465       CPU_INT08U    dig_val;
;;;3466       CPU_INT08U    lead_char_delta_0;
;;;3467       CPU_INT08U    lead_char_delta_a;
;;;3468       CPU_BOOLEAN   lead_char_dig;
;;;3469       CPU_BOOLEAN   lead_char_0;
;;;3470       CPU_BOOLEAN   fmt_invalid;
;;;3471       CPU_BOOLEAN   print_char;
;;;3472       CPU_BOOLEAN   nbr_neg_fmtd;
;;;3473   
;;;3474   
;;;3475                                                                   /* ---------------- VALIDATE FMT ARGS ----------------- */
;;;3476       if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
000010  981d              LDR      r0,[sp,#0x74]
000012  b918              CBNZ     r0,|L15.28|
;;;3477           return ((CPU_CHAR *)0);
000014  2000              MOVS     r0,#0
                  |L15.22|
;;;3478       }
;;;3479   
;;;3480       fmt_invalid = DEF_NO;
;;;3481   
;;;3482       if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
;;;3483           fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
;;;3484       }
;;;3485                                                                   /* If invalid base, ...                                 */
;;;3486       if ((nbr_base <  2u) ||
;;;3487           (nbr_base > 36u)) {
;;;3488           fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
;;;3489       }
;;;3490   
;;;3491       if (lead_char != (CPU_CHAR)'\0') {
;;;3492           print_char =  ASCII_IsPrint(lead_char);
;;;3493           if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
;;;3494               fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */
;;;3495   
;;;3496           } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
;;;3497               lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
;;;3498               if (lower_case != DEF_YES) {
;;;3499                   lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
;;;3500               } else {
;;;3501                   lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
;;;3502               }
;;;3503   
;;;3504               lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
;;;3505                                ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
;;;3506                                                       (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
;;;3507   
;;;3508               if (lead_char_dig == DEF_YES) {                     /* If lead char non-0 nbr base dig (see Note #3a2A), ...*/
;;;3509                   fmt_invalid = DEF_YES;                          /* ... fmt invalid str             (see Note #6e).      */
;;;3510               }
;;;3511           }
;;;3512       }
;;;3513   
;;;3514   
;;;3515                                                                   /* ----------------- PREPARE NBR FMT ------------------ */
;;;3516       pstr_fmt    = pstr;
;;;3517       lead_char_0 = DEF_NO;
;;;3518   
;;;3519       if (fmt_invalid == DEF_NO) {
;;;3520           nbr_fmt     = nbr;
;;;3521           nbr_log     = nbr;
;;;3522           nbr_dig_max = 1u;
;;;3523           while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
;;;3524               nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
;;;3525               nbr_log /= nbr_base;
;;;3526           }
;;;3527   
;;;3528           nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
;;;3529           if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
;;;3530               nbr_neg_fmtd = DEF_NO;
;;;3531               nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
;;;3532                                                                   /* ... calc nbr digs to fmt & nbr lead chars.           */
;;;3533               if (lead_char != (CPU_CHAR)'\0') {
;;;3534                   nbr_dig_fmtd  = nbr_dig;
;;;3535                   nbr_lead_char = nbr_dig     -
;;;3536                                   nbr_dig_min - nbr_neg_sign;
;;;3537               } else {
;;;3538                   nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
;;;3539                   nbr_lead_char = 0u;
;;;3540               }
;;;3541   
;;;3542               if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
;;;3543                   lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
;;;3544                               ?  DEF_YES : DEF_NO;
;;;3545               }
;;;3546   
;;;3547           } else {                                                /* Else if nbr trunc'd, ...                             */
;;;3548               fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
;;;3549           }
;;;3550       }
;;;3551   
;;;3552       if (fmt_invalid != DEF_NO) {
;;;3553           nbr_dig_fmtd = nbr_dig;
;;;3554       }
;;;3555   
;;;3556   
;;;3557                                                                   /* ------------------- FMT NBR STR -------------------- */
;;;3558       pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
;;;3559   
;;;3560       if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
;;;3561          *pstr_fmt = (CPU_CHAR)'\0';
;;;3562       }
;;;3563       pstr_fmt--;
;;;3564   
;;;3565   
;;;3566       for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
;;;3567           if (fmt_invalid == DEF_NO) {
;;;3568               if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
;;;3569                   (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
;;;3570                                                                   /* ... calc & fmt dig val;                      ...     */
;;;3571                   dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
;;;3572                   if (dig_val < 10u) {
;;;3573                      *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
;;;3574                   } else {
;;;3575                       if (lower_case !=  DEF_YES) {
;;;3576                          *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
;;;3577                       } else {
;;;3578                          *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
;;;3579                       }
;;;3580                   }
;;;3581   
;;;3582                   nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
;;;3583   
;;;3584               } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
;;;3585                        (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
;;;3586                          (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
;;;3587                         ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
;;;3588                          (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */
;;;3589   
;;;3590                  *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
;;;3591                   nbr_neg_fmtd = DEF_YES;
;;;3592   
;;;3593               } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
;;;3594                  *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
;;;3595               }
;;;3596   
;;;3597           } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
;;;3598              *pstr_fmt-- = '?';
;;;3599           }
;;;3600       }
;;;3601   
;;;3602   
;;;3603       if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
;;;3604           return ((CPU_CHAR *)0);
;;;3605       }
;;;3606   
;;;3607   
;;;3608       return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
;;;3609   }
000016  b011              ADD      sp,sp,#0x44
000018  e8bd8ff0          POP      {r4-r11,pc}
                  |L15.28|
00001c  f04f0b00          MOV      r11,#0                ;3480
000020  2f01              CMP      r7,#1                 ;3482
000022  da01              BGE      |L15.40|
000024  f04f0b01          MOV      r11,#1                ;3483
                  |L15.40|
000028  2d02              CMP      r5,#2                 ;3486
00002a  d301              BCC      |L15.48|
00002c  2d24              CMP      r5,#0x24              ;3487
00002e  d901              BLS      |L15.52|
                  |L15.48|
000030  f04f0b01          MOV      r11,#1                ;3488
                  |L15.52|
000034  b396              CBZ      r6,|L15.156|
000036  4630              MOV      r0,r6                 ;3492
000038  f7fffffe          BL       ASCII_IsPrint
00003c  9002              STR      r0,[sp,#8]            ;3492
00003e  9802              LDR      r0,[sp,#8]            ;3493
000040  2801              CMP      r0,#1                 ;3493
000042  d002              BEQ      |L15.74|
000044  f04f0b01          MOV      r11,#1                ;3494
000048  e028              B        |L15.156|
                  |L15.74|
00004a  2e30              CMP      r6,#0x30              ;3496
00004c  d026              BEQ      |L15.156|
00004e  f1a60030          SUB      r0,r6,#0x30           ;3497
000052  b2c0              UXTB     r0,r0                 ;3497
000054  9006              STR      r0,[sp,#0x18]         ;3497
000056  981b              LDR      r0,[sp,#0x6c]         ;3498
000058  2801              CMP      r0,#1                 ;3498
00005a  d004              BEQ      |L15.102|
00005c  f1a60041          SUB      r0,r6,#0x41           ;3499
000060  b2c0              UXTB     r0,r0                 ;3499
000062  9005              STR      r0,[sp,#0x14]         ;3499
000064  e003              B        |L15.110|
                  |L15.102|
000066  f1a60061          SUB      r0,r6,#0x61           ;3501
00006a  b2c0              UXTB     r0,r0                 ;3501
00006c  9005              STR      r0,[sp,#0x14]         ;3501
                  |L15.110|
00006e  2d0a              CMP      r5,#0xa               ;3504
000070  d802              BHI      |L15.120|
000072  9806              LDR      r0,[sp,#0x18]         ;3504
000074  42a8              CMP      r0,r5                 ;3504
000076  db09              BLT      |L15.140|
                  |L15.120|
000078  2d0a              CMP      r5,#0xa               ;3505
00007a  d909              BLS      |L15.144|
00007c  9806              LDR      r0,[sp,#0x18]         ;3505
00007e  280a              CMP      r0,#0xa               ;3505
000080  d304              BCC      |L15.140|
000082  f1a5000a          SUB      r0,r5,#0xa            ;3506
000086  9905              LDR      r1,[sp,#0x14]         ;3506
000088  4288              CMP      r0,r1                 ;3506
00008a  d901              BLS      |L15.144|
                  |L15.140|
00008c  2001              MOVS     r0,#1                 ;3506
00008e  e000              B        |L15.146|
                  |L15.144|
000090  2000              MOVS     r0,#0                 ;3506
                  |L15.146|
000092  9004              STR      r0,[sp,#0x10]         ;3506
000094  9804              LDR      r0,[sp,#0x10]         ;3508
000096  2801              CMP      r0,#1                 ;3508
000098  d100              BNE      |L15.156|
00009a  4683              MOV      r11,r0                ;3509
                  |L15.156|
00009c  9c1d              LDR      r4,[sp,#0x74]         ;3516
00009e  2000              MOVS     r0,#0                 ;3517
0000a0  9003              STR      r0,[sp,#0xc]          ;3517
0000a2  f1bb0f00          CMP      r11,#0                ;3519
0000a6  d141              BNE      |L15.300|
0000a8  980d              LDR      r0,[sp,#0x34]         ;3520
0000aa  900c              STR      r0,[sp,#0x30]         ;3520
0000ac  980d              LDR      r0,[sp,#0x34]         ;3521
0000ae  900b              STR      r0,[sp,#0x2c]         ;3521
0000b0  2001              MOVS     r0,#1                 ;3522
0000b2  900a              STR      r0,[sp,#0x28]         ;3522
0000b4  e007              B        |L15.198|
                  |L15.182|
0000b6  980a              LDR      r0,[sp,#0x28]         ;3524
0000b8  1c40              ADDS     r0,r0,#1              ;3524
0000ba  b2c0              UXTB     r0,r0                 ;3524
0000bc  900a              STR      r0,[sp,#0x28]         ;3524
0000be  980b              LDR      r0,[sp,#0x2c]         ;3525
0000c0  fbb0f0f5          UDIV     r0,r0,r5              ;3525
0000c4  900b              STR      r0,[sp,#0x2c]         ;3525
                  |L15.198|
0000c6  980b              LDR      r0,[sp,#0x2c]         ;3523
0000c8  42a8              CMP      r0,r5                 ;3523
0000ca  d2f4              BCS      |L15.182|
0000cc  9810              LDR      r0,[sp,#0x40]         ;3528
0000ce  2801              CMP      r0,#1                 ;3528
0000d0  d100              BNE      |L15.212|
0000d2  e000              B        |L15.214|
                  |L15.212|
0000d4  2000              MOVS     r0,#0                 ;3528
                  |L15.214|
0000d6  9008              STR      r0,[sp,#0x20]         ;3528
0000d8  990a              LDR      r1,[sp,#0x28]         ;3529
0000da  9808              LDR      r0,[sp,#0x20]         ;3529
0000dc  4408              ADD      r0,r0,r1              ;3529
0000de  42b8              CMP      r0,r7                 ;3529
0000e0  dc22              BGT      |L15.296|
0000e2  2000              MOVS     r0,#0                 ;3530
0000e4  9001              STR      r0,[sp,#4]            ;3530
0000e6  980a              LDR      r0,[sp,#0x28]         ;3531
0000e8  42b8              CMP      r0,r7                 ;3531
0000ea  da01              BGE      |L15.240|
0000ec  980a              LDR      r0,[sp,#0x28]         ;3531
0000ee  e000              B        |L15.242|
                  |L15.240|
0000f0  4638              MOV      r0,r7                 ;3531
                  |L15.242|
0000f2  9009              STR      r0,[sp,#0x24]         ;3531
0000f4  b13e              CBZ      r6,|L15.262|
0000f6  46b8              MOV      r8,r7                 ;3534
0000f8  9809              LDR      r0,[sp,#0x24]         ;3535
0000fa  1a39              SUBS     r1,r7,r0              ;3535
0000fc  9808              LDR      r0,[sp,#0x20]         ;3535
0000fe  1a08              SUBS     r0,r1,r0              ;3535
000100  b2c0              UXTB     r0,r0                 ;3535
000102  9007              STR      r0,[sp,#0x1c]         ;3535
000104  e006              B        |L15.276|
                  |L15.262|
000106  e9dd1008          LDRD     r1,r0,[sp,#0x20]      ;3538
00010a  4408              ADD      r0,r0,r1              ;3538
00010c  f00008ff          AND      r8,r0,#0xff           ;3538
000110  2000              MOVS     r0,#0                 ;3539
000112  9007              STR      r0,[sp,#0x1c]         ;3539
                  |L15.276|
000114  9807              LDR      r0,[sp,#0x1c]         ;3542
000116  2800              CMP      r0,#0                 ;3542
000118  dd08              BLE      |L15.300|
00011a  2e30              CMP      r6,#0x30              ;3543
00011c  d101              BNE      |L15.290|
00011e  2001              MOVS     r0,#1                 ;3544
000120  e000              B        |L15.292|
                  |L15.290|
000122  2000              MOVS     r0,#0                 ;3544
                  |L15.292|
000124  9003              STR      r0,[sp,#0xc]          ;3544
000126  e001              B        |L15.300|
                  |L15.296|
000128  f04f0b01          MOV      r11,#1                ;3548
                  |L15.300|
00012c  f1bb0f00          CMP      r11,#0                ;3552
000130  d000              BEQ      |L15.308|
000132  46b8              MOV      r8,r7                 ;3553
                  |L15.308|
000134  4444              ADD      r4,r4,r8              ;3558
000136  981c              LDR      r0,[sp,#0x70]         ;3560
000138  b108              CBZ      r0,|L15.318|
00013a  2000              MOVS     r0,#0                 ;3561
00013c  7020              STRB     r0,[r4,#0]            ;3561
                  |L15.318|
00013e  1e64              SUBS     r4,r4,#1              ;3563
000140  f04f0900          MOV      r9,#0                 ;3566
000144  e043              B        |L15.462|
                  |L15.326|
000146  f1bb0f00          CMP      r11,#0                ;3567
00014a  d13b              BNE      |L15.452|
00014c  980c              LDR      r0,[sp,#0x30]         ;3568
00014e  b910              CBNZ     r0,|L15.342|
000150  f1b90f00          CMP      r9,#0                 ;3569
000154  d11f              BNE      |L15.406|
                  |L15.342|
000156  980c              LDR      r0,[sp,#0x30]         ;3571
000158  fbb0f1f5          UDIV     r1,r0,r5              ;3571
00015c  fb050011          MLS      r0,r5,r1,r0           ;3571
000160  f0000aff          AND      r10,r0,#0xff          ;3571
000164  f1ba0f0a          CMP      r10,#0xa              ;3572
000168  d204              BCS      |L15.372|
00016a  f10a0030          ADD      r0,r10,#0x30          ;3573
00016e  f8040901          STRB     r0,[r4],#-1           ;3573
000172  e00b              B        |L15.396|
                  |L15.372|
000174  981b              LDR      r0,[sp,#0x6c]         ;3575
000176  2801              CMP      r0,#1                 ;3575
000178  d004              BEQ      |L15.388|
00017a  f10a0037          ADD      r0,r10,#0x37          ;3576
00017e  f8040901          STRB     r0,[r4],#-1           ;3576
000182  e003              B        |L15.396|
                  |L15.388|
000184  f10a0057          ADD      r0,r10,#0x57          ;3578
000188  f8040901          STRB     r0,[r4],#-1           ;3578
                  |L15.396|
00018c  980c              LDR      r0,[sp,#0x30]         ;3582
00018e  fbb0f0f5          UDIV     r0,r0,r5              ;3582
000192  900c              STR      r0,[sp,#0x30]         ;3582
000194  e019              B        |L15.458|
                  |L15.406|
000196  9810              LDR      r0,[sp,#0x40]         ;3584
000198  2801              CMP      r0,#1                 ;3584
00019a  d10f              BNE      |L15.444|
00019c  9803              LDR      r0,[sp,#0xc]          ;3585
00019e  b908              CBNZ     r0,|L15.420|
0001a0  9801              LDR      r0,[sp,#4]            ;3586
0001a2  b128              CBZ      r0,|L15.432|
                  |L15.420|
0001a4  9803              LDR      r0,[sp,#0xc]          ;3587
0001a6  b148              CBZ      r0,|L15.444|
0001a8  f1a80001          SUB      r0,r8,#1              ;3588
0001ac  4548              CMP      r0,r9                 ;3588
0001ae  d105              BNE      |L15.444|
                  |L15.432|
0001b0  202d              MOVS     r0,#0x2d              ;3590
0001b2  f8040901          STRB     r0,[r4],#-1           ;3590
0001b6  2001              MOVS     r0,#1                 ;3591
0001b8  9001              STR      r0,[sp,#4]            ;3591
0001ba  e006              B        |L15.458|
                  |L15.444|
0001bc  b12e              CBZ      r6,|L15.458|
0001be  f8046901          STRB     r6,[r4],#-1           ;3594
0001c2  e002              B        |L15.458|
                  |L15.452|
0001c4  203f              MOVS     r0,#0x3f              ;3598
0001c6  f8040901          STRB     r0,[r4],#-1           ;3598
                  |L15.458|
0001ca  f1090901          ADD      r9,r9,#1              ;3566
                  |L15.462|
0001ce  45c1              CMP      r9,r8                 ;3566
0001d0  d3b9              BCC      |L15.326|
0001d2  f1bb0f00          CMP      r11,#0                ;3603
0001d6  d001              BEQ      |L15.476|
0001d8  2000              MOVS     r0,#0                 ;3604
0001da  e71c              B        |L15.22|
                  |L15.476|
0001dc  981d              LDR      r0,[sp,#0x74]         ;3608
0001de  e71a              B        |L15.22|
;;;3610   
                          ENDP


                          AREA ||i.Str_FmtNbr_Int32S||, CODE, READONLY, ALIGN=1

                  Str_FmtNbr_Int32S PROC
;;;2257   
;;;2258   CPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2259                                 CPU_INT08U    nbr_dig,
;;;2260                                 CPU_INT08U    nbr_base,
;;;2261                                 CPU_CHAR      lead_char,
;;;2262                                 CPU_BOOLEAN   lower_case,
;;;2263                                 CPU_BOOLEAN   nul,
;;;2264                                 CPU_CHAR     *pstr)
;;;2265   {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4689              MOV      r9,r1
00000a  461f              MOV      r7,r3
00000c  e9ddab13          LDRD     r10,r11,[sp,#0x4c]
;;;2266       CPU_CHAR     *pstr_fmt;
;;;2267       CPU_INT32S    nbr_fmt;
;;;2268       CPU_BOOLEAN   nbr_neg;
;;;2269   
;;;2270   
;;;2271       if (nbr < 0) {                                              /* If nbr neg, ...                                      */
000010  2c00              CMP      r4,#0
000012  da02              BGE      |L16.26|
;;;2272           nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
000014  4265              RSBS     r5,r4,#0
;;;2273           nbr_neg =  DEF_YES;
000016  2601              MOVS     r6,#1
000018  e001              B        |L16.30|
                  |L16.26|
;;;2274       } else {
;;;2275           nbr_fmt =  nbr;
00001a  4625              MOV      r5,r4
;;;2276           nbr_neg =  DEF_NO;
00001c  2600              MOVS     r6,#0
                  |L16.30|
;;;2277       }
;;;2278   
;;;2279       pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
00001e  9812              LDR      r0,[sp,#0x48]
000020  4633              MOV      r3,r6
000022  e9cdab02          STRD     r10,r11,[sp,#8]
000026  e9cd7000          STRD     r7,r0,[sp,#0]
00002a  4649              MOV      r1,r9
00002c  4628              MOV      r0,r5
00002e  9a07              LDR      r2,[sp,#0x1c]
000030  f7fffffe          BL       Str_FmtNbr_Int32
000034  4680              MOV      r8,r0
;;;2280                                               nbr_dig,
;;;2281                                               nbr_base,
;;;2282                                               nbr_neg,
;;;2283                                               lead_char,
;;;2284                                               lower_case,
;;;2285                                               nul,
;;;2286                                               pstr);
;;;2287   
;;;2288       return (pstr_fmt);
000036  4640              MOV      r0,r8
;;;2289   }
000038  b009              ADD      sp,sp,#0x24
00003a  e8bd8ff0          POP      {r4-r11,pc}
;;;2290   
                          ENDP


                          AREA ||i.Str_FmtNbr_Int32U||, CODE, READONLY, ALIGN=1

                  Str_FmtNbr_Int32U PROC
;;;2041   
;;;2042   CPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;2043                                 CPU_INT08U    nbr_dig,
;;;2044                                 CPU_INT08U    nbr_base,
;;;2045                                 CPU_CHAR      lead_char,
;;;2046                                 CPU_BOOLEAN   lower_case,
;;;2047                                 CPU_BOOLEAN   nul,
;;;2048                                 CPU_CHAR     *pstr)
;;;2049   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
00000c  e9dd9a0f          LDRD     r9,r10,[sp,#0x3c]
000010  f8dd8038          LDR      r8,[sp,#0x38]
;;;2050       CPU_CHAR  *pstr_fmt;
;;;2051   
;;;2052   
;;;2053       pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
000014  2300              MOVS     r3,#0
000016  463a              MOV      r2,r7
000018  4631              MOV      r1,r6
00001a  4628              MOV      r0,r5
00001c  e88d0710          STM      sp,{r4,r8-r10}
000020  f7fffffe          BL       Str_FmtNbr_Int32
000024  4683              MOV      r11,r0
;;;2054                                   nbr_dig,
;;;2055                                   nbr_base,
;;;2056                                   DEF_NO,
;;;2057                                   lead_char,
;;;2058                                   lower_case,
;;;2059                                   nul,
;;;2060                                   pstr);
;;;2061   
;;;2062       return (pstr_fmt);
000026  4658              MOV      r0,r11
;;;2063   }
000028  b004              ADD      sp,sp,#0x10
00002a  e8bd9ff0          POP      {r4-r12,pc}
;;;2064   
                          ENDP


                          AREA ||i.Str_Len||, CODE, READONLY, ALIGN=1

                  Str_Len PROC
;;;218    
;;;219    CPU_SIZE_T  Str_Len (const  CPU_CHAR  *pstr)
000000  b530              PUSH     {r4,r5,lr}
;;;220    {
000002  4604              MOV      r4,r0
;;;221        CPU_SIZE_T  len;
;;;222    
;;;223    
;;;224        len = Str_Len_N(pstr,
000004  f04f31ff          MOV      r1,#0xffffffff
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       Str_Len_N
00000e  4605              MOV      r5,r0
;;;225                        DEF_INT_CPU_U_MAX_VAL);
;;;226    
;;;227        return (len);
000010  4628              MOV      r0,r5
;;;228    }
000012  bd30              POP      {r4,r5,pc}
;;;229    
                          ENDP


                          AREA ||i.Str_Len_N||, CODE, READONLY, ALIGN=1

                  Str_Len_N PROC
;;;277    
;;;278    CPU_SIZE_T  Str_Len_N (const  CPU_CHAR    *pstr,
000000  b510              PUSH     {r4,lr}
;;;279                                  CPU_SIZE_T   len_max)
;;;280    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;281        const  CPU_CHAR    *pstr_len;
;;;282               CPU_SIZE_T   len;
;;;283    
;;;284    
;;;285        pstr_len = pstr;
000006  4611              MOV      r1,r2
;;;286        len      = 0u;
000008  2000              MOVS     r0,#0
;;;287        while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
00000a  e001              B        |L19.16|
                  |L19.12|
;;;288               (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
;;;289               ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
;;;290            pstr_len++;
00000c  1c49              ADDS     r1,r1,#1
;;;291            len++;
00000e  1c40              ADDS     r0,r0,#1
                  |L19.16|
000010  b119              CBZ      r1,|L19.26|
000012  780c              LDRB     r4,[r1,#0]            ;288
000014  b10c              CBZ      r4,|L19.26|
000016  4298              CMP      r0,r3                 ;289
000018  d3f8              BCC      |L19.12|
                  |L19.26|
;;;292        }
;;;293    
;;;294        return (len);                                               /* Rtn str len (see Note #3b1).                         */
;;;295    }
00001a  bd10              POP      {r4,pc}
;;;296    
                          ENDP


                          AREA ||i.Str_ParseNbr_Int32||, CODE, READONLY, ALIGN=2

                  Str_ParseNbr_Int32 PROC
;;;3837   
;;;3838   static  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;3839                                                  CPU_CHAR     **pstr_next,
;;;3840                                                  CPU_INT08U     nbr_base,
;;;3841                                                  CPU_BOOLEAN    nbr_signed,
;;;3842                                                  CPU_BOOLEAN   *pnbr_neg)
;;;3843   {
000004  b08b              SUB      sp,sp,#0x2c
000006  4606              MOV      r6,r0
000008  4689              MOV      r9,r1
00000a  4615              MOV      r5,r2
;;;3844       const  CPU_CHAR     *pstr_parse;
;;;3845       const  CPU_CHAR     *pstr_parse_nbr;
;;;3846              CPU_CHAR     *pstr_parse_unused;
;;;3847              CPU_CHAR      parse_char;
;;;3848              CPU_INT08U    parse_dig;
;;;3849              CPU_INT32U    nbr;
;;;3850              CPU_BOOLEAN   nbr_neg_unused;
;;;3851              CPU_BOOLEAN   nbr_dig;
;;;3852              CPU_BOOLEAN   nbr_alpha;
;;;3853              CPU_BOOLEAN   nbr_hex;
;;;3854              CPU_BOOLEAN   nbr_hex_lower;
;;;3855              CPU_BOOLEAN   whitespace;
;;;3856              CPU_BOOLEAN   neg;
;;;3857              CPU_BOOLEAN   ovf;
;;;3858              CPU_BOOLEAN   done;
;;;3859   
;;;3860                                                                   /* --------------- VALIDATE PARSE ARGS ---------------- */
;;;3861       if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
00000c  f1b90f00          CMP      r9,#0
000010  d102              BNE      |L20.24|
;;;3862           pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
000012  f10d0924          ADD      r9,sp,#0x24
;;;3863          (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
000016  bf00              NOP      
                  |L20.24|
;;;3864       }
;;;3865      *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
000018  f8c96000          STR      r6,[r9,#0]
;;;3866   
;;;3867       if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
00001c  9818              LDR      r0,[sp,#0x60]
00001e  b910              CBNZ     r0,|L20.38|
;;;3868           pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
000020  a807              ADD      r0,sp,#0x1c
000022  9018              STR      r0,[sp,#0x60]
;;;3869          (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
000024  bf00              NOP      
                  |L20.38|
;;;3870       }
;;;3871      *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
000026  2100              MOVS     r1,#0
000028  9818              LDR      r0,[sp,#0x60]
00002a  7001              STRB     r1,[r0,#0]
;;;3872   
;;;3873   
;;;3874       if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
00002c  b91e              CBNZ     r6,|L20.54|
;;;3875           return (0u);
00002e  2000              MOVS     r0,#0
                  |L20.48|
;;;3876       }
;;;3877                                                                   /* Rtn zero if invalid base (see Note #4a).             */
;;;3878       if ((nbr_base == 1u) ||
;;;3879           (nbr_base > 36u)) {
;;;3880           return (0u);
;;;3881       }
;;;3882   
;;;3883   
;;;3884                                                                   /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
;;;3885       pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
;;;3886   
;;;3887       whitespace = ASCII_IsSpace(*pstr_parse);
;;;3888       while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
;;;3889           pstr_parse++;
;;;3890           whitespace = ASCII_IsSpace(*pstr_parse);
;;;3891       }
;;;3892   
;;;3893       switch (*pstr_parse) {
;;;3894           case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
;;;3895                pstr_parse++;
;;;3896                neg = DEF_NO;
;;;3897                break;
;;;3898   
;;;3899   
;;;3900           case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
;;;3901                if (nbr_signed == DEF_YES) {
;;;3902                    pstr_parse++;
;;;3903                }
;;;3904                neg = DEF_YES;
;;;3905                break;
;;;3906   
;;;3907   
;;;3908           default:
;;;3909                neg = DEF_NO;
;;;3910                break;
;;;3911       }
;;;3912   
;;;3913   
;;;3914                                                                   /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
;;;3915       pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
;;;3916   
;;;3917       switch (nbr_base) {
;;;3918           case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
;;;3919                if (*pstr_parse == '0') {                          /* If avail, ...                                        */
;;;3920                     pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
;;;3921                     switch (*pstr_parse) {
;;;3922                         case 'x':                                 /* For '0x' prefix, ...                                 */
;;;3923                         case 'X':
;;;3924                              nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
;;;3925                              parse_char = (CPU_CHAR)(*(pstr_parse + 1));
;;;3926                              nbr_hex    =  ASCII_IsDigHex(parse_char);
;;;3927                              if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
;;;3928                                  pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
;;;3929                              }
;;;3930                              break;
;;;3931   
;;;3932   
;;;3933                         default:                                  /* For '0'  prefix, ...                                 */
;;;3934                              nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
;;;3935                              break;
;;;3936                     }
;;;3937   
;;;3938                } else {                                           /* For non-'0' prefix, ...                              */
;;;3939                    nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
;;;3940                }
;;;3941                break;
;;;3942   
;;;3943   
;;;3944           case  8u:                                               /* See Note #2a1B1a2.                                   */
;;;3945                if (*pstr_parse == '0') {                          /* If avail, ...                                        */
;;;3946                     pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
;;;3947                }
;;;3948                break;
;;;3949   
;;;3950   
;;;3951           case 16u:                                               /* See Note #2a1B1a3.                                   */
;;;3952                if (*pstr_parse == '0') {                          /* If avail, ...                                        */
;;;3953                     pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
;;;3954                     switch (*pstr_parse) {
;;;3955                         case 'x':
;;;3956                         case 'X':
;;;3957                              parse_char = (CPU_CHAR)(*(pstr_parse + 1));
;;;3958                              nbr_hex    =  ASCII_IsDigHex(parse_char);
;;;3959                              if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
;;;3960                                  pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
;;;3961                              }
;;;3962                              break;
;;;3963   
;;;3964   
;;;3965                         default:
;;;3966                              break;
;;;3967                     }
;;;3968                }
;;;3969                break;
;;;3970   
;;;3971   
;;;3972           default:                                                /* See Note #2a1B1b.                                    */
;;;3973                break;
;;;3974       }
;;;3975   
;;;3976   
;;;3977                                                                   /* ------------------ PARSE INT STR ------------------- */
;;;3978       nbr  = 0u;
;;;3979       ovf  = DEF_NO;
;;;3980       done = DEF_NO;
;;;3981   
;;;3982       while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
;;;3983           parse_char = (CPU_CHAR)*pstr_parse;
;;;3984           nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
;;;3985           if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
;;;3986                                                                   /* ... convert parse char into nbr dig.                 */
;;;3987               nbr_dig = ASCII_IsDig(parse_char);
;;;3988               if (nbr_dig == DEF_YES) {
;;;3989                   parse_dig = (CPU_INT08U)(parse_char - '0');
;;;3990               } else {
;;;3991                   nbr_hex_lower = ASCII_IsLower(parse_char);
;;;3992                   if (nbr_hex_lower == DEF_YES) {
;;;3993                       parse_dig = (CPU_INT08U)((parse_char - 'a') + 10u);
;;;3994                   } else {
;;;3995                       parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
;;;3996                   }
;;;3997               }
;;;3998   
;;;3999               if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
;;;4000                   if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
;;;4001                       if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
;;;4002                                                                   /* ... merge parse char dig into nbr.                   */
;;;4003                           nbr *= nbr_base;
;;;4004                           nbr += parse_dig;
;;;4005                           if (nbr < parse_dig) {
;;;4006                               ovf = DEF_YES;
;;;4007                           }
;;;4008                       } else {
;;;4009                           ovf = DEF_YES;
;;;4010                       }
;;;4011                   }
;;;4012                   pstr_parse++;
;;;4013   
;;;4014               } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
;;;4015                   done = DEF_YES;
;;;4016               }
;;;4017   
;;;4018           } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
;;;4019               done = DEF_YES;
;;;4020           }
;;;4021       }
;;;4022   
;;;4023       if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
;;;4024           nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
;;;4025       }
;;;4026   
;;;4027   
;;;4028       if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
;;;4029          *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
;;;4030       } else {
;;;4031          *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
;;;4032       }
;;;4033   
;;;4034      *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
;;;4035   
;;;4036   
;;;4037       return (nbr);
;;;4038   }
000030  b00f              ADD      sp,sp,#0x3c
000032  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.54|
000036  2d01              CMP      r5,#1                 ;3878
000038  d001              BEQ      |L20.62|
00003a  2d24              CMP      r5,#0x24              ;3879
00003c  d901              BLS      |L20.66|
                  |L20.62|
00003e  2000              MOVS     r0,#0                 ;3880
000040  e7f6              B        |L20.48|
                  |L20.66|
000042  4634              MOV      r4,r6                 ;3885
000044  7820              LDRB     r0,[r4,#0]            ;3887
000046  f7fffffe          BL       ASCII_IsSpace
00004a  9003              STR      r0,[sp,#0xc]          ;3887
00004c  e004              B        |L20.88|
                  |L20.78|
00004e  1c64              ADDS     r4,r4,#1              ;3889
000050  7820              LDRB     r0,[r4,#0]            ;3890
000052  f7fffffe          BL       ASCII_IsSpace
000056  9003              STR      r0,[sp,#0xc]          ;3890
                  |L20.88|
000058  9803              LDR      r0,[sp,#0xc]          ;3888
00005a  2801              CMP      r0,#1                 ;3888
00005c  d0f7              BEQ      |L20.78|
00005e  7820              LDRB     r0,[r4,#0]            ;3893
000060  282b              CMP      r0,#0x2b              ;3893
000062  d002              BEQ      |L20.106|
000064  282d              CMP      r0,#0x2d              ;3893
000066  d10b              BNE      |L20.128|
000068  e003              B        |L20.114|
                  |L20.106|
00006a  1c64              ADDS     r4,r4,#1              ;3895
00006c  f04f0b00          MOV      r11,#0                ;3896
000070  e009              B        |L20.134|
                  |L20.114|
000072  980e              LDR      r0,[sp,#0x38]         ;3901
000074  2801              CMP      r0,#1                 ;3901
000076  d100              BNE      |L20.122|
000078  1c64              ADDS     r4,r4,#1              ;3902
                  |L20.122|
00007a  f04f0b01          MOV      r11,#1                ;3904
00007e  e002              B        |L20.134|
                  |L20.128|
000080  f04f0b00          MOV      r11,#0                ;3909
000084  bf00              NOP                            ;3910
                  |L20.134|
000086  bf00              NOP                            ;3897
000088  940a              STR      r4,[sp,#0x28]         ;3915
00008a  b125              CBZ      r5,|L20.150|
00008c  2d08              CMP      r5,#8                 ;3917
00008e  d01c              BEQ      |L20.202|
000090  2d10              CMP      r5,#0x10              ;3917
000092  d136              BNE      |L20.258|
000094  e01e              B        |L20.212|
                  |L20.150|
000096  7820              LDRB     r0,[r4,#0]            ;3919
000098  2830              CMP      r0,#0x30              ;3919
00009a  d114              BNE      |L20.198|
00009c  1c64              ADDS     r4,r4,#1              ;3920
00009e  7820              LDRB     r0,[r4,#0]            ;3921
0000a0  2858              CMP      r0,#0x58              ;3921
0000a2  d002              BEQ      |L20.170|
0000a4  2878              CMP      r0,#0x78              ;3921
0000a6  d10b              BNE      |L20.192|
0000a8  bf00              NOP                            ;3923
                  |L20.170|
0000aa  2510              MOVS     r5,#0x10              ;3924
0000ac  7867              LDRB     r7,[r4,#1]            ;3925
0000ae  4638              MOV      r0,r7                 ;3926
0000b0  f7fffffe          BL       ASCII_IsDigHex
0000b4  4682              MOV      r10,r0                ;3926
0000b6  f1ba0f01          CMP      r10,#1                ;3927
0000ba  d100              BNE      |L20.190|
0000bc  1c64              ADDS     r4,r4,#1              ;3928
                  |L20.190|
0000be  e001              B        |L20.196|
                  |L20.192|
0000c0  2508              MOVS     r5,#8                 ;3934
0000c2  bf00              NOP                            ;3935
                  |L20.196|
0000c4  e000              B        |L20.200|
                  |L20.198|
0000c6  250a              MOVS     r5,#0xa               ;3939
                  |L20.200|
0000c8  e01c              B        |L20.260|
                  |L20.202|
0000ca  7820              LDRB     r0,[r4,#0]            ;3945
0000cc  2830              CMP      r0,#0x30              ;3945
0000ce  d100              BNE      |L20.210|
0000d0  1c64              ADDS     r4,r4,#1              ;3946
                  |L20.210|
0000d2  e017              B        |L20.260|
                  |L20.212|
0000d4  7820              LDRB     r0,[r4,#0]            ;3952
0000d6  2830              CMP      r0,#0x30              ;3952
0000d8  d112              BNE      |L20.256|
0000da  1c64              ADDS     r4,r4,#1              ;3953
0000dc  7820              LDRB     r0,[r4,#0]            ;3954
0000de  2858              CMP      r0,#0x58              ;3954
0000e0  d002              BEQ      |L20.232|
0000e2  2878              CMP      r0,#0x78              ;3954
0000e4  d10a              BNE      |L20.252|
0000e6  bf00              NOP                            ;3956
                  |L20.232|
0000e8  7867              LDRB     r7,[r4,#1]            ;3957
0000ea  4638              MOV      r0,r7                 ;3958
0000ec  f7fffffe          BL       ASCII_IsDigHex
0000f0  4682              MOV      r10,r0                ;3958
0000f2  f1ba0f01          CMP      r10,#1                ;3959
0000f6  d100              BNE      |L20.250|
0000f8  1c64              ADDS     r4,r4,#1              ;3960
                  |L20.250|
0000fa  e000              B        |L20.254|
                  |L20.252|
0000fc  bf00              NOP                            ;3966
                  |L20.254|
0000fe  bf00              NOP                            ;3962
                  |L20.256|
000100  e000              B        |L20.260|
                  |L20.258|
000102  bf00              NOP                            ;3973
                  |L20.260|
000104  bf00              NOP                            ;3941
000106  f04f0800          MOV      r8,#0                 ;3978
00010a  2000              MOVS     r0,#0                 ;3979
00010c  9002              STR      r0,[sp,#8]            ;3979
00010e  9001              STR      r0,[sp,#4]            ;3980
000110  e040              B        |L20.404|
                  |L20.274|
000112  7827              LDRB     r7,[r4,#0]            ;3983
000114  4638              MOV      r0,r7                 ;3984
000116  f7fffffe          BL       ASCII_IsAlphaNum
00011a  9005              STR      r0,[sp,#0x14]         ;3984
00011c  9805              LDR      r0,[sp,#0x14]         ;3985
00011e  2801              CMP      r0,#1                 ;3985
000120  d136              BNE      |L20.400|
000122  4638              MOV      r0,r7                 ;3987
000124  f7fffffe          BL       ASCII_IsDig
000128  9006              STR      r0,[sp,#0x18]         ;3987
00012a  9806              LDR      r0,[sp,#0x18]         ;3988
00012c  2801              CMP      r0,#1                 ;3988
00012e  d104              BNE      |L20.314|
000130  f1a70030          SUB      r0,r7,#0x30           ;3989
000134  b2c0              UXTB     r0,r0                 ;3989
000136  9008              STR      r0,[sp,#0x20]         ;3989
000138  e00f              B        |L20.346|
                  |L20.314|
00013a  4638              MOV      r0,r7                 ;3991
00013c  f7fffffe          BL       ASCII_IsLower
000140  9004              STR      r0,[sp,#0x10]         ;3991
000142  9804              LDR      r0,[sp,#0x10]         ;3992
000144  2801              CMP      r0,#1                 ;3992
000146  d104              BNE      |L20.338|
000148  f1a70057          SUB      r0,r7,#0x57           ;3993
00014c  b2c0              UXTB     r0,r0                 ;3993
00014e  9008              STR      r0,[sp,#0x20]         ;3993
000150  e003              B        |L20.346|
                  |L20.338|
000152  f1a70037          SUB      r0,r7,#0x37           ;3995
000156  b2c0              UXTB     r0,r0                 ;3995
000158  9008              STR      r0,[sp,#0x20]         ;3995
                  |L20.346|
00015a  9808              LDR      r0,[sp,#0x20]         ;3999
00015c  42a8              CMP      r0,r5                 ;3999
00015e  da14              BGE      |L20.394|
000160  9802              LDR      r0,[sp,#8]            ;4000
000162  b980              CBNZ     r0,|L20.390|
000164  4816              LDR      r0,|L20.448|
000166  f8500025          LDR      r0,[r0,r5,LSL #2]     ;4001
00016a  4540              CMP      r0,r8                 ;4001
00016c  d309              BCC      |L20.386|
00016e  fb08f805          MUL      r8,r8,r5              ;4003
000172  9808              LDR      r0,[sp,#0x20]         ;4004
000174  4480              ADD      r8,r8,r0              ;4004
000176  9808              LDR      r0,[sp,#0x20]         ;4005
000178  4580              CMP      r8,r0                 ;4005
00017a  d204              BCS      |L20.390|
00017c  2001              MOVS     r0,#1                 ;4006
00017e  9002              STR      r0,[sp,#8]            ;4006
000180  e001              B        |L20.390|
                  |L20.386|
000182  2001              MOVS     r0,#1                 ;4009
000184  9002              STR      r0,[sp,#8]            ;4009
                  |L20.390|
000186  1c64              ADDS     r4,r4,#1              ;4012
000188  e004              B        |L20.404|
                  |L20.394|
00018a  2001              MOVS     r0,#1                 ;4015
00018c  9001              STR      r0,[sp,#4]            ;4015
00018e  e001              B        |L20.404|
                  |L20.400|
000190  2001              MOVS     r0,#1                 ;4019
000192  9001              STR      r0,[sp,#4]            ;4019
                  |L20.404|
000194  9801              LDR      r0,[sp,#4]            ;3982
000196  2800              CMP      r0,#0                 ;3982
000198  d0bb              BEQ      |L20.274|
00019a  9802              LDR      r0,[sp,#8]            ;4023
00019c  2801              CMP      r0,#1                 ;4023
00019e  d101              BNE      |L20.420|
0001a0  f04f38ff          MOV      r8,#0xffffffff        ;4024
                  |L20.420|
0001a4  980a              LDR      r0,[sp,#0x28]         ;4028
0001a6  4284              CMP      r4,r0                 ;4028
0001a8  d002              BEQ      |L20.432|
0001aa  f8c94000          STR      r4,[r9,#0]            ;4029
0001ae  e001              B        |L20.436|
                  |L20.432|
0001b0  f8c96000          STR      r6,[r9,#0]            ;4031
                  |L20.436|
0001b4  9818              LDR      r0,[sp,#0x60]         ;4034
0001b6  f880b000          STRB     r11,[r0,#0]           ;4034
0001ba  4640              MOV      r0,r8                 ;4037
0001bc  e738              B        |L20.48|
;;;4039   
                          ENDP

0001be  0000              DCW      0x0000
                  |L20.448|
                          DCD      Str_MultOvfThTbl_Int32U

                          AREA ||i.Str_ParseNbr_Int32S||, CODE, READONLY, ALIGN=1

                  Str_ParseNbr_Int32S PROC
;;;3191   
;;;3192   CPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3193                                           CPU_CHAR    **pstr_next,
;;;3194                                           CPU_INT08U    nbr_base)
;;;3195   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;3196       CPU_INT32S   nbr;
;;;3197       CPU_INT32U   nbr_abs;
;;;3198       CPU_BOOLEAN  nbr_neg;
;;;3199   
;;;3200   
;;;3201       nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
00000a  a801              ADD      r0,sp,#4
00000c  2301              MOVS     r3,#1
00000e  463a              MOV      r2,r7
000010  4631              MOV      r1,r6
000012  9000              STR      r0,[sp,#0]
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       Str_ParseNbr_Int32
00001a  4604              MOV      r4,r0
;;;3202                                    pstr_next,
;;;3203                                    nbr_base,
;;;3204                                    DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
;;;3205                                   &nbr_neg);
;;;3206   
;;;3207       if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
00001c  f89d0004          LDRB     r0,[sp,#4]
000020  b940              CBNZ     r0,|L21.52|
;;;3208           nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
000022  f1b44f00          CMP      r4,#0x80000000
000026  d302              BCC      |L21.46|
000028  f06f4000          MVN      r0,#0x80000000
00002c  e000              B        |L21.48|
                  |L21.46|
;;;3209                                                                       :  (CPU_INT32S)nbr_abs;
00002e  4620              MOV      r0,r4
                  |L21.48|
000030  4680              MOV      r8,r0
000032  e007              B        |L21.68|
                  |L21.52|
;;;3210       } else {
;;;3211           nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
000034  f1b44f00          CMP      r4,#0x80000000
000038  d302              BCC      |L21.64|
00003a  f04f4000          MOV      r0,#0x80000000
00003e  e000              B        |L21.66|
                  |L21.64|
;;;3212                                                                       : -(CPU_INT32S)nbr_abs;
000040  4260              RSBS     r0,r4,#0
                  |L21.66|
000042  4680              MOV      r8,r0
                  |L21.68|
;;;3213       }
;;;3214   
;;;3215       return (nbr);
000044  4640              MOV      r0,r8
;;;3216   }
000046  e8bd81fc          POP      {r2-r8,pc}
;;;3217   
                          ENDP


                          AREA ||i.Str_ParseNbr_Int32U||, CODE, READONLY, ALIGN=1

                  Str_ParseNbr_Int32U PROC
;;;2975   
;;;2976   CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
000000  b5f8              PUSH     {r3-r7,lr}
;;;2977                                           CPU_CHAR    **pstr_next,
;;;2978                                           CPU_INT08U    nbr_base)
;;;2979   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;2980       CPU_INT32U  nbr;
;;;2981   
;;;2982   
;;;2983       nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
000008  2000              MOVS     r0,#0
00000a  4603              MOV      r3,r0
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  9000              STR      r0,[sp,#0]
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       Str_ParseNbr_Int32
000018  4607              MOV      r7,r0
;;;2984                                               pstr_next,
;;;2985                                               nbr_base,
;;;2986                                               DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
;;;2987                                (CPU_BOOLEAN *)0);
;;;2988   
;;;2989       return (nbr);
00001a  4638              MOV      r0,r7
;;;2990   }
00001c  bdf8              POP      {r3-r7,pc}
;;;2991   
                          ENDP


                          AREA ||i.Str_Str||, CODE, READONLY, ALIGN=1

                  Str_Str PROC
;;;1765   
;;;1766   CPU_CHAR  *Str_Str (const  CPU_CHAR  *pstr,
000000  b570              PUSH     {r4-r6,lr}
;;;1767                       const  CPU_CHAR  *pstr_srch)
;;;1768   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1769       CPU_CHAR  *pstr_rtn;
;;;1770   
;;;1771   
;;;1772       pstr_rtn = Str_Str_N(pstr,
000006  f04f32ff          MOV      r2,#0xffffffff
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       Str_Str_N
000012  4606              MOV      r6,r0
;;;1773                            pstr_srch,
;;;1774                            DEF_INT_CPU_U_MAX_VAL);
;;;1775   
;;;1776       return (pstr_rtn);
000014  4630              MOV      r0,r6
;;;1777   }
000016  bd70              POP      {r4-r6,pc}
;;;1778   
                          ENDP


                          AREA ||i.Str_Str_N||, CODE, READONLY, ALIGN=1

                  Str_Str_N PROC
;;;1849   
;;;1850   CPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1851                         const  CPU_CHAR    *pstr_srch,
;;;1852                                CPU_SIZE_T   len_max)
;;;1853   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1854              CPU_SIZE_T    str_len;
;;;1855              CPU_SIZE_T    str_len_srch;
;;;1856              CPU_SIZE_T    len_max_srch;
;;;1857              CPU_SIZE_T    srch_len;
;;;1858              CPU_SIZE_T    srch_ix;
;;;1859              CPU_BOOLEAN   srch_done;
;;;1860              CPU_INT16S    srch_cmp;
;;;1861       const  CPU_CHAR     *pstr_str;
;;;1862       const  CPU_CHAR     *pstr_srch_ix;
;;;1863   
;;;1864                                                                   /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
;;;1865       if (pstr == (const CPU_CHAR *)0) {
00000a  b91e              CBNZ     r6,|L24.20|
;;;1866           return ((CPU_CHAR *)0);
00000c  2000              MOVS     r0,#0
                  |L24.14|
;;;1867       }
;;;1868       if (pstr_srch == (const CPU_CHAR *)0) {
;;;1869           return ((CPU_CHAR *)0);
;;;1870       }
;;;1871   
;;;1872       if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
;;;1873           return ((CPU_CHAR *)0);
;;;1874       }
;;;1875   
;;;1876                                                                   /* Lim max srch str len (to chk > str len).             */
;;;1877       len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
;;;1878                    ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
;;;1879   
;;;1880       str_len      = Str_Len_N(pstr,      len_max);
;;;1881       str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
;;;1882       if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
;;;1883           return ((CPU_CHAR *)pstr);
;;;1884       }
;;;1885       if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
;;;1886           return ((CPU_CHAR *)0);
;;;1887       }
;;;1888                                                                   /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
;;;1889       pstr_str = pstr      + str_len;
;;;1890       if (pstr_str == (const CPU_CHAR *)0) {
;;;1891           return ((CPU_CHAR *)0);
;;;1892       }
;;;1893       pstr_str = pstr_srch + str_len_srch;
;;;1894       if (pstr_str == (const CPU_CHAR *)0) {
;;;1895           return ((CPU_CHAR *)0);
;;;1896       }
;;;1897   
;;;1898   
;;;1899       srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
;;;1900       srch_ix   = 0u;
;;;1901   
;;;1902       do {
;;;1903           pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
;;;1904           srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
;;;1905           srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
;;;1906           srch_ix++;
;;;1907       } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
;;;1908   
;;;1909   
;;;1910       if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
;;;1911           return ((CPU_CHAR *)0);
;;;1912       }
;;;1913   
;;;1914       return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
;;;1915   }
00000e  b004              ADD      sp,sp,#0x10
000010  e8bd8ff0          POP      {r4-r11,pc}
                  |L24.20|
000014  b90f              CBNZ     r7,|L24.26|
000016  2000              MOVS     r0,#0                 ;1869
000018  e7f9              B        |L24.14|
                  |L24.26|
00001a  b90d              CBNZ     r5,|L24.32|
00001c  2000              MOVS     r0,#0                 ;1873
00001e  e7f6              B        |L24.14|
                  |L24.32|
000020  1c68              ADDS     r0,r5,#1              ;1877
000022  d000              BEQ      |L24.38|
000024  e001              B        |L24.42|
                  |L24.38|
000026  f04f30ff          MOV      r0,#0xffffffff        ;1878
                  |L24.42|
00002a  9003              STR      r0,[sp,#0xc]          ;1878
00002c  4629              MOV      r1,r5                 ;1880
00002e  4630              MOV      r0,r6                 ;1880
000030  f7fffffe          BL       Str_Len_N
000034  4680              MOV      r8,r0                 ;1880
000036  4638              MOV      r0,r7                 ;1881
000038  9903              LDR      r1,[sp,#0xc]          ;1881
00003a  f7fffffe          BL       Str_Len_N
00003e  4604              MOV      r4,r0                 ;1881
000040  b90c              CBNZ     r4,|L24.70|
000042  4630              MOV      r0,r6                 ;1883
000044  e7e3              B        |L24.14|
                  |L24.70|
000046  4544              CMP      r4,r8                 ;1885
000048  d901              BLS      |L24.78|
00004a  2000              MOVS     r0,#0                 ;1886
00004c  e7df              B        |L24.14|
                  |L24.78|
00004e  eb060b08          ADD      r11,r6,r8             ;1889
000052  f1bb0f00          CMP      r11,#0                ;1890
000056  d101              BNE      |L24.92|
000058  2000              MOVS     r0,#0                 ;1891
00005a  e7d8              B        |L24.14|
                  |L24.92|
00005c  eb070b04          ADD      r11,r7,r4             ;1893
000060  f1bb0f00          CMP      r11,#0                ;1894
000064  d101              BNE      |L24.106|
000066  2000              MOVS     r0,#0                 ;1895
000068  e7d1              B        |L24.14|
                  |L24.106|
00006a  eba80004          SUB      r0,r8,r4              ;1899
00006e  9002              STR      r0,[sp,#8]            ;1899
000070  f04f0900          MOV      r9,#0                 ;1900
000074  bf00              NOP                            ;1902
                  |L24.118|
000076  eb060009          ADD      r0,r6,r9              ;1903
00007a  9000              STR      r0,[sp,#0]            ;1903
00007c  4622              MOV      r2,r4                 ;1904
00007e  4639              MOV      r1,r7                 ;1904
000080  9800              LDR      r0,[sp,#0]            ;1904
000082  f7fffffe          BL       Str_Cmp_N
000086  4682              MOV      r10,r0                ;1904
000088  f1ba0f00          CMP      r10,#0                ;1905
00008c  d101              BNE      |L24.146|
00008e  2001              MOVS     r0,#1                 ;1905
000090  e000              B        |L24.148|
                  |L24.146|
000092  2000              MOVS     r0,#0                 ;1905
                  |L24.148|
000094  9001              STR      r0,[sp,#4]            ;1905
000096  f1090901          ADD      r9,r9,#1              ;1906
00009a  9801              LDR      r0,[sp,#4]            ;1907
00009c  b910              CBNZ     r0,|L24.164|
00009e  9802              LDR      r0,[sp,#8]            ;1907
0000a0  4581              CMP      r9,r0                 ;1907
0000a2  d9e8              BLS      |L24.118|
                  |L24.164|
0000a4  f1ba0f00          CMP      r10,#0                ;1910
0000a8  d001              BEQ      |L24.174|
0000aa  2000              MOVS     r0,#0                 ;1911
0000ac  e7af              B        |L24.14|
                  |L24.174|
0000ae  9800              LDR      r0,[sp,#0]            ;1914
0000b0  e7ad              B        |L24.14|
;;;1916   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  Str_MultOvfThTbl_Int32U
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0x7fffffff
                          DCD      0x55555555
                          DCD      0x3fffffff
                          DCD      0x33333333
                          DCD      0x2aaaaaaa
                          DCD      0x24924924
                          DCD      0x1fffffff
                          DCD      0x1c71c71c
                          DCD      0x19999999
                          DCD      0x1745d174
                          DCD      0x15555555
                          DCD      0x13b13b13
                          DCD      0x12492492
                          DCD      0x11111111
                          DCD      0x0fffffff
                          DCD      0x0f0f0f0f
                          DCD      0x0e38e38e
                          DCD      0x0d79435e
                          DCD      0x0ccccccc
                          DCD      0x0c30c30c
                          DCD      0x0ba2e8ba
                          DCD      0x0b21642c
                          DCD      0x0aaaaaaa
                          DCD      0x0a3d70a3
                          DCD      0x09d89d89
                          DCD      0x097b425e
                          DCD      0x09249249
                          DCD      0x08d3dcb0
                          DCD      0x08888888
                          DCD      0x08421084
                          DCD      0x07ffffff
                          DCD      0x07c1f07c
                          DCD      0x07878787
                          DCD      0x07507507
                          DCD      0x071c71c7
