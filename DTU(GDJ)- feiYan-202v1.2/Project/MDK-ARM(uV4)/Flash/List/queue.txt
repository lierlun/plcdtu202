; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\queue.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\queue.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\queue.crf ..\..\User\Modbus\queue.c]
                          THUMB

                          AREA ||i.ClearQueue||, CODE, READONLY, ALIGN=1

                  ClearQueue PROC
;;;159     *---------------------------------------------------------------------------*/
;;;160    State ClearQueue(CircleQueue *queue )
000000  4601              MOV      r1,r0
;;;161    {
;;;162        queue->front = 0;
000002  2200              MOVS     r2,#0
000004  f44f60af          MOV      r0,#0x578
000008  5042              STR      r2,[r0,r1]
;;;163    	  queue->rear = 0;
00000a  1d00              ADDS     r0,r0,#4
00000c  5042              STR      r2,[r0,r1]
;;;164        queue->count = 0;
00000e  1d00              ADDS     r0,r0,#4
000010  5042              STR      r2,[r0,r1]
;;;165        return OK;
000012  2001              MOVS     r0,#1
;;;166    
;;;167    }
000014  4770              BX       lr
;;;168    
                          ENDP


                          AREA ||i.DeQueue||, CODE, READONLY, ALIGN=1

                  DeQueue PROC
;;;94      *---------------------------------------------------------------------------*/
;;;95     State DeQueue(CircleQueue *queue,ElemType *e)
000000  b570              PUSH     {r4-r6,lr}
;;;96     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;97         //判断队列是否为空
;;;98         if(queue->count == 0)
000006  f44f60b0          MOV      r0,#0x580
00000a  5900              LDR      r0,[r0,r4]
00000c  b908              CBNZ     r0,|L2.18|
;;;99     	  return ERROR;
00000e  2000              MOVS     r0,#0
                  |L2.16|
;;;100        //保存返回值
;;;101        *e = queue->data[queue->front];
;;;102        //更新队头指针
;;;103        queue->front = (queue->front + 1) % QUEUESIZE;
;;;104        //更新队列长度
;;;105        queue->count--;
;;;106        return OK;
;;;107    
;;;108    }
000010  bd70              POP      {r4-r6,pc}
                  |L2.18|
000012  f44f60af          MOV      r0,#0x578             ;101
000016  5900              LDR      r0,[r0,r4]            ;101
000018  ebc000c0          RSB      r0,r0,r0,LSL #3       ;101
00001c  eb040180          ADD      r1,r4,r0,LSL #2       ;101
000020  221c              MOVS     r2,#0x1c              ;101
000022  4628              MOV      r0,r5                 ;101
000024  f7fffffe          BL       __aeabi_memcpy4
000028  f44f60af          MOV      r0,#0x578             ;103
00002c  5900              LDR      r0,[r0,r4]            ;103
00002e  1c40              ADDS     r0,r0,#1              ;103
000030  2132              MOVS     r1,#0x32              ;103
000032  fb90f2f1          SDIV     r2,r0,r1              ;103
000036  fb010112          MLS      r1,r1,r2,r0           ;103
00003a  f44f60af          MOV      r0,#0x578             ;103
00003e  5101              STR      r1,[r0,r4]            ;103
000040  f44f60b0          MOV      r0,#0x580             ;105
000044  5900              LDR      r0,[r0,r4]            ;105
000046  1e40              SUBS     r0,r0,#1              ;105
000048  f44f61b0          MOV      r1,#0x580             ;105
00004c  5108              STR      r0,[r1,r4]            ;105
00004e  2001              MOVS     r0,#1                 ;106
000050  e7de              B        |L2.16|
;;;109    
                          ENDP


                          AREA ||i.EnQueue||, CODE, READONLY, ALIGN=1

                  EnQueue PROC
;;;69      *---------------------------------------------------------------------------*/
;;;70     State EnQueue(CircleQueue *queue, ElemType e)
000000  b40f              PUSH     {r0-r3}
;;;71     {
000002  b510              PUSH     {r4,lr}
000004  4604              MOV      r4,r0
;;;72         //验证队列是否已满
;;;73         if(queue->count == QUEUESIZE)
000006  f44f60b0          MOV      r0,#0x580
00000a  5900              LDR      r0,[r0,r4]
00000c  2832              CMP      r0,#0x32
00000e  d103              BNE      |L3.24|
;;;74            return ERROR;
000010  2000              MOVS     r0,#0
                  |L3.18|
;;;75         //入队
;;;76         queue->data[queue->rear] = e;
;;;77         //对尾指针后移
;;;78         queue->rear = (queue->rear + 1) % QUEUESIZE;
;;;79         //更新队列长度
;;;80         queue->count++;
;;;81         return OK;
;;;82     
;;;83     }
000012  bc10              POP      {r4}
000014  f85dfb14          LDR      pc,[sp],#0x14
                  |L3.24|
000018  f240517c          MOV      r1,#0x57c             ;76
00001c  5909              LDR      r1,[r1,r4]            ;76
00001e  ebc101c1          RSB      r1,r1,r1,LSL #3       ;76
000022  eb040081          ADD      r0,r4,r1,LSL #2       ;76
000026  221c              MOVS     r2,#0x1c              ;76
000028  a903              ADD      r1,sp,#0xc            ;76
00002a  f7fffffe          BL       __aeabi_memcpy4
00002e  f240507c          MOV      r0,#0x57c             ;78
000032  5900              LDR      r0,[r0,r4]            ;78
000034  1c40              ADDS     r0,r0,#1              ;78
000036  2132              MOVS     r1,#0x32              ;78
000038  fb90f2f1          SDIV     r2,r0,r1              ;78
00003c  fb010112          MLS      r1,r1,r2,r0           ;78
000040  f240507c          MOV      r0,#0x57c             ;78
000044  5101              STR      r1,[r0,r4]            ;78
000046  1d00              ADDS     r0,r0,#4              ;80
000048  5900              LDR      r0,[r0,r4]            ;80
00004a  1c40              ADDS     r0,r0,#1              ;80
00004c  f44f61b0          MOV      r1,#0x580             ;80
000050  5108              STR      r0,[r1,r4]            ;80
000052  2001              MOVS     r0,#1                 ;81
000054  e7dd              B        |L3.18|
;;;84     
                          ENDP


                          AREA ||i.GetHead||, CODE, READONLY, ALIGN=1

                  GetHead PROC
;;;120     *---------------------------------------------------------------------------*/
;;;121    State GetHead(CircleQueue *queue,ElemType *e)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;123        //判断队列是否为空
;;;124        if(queue->count == 0)
000006  f44f60b0          MOV      r0,#0x580
00000a  5900              LDR      r0,[r0,r4]
00000c  b908              CBNZ     r0,|L4.18|
;;;125    	   return ERROR;
00000e  2000              MOVS     r0,#0
                  |L4.16|
;;;126    
;;;127        *e = queue->data[queue->front];
;;;128    	return OK;
;;;129    }
000010  bd70              POP      {r4-r6,pc}
                  |L4.18|
000012  f44f60af          MOV      r0,#0x578             ;127
000016  5900              LDR      r0,[r0,r4]            ;127
000018  ebc000c0          RSB      r0,r0,r0,LSL #3       ;127
00001c  eb040180          ADD      r1,r4,r0,LSL #2       ;127
000020  221c              MOVS     r2,#0x1c              ;127
000022  4628              MOV      r0,r5                 ;127
000024  f7fffffe          BL       __aeabi_memcpy4
000028  2001              MOVS     r0,#1                 ;128
00002a  e7f1              B        |L4.16|
;;;130    
                          ENDP


                          AREA ||i.GetLength||, CODE, READONLY, ALIGN=1

                  GetLength PROC
;;;177     *---------------------------------------------------------------------------*/
;;;178    int GetLength(CircleQueue *queue)
000000  4601              MOV      r1,r0
;;;179    {
;;;180        return queue->count;
000002  f44f60b0          MOV      r0,#0x580
000006  5840              LDR      r0,[r0,r1]
;;;181    }
000008  4770              BX       lr
                          ENDP


                          AREA ||i.InitQueue||, CODE, READONLY, ALIGN=1

                  InitQueue PROC
;;;12      *---------------------------------------------------------------------------*/
;;;13     State InitQueue(CircleQueue *queue)
000000  4601              MOV      r1,r0
;;;14     {
;;;15         queue->front = 0; 
000002  2200              MOVS     r2,#0
000004  f44f60af          MOV      r0,#0x578
000008  5042              STR      r2,[r0,r1]
;;;16     	  queue->rear = 0;
00000a  1d00              ADDS     r0,r0,#4
00000c  5042              STR      r2,[r0,r1]
;;;17         queue->count = 0;
00000e  1d00              ADDS     r0,r0,#4
000010  5042              STR      r2,[r0,r1]
;;;18         return OK;
000012  2001              MOVS     r0,#1
;;;19     }
000014  4770              BX       lr
;;;20     
                          ENDP


                          AREA ||i.IsQueueEmpty||, CODE, READONLY, ALIGN=1

                  IsQueueEmpty PROC
;;;34      *---------------------------------------------------------------------------*/
;;;35     State IsQueueEmpty(CircleQueue *queue)
000000  4601              MOV      r1,r0
;;;36     {
;;;37         if(queue->count == 0)
000002  f44f60b0          MOV      r0,#0x580
000006  5840              LDR      r0,[r0,r1]
000008  b908              CBNZ     r0,|L7.14|
;;;38             return TRUE;
00000a  2001              MOVS     r0,#1
                  |L7.12|
;;;39         else
;;;40             return FALSE;
;;;41     }
00000c  4770              BX       lr
                  |L7.14|
00000e  2000              MOVS     r0,#0                 ;40
000010  e7fc              B        |L7.12|
;;;42     
                          ENDP


                          AREA ||i.IsQueueFull||, CODE, READONLY, ALIGN=1

                  IsQueueFull PROC
;;;51      *---------------------------------------------------------------------------*/
;;;52     State IsQueueFull(CircleQueue *queue)
000000  4601              MOV      r1,r0
;;;53     {
;;;54         if(queue->count == QUEUESIZE)
000002  f44f60b0          MOV      r0,#0x580
000006  5840              LDR      r0,[r0,r1]
000008  2832              CMP      r0,#0x32
00000a  d101              BNE      |L8.16|
;;;55             return TRUE;
00000c  2001              MOVS     r0,#1
                  |L8.14|
;;;56         else
;;;57             return FALSE;
;;;58     }
00000e  4770              BX       lr
                  |L8.16|
000010  2000              MOVS     r0,#0                 ;57
000012  e7fc              B        |L8.14|
;;;59     
                          ENDP


                          AREA ||i.SetHead||, CODE, READONLY, ALIGN=1

                  SetHead PROC
;;;140     *---------------------------------------------------------------------------*/
;;;141    State SetHead(CircleQueue *queue,ElemType e)
000000  b40f              PUSH     {r0-r3}
;;;142    {
000002  b510              PUSH     {r4,lr}
000004  4604              MOV      r4,r0
;;;143        //判断队列是否为空
;;;144        if(queue->count == 0)
000006  f44f60b0          MOV      r0,#0x580
00000a  5900              LDR      r0,[r0,r4]
00000c  b918              CBNZ     r0,|L9.22|
;;;145    	   return ERROR;
00000e  2000              MOVS     r0,#0
                  |L9.16|
;;;146    
;;;147        queue->data[queue->front] = e;
;;;148    	return OK;
;;;149    }
000010  bc10              POP      {r4}
000012  f85dfb14          LDR      pc,[sp],#0x14
                  |L9.22|
000016  f44f61af          MOV      r1,#0x578             ;147
00001a  5909              LDR      r1,[r1,r4]            ;147
00001c  ebc101c1          RSB      r1,r1,r1,LSL #3       ;147
000020  eb040081          ADD      r0,r4,r1,LSL #2       ;147
000024  221c              MOVS     r2,#0x1c              ;147
000026  a903              ADD      r1,sp,#0xc            ;147
000028  f7fffffe          BL       __aeabi_memcpy4
00002c  2001              MOVS     r0,#1                 ;148
00002e  e7ef              B        |L9.16|
;;;150    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_M485Cmd
                          %        1412
