; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\Flash\Obj\bsp_cpu_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\Flash\Obj\bsp_cpu_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\uCOS-III\uC-CPU -I..\..\uCOS-III\uC-CPU\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uC-LIB -I..\..\uCOS-III\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\..\uCOS-III\uCOS-III\Source -I..\..\uCOS-III\uCOS-III\Ports\ARM-Cortex-M3\RealView -I..\..\Malloc -I..\..\User\Modbus -Id:\Keil_v4\ARM\RV31\INC -Id:\Keil_v4\ARM\CMSIS\Include -Id:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\Flash\Obj\bsp_cpu_flash.crf ..\..\User\bsp\src\bsp_cpu_flash.c]
                          THUMB

                          AREA ||i.bsp_CmpCpuFlash||, CODE, READONLY, ALIGN=1

                  bsp_CmpCpuFlash PROC
;;;85     */
;;;86     uint8_t bsp_CmpCpuFlash(uint32_t _ulFlashAddr, uint8_t *_ucpBuf, uint32_t _ulSize)
000000  b570              PUSH     {r4-r6,lr}
;;;87     {
000002  4603              MOV      r3,r0
;;;88     	uint32_t i;
;;;89     	uint8_t ucIsEqu;	/* 相等标志 */
;;;90     	uint8_t ucByte;
;;;91     
;;;92     	/* 如果偏移地址超过芯片容量，则不改写输出缓冲区 */
;;;93     	if (_ulFlashAddr + _ulSize > FLASH_BASE_ADDR + FLASH_SIZE)
000004  1898              ADDS     r0,r3,r2
000006  f1b06f01          CMP      r0,#0x8100000
00000a  d901              BLS      |L1.16|
;;;94     	{
;;;95     		return FLASH_PARAM_ERR;		/*　函数参数错误　*/
00000c  2003              MOVS     r0,#3
                  |L1.14|
;;;96     	}
;;;97     
;;;98     	/* 长度为0时返回正确 */
;;;99     	if (_ulSize == 0)
;;;100    	{
;;;101    		return FLASH_IS_EQU;		/* Flash内容和待写入的数据相等 */
;;;102    	}
;;;103    
;;;104    	ucIsEqu = 1;			/* 先假设所有字节和待写入的数据相等，如果遇到任何一个不相等，则设置为 0 */
;;;105    	for (i = 0; i < _ulSize; i++)
;;;106    	{
;;;107    		ucByte = *(uint8_t *)_ulFlashAddr;
;;;108    
;;;109    		if (ucByte != *_ucpBuf)
;;;110    		{
;;;111    			if (ucByte != 0xFF)
;;;112    			{
;;;113    				return FLASH_REQ_ERASE;		/* 需要擦除后再写 */
;;;114    			}
;;;115    			else
;;;116    			{
;;;117    				ucIsEqu = 0;	/* 不相等，需要写 */
;;;118    			}
;;;119    		}
;;;120    
;;;121    		_ulFlashAddr++;
;;;122    		_ucpBuf++;
;;;123    	}
;;;124    
;;;125    	if (ucIsEqu == 1)
;;;126    	{
;;;127    		return FLASH_IS_EQU;	/* Flash内容和待写入的数据相等，不需要擦除和写操作 */
;;;128    	}
;;;129    	else
;;;130    	{
;;;131    		return FLASH_REQ_WRITE;	/* Flash不需要擦除，直接写 */
;;;132    	}
;;;133    }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  b90a              CBNZ     r2,|L1.22|
000012  2000              MOVS     r0,#0                 ;101
000014  e7fb              B        |L1.14|
                  |L1.22|
000016  2601              MOVS     r6,#1                 ;104
000018  2400              MOVS     r4,#0                 ;105
00001a  e00b              B        |L1.52|
                  |L1.28|
00001c  781d              LDRB     r5,[r3,#0]            ;107
00001e  7808              LDRB     r0,[r1,#0]            ;109
000020  42a8              CMP      r0,r5                 ;109
000022  d004              BEQ      |L1.46|
000024  2dff              CMP      r5,#0xff              ;111
000026  d001              BEQ      |L1.44|
000028  2002              MOVS     r0,#2                 ;113
00002a  e7f0              B        |L1.14|
                  |L1.44|
00002c  2600              MOVS     r6,#0                 ;117
                  |L1.46|
00002e  1c5b              ADDS     r3,r3,#1              ;121
000030  1c49              ADDS     r1,r1,#1              ;122
000032  1c64              ADDS     r4,r4,#1              ;105
                  |L1.52|
000034  4294              CMP      r4,r2                 ;105
000036  d3f1              BCC      |L1.28|
000038  2e01              CMP      r6,#1                 ;125
00003a  d101              BNE      |L1.64|
00003c  2000              MOVS     r0,#0                 ;127
00003e  e7e6              B        |L1.14|
                  |L1.64|
000040  2001              MOVS     r0,#1                 ;131
000042  e7e4              B        |L1.14|
;;;134    
                          ENDP


                          AREA ||i.bsp_GetSector||, CODE, READONLY, ALIGN=1

                  bsp_GetSector PROC
;;;28     */
;;;29     uint32_t bsp_GetSector(uint32_t _ulWrAddr)
000000  4601              MOV      r1,r0
;;;30     {
;;;31     	uint32_t sector = 0;
000002  2000              MOVS     r0,#0
;;;32     
;;;33     	sector = _ulWrAddr & SECTOR_MASK;
000004  0ac8              LSRS     r0,r1,#11
000006  02c0              LSLS     r0,r0,#11
;;;34     
;;;35     	return sector;
;;;36     }
000008  4770              BX       lr
;;;37     
                          ENDP


                          AREA ||i.bsp_ReadCpuFlash||, CODE, READONLY, ALIGN=1

                  bsp_ReadCpuFlash PROC
;;;47     */
;;;48     uint8_t bsp_ReadCpuFlash(uint32_t _ulFlashAddr, uint8_t *_ucpDst, uint32_t _ulSize)
000000  b510              PUSH     {r4,lr}
;;;49     {
000002  4603              MOV      r3,r0
;;;50     	uint32_t i;
;;;51     
;;;52     	/* 如果偏移地址超过芯片容量，则不改写输出缓冲区 */
;;;53     	if (_ulFlashAddr + _ulSize > FLASH_BASE_ADDR + FLASH_SIZE)
000004  1898              ADDS     r0,r3,r2
000006  f1b06f01          CMP      r0,#0x8100000
00000a  d901              BLS      |L3.16|
;;;54     	{
;;;55     		return 1;
00000c  2001              MOVS     r0,#1
                  |L3.14|
;;;56     	}
;;;57     
;;;58     	/* 长度为0时不继续操作,否则起始地址为奇地址会出错 */
;;;59     	if (_ulSize == 0)
;;;60     	{
;;;61     		return 1;
;;;62     	}
;;;63     
;;;64     	for (i = 0; i < _ulSize; i++)
;;;65     	{
;;;66     		*_ucpDst++ = *(uint8_t *)_ulFlashAddr++;
;;;67     	}
;;;68     
;;;69     	return 0;
;;;70     }
00000e  bd10              POP      {r4,pc}
                  |L3.16|
000010  b90a              CBNZ     r2,|L3.22|
000012  2001              MOVS     r0,#1                 ;61
000014  e7fb              B        |L3.14|
                  |L3.22|
000016  2400              MOVS     r4,#0                 ;64
000018  e004              B        |L3.36|
                  |L3.26|
00001a  f8130b01          LDRB     r0,[r3],#1            ;66
00001e  f8010b01          STRB     r0,[r1],#1            ;66
000022  1c64              ADDS     r4,r4,#1              ;64
                  |L3.36|
000024  4294              CMP      r4,r2                 ;64
000026  d3f8              BCC      |L3.26|
000028  2000              MOVS     r0,#0                 ;69
00002a  e7f0              B        |L3.14|
;;;71     
                          ENDP


                          AREA ||i.bsp_WriteCpuFlash||, CODE, READONLY, ALIGN=1

                  bsp_WriteCpuFlash PROC
;;;144    */
;;;145    uint8_t bsp_WriteCpuFlash(uint32_t _ulFlashAddr, uint8_t *_ucpSrc, uint32_t _ulSize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;146    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;147    	uint32_t i;
;;;148    	uint8_t ucRet;
;;;149    	uint16_t usTemp;
;;;150    	FLASH_Status status = FLASH_COMPLETE;
00000a  f04f0904          MOV      r9,#4
;;;151    
;;;152    	/* 如果偏移地址超过芯片容量，则不改写输出缓冲区 */
;;;153    	if (_ulFlashAddr + _ulSize > FLASH_BASE_ADDR + FLASH_SIZE)
00000e  1938              ADDS     r0,r7,r4
000010  f1b06f01          CMP      r0,#0x8100000
000014  d902              BLS      |L4.28|
;;;154    	{
;;;155    		return 1;
000016  2001              MOVS     r0,#1
                  |L4.24|
;;;156    	}
;;;157    
;;;158    	/* 长度为0 时不继续操作  */
;;;159    	if (_ulSize == 0)
;;;160    	{
;;;161    		return 0;
;;;162    	}
;;;163    
;;;164    	/* 长度为奇数时不继续操作  */
;;;165    	if ((_ulSize % 2) != 0)
;;;166    	{
;;;167    		return 1;
;;;168    	}	
;;;169    
;;;170    	ucRet = bsp_CmpCpuFlash(_ulFlashAddr, _ucpSrc, _ulSize);
;;;171    
;;;172    	if (ucRet == FLASH_IS_EQU)
;;;173    	{
;;;174    		return 0;
;;;175    	}
;;;176    
;;;177    	__set_PRIMASK(1);  		/* 关中断 */
;;;178    
;;;179    	/* FLASH 解锁 */
;;;180    	FLASH_Unlock();
;;;181    
;;;182      	/* Clear pending flags (if any) */
;;;183    	FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);	
;;;184    
;;;185    	/* 需要擦除 */
;;;186    	if (ucRet == FLASH_REQ_ERASE)
;;;187    	{
;;;188    		status = FLASH_ErasePage(bsp_GetSector(_ulFlashAddr));
;;;189    		if (status != FLASH_COMPLETE)
;;;190    		{
;;;191    			return 2;
;;;192    		}		
;;;193    	}
;;;194    
;;;195    	/* 按字节模式编程（为提高效率，可以按字编程，一次写入4字节） */
;;;196    	for (i = 0; i < _ulSize / 2; i++)
;;;197    	{
;;;198    		//FLASH_ProgramByte(_ulFlashAddr++, *_ucpSrc++);		
;;;199    		usTemp = _ucpSrc[2 * i];
;;;200    		usTemp |= (_ucpSrc[2 * i + 1] << 8);
;;;201    		status = FLASH_ProgramHalfWord(_ulFlashAddr, usTemp);
;;;202    		if (status != FLASH_COMPLETE)
;;;203    		{
;;;204    			break;
;;;205    		}
;;;206    		
;;;207    		_ulFlashAddr += 2;
;;;208    	}
;;;209    
;;;210      	/* Flash 加锁，禁止写Flash控制寄存器 */
;;;211      	FLASH_Lock();
;;;212    
;;;213      	__set_PRIMASK(0);  		/* 开中断 */
;;;214    
;;;215    	if (status == FLASH_COMPLETE)
;;;216    	{
;;;217    		return 0;
;;;218    	}
;;;219    	return 2;
;;;220    }
000018  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.28|
00001c  b90c              CBNZ     r4,|L4.34|
00001e  2000              MOVS     r0,#0                 ;161
000020  e7fa              B        |L4.24|
                  |L4.34|
000022  f0140f01          TST      r4,#1                 ;165
000026  d001              BEQ      |L4.44|
000028  2001              MOVS     r0,#1                 ;167
00002a  e7f5              B        |L4.24|
                  |L4.44|
00002c  4622              MOV      r2,r4                 ;170
00002e  4641              MOV      r1,r8                 ;170
000030  4638              MOV      r0,r7                 ;170
000032  f7fffffe          BL       bsp_CmpCpuFlash
000036  4606              MOV      r6,r0                 ;170
000038  b90e              CBNZ     r6,|L4.62|
00003a  2000              MOVS     r0,#0                 ;174
00003c  e7ec              B        |L4.24|
                  |L4.62|
00003e  2001              MOVS     r0,#1                 ;177
000040  f3808810          MSR      PRIMASK,r0            ;177
000044  bf00              NOP                            ;177
000046  f7fffffe          BL       FLASH_Unlock
00004a  2035              MOVS     r0,#0x35              ;183
00004c  f7fffffe          BL       FLASH_ClearFlag
000050  2e02              CMP      r6,#2                 ;186
000052  d10b              BNE      |L4.108|
000054  4638              MOV      r0,r7                 ;188
000056  f7fffffe          BL       bsp_GetSector
00005a  4683              MOV      r11,r0                ;188
00005c  f7fffffe          BL       FLASH_ErasePage
000060  4681              MOV      r9,r0                 ;188
000062  f1b90f04          CMP      r9,#4                 ;189
000066  d001              BEQ      |L4.108|
000068  2002              MOVS     r0,#2                 ;191
00006a  e7d5              B        |L4.24|
                  |L4.108|
00006c  2500              MOVS     r5,#0                 ;196
00006e  e012              B        |L4.150|
                  |L4.112|
000070  f818a015          LDRB     r10,[r8,r5,LSL #1]    ;199
000074  0068              LSLS     r0,r5,#1              ;200
000076  1c40              ADDS     r0,r0,#1              ;200
000078  f8180000          LDRB     r0,[r8,r0]            ;200
00007c  ea4a2a00          ORR      r10,r10,r0,LSL #8     ;200
000080  4651              MOV      r1,r10                ;201
000082  4638              MOV      r0,r7                 ;201
000084  f7fffffe          BL       FLASH_ProgramHalfWord
000088  4681              MOV      r9,r0                 ;201
00008a  f1b90f04          CMP      r9,#4                 ;202
00008e  d000              BEQ      |L4.146|
000090  e004              B        |L4.156|
                  |L4.146|
000092  1cbf              ADDS     r7,r7,#2              ;207
000094  1c6d              ADDS     r5,r5,#1              ;196
                  |L4.150|
000096  ebb50f54          CMP      r5,r4,LSR #1          ;196
00009a  d3e9              BCC      |L4.112|
                  |L4.156|
00009c  bf00              NOP                            ;204
00009e  f7fffffe          BL       FLASH_Lock
0000a2  2000              MOVS     r0,#0                 ;213
0000a4  f3808810          MSR      PRIMASK,r0            ;213
0000a8  bf00              NOP                            ;213
0000aa  f1b90f04          CMP      r9,#4                 ;215
0000ae  d100              BNE      |L4.178|
0000b0  e7b2              B        |L4.24|
                  |L4.178|
0000b2  2002              MOVS     r0,#2                 ;219
0000b4  e7b0              B        |L4.24|
;;;221    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_cpu_flash.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_cpu_flash_c_4320bcf1____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_cpu_flash_c_4320bcf1____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_cpu_flash_c_4320bcf1____REVSH|
#line 128
|__asm___15_bsp_cpu_flash_c_4320bcf1____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
